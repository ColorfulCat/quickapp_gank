// Generated by IcedCoffeeScript 1.7.1-f
(function() {
  var EventEmitter, FSChange, FSFile, FSTree, Path, PlaPath, appendUniques, debug, fs, iced, prependUniques, __iced_k, __iced_k_noop,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = {
    Deferrals: (function() {
      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) {
          return this.continuation(this.ret);
        }
      };

      _Class.prototype.defer = function(defer_params) {
        ++this.count;
        return (function(_this) {
          return function() {
            var inner_params, _ref;
            inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            if (defer_params != null) {
              if ((_ref = defer_params.assign_fn) != null) {
                _ref.apply(null, inner_params);
              }
            }
            return _this._fulfill();
          };
        })(this);
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    },
    trampoline: function(_fn) {
      return _fn();
    }
  };
  __iced_k = __iced_k_noop = function() {};

  debug = require('debug')('fsmonitor');

  fs = require('fs');

  Path = require('path');

  EventEmitter = require('events').EventEmitter;

  PlaPath = require('./pathutil').PlaPath;

  prependUniques = function(dest, source) {
    var item, _i, _len;
    for (_i = 0, _len = source.length; _i < _len; _i++) {
      item = source[_i];
      if (dest.indexOf(item) < 0) {
        dest.unshift(item);
      }
    }
    return dest;
  };

  appendUniques = function(dest, source) {
    var item, _i, _len;
    for (_i = 0, _len = source.length; _i < _len; _i++) {
      item = source[_i];
      if (dest.indexOf(item) < 0) {
        dest.push(item);
      }
    }
    return dest;
  };

  FSFile = (function() {
    function FSFile(relpath, stats) {
      this.relpath = relpath;
      this.stats = stats;
    }

    FSFile.prototype.equals = function(peer) {
      if (this.stats.isFile()) {
        return (this.stats.size === peer.stats.size) && (this.stats.mode === peer.stats.mode) && (+this.stats.mtime === +peer.stats.mtime) && (this.stats.dev === peer.stats.dev) && (this.stats.ino === peer.stats.ino);
      } else {
        return this.stats.mode === peer.stats.mode;
      }
    };

    FSFile.prototype.toString = function() {
      return "FSFile(" + this.relpath + ")";
    };

    return FSFile;

  })();

  FSChange = (function() {
    function FSChange() {
      this.addedFiles = [];
      this.modifiedFiles = [];
      this.removedFiles = [];
      this.addedFolders = [];
      this.modifiedFolders = [];
      this.removedFolders = [];
    }

    FSChange.prototype.isEmpty = function() {
      return (this.addedFiles.length + this.modifiedFiles.length + this.removedFiles.length + this.addedFolders.length + this.modifiedFolders.length + this.removedFolders.length) === 0;
    };

    FSChange.prototype.prepend = function(peer) {
      prependUniques(this.addedFiles, peer.addedFiles);
      prependUniques(this.modifiedFiles, peer.modifiedFiles);
      prependUniques(this.removedFiles, peer.removedFiles);
      prependUniques(this.addedFolders, peer.addedFolders);
      prependUniques(this.modifiedFolders, peer.modifiedFolders);
      return prependUniques(this.removedFolders, peer.removedFolders);
    };

    FSChange.prototype.append = function(peer) {
      appendUniques(this.addedFiles, peer.addedFiles);
      appendUniques(this.modifiedFiles, peer.modifiedFiles);
      appendUniques(this.removedFiles, peer.removedFiles);
      appendUniques(this.addedFolders, peer.addedFolders);
      appendUniques(this.modifiedFolders, peer.modifiedFolders);
      return appendUniques(this.removedFolders, peer.removedFolders);
    };

    FSChange.prototype.toString = function() {
      return [this._listToString('+', this.addedFiles, ''), this._listToString('!', this.modifiedFiles, ''), this._listToString('-', this.removedFiles, ''), this._listToString('+', this.addedFolders, '/'), this._listToString('!', this.modifiedFolders, '/'), this._listToString('-', this.removedFolders, '/')].join('');
    };

    FSChange.prototype._listToString = function(prefix, list, suffix) {
      var relpath, result, _i, _len, _ref;
      result = [];
      _ref = list.slice(0).sort();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        relpath = _ref[_i];
        result.push("" + prefix + relpath + suffix + "\n");
      }
      return result.join('');
    };

    return FSChange;

  })();

  module.exports = FSTree = (function(_super) {
    __extends(FSTree, _super);

    function FSTree(root, filter) {
      var ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      this.root = root;
      this.filter = filter;
      if (this.filter && !((typeof this.filter.matches === 'function') && (typeof this.filter.excludes === 'function'))) {
        throw new Error("Invalid filter provided to FSTree; must define .matches() and .excludes()");
      }
      this.filter || (this.filter = {
        matches: (function() {
          return true;
        }),
        excludes: (function() {
          return false;
        })
      });
      this._files = [];
      this._folders = [];
      this._errors = [];
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "c:\\Users\\saita\\Documents\\program\\fsmonitor.js\\lib\\tree.iced",
            funcname: "FSTree"
          });
          _this._walk(_this.root, '', __iced_deferrals.defer({
            lineno: 93
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this._updateRequested = false;
          _this._updateInProgress = false;
          debug("Finished building FSTree with " + _this._files.length + " files and " + _this._folders.length + " folders at " + _this.root);
          return _this.emit('complete');
        };
      })(this));
    }

    FSTree.prototype.update = function(folder, item) {
      this._updateRequested = true;
      if (!this._updateInProgress) {
        this._performQueuedUpdate();
      }
    };

    FSTree.prototype._performQueuedUpdate = function() {
      var change, file, folder, key, old, oldFiles, oldFolders, relpath, ___iced_passed_deferral, __iced_deferrals, __iced_k, _i, _j, _len, _len1, _ref, _ref1;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      this._updateInProgress = true;
      this._updateRequested = false;
      debug("Updating FSTree at " + this.root);
      oldFiles = {};
      _ref = this._files;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        oldFiles[file.relpath] = file;
      }
      oldFolders = {};
      _ref1 = this._folders;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        folder = _ref1[_j];
        oldFolders[folder.relpath] = folder;
      }
      this._files = [];
      this._folders = [];
      this._errors = [];
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "c:\\Users\\saita\\Documents\\program\\fsmonitor.js\\lib\\tree.iced",
            funcname: "FSTree._performQueuedUpdate"
          });
          _this._walk(_this.root, '', __iced_deferrals.defer({
            lineno: 124
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          var _k, _l, _len2, _len3, _ref2, _ref3;
          change = new FSChange();
          _ref2 = _this._files;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            file = _ref2[_k];
            relpath = file.relpath;
            if (oldFiles.hasOwnProperty(relpath)) {
              old = oldFiles[relpath];
              delete oldFiles[relpath];
              if (!file.equals(old)) {
                change.modifiedFiles.push(relpath);
              }
              if (!file.equals(old)) {
                debug("Change in file " + relpath + ":");
                if (file.stats.size !== old.stats.size) {
                  debug("  .. size " + file.stats.size + " != " + old.stats.size);
                }
                if (file.stats.mode !== old.stats.mode) {
                  debug("  .. mode " + file.stats.mode + " != " + old.stats.mode);
                }
                if (+file.stats.mtime !== +old.stats.mtime) {
                  debug("  .. mtime " + (+file.stats.mtime) + " != " + (+old.stats.mtime));
                }
                if (file.stats.size !== old.stats.size) {
                  debug("  .. size " + file.stats.size + " != " + old.stats.size);
                }
                if (file.stats.dev !== old.stats.dev) {
                  debug("  .. dev " + file.stats.dev + " != " + old.stats.dev);
                }
                if (file.stats.ino !== old.stats.ino) {
                  debug("  .. ino " + file.stats.ino + " != " + old.stats.ino);
                }
              }
            } else {
              change.addedFiles.push(relpath);
            }
          }
          for (key in oldFiles) {
            if (!__hasProp.call(oldFiles, key)) continue;
            file = oldFiles[key];
            change.removedFiles.push(file.relpath);
          }
          _ref3 = _this._folders;
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            folder = _ref3[_l];
            relpath = folder.relpath;
            if (oldFolders.hasOwnProperty(relpath)) {
              old = oldFolders[relpath];
              delete oldFolders[relpath];
              if (!folder.equals(old)) {
                change.modifiedFolders.push(relpath);
              }
              if (!folder.equals(old)) {
                debug("Change in folder " + relpath + "/:");
                if (folder.stats.mode !== old.stats.mode) {
                  debug("  .. mode " + folder.stats.mode + " != " + old.stats.mode);
                }
              }
            } else {
              change.addedFolders.push(relpath);
            }
          }
          for (key in oldFolders) {
            if (!__hasProp.call(oldFolders, key)) continue;
            folder = oldFolders[key];
            change.removedFolders.push(folder.relpath);
          }
          if (!change.isEmpty()) {
            _this.emit('change', change);
          }
          _this._updateInProgress = false;
          if (_this._updateRequested) {
            return _this._performQueuedUpdate();
          }
        };
      })(this));
    };

    Object.defineProperty(FSTree.prototype, 'allFiles', {
      get: function() {
        var file;
        return ((function() {
          var _i, _len, _ref, _results;
          _ref = this._files;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            file = _ref[_i];
            _results.push(file.relpath);
          }
          return _results;
        }).call(this)).sort();
      }
    });

    Object.defineProperty(FSTree.prototype, 'allFolders', {
      get: function() {
        var file;
        return ((function() {
          var _i, _len, _ref, _results;
          _ref = this._folders;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            file = _ref[_i];
            _results.push(file.relpath);
          }
          return _results;
        }).call(this)).sort();
      }
    });

    FSTree.prototype.findMatchingPaths = function(list) {
      var file;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = this._files;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          if (list.matches(file.relpath)) {
            _results.push(file.relpath);
          }
        }
        return _results;
      }).call(this)).sort();
    };

    FSTree.prototype.findFilesBySuffix = function(suffix, _arg, callback) {
      var allMatches, bestMatch, bestMatches, bestScore, bestSubtree, file, match, name, path, score;
      bestSubtree = _arg.bestSubtree;
      suffix = PlaPath.normalize(suffix);
      name = Path.basename(suffix);
      bestScore = 0;
      allMatches = (function() {
        var _i, _len, _ref, _results;
        _ref = this._files;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          path = file.relpath;
          if (Path.basename(path) !== name) {
            continue;
          }
          score = PlaPath.numberOfMatchingTrailingComponents(path, suffix);
          if (bestSubtree && PlaPath.isSubpath(path, bestSubtree)) {
            score += 0.5;
          }
          if (score > bestScore) {
            bestScore = score;
          }
          debug("findFilesMatchingSuffixInSubtree match: path = %j, score = %j", path, score);
          _results.push({
            path: path,
            score: score
          });
        }
        return _results;
      }).call(this);
      bestMatches = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = allMatches.length; _i < _len; _i++) {
          match = allMatches[_i];
          if (match.score === bestScore) {
            _results.push(match);
          }
        }
        return _results;
      })();
      bestMatch = bestMatches.length === 1 ? bestMatches[0] : null;
      return process.nextTick(function() {
        return callback(null, {
          allMatches: allMatches,
          bestMatches: bestMatches,
          bestMatch: bestMatch
        });
      });
    };

    FSTree.prototype._addError = function(path, err) {
      return this._errors.push({
        path: path,
        err: err
      });
    };

    FSTree.prototype._addFile = function(relpath, stats) {
      debug("file: " + relpath);
      return this._files.push(new FSFile(relpath, stats));
    };

    FSTree.prototype._addFolder = function(relpath, stats) {
      debug("FOLD: " + relpath);
      return this._folders.push(new FSFile(relpath, stats));
    };

    FSTree.prototype._walk = function(path, relpath, autocb) {
      var err, file, files, stats, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = autocb;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "c:\\Users\\saita\\Documents\\program\\fsmonitor.js\\lib\\tree.iced",
            funcname: "FSTree._walk"
          });
          fs.lstat(path, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return stats = arguments[1];
              };
            })(),
            lineno: 224
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (err) {
            autocb(_this._addError(path, err));
            return;
          }
          if (stats.isFile()) {
            return __iced_k(_this.filter.matches(relpath, false) ? _this._addFile(relpath, stats) : void 0);
          } else {
            (function(__iced_k) {
              if (stats.isDirectory()) {
                if (_this.filter.excludes(relpath, true)) {
                  autocb();
                  return;
                }
                _this._addFolder(relpath, stats);
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "c:\\Users\\saita\\Documents\\program\\fsmonitor.js\\lib\\tree.iced",
                    funcname: "FSTree._walk"
                  });
                  fs.readdir(path, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        err = arguments[0];
                        return files = arguments[1];
                      };
                    })(),
                    lineno: 234
                  }));
                  __iced_deferrals._fulfill();
                })(function() {
                  if (err) {
                    autocb(_this._addError(path, err));
                    return;
                  }
                  (function(__iced_k) {
                    var _i, _len, _ref, _results, _while;
                    _ref = files;
                    _len = _ref.length;
                    _i = 0;
                    _results = [];
                    _while = function(__iced_k) {
                      var _break, _continue, _next;
                      _break = function() {
                        return __iced_k(_results);
                      };
                      _continue = function() {
                        return iced.trampoline(function() {
                          ++_i;
                          return _while(__iced_k);
                        });
                      };
                      _next = function(__iced_next_arg) {
                        _results.push(__iced_next_arg);
                        return _continue();
                      };
                      if (!(_i < _len)) {
                        return _break();
                      } else {
                        file = _ref[_i];
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename: "c:\\Users\\saita\\Documents\\program\\fsmonitor.js\\lib\\tree.iced",
                            funcname: "FSTree._walk"
                          });
                          _this._walk(Path.join(path, file), Path.join(relpath, file), __iced_deferrals.defer({
                            lineno: 238
                          }));
                          __iced_deferrals._fulfill();
                        })(_next);
                      }
                    };
                    _while(__iced_k);
                  })(__iced_k);
                });
              } else {
                return __iced_k();
              }
            })(__iced_k);
          }
        };
      })(this));
    };

    return FSTree;

  })(EventEmitter);

}).call(this);
