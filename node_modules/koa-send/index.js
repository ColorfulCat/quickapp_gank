'use strict';

/**
 * Send file at `path` with the
 * given `options` to the koa `ctx`.
 *
 * @param {Context} ctx
 * @param {String} path
 * @param {Object} [opts]
 * @return {Function}
 * @api public
 */

var send = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(ctx, path) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var root, trailingSlash, index, maxage, immutable, hidden, format, extensions, brotli, gzip, setHeaders, encodingExt, list, i, ext, stats, notfound, directives;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            assert(ctx, 'koa context required');
            assert(path, 'pathname required');

            // options
            debug('send "%s" %j', path, opts);
            root = opts.root ? normalize(resolve(opts.root)) : '';
            trailingSlash = path[path.length - 1] === '/';

            path = path.substr(parse(path).root.length);
            index = opts.index;
            maxage = opts.maxage || opts.maxAge || 0;
            immutable = opts.immutable || false;
            hidden = opts.hidden || false;
            format = opts.format !== false;
            extensions = Array.isArray(opts.extensions) ? opts.extensions : false;
            brotli = opts.brotli !== false;
            gzip = opts.gzip !== false;
            setHeaders = opts.setHeaders;

            if (!(setHeaders && typeof setHeaders !== 'function')) {
              _context.next = 17;
              break;
            }

            throw new TypeError('option setHeaders must be function');

          case 17:

            // normalize path
            path = decode(path);

            if (!(path === -1)) {
              _context.next = 20;
              break;
            }

            return _context.abrupt('return', ctx.throw(400, 'failed to decode'));

          case 20:

            // index file support
            if (index && trailingSlash) path += index;

            path = resolvePath(root, path);

            // hidden file support, ignore

            if (!(!hidden && isHidden(root, path))) {
              _context.next = 24;
              break;
            }

            return _context.abrupt('return');

          case 24:
            encodingExt = '';
            // serve brotli file when possible otherwise gzipped file when possible

            _context.t0 = ctx.acceptsEncodings('br', 'identity') === 'br' && brotli;

            if (!_context.t0) {
              _context.next = 30;
              break;
            }

            _context.next = 29;
            return fs.exists(path + '.br');

          case 29:
            _context.t0 = _context.sent;

          case 30:
            if (!_context.t0) {
              _context.next = 37;
              break;
            }

            path = path + '.br';
            ctx.set('Content-Encoding', 'br');
            ctx.res.removeHeader('Content-Length');
            encodingExt = '.br';
            _context.next = 47;
            break;

          case 37:
            _context.t1 = ctx.acceptsEncodings('gzip', 'identity') === 'gzip' && gzip;

            if (!_context.t1) {
              _context.next = 42;
              break;
            }

            _context.next = 41;
            return fs.exists(path + '.gz');

          case 41:
            _context.t1 = _context.sent;

          case 42:
            if (!_context.t1) {
              _context.next = 47;
              break;
            }

            path = path + '.gz';
            ctx.set('Content-Encoding', 'gzip');
            ctx.res.removeHeader('Content-Length');
            encodingExt = '.gz';

          case 47:
            if (!(extensions && !/\.[^/]*$/.exec(path))) {
              _context.next = 63;
              break;
            }

            list = [].concat(extensions);
            i = 0;

          case 50:
            if (!(i < list.length)) {
              _context.next = 63;
              break;
            }

            ext = list[i];

            if (!(typeof ext !== 'string')) {
              _context.next = 54;
              break;
            }

            throw new TypeError('option extensions must be array of strings or false');

          case 54:
            if (!/^\./.exec(ext)) ext = '.' + ext;
            _context.next = 57;
            return fs.exists(path + ext);

          case 57:
            if (!_context.sent) {
              _context.next = 60;
              break;
            }

            path = path + ext;
            return _context.abrupt('break', 63);

          case 60:
            i++;
            _context.next = 50;
            break;

          case 63:

            // stat
            stats = void 0;
            _context.prev = 64;
            _context.next = 67;
            return fs.stat(path);

          case 67:
            stats = _context.sent;

            if (!stats.isDirectory()) {
              _context.next = 77;
              break;
            }

            if (!(format && index)) {
              _context.next = 76;
              break;
            }

            path += '/' + index;
            _context.next = 73;
            return fs.stat(path);

          case 73:
            stats = _context.sent;
            _context.next = 77;
            break;

          case 76:
            return _context.abrupt('return');

          case 77:
            _context.next = 86;
            break;

          case 79:
            _context.prev = 79;
            _context.t2 = _context['catch'](64);
            notfound = ['ENOENT', 'ENAMETOOLONG', 'ENOTDIR'];

            if (!notfound.includes(_context.t2.code)) {
              _context.next = 84;
              break;
            }

            throw createError(404, _context.t2);

          case 84:
            _context.t2.status = 500;
            throw _context.t2;

          case 86:

            if (setHeaders) setHeaders(ctx.res, path, stats);

            // stream
            ctx.set('Content-Length', stats.size);
            if (!ctx.response.get('Last-Modified')) ctx.set('Last-Modified', stats.mtime.toUTCString());
            if (!ctx.response.get('Cache-Control')) {
              directives = ['max-age=' + (maxage / 1000 | 0)];

              if (immutable) {
                directives.push('immutable');
              }
              ctx.set('Cache-Control', directives.join(','));
            }
            ctx.type = type(path, encodingExt);
            ctx.body = fs.createReadStream(path);

            return _context.abrupt('return', path);

          case 93:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this, [[64, 79]]);
  }));

  return function send(_x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

/**
 * Check if it's hidden.
 */

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/**
 * Module dependencies.
 */

var debug = require('debug')('koa-send');
var resolvePath = require('resolve-path');
var createError = require('http-errors');
var assert = require('assert');
var fs = require('mz/fs');

var _require = require('path'),
    normalize = _require.normalize,
    basename = _require.basename,
    extname = _require.extname,
    resolve = _require.resolve,
    parse = _require.parse,
    sep = _require.sep;

/**
 * Expose `send()`.
 */

module.exports = send;function isHidden(root, path) {
  path = path.substr(root.length).split(sep);
  for (var i = 0; i < path.length; i++) {
    if (path[i][0] === '.') return true;
  }
  return false;
}

/**
 * File type.
 */

function type(file, ext) {
  return ext !== '' ? extname(basename(file, ext)) : extname(file);
}

/**
 * Decode `path`.
 */

function decode(path) {
  try {
    return decodeURIComponent(path);
  } catch (err) {
    return -1;
  }
}