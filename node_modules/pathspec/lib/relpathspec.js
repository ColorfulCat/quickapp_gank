// Generated by CoffeeScript 1.3.3
(function() {
  var Mask, PathComponents, RelPathSpec, SingleSubpathRelPathSpec, StarStarRelPathSpec, Subpath,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Mask = require('./mask');

  PathComponents = (function() {

    function PathComponents(components, isDir, hasSlash) {
      this.components = components;
      this.isDir = isDir;
      this.hasSlash = hasSlash;
    }

    PathComponents.prototype.split = function(delimiter, collapseConsecutiveDelimiters) {
      var component, index, result, _i, _len, _ref;
      if (collapseConsecutiveDelimiters == null) {
        collapseConsecutiveDelimiters = true;
      }
      result = [[]];
      _ref = this.components;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        component = _ref[index];
        if (component === delimiter) {
          if (collapseConsecutiveDelimiters && (index > 0) && this.components[index - 1] === delimiter) {
            continue;
          }
          result.push([]);
        } else {
          result[result.length - 1].push(component);
        }
      }
      return result;
    };

    return PathComponents;

  })();

  PathComponents.parse = function(string) {
    var c, components, hasLeadingSlash, hasSlash, isDir;
    if (!string) {
      return new PathComponents([], false);
    } else {
      components = string.split('/');
      isDir = components[components.length - 1] === '';
      hasLeadingSlash = components[0] === '';
      components = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = components.length; _i < _len; _i++) {
          c = components[_i];
          if (c) {
            _results.push(c);
          }
        }
        return _results;
      })();
      hasSlash = hasLeadingSlash || components.length > 1;
      return new PathComponents(components, isDir, hasSlash);
    }
  };

  Subpath = (function() {

    function Subpath(masks) {
      this.masks = masks;
    }

    Subpath.prototype.matchesAt = function(components, startIndex) {
      var i, _i, _ref;
      if (components.length < this.masks.length) {
        return false;
      }
      for (i = _i = 0, _ref = this.masks.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (!this.masks[i].matches(components[startIndex + i])) {
          return false;
        }
      }
      return true;
    };

    Subpath.prototype.matchesEntirely = function(components) {
      return (components.length === this.masks.length) && this.matchesAt(components, 0);
    };

    Subpath.prototype.matchesAtStart = function(components) {
      return this.matchesAt(components, 0);
    };

    Subpath.prototype.matchesAtEnd = function(components) {
      return this.matchesAt(components, components.length - this.masks.length);
    };

    Subpath.prototype.find = function(components) {
      var i, _i, _ref;
      for (i = _i = 0, _ref = components.length - this.masks.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (this.matchesAt(components, i)) {
          return i;
        }
      }
      return -1;
    };

    Subpath.prototype.matchAndRemoveAtStart = function(components) {
      if (this.matchesAtStart(components)) {
        return components.slice(this.masks.length);
      } else {
        return null;
      }
    };

    Subpath.prototype.matchAndRemoveAtEnd = function(components) {
      if (this.matchesAtEnd(components)) {
        return components.slice(0, components.length - this.masks.length);
      } else {
        return null;
      }
    };

    Subpath.prototype.findAndRemove = function(components) {
      var index;
      if ((index = this.find(components)) >= 0) {
        return components.slice(index + this.masks.length);
      } else {
        return null;
      }
    };

    Subpath.prototype.toString = function() {
      var mask;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = this.masks;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          mask = _ref[_i];
          _results.push(mask.toString());
        }
        return _results;
      }).call(this)).join('/');
    };

    return Subpath;

  })();

  RelPathSpec = (function() {

    function RelPathSpec() {}

    RelPathSpec.prototype.matches = function(path, isDir) {
      var parsed;
      if (isDir == null) {
        isDir = false;
      }
      parsed = PathComponents.parse(path);
      if (this.mustBeDir && !(isDir || parsed.isDir)) {
        return false;
      }
      return this.matchesComponents(parsed.components);
    };

    return RelPathSpec;

  })();

  SingleSubpathRelPathSpec = (function(_super) {

    __extends(SingleSubpathRelPathSpec, _super);

    function SingleSubpathRelPathSpec(subpath, mustBeDir) {
      this.subpath = subpath;
      this.mustBeDir = mustBeDir;
    }

    SingleSubpathRelPathSpec.prototype.matchesComponents = function(components) {
      return this.subpath.matchesEntirely(components);
    };

    return SingleSubpathRelPathSpec;

  })(RelPathSpec);

  StarStarRelPathSpec = (function(_super) {

    __extends(StarStarRelPathSpec, _super);

    function StarStarRelPathSpec(subpaths, mustBeDir) {
      this.subpaths = subpaths;
      this.mustBeDir = mustBeDir;
      this.prefix = this.subpaths.shift();
      this.suffix = this.subpaths.pop();
    }

    StarStarRelPathSpec.prototype.matchesComponents = function(components) {
      var subpath, _i, _len, _ref;
      if (!(components = this.prefix.matchAndRemoveAtStart(components))) {
        return false;
      }
      if (!(components = this.suffix.matchAndRemoveAtEnd(components))) {
        return false;
      }
      _ref = this.subpaths;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subpath = _ref[_i];
        if (!(components = subpath.findAndRemove(components))) {
          return false;
        }
      }
      return true;
    };

    StarStarRelPathSpec.prototype.toString = function() {
      var subpath;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = [this.prefix].concat(this.subpaths).concat([this.suffix]);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          subpath = _ref[_i];
          _results.push(subpath.toString());
        }
        return _results;
      }).call(this)).join('/**/').replace(/^\/\*\*|\*\*\/$/g, '**');
    };

    return StarStarRelPathSpec;

  })(RelPathSpec);

  RelPathSpec.parse = function(path, gitStyle) {
    var component, parsed, subcomponents, subpaths;
    if (gitStyle == null) {
      gitStyle = false;
    }
    parsed = PathComponents.parse(path);
    subpaths = (function() {
      var _i, _len, _ref, _results;
      _ref = parsed.split('**');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subcomponents = _ref[_i];
        _results.push(new Subpath((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = subcomponents.length; _j < _len1; _j++) {
            component = subcomponents[_j];
            _results1.push(Mask.parse(component));
          }
          return _results1;
        })()));
      }
      return _results;
    })();
    if (gitStyle) {
      if (!parsed.hasSlash) {
        subpaths.unshift(new Subpath([]));
      }
      if (subpaths[subpaths.length - 1].masks.length !== 0) {
        subpaths.push(new Subpath([]));
      }
    }
    if (subpaths.length === 1) {
      return new SingleSubpathRelPathSpec(subpaths[0], parsed.isDir);
    } else {
      return new StarStarRelPathSpec(subpaths, parsed.isDir);
    }
  };

  RelPathSpec.parseGitStyleSpec = function(spec) {
    return RelPathSpec.parse(spec, true);
  };

  module.exports = RelPathSpec;

}).call(this);
