/**
 * Created by exolution on 17/1/4.
 */
const Path = require('path');
const Util = require('../util');
const Fs = require('fs');
const Chalk = require('chalk');
const Inquirer = require('inquirer');
const ChildProcess = require('child_process');
module.exports = class NPMLocator {
    constructor() {
    }

    locate(location) {
        let [packageNameAndVersion,bin]=location.split('.');
        let [packageName,version]=packageNameAndVersion.split('@')
        bin = bin || packageName;
        let dependency = {
            packageName,
            version,
            bin
        };
        return new Promise((resolve, reject)=> {

            let packagePath = Path.join(Util.modulePath(), packageName);
            if (Fs.existsSync(packagePath)) {

                let binPath = this.findBinPath(packagePath, bin);
                if (binPath)resolve({
                    packageName,
                    version,
                    bin,
                    path: binPath
                });
                else reject('can not find executable files[' + bin + '] in module [' + packageName + ']');
            }
            else {
                Inquirer.prompt({
                    type: 'confirm',
                    message: 'This command need to install ' + Chalk.white.bgBlue(packageName) + '. Install now?',
                    name: 'setup'
                }).then((answers) => {

                    if (answers.setup) {
                        Util.npmInstall(packageName + (version?'@' + version:''), Util.homePath(), true);
                        this.locate(location).then(function (ret) {
                            resolve({
                                packageName,
                                version,
                                bin,
                                path: ret
                            });
                        }, function (reason) {
                            reject(reason)
                        });
                    }
                    else {
                        reject('Install rejected!');
                    }
                })
            }
        })
    }

    findBinPath(path, bin) {
        let packageJSON = require(Path.join(path, 'package.json'));
        this.findLatestVersion(path, packageJSON);
        if (typeof packageJSON.bin == 'string') {
            packageJSON.bin = {[packageJSON.name]: packageJSON.bin};
        }
        if(packageJSON.bin[bin]){
            return Path.join(path,packageJSON.bin[bin]);
        }
        else{
            let defaultPath=Path.dirname(packageJSON.bin[packageJSON.name]);
            let files=Fs.readdirSync(Path.join(path,defaultPath));
            files=files.filter(f=>Path.basename(f,Path.extname(f))==packageJSON.name+'-'+bin);
            if(files[0]){
               return Path.join(path,defaultPath,files[0]);
            }
            return null;
        }
        return packageJSON.bin[bin] ? Path.join(path, packageJSON.bin[bin]) : null;
    }

    findLatestVersion(packagePath, packageJSON) {
        let npm = ChildProcess.spawn(process.platform === 'win32' ? 'npm.cmd' : 'npm', ['show', Path.basename(packagePath), 'version'],{timeout:5});
        npm.stdout.on('data', (data) => {
            let latestVersion = data.toString().replace('\\n', '');
            packageJSON._latestVersion = latestVersion;
            Fs.writeFile(Path.join(packagePath, 'package.json'), JSON.stringify(packageJSON, null, 4), function () {
            });
        });
    }
}