/**
 * Created by exolution on 17/1/3.
 */
const ChildProcess = require('child_process');
const Util = require('./util');
const Command = require('./Command');
const Argv = require('./Argv');
const Chalk=require('chalk');
class XToolkit {
    constructor() {
        this.begin = false;
        this._commands = {};
    }

    _usage() {

    }

    usage(func) {
        this._usage = func;
    }

    version(ver) {
        if (typeof ver !== 'function') {
            this._version = function () {
                console.log('   v'+ver);
            }
        }
        else {
            this._version = ver;
        }
    }

    command(command, location, args, description) {
        if (!this.begin) {
            this.begin = true;
            process.nextTick(()=> {
                this.done()
            })
        }
        this._commands[command] = new Command(command, location, args, description);
        return this;
    }

    showSubVersion() {
        let info=JSON.parse(ChildProcess.execSync('npm ls --json --depth=0', {cwd: Util.homePath()}).toString());
        if(info.dependencies){
            for(var key in info.dependencies){
                console.log(Chalk.gray(' - '+key+' : v'+info.dependencies[key].version));
            }
        }
    }

    done() {
        let argv = new Argv(process.argv.slice(2));
        let cmd = argv._params[0];
        if (this._commands[cmd]) {
            this._commands[cmd].run().catch((err)=> {
                console.error(err);
                if (err.stack)console.error(err.stack);
            });
        }
        else if (this._commands['']) {
            if ((argv.version || argv.v)&&this._version) {
                this._version();
                this.showSubVersion();
            }
            else {
                this._commands[''].run().catch((err)=> {
                    console.error(err);
                    if (err.stack)console.error(err.stack);
                });
            }
        }
    }
}


module.exports = new XToolkit();