/* Runtime.js */
/*
 * Copyright (C) 2014 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// This gets all concatenated module descriptors in the release mode.
var allDescriptors = [{"dependencies": ["platform", "common", "host", "ui", "diff"], "name": "ui_lazy", "scripts": []}, {"experiment": "promiseTracker", "extensions": [{"name": "promises", "title": "Promises", "className": "WebInspector.PromisePane", "type": "drawer-view", "order": 30, "persistence": "permanent"}], "name": "promises", "dependencies": ["components", "ui_lazy"], "scripts": []}, {"name": "heap_snapshot_worker", "scripts": []}, {"dependencies": ["components", "source_frame", "snippets", "ui_lazy", "extensions"], "extensions": [{"className": "WebInspector.SourcesPanelFactory", "order": 30, "type": "@WebInspector.PanelFactory", "name": "sources", "title": "Sources"}, {"className": "WebInspector.SourcesPanel.ContextMenuProvider", "contextTypes": ["WebInspector.UISourceCode", "WebInspector.UILocation", "WebInspector.RemoteObject", "WebInspector.NetworkRequest"], "type": "@WebInspector.ContextMenu.Provider"}, {"iconClass": "pause-toolbar-item", "className": "WebInspector.SourcesPanel.RevealingActionDelegate", "contextTypes": ["WebInspector.SourcesPanel", "WebInspector.ShortcutRegistry.ForwardedShortcut"], "actionId": "debugger.toggle-pause", "bindings": [{"platform": "windows,linux", "shortcut": "F8 Ctrl+\\"}, {"platform": "mac", "shortcut": "F8 Meta+\\"}], "type": "@WebInspector.ActionDelegate"}, {"iconClass": "step-over-toolbar-item", "title": "Step over next function call", "className": "WebInspector.SourcesPanel.DebuggingActionDelegate", "contextTypes": ["WebInspector.SourcesPanel"], "actionId": "debugger.step-over", "bindings": [{"platform": "windows,linux", "shortcut": "F10 Ctrl+'"}, {"platform": "mac", "shortcut": "F10 Meta+'"}], "type": "@WebInspector.ActionDelegate"}, {"iconClass": "step-in-toolbar-item", "title": "Step into next function call", "className": "WebInspector.SourcesPanel.DebuggingActionDelegate", "contextTypes": ["WebInspector.SourcesPanel"], "actionId": "debugger.step-into", "bindings": [{"platform": "windows,linux", "shortcut": "F11 Ctrl+;"}, {"platform": "mac", "shortcut": "F11 Meta+;"}], "type": "@WebInspector.ActionDelegate"}, {"className": "WebInspector.SourcesPanel.DebuggingActionDelegate", "experiment": "stepIntoAsync", "contextTypes": ["WebInspector.SourcesPanel"], "actionId": "debugger.step-into-async", "bindings": [{"platform": "windows,linux", "shortcut": "Alt+F11 Alt+Ctrl+;"}, {"platform": "mac", "shortcut": "Alt+F11 Alt+Meta+;"}], "type": "@WebInspector.ActionDelegate"}, {"iconClass": "step-out-toolbar-item", "title": "Step out of current function", "className": "WebInspector.SourcesPanel.DebuggingActionDelegate", "contextTypes": ["WebInspector.SourcesPanel"], "actionId": "debugger.step-out", "bindings": [{"platform": "windows,linux", "shortcut": "Shift+F11 Shift+Ctrl+;"}, {"platform": "mac", "shortcut": "Shift+F11 Shift+Meta+;"}], "type": "@WebInspector.ActionDelegate"}, {"iconClass": "play-toolbar-item", "title": "Run snippet", "className": "WebInspector.SourcesPanel.DebuggingActionDelegate", "contextTypes": ["WebInspector.SourcesPanel"], "actionId": "debugger.run-snippet", "bindings": [{"platform": "windows,linux", "shortcut": "Ctrl+Enter"}, {"platform": "mac", "shortcut": "Meta+Enter"}], "type": "@WebInspector.ActionDelegate"}, {"className": "WebInspector.AdvancedSearchView.ActionDelegate", "bindings": [{"platform": "mac", "shortcut": "Meta+Alt+F"}, {"platform": "windows,linux", "shortcut": "Ctrl+Shift+F"}], "type": "@WebInspector.ActionDelegate", "actionId": "sources.search.toggle", "title": "Search all files"}, {"iconClass": "breakpoint-toolbar-item", "className": "WebInspector.SourcesPanel.DebuggingActionDelegate", "contextTypes": ["WebInspector.SourcesPanel"], "actionId": "debugger.toggle-breakpoints-active", "bindings": [{"platform": "windows,linux", "shortcut": "Ctrl+F8"}, {"platform": "mac", "shortcut": "Meta+F8"}], "type": "@WebInspector.ActionDelegate"}, {"type": "context-menu-item", "location": "mainMenu/navigate", "actionId": "sources.search.toggle"}, {"type": "context-menu-item", "location": "navigatorMenu/navigate", "actionId": "sources.go-to-source"}, {"className": "WebInspector.SourcesPanel.UILocationRevealer", "contextTypes": ["WebInspector.UILocation"], "type": "@WebInspector.Revealer"}, {"className": "WebInspector.SourcesPanel.DebuggerLocationRevealer", "contextTypes": ["WebInspector.DebuggerModel.Location"], "type": "@WebInspector.Revealer"}, {"className": "WebInspector.SourcesPanel.UISourceCodeRevealer", "contextTypes": ["WebInspector.UISourceCode"], "type": "@WebInspector.Revealer"}, {"className": "WebInspector.SourcesPanel.DebuggerPausedDetailsRevealer", "contextTypes": ["WebInspector.DebuggerPausedDetails"], "type": "@WebInspector.Revealer"}, {"className": "WebInspector.InplaceFormatterEditorAction", "type": "@WebInspector.SourcesView.EditorAction"}, {"className": "WebInspector.ScriptFormatterEditorAction", "type": "@WebInspector.SourcesView.EditorAction"}, {"name": "sources", "title": "Sources", "className": "WebInspector.SourcesNavigatorView", "type": "navigator-view", "order": 1, "persistence": "permanent"}, {"name": "contentScripts", "title": "Content scripts", "className": "WebInspector.ContentScriptsNavigatorView", "type": "navigator-view", "order": 2, "persistence": "permanent"}, {"name": "snippets", "title": "Snippets", "className": "WebInspector.SnippetsNavigatorView", "type": "navigator-view", "order": 3, "persistence": "permanent"}, {"title": "Go to file...", "className": "WebInspector.SourcesPanel.RevealingActionDelegate", "actionId": "sources.go-to-source", "bindings": [{"platform": "mac", "shortcut": "Meta+P Meta+O"}, {"platform": "windows,linux", "shortcut": "Ctrl+P Ctrl+O"}], "type": "@WebInspector.ActionDelegate", "order": 100}, {"className": "WebInspector.SourcesView.SwitchFileActionDelegate", "contextTypes": ["WebInspector.SourcesView"], "bindings": [{"shortcut": "Alt+O"}], "type": "@WebInspector.ActionDelegate", "actionId": "sources.switch-file"}, {"defaultValue": "true", "type": "setting", "settingName": "navigatorGroupByFolder", "settingType": "boolean"}, {"category": "Sources", "title": "Search in content scripts", "defaultValue": false, "settingName": "searchInContentScripts", "settingType": "boolean", "type": "setting"}, {"category": "Sources", "title": "Enable JavaScript source maps", "defaultValue": true, "settingName": "jsSourceMapsEnabled", "settingType": "boolean", "type": "setting"}, {"category": "Sources", "title": "Detect indentation", "defaultValue": true, "settingName": "textEditorAutoDetectIndent", "settingType": "boolean", "type": "setting"}, {"category": "Sources", "title": "Autocompletion", "defaultValue": true, "settingName": "textEditorAutocompletion", "settingType": "boolean", "type": "setting"}, {"category": "Sources", "title": "Bracket matching", "defaultValue": true, "settingName": "textEditorBracketMatching", "settingType": "boolean", "type": "setting"}, {"category": "Sources", "title": "Show whitespace characters:", "defaultValue": "original", "settingName": "showWhitespacesInEditor", "settingType": "enum", "type": "setting", "options": [["None", "none"], ["All", "all"], ["Trailing", "trailing"]]}, {"category": "Sources", "title": "Display variable values inline while debugging", "defaultValue": true, "settingName": "inlineVariableValues", "settingType": "boolean", "type": "setting"}, {"category": "Sources", "title": "Enable CSS source maps", "defaultValue": true, "settingName": "cssSourceMapsEnabled", "settingType": "boolean", "type": "setting"}, {"title": "Auto-reload generated CSS", "defaultValue": false, "parentSettingName": "cssSourceMapsEnabled", "settingName": "cssReloadEnabled", "settingType": "boolean", "type": "setting"}, {"name": "sources.search", "title": "Search", "className": "WebInspector.AdvancedSearchView", "type": "drawer-view", "order": 100, "persistence": "closeable"}, {"className": "WebInspector.RevisionHistoryView", "type": "drawer-view", "name": "sources.history", "persistence": "temporary", "title": "History"}], "name": "sources", "scripts": []}, {"remote": true, "name": "emulated_devices", "dependencies": ["emulation"], "extensions": [{"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "iPhone 4", "screen": {"horizontal": {"width": 480, "height": 320}, "device-pixel-ratio": 2, "vertical": {"width": 320, "height": 480}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1", "type": "phone"}, "type": "emulated-device"}, {"device": {"show-by-default": true, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "iPhone 5", "screen": {"horizontal": {"width": 568, "height": 320}, "device-pixel-ratio": 2, "vertical": {"width": 320, "height": 568}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1", "type": "phone"}, "type": "emulated-device", "order": 40}, {"device": {"show-by-default": true, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "iPhone 6", "screen": {"horizontal": {"width": 667, "height": 375}, "device-pixel-ratio": 2, "vertical": {"width": 375, "height": 667}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1", "type": "phone"}, "type": "emulated-device", "order": 50}, {"device": {"show-by-default": true, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "iPhone 6 Plus", "screen": {"horizontal": {"width": 736, "height": 414}, "device-pixel-ratio": 3, "vertical": {"width": 414, "height": 736}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1", "type": "phone"}, "type": "emulated-device", "order": 60}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "BlackBerry Z30", "screen": {"horizontal": {"width": 640, "height": 360}, "device-pixel-ratio": 2, "vertical": {"width": 360, "height": 640}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+", "type": "phone"}, "type": "emulated-device"}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Nexus 4", "screen": {"horizontal": {"width": 640, "height": 384}, "device-pixel-ratio": 2, "vertical": {"width": 384, "height": 640}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.23 Mobile Safari/537.36", "type": "phone"}, "type": "emulated-device"}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 25, "right": 0, "bottom": 48, "left": 0}, "image": "@url(google-nexus-5-vertical-default-1x.png) 1x, @url(google-nexus-5-vertical-default-2x.png) 2x", "orientation": "vertical", "title": "default"}, {"insets": {"top": 80, "right": 0, "bottom": 48, "left": 0}, "image": "@url(google-nexus-5-vertical-navigation-1x.png) 1x, @url(google-nexus-5-vertical-navigation-2x.png) 2x", "orientation": "vertical", "title": "navigation bar"}, {"insets": {"top": 80, "right": 0, "bottom": 312, "left": 0}, "image": "@url(google-nexus-5-vertical-keyboard-1x.png) 1x, @url(google-nexus-5-vertical-keyboard-2x.png) 2x", "orientation": "vertical", "title": "keyboard"}, {"insets": {"top": 25, "right": 42, "bottom": 0, "left": 0}, "image": "@url(google-nexus-5-horizontal-default-1x.png) 1x, @url(google-nexus-5-horizontal-default-2x.png) 2x", "orientation": "horizontal", "title": "default"}, {"insets": {"top": 80, "right": 42, "bottom": 0, "left": 0}, "image": "@url(google-nexus-5-horizontal-navigation-1x.png) 1x, @url(google-nexus-5-horizontal-navigation-2x.png) 2x", "orientation": "horizontal", "title": "navigation bar"}, {"insets": {"top": 80, "right": 42, "bottom": 202, "left": 0}, "image": "@url(google-nexus-5-horizontal-keyboard-1x.png) 1x, @url(google-nexus-5-horizontal-keyboard-2x.png) 2x", "orientation": "horizontal", "title": "keyboard"}], "title": "Nexus 5", "screen": {"horizontal": {"width": 640, "height": 360}, "device-pixel-ratio": 3, "vertical": {"width": 360, "height": 640}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.23 Mobile Safari/537.36", "type": "phone"}, "type": "emulated-device"}, {"device": {"show-by-default": true, "modes": [{"insets": {"top": 24, "right": 0, "bottom": 48, "left": 0}, "image": "@url(google-nexus-5x-vertical-default-1x.png) 1x, @url(google-nexus-5x-vertical-default-2x.png) 2x", "orientation": "vertical", "title": "default"}, {"insets": {"top": 80, "right": 0, "bottom": 48, "left": 0}, "image": "@url(google-nexus-5x-vertical-navigation-1x.png) 1x, @url(google-nexus-5x-vertical-navigation-2x.png) 2x", "orientation": "vertical", "title": "navigation bar"}, {"insets": {"top": 80, "right": 0, "bottom": 342, "left": 0}, "image": "@url(google-nexus-5x-vertical-keyboard-1x.png) 1x, @url(google-nexus-5x-vertical-keyboard-2x.png) 2x", "orientation": "vertical", "title": "keyboard"}, {"insets": {"top": 24, "right": 48, "bottom": 0, "left": 0}, "image": "@url(google-nexus-5x-horizontal-default-1x.png) 1x, @url(google-nexus-5x-horizontal-default-2x.png) 2x", "orientation": "horizontal", "title": "default"}, {"insets": {"top": 80, "right": 48, "bottom": 0, "left": 0}, "image": "@url(google-nexus-5x-horizontal-navigation-1x.png) 1x, @url(google-nexus-5x-horizontal-navigation-2x.png) 2x", "orientation": "horizontal", "title": "navigation bar"}, {"insets": {"top": 80, "right": 48, "bottom": 222, "left": 0}, "image": "@url(google-nexus-5x-horizontal-keyboard-1x.png) 1x, @url(google-nexus-5x-horizontal-keyboard-2x.png) 2x", "orientation": "horizontal", "title": "keyboard"}], "title": "Nexus 5X", "screen": {"horizontal": {"width": 731, "height": 411}, "device-pixel-ratio": 2.625, "vertical": {"width": 411, "height": 731}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.23 Mobile Safari/537.36", "type": "phone"}, "type": "emulated-device", "order": 20}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Nexus 6", "screen": {"horizontal": {"width": 732, "height": 412}, "device-pixel-ratio": 3.5, "vertical": {"width": 412, "height": 732}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (Linux; Android 5.1.1; Nexus 6 Build/LYZ28E) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.23 Mobile Safari/537.36", "type": "phone"}, "type": "emulated-device"}, {"device": {"show-by-default": true, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Nexus 6P", "screen": {"horizontal": {"width": 773, "height": 435}, "device-pixel-ratio": 3.3, "vertical": {"width": 435, "height": 773}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (Linux; Android 5.1.1; Nexus 6 Build/LYZ28E) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.23 Mobile Safari/537.36", "type": "phone"}, "type": "emulated-device", "order": 30}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "LG Optimus L70", "screen": {"horizontal": {"width": 640, "height": 384}, "device-pixel-ratio": 1.25, "vertical": {"width": 384, "height": 640}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/48.0.2564.23 Mobile Safari/537.36", "type": "phone"}, "type": "emulated-device"}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Nokia N9", "screen": {"horizontal": {"width": 640, "height": 360}, "device-pixel-ratio": 1, "vertical": {"width": 360, "height": 640}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13", "type": "phone"}, "type": "emulated-device"}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Nokia Lumia 520", "screen": {"horizontal": {"width": 533, "height": 320}, "device-pixel-ratio": 1.4, "vertical": {"width": 320, "height": 533}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)", "type": "phone"}, "type": "emulated-device"}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Galaxy S III", "screen": {"horizontal": {"width": 640, "height": 360}, "device-pixel-ratio": 2, "vertical": {"width": 360, "height": 640}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30", "type": "phone"}, "type": "emulated-device"}, {"device": {"show-by-default": true, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Galaxy S5", "screen": {"horizontal": {"width": 640, "height": 360}, "device-pixel-ratio": 3, "vertical": {"width": 360, "height": 640}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.23 Mobile Safari/537.36", "type": "phone"}, "type": "emulated-device", "order": 10}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Kindle Fire HDX", "screen": {"horizontal": {"width": 2560, "height": 1600}, "device-pixel-ratio": 2, "vertical": {"width": 1600, "height": 2560}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true", "type": "tablet"}, "type": "emulated-device"}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "iPad Mini", "screen": {"horizontal": {"width": 1024, "height": 768}, "device-pixel-ratio": 2, "vertical": {"width": 768, "height": 1024}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (iPad; CPU OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1", "type": "tablet"}, "type": "emulated-device"}, {"device": {"show-by-default": true, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "iPad", "screen": {"horizontal": {"width": 1024, "height": 768}, "device-pixel-ratio": 2, "vertical": {"width": 768, "height": 1024}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (iPad; CPU OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1", "type": "tablet"}, "type": "emulated-device", "order": 70}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Blackberry PlayBook", "screen": {"horizontal": {"width": 1024, "height": 600}, "device-pixel-ratio": 1, "vertical": {"width": 600, "height": 1024}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+", "type": "tablet"}, "type": "emulated-device"}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Nexus 10", "screen": {"horizontal": {"width": 1280, "height": 800}, "device-pixel-ratio": 2, "vertical": {"width": 800, "height": 1280}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (Linux; Android 4.3; Nexus 10 Build/JSS15Q) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.23 Safari/537.36", "type": "tablet"}, "type": "emulated-device"}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Nexus 7", "screen": {"horizontal": {"width": 960, "height": 600}, "device-pixel-ratio": 2, "vertical": {"width": 600, "height": 960}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (Linux; Android 4.3; Nexus 7 Build/JSS15Q) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.23 Safari/537.36", "type": "tablet"}, "type": "emulated-device"}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Galaxy Note 3", "screen": {"horizontal": {"width": 640, "height": 360}, "device-pixel-ratio": 3, "vertical": {"width": 360, "height": 640}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30", "type": "phone"}, "type": "emulated-device"}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "vertical", "title": "default"}, {"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Galaxy Note II", "screen": {"horizontal": {"width": 640, "height": 360}, "device-pixel-ratio": 2, "vertical": {"width": 360, "height": 640}}, "capabilities": ["touch", "mobile"], "user-agent": "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30", "type": "phone"}, "type": "emulated-device"}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Laptop with touch", "screen": {"horizontal": {"width": 1280, "height": 950}, "device-pixel-ratio": 1, "vertical": {"width": 950, "height": 1280}}, "capabilities": ["touch"], "user-agent": "", "type": "notebook"}, "type": "emulated-device"}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Laptop with HiDPI screen", "screen": {"horizontal": {"width": 1440, "height": 900}, "device-pixel-ratio": 2, "vertical": {"width": 900, "height": 1440}}, "capabilities": [], "user-agent": "", "type": "notebook"}, "type": "emulated-device"}, {"device": {"show-by-default": false, "modes": [{"insets": {"top": 0, "right": 0, "bottom": 0, "left": 0}, "orientation": "horizontal", "title": "default"}], "title": "Laptop with MDPI screen", "screen": {"horizontal": {"width": 1280, "height": 800}, "device-pixel-ratio": 1, "vertical": {"width": 800, "height": 1280}}, "capabilities": [], "user-agent": "", "type": "notebook"}, "type": "emulated-device"}], "scripts": []}, {"skip_compilation": ["diff_match_patch.js"], "dependencies": ["common"], "name": "diff", "scripts": []}, {"dependencies": ["sdk", "platform", "workspace"], "name": "bindings", "scripts": []}, {"dependencies": ["bindings"], "name": "snippets", "scripts": []}, {"skip_compilation": ["../acorn/acorn.js", "../cm/headlesscodemirror.js", "../cm/css.js", "../cm/xml.js", "../cm/htmlmixed.js"], "name": "script_formatter_worker", "scripts": []}, {"dependencies": ["components", "ui_lazy"], "extensions": [{"className": "WebInspector.ConsolePanelFactory", "order": 20, "type": "@WebInspector.PanelFactory", "name": "console", "title": "Console"}, {"name": "console", "title": "Console", "className": "WebInspector.ConsolePanel.WrapperView", "type": "drawer-view", "order": 0, "persistence": "permanent"}, {"className": "WebInspector.ConsolePanel.ConsoleRevealer", "contextTypes": ["WebInspector.Console"], "type": "@WebInspector.Revealer"}, {"className": "WebInspector.ConsoleView.ActionDelegate", "bindings": [{"shortcut": "Ctrl+`"}], "type": "@WebInspector.ActionDelegate", "actionId": "console.show"}, {"iconClass": "clear-toolbar-item", "title": "Clear console", "className": "WebInspector.ConsoleView.ActionDelegate", "actionId": "console.clear", "bindings": [{"platform": "windows,linux", "shortcut": "Ctrl+L"}, {"platform": "mac", "shortcut": "Ctrl+L Meta+K"}], "type": "@WebInspector.ActionDelegate"}, {"category": "Console", "className": "WebInspector.ConsoleView.ActionDelegate", "type": "@WebInspector.ActionDelegate", "actionId": "console.clear.history", "title": "Clear console history"}, {"category": "Console", "title": "Hide network messages", "defaultValue": false, "settingName": "hideNetworkMessages", "settingType": "boolean", "type": "setting"}, {"category": "Console", "title": "Log XMLHttpRequests", "defaultValue": false, "settingName": "monitoringXHREnabled", "settingType": "boolean", "type": "setting"}, {"category": "Console", "title": "Preserve log upon navigation", "defaultValue": false, "settingName": "preserveConsoleLog", "settingType": "boolean", "type": "setting"}, {"category": "Console", "title": "Show timestamps", "defaultValue": false, "settingName": "consoleTimestampsEnabled", "settingType": "boolean", "type": "setting"}, {"category": "Console", "title": "Autocomplete from history", "defaultValue": true, "settingName": "consoleHistoryAutocomplete", "settingType": "boolean", "type": "setting"}], "name": "console", "scripts": []}, {"dependencies": ["source_frame", "components", "components_lazy", "ui_lazy"], "extensions": [{"className": "WebInspector.NetworkPanelFactory", "order": 40, "type": "@WebInspector.PanelFactory", "name": "network", "title": "Network"}, {"className": "WebInspector.NetworkPanel.ContextMenuProvider", "contextTypes": ["WebInspector.NetworkRequest", "WebInspector.Resource", "WebInspector.UISourceCode"], "type": "@WebInspector.ContextMenu.Provider"}, {"className": "WebInspector.NetworkPanel.RequestRevealer", "contextTypes": ["WebInspector.NetworkRequest"], "type": "@WebInspector.Revealer"}, {"category": "Network", "title": "Show primary load waterfall", "defaultValue": false, "experiment": "showPrimaryLoadWaterfallInNetworkTimeline", "settingName": "networkShowPrimaryLoadWaterfall", "settingType": "boolean", "type": "setting"}, {"category": "Network", "title": "Color-code resource types", "defaultValue": false, "settingName": "networkColorCodeResourceTypes", "settingType": "boolean", "type": "setting"}, {"className": "WebInspector.BlockedURLsPane.ActionDelegate", "iconClass": "block-toolbar-item", "type": "@WebInspector.ActionDelegate", "actionId": "network.blocked-urls.show", "title": "Block network requests"}, {"iconClass": "record-toolbar-item", "className": "WebInspector.NetworkPanel.RecordActionDelegate", "contextTypes": ["WebInspector.NetworkPanel"], "actionId": "network.toggle-recording", "bindings": [{"platform": "windows,linux", "shortcut": "Ctrl+E"}, {"platform": "mac", "shortcut": "Meta+E"}], "type": "@WebInspector.ActionDelegate"}, {"name": "network.blocked-urls", "title": "Request blocking", "className": "WebInspector.BlockedURLsPane", "experiment": "requestBlocking", "type": "drawer-view", "order": 60, "persistence": "closeable"}, {"className": "WebInspector.NetworkConfigView.ShowActionDelegate", "type": "@WebInspector.ActionDelegate", "actionId": "network.show-config", "title": "Network conditions"}, {"actionId": "network.show-config", "type": "context-menu-item", "location": "mainMenu/tools/open", "order": 60}, {"name": "network.config", "title": "Network conditions", "className": "WebInspector.NetworkConfigView", "type": "drawer-view", "order": 40, "persistence": "closeable"}], "name": "network", "scripts": []}, {"remote": true, "name": "cm_modes", "dependencies": ["source_frame"], "extensions": [{"className": "WebInspector.DefaultCodeMirrorMimeMode", "mimeTypes": ["text/x-csrc", "text/x-c", "text/x-chdr", "text/x-c++src", "text/x-c++hdr", "text/x-java", "text/x-csharp", "text/x-scala", "x-shader/x-vertex", "x-shader/x-fragment"], "type": "@WebInspector.CodeMirrorMimeMode", "fileName": "clike.js"}, {"className": "WebInspector.DefaultCodeMirrorMimeMode", "mimeTypes": ["text/x-coffeescript"], "type": "@WebInspector.CodeMirrorMimeMode", "fileName": "coffeescript.js"}, {"className": "WebInspector.DefaultCodeMirrorMimeMode", "mimeTypes": ["application/x-httpd-php", "application/x-httpd-php-open", "text/x-php"], "dependencies": ["clike.js"], "type": "@WebInspector.CodeMirrorMimeMode", "fileName": "php.js"}, {"className": "WebInspector.DefaultCodeMirrorMimeMode", "mimeTypes": ["text/x-python", "text/x-cython"], "type": "@WebInspector.CodeMirrorMimeMode", "fileName": "python.js"}, {"className": "WebInspector.DefaultCodeMirrorMimeMode", "mimeTypes": ["text/x-sh"], "type": "@WebInspector.CodeMirrorMimeMode", "fileName": "shell.js"}, {"className": "WebInspector.DefaultCodeMirrorMimeMode", "mimeTypes": ["text/x-livescript"], "type": "@WebInspector.CodeMirrorMimeMode", "fileName": "livescript.js"}, {"className": "WebInspector.DefaultCodeMirrorMimeMode", "mimeTypes": ["text/x-clojure"], "type": "@WebInspector.CodeMirrorMimeMode", "fileName": "clojure.js"}, {"className": "WebInspector.DefaultCodeMirrorMimeMode", "mimeTypes": ["text/x-styl"], "type": "@WebInspector.CodeMirrorMimeMode", "fileName": "stylus.js"}], "scripts": []}, {"dependencies": [], "name": "platform", "scripts": []}, {"dependencies": ["elements"], "extensions": [{"className": "WebInspector.AnimationTimeline.ButtonProvider", "type": "@WebInspector.ToolbarItem.Provider", "order": 2, "location": "styles-sidebarpane-toolbar"}, {"name": "animations", "title": "Animations", "className": "WebInspector.AnimationTimeline", "type": "drawer-view", "order": 0, "persistence": "closeable"}], "name": "animation", "scripts": []}, {"dependencies": ["components"], "extensions": [{"className": "WebInspector.CodeMirrorUtils", "type": "@WebInspector.InplaceEditor"}, {"className": "WebInspector.CodeMirrorUtils.TokenizerFactory", "type": "@WebInspector.TokenizerFactory"}, {"category": "Sources", "title": "Default indentation:", "defaultValue": "    ", "settingName": "textEditorIndent", "settingType": "enum", "type": "setting", "options": [["2 spaces", "  "], ["4 spaces", "    "], ["8 spaces", "        "], ["Tab character", "\t"]]}], "name": "source_frame", "scripts": [], "skip_compilation": ["../cm/codemirror.js", "../cm/css.js", "../cm/javascript.js", "../cm/simple.js", "../cm/xml.js", "../cm/htmlmixed.js", "../cm/htmlembedded.js", "../cm/matchbrackets.js", "../cm/closebrackets.js", "../cm/markselection.js", "../cm/comment.js", "../cm/overlay.js", "../cm/activeline.js"]}, {"dependencies": ["extensions", "host", "platform", "sdk"], "extensions": [{"className": "WebInspector.SimpleAppProvider", "type": "@WebInspector.AppProvider", "order": 10}, {"className": "WebInspector.HandlerRegistry.ContextMenuProvider", "contextTypes": ["WebInspector.UISourceCode", "WebInspector.Resource", "WebInspector.NetworkRequest", "Node"], "type": "@WebInspector.ContextMenu.Provider"}, {"className": "WebInspector.Main.ReloadActionDelegate", "bindings": [{"platform": "windows,linux", "shortcut": "F5 Ctrl+R"}, {"platform": "mac", "shortcut": "Meta+R"}], "type": "@WebInspector.ActionDelegate", "actionId": "main.reload"}, {"className": "WebInspector.Main.ReloadActionDelegate", "bindings": [{"platform": "windows,linux", "shortcut": "Shift+F5 Ctrl+F5 Ctrl+Shift+F5 Shift+Ctrl+R"}, {"platform": "mac", "shortcut": "Shift+Meta+R"}], "type": "@WebInspector.ActionDelegate", "actionId": "main.hard-reload"}, {"className": "WebInspector.InspectorView.DrawerToggleActionDelegate", "bindings": [{"shortcut": "Esc"}], "type": "@WebInspector.ActionDelegate", "actionId": "main.toggle-drawer", "order": 100}, {"className": "WebInspector.Main.ReloadActionDelegate", "bindings": [{"shortcut": "Alt+R"}], "type": "@WebInspector.ActionDelegate", "actionId": "main.debug-reload"}, {"className": "WebInspector.DockController.ToggleDockActionDelegate", "bindings": [{"platform": "windows,linux", "shortcut": "Ctrl+Shift+D"}, {"platform": "mac", "shortcut": "Meta+Shift+D"}], "type": "@WebInspector.ActionDelegate", "actionId": "main.toggle-dock"}, {"className": "WebInspector.Main.ZoomActionDelegate", "bindings": [{"platform": "windows,linux", "shortcut": "Ctrl+Plus Ctrl+Shift+Plus Ctrl+NumpadPlus Ctrl+Shift+NumpadPlus"}, {"platform": "mac", "shortcut": "Meta+Plus Meta+Shift+Plus Meta+NumpadPlus Meta+Shift+NumpadPlus"}], "type": "@WebInspector.ActionDelegate", "actionId": "main.zoom-in"}, {"className": "WebInspector.Main.ZoomActionDelegate", "bindings": [{"platform": "windows,linux", "shortcut": "Ctrl+Minus Ctrl+Shift+Minus Ctrl+NumpadMinus Ctrl+Shift+NumpadMinus"}, {"platform": "mac", "shortcut": "Meta+Minus Meta+Shift+Minus Meta+NumpadMinus Meta+Shift+NumpadMinus"}], "type": "@WebInspector.ActionDelegate", "actionId": "main.zoom-out"}, {"className": "WebInspector.Main.ZoomActionDelegate", "bindings": [{"platform": "windows,linux", "shortcut": "Ctrl+0 Ctrl+Numpad0"}, {"platform": "mac", "shortcut": "Meta+0 Meta+Numpad0"}], "type": "@WebInspector.ActionDelegate", "actionId": "main.zoom-reset"}, {"className": "WebInspector.Main.SearchActionDelegate", "bindings": [{"platform": "windows,linux", "shortcut": "Ctrl+F"}, {"platform": "mac", "shortcut": "Meta+F F3"}], "type": "@WebInspector.ActionDelegate", "actionId": "main.search-in-panel.find"}, {"className": "WebInspector.Main.SearchActionDelegate", "bindings": [{"shortcut": "Esc"}], "type": "@WebInspector.ActionDelegate", "actionId": "main.search-in-panel.cancel", "order": 10}, {"className": "WebInspector.Main.SearchActionDelegate", "bindings": [{"platform": "mac", "shortcut": "Meta+G"}], "type": "@WebInspector.ActionDelegate", "actionId": "main.search-in-panel.find-next"}, {"className": "WebInspector.Main.SearchActionDelegate", "bindings": [{"platform": "mac", "shortcut": "Meta+Shift+G"}], "type": "@WebInspector.ActionDelegate", "actionId": "main.search-in-panel.find-previous"}, {"className": "WebInspector.RenderingOptionsView.ShowActionDelegate", "type": "@WebInspector.ActionDelegate", "actionId": "main.show-rendering-options", "title": "Rendering settings"}, {"separator": true, "type": "@WebInspector.ToolbarItem.Provider", "location": "main-toolbar-left", "order": 100}, {"className": "WebInspector.Main.WarningErrorCounter", "type": "@WebInspector.ToolbarItem.Provider", "order": 1, "location": "main-toolbar-right"}, {"separator": true, "type": "@WebInspector.ToolbarItem.Provider", "order": 98, "location": "main-toolbar-right"}, {"className": "WebInspector.Main.MainMenuItem", "type": "@WebInspector.ToolbarItem.Provider", "order": 99, "location": "main-toolbar-right"}, {"className": "WebInspector.DockController.CloseButtonProvider", "type": "@WebInspector.ToolbarItem.Provider", "order": 100, "location": "main-toolbar-right"}, {"category": "", "title": "Disable cache (while DevTools is open)", "defaultValue": false, "settingName": "cacheDisabled", "settingType": "boolean", "type": "setting", "order": 0}, {"category": "", "title": "Disable JavaScript", "defaultValue": false, "settingName": "javaScriptDisabled", "settingType": "boolean", "type": "setting", "order": 1}, {"category": "", "title": "Auto-open DevTools for popups", "defaultValue": false, "settingName": "autoAttachToCreatedPages", "settingType": "boolean", "type": "setting", "order": 2}, {"category": "Appearance", "title": "Theme:", "defaultValue": "default", "settingName": "uiTheme", "settingType": "enum", "type": "setting", "options": [["Default", "default"], ["Dark", "dark"]]}, {"category": "Appearance", "title": "Panel layout:", "defaultValue": "auto", "settingName": "sidebarPosition", "settingType": "enum", "type": "setting", "options": [["horizontal", "bottom"], ["vertical", "right"], ["auto", "auto"]]}, {"category": "Appearance", "title-mac": "Enable Cmd + 1-9 shortcut to switch panels", "title": "Enable Ctrl + 1-9 shortcut to switch panels", "defaultValue": false, "settingName": "shortcutPanelSwitch", "settingType": "boolean", "type": "setting"}, {"category": "Appearance", "title": "Don't show Chrome Data Saver warning", "defaultValue": false, "settingName": "disableDataSaverInfobar", "settingType": "boolean", "type": "setting"}, {"category": "Appearance", "title": "Disable paused state overlay", "defaultValue": false, "settingName": "disablePausedStateOverlay", "settingType": "boolean", "type": "setting"}, {"category": "Extensions", "className": "WebInspector.HandlerRegistry.OpenAnchorLocationSettingUI", "type": "@WebInspector.SettingUI"}, {"category": "Elements", "className": "WebInspector.ShowMetricsRulersSettingUI", "type": "@WebInspector.SettingUI", "order": 3}, {"subMenuId": "mainMenu/tools", "order": 80, "type": "context-menu-item", "location": "mainMenu/navigate", "title": "More tools"}, {"actionId": "main.show-rendering-options", "type": "context-menu-item", "location": "mainMenu/tools/open", "order": 80}, {"name": "rendering", "title": "Rendering", "className": "WebInspector.RenderingOptionsView", "type": "drawer-view", "order": 50, "persistence": "closeable"}], "name": "main", "scripts": [], "skip_compilation": ["Tests.js"]}, {"dependencies": ["components", "extensions"], "extensions": [{"className": "WebInspector.ElementsPanelFactory", "order": 10, "type": "@WebInspector.PanelFactory", "name": "elements", "title": "Elements"}, {"className": "WebInspector.ElementsPanel.ContextMenuProvider", "contextTypes": ["WebInspector.RemoteObject", "WebInspector.DOMNode", "WebInspector.DeferredDOMNode"], "type": "@WebInspector.ContextMenu.Provider"}, {"className": "WebInspector.ElementsTreeOutline.Renderer", "contextTypes": ["WebInspector.DOMNode", "WebInspector.RemoteObject"], "type": "@WebInspector.Renderer"}, {"className": "WebInspector.ElementsPanel.DOMNodeRevealer", "contextTypes": ["WebInspector.DOMNode", "WebInspector.DeferredDOMNode", "WebInspector.RemoteObject"], "type": "@WebInspector.Revealer"}, {"category": "Elements", "title": "Color format:", "defaultValue": "original", "options": [["As authored", "original"], ["HEX: #DAC0DE", "hex", true], ["RGB: rgb(128, 255, 255)", "rgb", true], ["HSL: hsl(300, 80%, 90%)", "hsl", true]], "settingName": "colorFormat", "settingType": "enum", "type": "setting", "order": 0}, {"category": "Elements", "title": "Show user agent shadow DOM", "defaultValue": false, "settingName": "showUAShadowDOM", "settingType": "boolean", "type": "setting", "order": 1}, {"category": "Elements", "title": "Word wrap", "defaultValue": true, "settingName": "domWordWrap", "settingType": "boolean", "type": "setting", "order": 2}, {"category": "Elements", "title": "Reveal DOM node on hover.", "defaultValue": true, "settingName": "highlightNodeOnHoverInOverlay", "settingType": "boolean", "type": "setting", "order": 4}, {"className": "WebInspector.ElementStatePaneWidget.ButtonProvider", "type": "@WebInspector.ToolbarItem.Provider", "order": 1, "location": "styles-sidebarpane-toolbar"}, {"className": "WebInspector.ClassesPaneWidget.ButtonProvider", "type": "@WebInspector.ToolbarItem.Provider", "order": 2, "location": "styles-sidebarpane-toolbar"}, {"className": "WebInspector.ElementsActionDelegate", "contextTypes": ["WebInspector.ElementsPanel"], "bindings": [{"shortcut": "H"}], "type": "@WebInspector.ActionDelegate", "actionId": "elements.hide-element"}, {"className": "WebInspector.ElementsActionDelegate", "contextTypes": ["WebInspector.ElementsPanel"], "bindings": [{"shortcut": "F2"}], "type": "@WebInspector.ActionDelegate", "actionId": "elements.edit-as-html"}, {"className": "WebInspector.ElementsPanel.PseudoStateMarkerDecorator", "marker": "pseudo-state-marker", "type": "@WebInspector.DOMPresentationUtils.MarkerDecorator"}, {"className": "WebInspector.DOMPresentationUtils.GenericDecorator", "marker": "hidden-marker", "type": "@WebInspector.DOMPresentationUtils.MarkerDecorator", "color": "#555", "title": "Element is hidden"}, {"iconClass": "node-search-toolbar-item", "title": "Select an element in the page to inspect it", "className": "WebInspector.InspectElementModeController.ToggleSearchActionDelegate", "actionId": "elements.toggle-element-search", "bindings": [{"platform": "windows,linux", "shortcut": "Ctrl+Shift+C"}, {"platform": "mac", "shortcut": "Meta+Shift+C"}], "type": "@WebInspector.ActionDelegate"}, {"order": 0, "type": "@WebInspector.ToolbarItem.Provider", "actionId": "elements.toggle-element-search", "location": "main-toolbar-left"}, {"className": "WebInspector.InspectElementModeController.LayoutEditorButtonProvider", "experiment": "layoutEditor", "type": "@WebInspector.ToolbarItem.Provider", "order": 4, "location": "styles-sidebarpane-toolbar"}], "name": "elements", "scripts": []}, {"dependencies": ["common", "host", "platform"], "name": "workspace", "scripts": []}, {"experiment": "accessibilityInspection", "extensions": [{"className": "WebInspector.AccessibilitySidebarView", "type": "@WebInspector.Widget", "location": "elements-panel", "title": "Accessibility"}], "name": "accessibility", "dependencies": ["elements"], "scripts": []}, {"dependencies": ["common", "platform"], "name": "host", "scripts": []}, {"dependencies": ["bindings", "components", "platform", "ui"], "extensions": [{"className": "WebInspector.AdvancedAppProvider", "type": "@WebInspector.AppProvider", "order": 0, "condition": "can_dock"}, {"iconClass": "phone-toolbar-item", "title": "Toggle device mode", "className": "WebInspector.DeviceModeWrapper.ActionDelegate", "actionId": "emulation.toggle-device-mode", "bindings": [{"platform": "windows,linux", "shortcut": "Shift+Ctrl+M"}, {"platform": "mac", "shortcut": "Shift+Meta+M"}], "type": "@WebInspector.ActionDelegate", "condition": "can_dock"}, {"order": 1, "type": "@WebInspector.ToolbarItem.Provider", "actionId": "emulation.toggle-device-mode", "condition": "can_dock", "location": "main-toolbar-left"}, {"name": "devices", "settings": ["standardEmulatedDeviceList", "customEmulatedDeviceList"], "title": "Devices", "className": "WebInspector.DevicesSettingsTab", "type": "settings-view", "order": "30"}, {"className": "WebInspector.SensorsView.ShowActionDelegate", "type": "@WebInspector.ActionDelegate", "actionId": "emulation.show-sensors", "title": "Sensors"}, {"actionId": "emulation.show-sensors", "type": "context-menu-item", "location": "mainMenu/tools/open", "order": 100}, {"name": "sensors", "title": "Sensors", "className": "WebInspector.SensorsView", "type": "drawer-view", "order": 100, "persistence": "closeable"}, {"className": "WebInspector.DeviceModeWrapper.ActionDelegate", "type": "@WebInspector.ActionDelegate", "actionId": "emulation.request-app-banner", "title": "Request app banner\u2026"}, {"actionId": "emulation.request-app-banner", "experiment": "appBanner", "type": "context-menu-item", "location": "deviceModeMenu/tools", "order": 10}], "name": "emulation", "scripts": []}, {"dependencies": ["platform", "common", "host"], "name": "ui", "scripts": []}, {"skip_compilation": ["../InspectorBackendCommands.js", "../SupportedCSSProperties.js"], "dependencies": ["common", "host", "platform"], "extensions": [{"defaultValue": [], "type": "setting", "settingName": "blockedURLs", "settingType": "array"}, {"defaultValue": "", "type": "setting", "settingName": "skipStackFramesPattern", "settingType": "regex"}, {"defaultValue": false, "type": "setting", "settingName": "skipContentScripts", "settingType": "boolean"}, {"defaultValue": false, "type": "setting", "settingName": "pauseOnExceptionEnabled", "settingType": "boolean"}, {"defaultValue": false, "type": "setting", "settingName": "pauseOnCaughtException", "settingType": "boolean"}, {"defaultValue": false, "type": "setting", "settingName": "enableAsyncStackTraces", "settingType": "boolean"}, {"defaultValue": false, "type": "setting", "settingName": "showMetricsRulers", "settingType": "boolean"}], "name": "sdk", "scripts": []}, {"name": "temp_storage_shared_worker", "scripts": []}, {"dependencies": ["platform", "common", "diff", "sdk"], "name": "sass", "scripts": []}, {"dependencies": ["components"], "extensions": [{"className": "WebInspector.SettingsController.ActionDelegate", "bindings": [{"shortcut": "F1 Shift+?"}], "type": "@WebInspector.ActionDelegate", "actionId": "settings.show", "title": "Settings"}, {"className": "WebInspector.SettingsController.ActionDelegate", "type": "@WebInspector.ActionDelegate", "actionId": "settings.help", "title": "Help"}, {"className": "WebInspector.SettingsController.ActionDelegate", "type": "@WebInspector.ActionDelegate", "actionId": "settings.shortcuts", "title": "Shortcuts"}, {"className": "WebInspector.SettingsController.Revealer", "contextTypes": ["WebInspector.Setting"], "type": "@WebInspector.Revealer"}, {"actionId": "settings.shortcuts", "type": "context-menu-item", "location": "mainMenu/footer", "order": 10}, {"actionId": "settings.show", "type": "context-menu-item", "location": "mainMenu/footer", "order": 20}, {"actionId": "settings.help", "type": "context-menu-item", "location": "mainMenu/footer", "order": 30}], "name": "settings", "scripts": []}, {"dependencies": ["sdk", "ui", "ui_lazy"], "name": "components_lazy", "scripts": []}, {"dependencies": ["components", "ui_lazy"], "extensions": [{"className": "WebInspector.ProfilesPanelFactory", "order": 60, "type": "@WebInspector.PanelFactory", "name": "profiles", "title": "Profiles"}, {"className": "WebInspector.ProfilesPanel.ContextMenuProvider", "contextTypes": ["WebInspector.RemoteObject"], "type": "@WebInspector.ContextMenu.Provider"}, {"category": "Profiler", "title": "Show advanced heap snapshot properties", "defaultValue": false, "settingName": "showAdvancedHeapSnapshotProperties", "settingType": "boolean", "type": "setting"}, {"category": "Profiler", "title": "Record heap allocation stack traces", "defaultValue": false, "settingName": "recordAllocationStacks", "settingType": "boolean", "type": "setting"}, {"category": "Profiler", "title": "High resolution CPU profiling", "defaultValue": true, "settingName": "highResolutionCpuProfiling", "settingType": "boolean", "type": "setting"}, {"category": "Profiler", "title": "Show native functions in JS Profile", "defaultValue": false, "settingName": "showNativeFunctionsInJSProfile", "settingType": "boolean", "type": "setting"}, {"iconClass": "record-toolbar-item", "className": "WebInspector.ProfilesPanel.RecordActionDelegate", "contextTypes": ["WebInspector.ProfilesPanel"], "actionId": "profiler.toggle-recording", "bindings": [{"platform": "windows,linux", "shortcut": "Ctrl+E"}, {"platform": "mac", "shortcut": "Meta+E"}], "type": "@WebInspector.ActionDelegate"}], "name": "profiler", "scripts": []}, {"remote": true, "name": "screencast", "dependencies": ["components"], "extensions": [{"className": "WebInspector.ScreencastAppProvider", "type": "@WebInspector.AppProvider", "order": 1}, {"className": "WebInspector.ScreencastApp.ToolbarButtonProvider", "type": "@WebInspector.ToolbarItem.Provider", "order": 1, "location": "main-toolbar-left"}, {"className": "WebInspector.ScreencastApp.ActionDelegate", "type": "@WebInspector.ActionDelegate", "actionId": "screencast.request-app-banner", "title": "Request app banner\u2026"}, {"experiment": "appBanner", "actionId": "screencast.request-app-banner", "type": "context-menu-item", "order": 10, "condition": "remoteFrontend", "location": "mainMenu/tools"}], "scripts": [], "condition": "remoteFrontend"}, {"dependencies": ["components"], "name": "extensions", "scripts": []}, {"skip_compilation": ["TestBase.js"], "dependencies": ["platform"], "name": "common", "scripts": []}, {"dependencies": ["bindings", "platform", "ui"], "extensions": [{"category": "Console", "title": "Enable custom formatters", "defaultValue": false, "settingName": "customFormatters", "settingType": "boolean", "type": "setting"}, {"className": "WebInspector.DOMPresentationUtils.GenericDecorator", "marker": "breakpoint-marker", "type": "@WebInspector.DOMPresentationUtils.MarkerDecorator", "color": "rgb(105, 140, 254)", "title": "DOM Breakpoint"}, {"defaultValue": [], "type": "setting", "settingName": "customNetworkConditions", "settingType": "array"}, {"name": "network-conditions", "settings": ["customNetworkConditions"], "title": "Throttling", "className": "WebInspector.NetworkConditionsSettingsTab", "type": "settings-view", "order": "35"}], "name": "components", "scripts": []}, {"dependencies": ["platform", "ui", "host", "components"], "extensions": [{"className": "WebInspector.DevicesDialog.ActionDelegate", "type": "@WebInspector.ActionDelegate", "actionId": "devices.dialog.show", "title": "Inspect devices\u2026"}, {"actionId": "devices.dialog.show", "type": "context-menu-item", "location": "mainMenu/tools/open", "order": 50}], "name": "devices", "scripts": []}];
var applicationDescriptor;
var _loadedScripts = {};

// FIXME: This is a workaround to force Closure compiler provide
// the standard ES6 runtime for all modules. This should be removed
// once Closure provides standard externs for Map et al.
for (var k of []) {};

/**
 * @param {string} url
 * @return {!Promise.<string>}
 */
function loadResourcePromise(url)
{
    return new Promise(load);

    /**
     * @param {function(?)} fulfill
     * @param {function(*)} reject
     */
    function load(fulfill, reject)
    {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.onreadystatechange = onreadystatechange;

        /**
         * @param {Event} e
         */
        function onreadystatechange(e)
        {
            if (xhr.readyState !== 4)
                return;

            if ([0, 200, 304].indexOf(xhr.status) === -1)  // Testing harness file:/// results in 0.
                reject(new Error("While loading from url " + url + " server responded with a status of " + xhr.status));
            else
                fulfill(e.target.response);
        }
        xhr.send(null);
    }
}

/**
 * http://tools.ietf.org/html/rfc3986#section-5.2.4
 * @param {string} path
 * @return {string}
 */
function normalizePath(path)
{
    if (path.indexOf("..") === -1 && path.indexOf('.') === -1)
        return path;

    var normalizedSegments = [];
    var segments = path.split("/");
    for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment === ".")
            continue;
        else if (segment === "..")
            normalizedSegments.pop();
        else if (segment)
            normalizedSegments.push(segment);
    }
    var normalizedPath = normalizedSegments.join("/");
    if (normalizedPath[normalizedPath.length - 1] === "/")
        return normalizedPath;
    if (path[0] === "/" && normalizedPath)
        normalizedPath = "/" + normalizedPath;
    if ((path[path.length - 1] === "/") || (segments[segments.length - 1] === ".") || (segments[segments.length - 1] === ".."))
        normalizedPath = normalizedPath + "/";

    return normalizedPath;
}

/**
 * @param {!Array.<string>} scriptNames
 * @param {string=} base
 * @return {!Promise.<undefined>}
 */
function loadScriptsPromise(scriptNames, base)
{
    /** @type {!Array.<!Promise.<string>>} */
    var promises = [];
    /** @type {!Array.<string>} */
    var urls = [];
    var sources = new Array(scriptNames.length);
    var scriptToEval = 0;
    for (var i = 0; i < scriptNames.length; ++i) {
        var scriptName = scriptNames[i];
        var sourceURL = (base || self._importScriptPathPrefix) + scriptName;
        var schemaIndex = sourceURL.indexOf("://") + 3;
        sourceURL = sourceURL.substring(0, schemaIndex) + normalizePath(sourceURL.substring(schemaIndex));
        if (_loadedScripts[sourceURL])
            continue;
        urls.push(sourceURL);
        promises.push(loadResourcePromise(sourceURL).then(scriptSourceLoaded.bind(null, i), scriptSourceLoaded.bind(null, i, undefined)));
    }
    return Promise.all(promises).then(undefined);

    /**
     * @param {number} scriptNumber
     * @param {string=} scriptSource
     */
    function scriptSourceLoaded(scriptNumber, scriptSource)
    {
        sources[scriptNumber] = scriptSource || "";
        // Eval scripts as fast as possible.
        while (typeof sources[scriptToEval] !== "undefined") {
            evaluateScript(urls[scriptToEval], sources[scriptToEval]);
            ++scriptToEval;
        }
    }

    /**
     * @param {string} sourceURL
     * @param {string=} scriptSource
     */
    function evaluateScript(sourceURL, scriptSource)
    {
        _loadedScripts[sourceURL] = true;
        if (!scriptSource) {
            // Do not reject, as this is normal in the hosted mode.
            console.error("Empty response arrived for script '" + sourceURL + "'");
            return;
        }
        self.eval(scriptSource + "\n//# sourceURL=" + sourceURL);
    }
}

(function() {
    var baseUrl = self.location ? self.location.origin + self.location.pathname : "";
    self._importScriptPathPrefix = baseUrl.substring(0, baseUrl.lastIndexOf("/") + 1);
})();

/**
 * @constructor
 * @param {!Array.<!Runtime.ModuleDescriptor>} descriptors
 * @param {!Array.<string>=} coreModuleNames
 */
function Runtime(descriptors, coreModuleNames)
{
    /**
     * @type {!Array.<!Runtime.Module>}
     */
    this._modules = [];
    /**
     * @type {!Object.<string, !Runtime.Module>}
     */
    this._modulesMap = {};
    /**
     * @type {!Array.<!Runtime.Extension>}
     */
    this._extensions = [];

    /**
     * @type {!Object.<string, !function(new:Object)>}
     */
    this._cachedTypeClasses = {};

    /**
     * @type {!Object.<string, !Runtime.ModuleDescriptor>}
     */
    this._descriptorsMap = {};

    for (var i = 0; i < descriptors.length; ++i)
        this._registerModule(descriptors[i]);
    if (coreModuleNames)
        this._loadAutoStartModules(coreModuleNames);
}

/**
 * @type {!Object.<string, string>}
 */
Runtime._queryParamsObject = { __proto__: null };

/**
 * @type {!Object.<string, string>}
 */
Runtime.cachedResources = { __proto__: null };

/**
 * @return {boolean}
 */
Runtime.isReleaseMode = function()
{
    return !!allDescriptors.length;
}

/**
 * @param {string} appName
 */
Runtime.startApplication = function(appName)
{
    console.timeStamp("Runtime.startApplication");

    var allDescriptorsByName = {};
    for (var i = 0; Runtime.isReleaseMode() && i < allDescriptors.length; ++i) {
        var d = allDescriptors[i];
        allDescriptorsByName[d["name"]] = d;
    }

    var applicationPromise;
    if (applicationDescriptor)
        applicationPromise = Promise.resolve(applicationDescriptor);
    else
        applicationPromise = loadResourcePromise(appName + ".json").then(JSON.parse.bind(JSON));

    applicationPromise.then(parseModuleDescriptors);

    /**
     * @param {!Array.<!Object>} configuration
     */
    function parseModuleDescriptors(configuration)
    {
        var moduleJSONPromises = [];
        var coreModuleNames = [];
        for (var i = 0; i < configuration.length; ++i) {
            var descriptor = configuration[i];
            if (descriptor["type"] === "worker")
                continue;
            var name = descriptor["name"];
            var moduleJSON = allDescriptorsByName[name];
            if (moduleJSON)
                moduleJSONPromises.push(Promise.resolve(moduleJSON));
            else
                moduleJSONPromises.push(loadResourcePromise(name + "/module.json").then(JSON.parse.bind(JSON)));
            if (descriptor["type"] === "autostart")
                coreModuleNames.push(name);
        }

        Promise.all(moduleJSONPromises).then(instantiateRuntime);
        /**
         * @param {!Array.<!Object>} moduleDescriptors
         */
        function instantiateRuntime(moduleDescriptors)
        {
            for (var i = 0; !Runtime.isReleaseMode() && i < moduleDescriptors.length; ++i) {
                moduleDescriptors[i]["name"] = configuration[i]["name"];
                moduleDescriptors[i]["condition"] = configuration[i]["condition"];
            }
            self.runtime = new Runtime(moduleDescriptors, coreModuleNames);
        }
    }
}

/**
 * @param {string} name
 * @return {?string}
 */
Runtime.queryParam = function(name)
{
    return Runtime._queryParamsObject[name] || null;
}

/**
 * @param {!Array.<string>} banned
 * @return {string}
 */
Runtime.constructQueryParams = function(banned)
{
    var params = [];
    for (var key in Runtime._queryParamsObject) {
        if (!key || banned.indexOf(key) !== -1)
            continue;
        params.push(key + "=" + Runtime._queryParamsObject[key]);
    }
    return params.length ? "?" + params.join("&") : "";
}

/**
 * @return {!Object}
 */
Runtime._experimentsSetting = function()
{
    try {
        return /** @type {!Object} */ (JSON.parse(self.localStorage && self.localStorage["experiments"] ? self.localStorage["experiments"] : "{}"));
    } catch (e) {
        console.error("Failed to parse localStorage['experiments']");
        return {};
    }
}

/**
 * @param {!Array.<!Promise.<T, !Error>>} promises
 * @return {!Promise.<!Array.<T>>}
 * @template T
 */
Runtime._some = function(promises)
{
    var all = [];
    var wasRejected = [];
    for (var i = 0; i < promises.length; ++i) {
        // Workaround closure compiler bug.
        var handlerFunction = /** @type {function()} */ (handler.bind(promises[i], i));
        all.push(promises[i].catch(handlerFunction));
    }

    return Promise.all(all).then(filterOutFailuresResults);

    /**
     * @param {!Array.<T>} results
     * @return {!Array.<T>}
     * @template T
     */
    function filterOutFailuresResults(results)
    {
        var filtered = [];
        for (var i = 0; i < results.length; ++i) {
            if (!wasRejected[i])
                filtered.push(results[i]);
        }
        return filtered;
    }

    /**
     * @this {!Promise}
     * @param {number} index
     * @param {!Error} e
     */
    function handler(index, e)
    {
        wasRejected[index] = true;
        console.error(e.stack);
    }
}

Runtime._console = console;
Runtime._originalAssert = console.assert;
Runtime._assert = function(value, message)
{
    if (value)
        return;
    Runtime._originalAssert.call(Runtime._console, value, message + " " + new Error().stack);
}

Runtime.prototype = {
    useTestBase: function()
    {
        Runtime._remoteBase = "http://localhost:8000/inspector-sources/";
    },

    /**
     * @param {!Runtime.ModuleDescriptor} descriptor
     */
    _registerModule: function(descriptor)
    {
        var module = new Runtime.Module(this, descriptor);
        this._modules.push(module);
        this._modulesMap[descriptor["name"]] = module;
    },

    /**
     * @param {string} moduleName
     * @return {!Promise.<undefined>}
     */
    loadModulePromise: function(moduleName)
    {
        return this._modulesMap[moduleName]._loadPromise();
    },

    /**
     * @param {!Array.<string>} moduleNames
     * @return {!Promise.<!Array.<*>>}
     */
    _loadAutoStartModules: function(moduleNames)
    {
        var promises = [];
        for (var i = 0; i < moduleNames.length; ++i) {
            if (Runtime.isReleaseMode())
                this._modulesMap[moduleNames[i]]._loaded = true;
            else
                promises.push(this.loadModulePromise(moduleNames[i]));
        }
        return Promise.all(promises);
    },

    /**
     * @param {!Runtime.Extension} extension
     * @param {?function(function(new:Object)):boolean} predicate
     * @return {boolean}
     */
    _checkExtensionApplicability: function(extension, predicate)
    {
        if (!predicate)
            return false;
        var contextTypes = /** @type {!Array.<string>|undefined} */ (extension.descriptor().contextTypes);
        if (!contextTypes)
            return true;
        for (var i = 0; i < contextTypes.length; ++i) {
            var contextType = this._resolve(contextTypes[i]);
            var isMatching = !!contextType && predicate(contextType);
            if (isMatching)
                return true;
        }
        return false;
    },

    /**
     * @param {!Runtime.Extension} extension
     * @param {?Object} context
     * @return {boolean}
     */
    isExtensionApplicableToContext: function(extension, context)
    {
        if (!context)
            return true;
        return this._checkExtensionApplicability(extension, isInstanceOf);

        /**
         * @param {!Function} targetType
         * @return {boolean}
         */
        function isInstanceOf(targetType)
        {
            return context instanceof targetType;
        }
    },

    /**
     * @param {!Runtime.Extension} extension
     * @param {!Set.<!Function>=} currentContextTypes
     * @return {boolean}
     */
    isExtensionApplicableToContextTypes: function(extension, currentContextTypes)
    {
        if (!extension.descriptor().contextTypes)
            return true;

        return this._checkExtensionApplicability(extension, currentContextTypes ? isContextTypeKnown : null);

        /**
         * @param {!Function} targetType
         * @return {boolean}
         */
        function isContextTypeKnown(targetType)
        {
            return currentContextTypes.has(targetType);
        }
    },

    /**
     * @param {*} type
     * @param {?Object=} context
     * @return {!Array.<!Runtime.Extension>}
     */
    extensions: function(type, context)
    {
        return this._extensions.filter(filter).sort(orderComparator);

        /**
         * @param {!Runtime.Extension} extension
         * @return {boolean}
         */
        function filter(extension)
        {
            if (extension._type !== type && extension._typeClass() !== type)
                return false;
            if (!extension.enabled())
                return false;
            return !context || extension.isApplicable(context);
        }

        /**
         * @param {!Runtime.Extension} extension1
         * @param {!Runtime.Extension} extension2
         * @return {number}
         */
        function orderComparator(extension1, extension2)
        {
            var order1 = extension1.descriptor()["order"] || 0;
            var order2 = extension2.descriptor()["order"] || 0;
            return order1 - order2;
        }
    },

    /**
     * @param {*} type
     * @param {?Object=} context
     * @return {?Runtime.Extension}
     */
    extension: function(type, context)
    {
        return this.extensions(type, context)[0] || null;
    },

    /**
     * @param {*} type
     * @param {?Object=} context
     * @return {!Promise.<!Array.<!Object>>}
     */
    instancesPromise: function(type, context)
    {
        var extensions = this.extensions(type, context);
        var promises = [];
        for (var i = 0; i < extensions.length; ++i)
            promises.push(extensions[i].instancePromise());
        return Runtime._some(promises);
    },

    /**
     * @param {*} type
     * @param {?Object=} context
     * @return {!Promise.<!Object>}
     */
    instancePromise: function(type, context)
    {
        var extension = this.extension(type, context);
        if (!extension)
            return Promise.reject(new Error("No such extension: " + type + " in given context."));
        return extension.instancePromise();
    },

    /**
     * @return {?function(new:Object)}
     */
    _resolve: function(typeName)
    {
        if (!this._cachedTypeClasses[typeName]) {
            var path = typeName.split(".");
            var object = window;
            for (var i = 0; object && (i < path.length); ++i)
                object = object[path[i]];
            if (object)
                this._cachedTypeClasses[typeName] = /** @type function(new:Object) */(object);
        }
        return this._cachedTypeClasses[typeName] || null;
    }
}

/**
 * @constructor
 */
Runtime.ModuleDescriptor = function()
{
    /**
     * @type {string}
     */
    this.name;

    /**
     * @type {!Array.<!Runtime.ExtensionDescriptor>}
     */
    this.extensions;

    /**
     * @type {!Array.<string>|undefined}
     */
    this.dependencies;

    /**
     * @type {!Array.<string>}
     */
    this.scripts;

    /**
     * @type {boolean|undefined}
     */
    this.remote;
}

/**
 * @constructor
 */
Runtime.ExtensionDescriptor = function()
{
    /**
     * @type {string}
     */
    this.type;

    /**
     * @type {string|undefined}
     */
    this.className;

    /**
     * @type {!Array.<string>|undefined}
     */
    this.contextTypes;
}

/**
 * @constructor
 * @param {!Runtime} manager
 * @param {!Runtime.ModuleDescriptor} descriptor
 */
Runtime.Module = function(manager, descriptor)
{
    this._manager = manager;
    this._descriptor = descriptor;
    this._name = descriptor.name;
    /** @type {!Object.<string, ?Object>} */
    this._instanceMap = {};
    var extensions = /** @type {?Array.<!Runtime.ExtensionDescriptor>} */ (descriptor.extensions);
    for (var i = 0; extensions && i < extensions.length; ++i)
        this._manager._extensions.push(new Runtime.Extension(this, extensions[i]));
    this._loaded = false;
}

Runtime.Module.prototype = {
    /**
     * @return {string}
     */
    name: function()
    {
        return this._name;
    },

    /**
     * @return {boolean}
     */
    enabled: function()
    {
        var activatorExperiment = this._descriptor["experiment"];
        if (activatorExperiment && !Runtime.experiments.isEnabled(activatorExperiment))
            return false;
        var condition = this._descriptor["condition"];
        if (condition && !Runtime.queryParam(condition))
            return false;
        return true;
    },

    /**
     * @param {string} name
     * @return {string}
     */
    resource: function(name)
    {
        var fullName = this._name + "/" + name;
        var content = Runtime.cachedResources[fullName];
        if (!content)
            throw new Error(fullName + " not preloaded. Check module.json");
        return content;
    },

    /**
     * @return {!Promise.<undefined>}
     */
    _loadPromise: function()
    {
        if (this._loaded)
            return Promise.resolve();

        if (!this.enabled())
            return Promise.reject(new Error("Module " + this._name + " is not enabled"));

        if (this._pendingLoadPromise)
            return this._pendingLoadPromise;

        var dependencies = this._descriptor.dependencies;
        var dependencyPromises = [];
        for (var i = 0; dependencies && i < dependencies.length; ++i)
            dependencyPromises.push(this._manager._modulesMap[dependencies[i]]._loadPromise());

        this._pendingLoadPromise = Promise.all(dependencyPromises)
            .then(this._loadResources.bind(this))
            .then(this._loadScripts.bind(this))
            .then(markAsLoaded.bind(this));

        return this._pendingLoadPromise;

        /**
         * @this {Runtime.Module}
         */
        function markAsLoaded()
        {
            delete this._pendingLoadPromise;
            this._loaded = true;
        }
    },

    /**
     * @return {!Promise.<undefined>}
     * @this {Runtime.Module}
     */
    _loadResources: function()
    {
        var resources = this._descriptor["resources"];
        if (!resources)
            return Promise.resolve();
        var promises = [];
        for (var i = 0; i < resources.length; ++i) {
            var url = this._modularizeURL(resources[i]);
            promises.push(loadResourcePromise(url).then(cacheResource.bind(this, url), cacheResource.bind(this, url, undefined)));
        }
        return Promise.all(promises).then(undefined);

        /**
         * @param {string} path
         * @param {string=} content
         */
        function cacheResource(path, content)
        {
            if (!content) {
                console.error("Failed to load resource: " + path);
                return;
            }
            Runtime.cachedResources[path] = content + Runtime.resolveSourceURL(path);
        }
    },

    /**
     * @return {!Promise.<undefined>}
     */
    _loadScripts: function()
    {
        if (!this._descriptor.scripts)
            return Promise.resolve();

        if (Runtime.isReleaseMode())
            return loadScriptsPromise([this._name + "_module.js"], this._remoteBase());

        return loadScriptsPromise(this._descriptor.scripts.map(this._modularizeURL, this));
    },

    /**
     * @param {string} resourceName
     */
    _modularizeURL: function(resourceName)
    {
        return normalizePath(this._name + "/" + resourceName);
    },

    /**
     * @return {string|undefined}
     */
    _remoteBase: function()
    {
        return this._descriptor.remote && Runtime._remoteBase || undefined;
    },

    /**
     * @param {string} value
     * @return {string}
     */
    substituteURL: function(value)
    {
        var base = this._remoteBase() || "";
        return value.replace(/@url\(([^\)]*?)\)/g, convertURL.bind(this));

        function convertURL(match, url)
        {
            return base + this._modularizeURL(url);
        }
    },

    /**
     * @param {string} className
     * @param {!Runtime.Extension} extension
     * @return {?Object}
     */
    _instance: function(className, extension)
    {
        if (className in this._instanceMap)
            return this._instanceMap[className];

        var constructorFunction = window.eval(className);
        if (!(constructorFunction instanceof Function)) {
            this._instanceMap[className] = null;
            return null;
        }

        var instance = new constructorFunction(extension);
        this._instanceMap[className] = instance;
        return instance;
    }
}

/**
 * @constructor
 * @param {!Runtime.Module} module
 * @param {!Runtime.ExtensionDescriptor} descriptor
 */
Runtime.Extension = function(module, descriptor)
{
    this._module = module;
    this._descriptor = descriptor;

    this._type = descriptor.type;
    this._hasTypeClass = this._type.charAt(0) === "@";

    /**
     * @type {?string}
     */
    this._className = descriptor.className || null;
}

Runtime.Extension.prototype = {
    /**
     * @return {!Object}
     */
    descriptor: function()
    {
        return this._descriptor;
    },

    /**
     * @return {!Runtime.Module}
     */
    module: function()
    {
        return this._module;
    },

    /**
     * @return {boolean}
     */
    enabled: function()
    {
        var activatorExperiment = this.descriptor()["experiment"];
        if (activatorExperiment && activatorExperiment.startsWith("!") && Runtime.experiments.isEnabled(activatorExperiment.substring(1)))
            return false;
        if (activatorExperiment && !activatorExperiment.startsWith("!") && !Runtime.experiments.isEnabled(activatorExperiment))
            return false;
        var condition = this.descriptor()["condition"];
        if (condition && !Runtime.queryParam(condition))
            return false;
        return this._module.enabled();
    },

    /**
     * @return {?function(new:Object)}
     */
    _typeClass: function()
    {
        if (!this._hasTypeClass)
            return null;
        return this._module._manager._resolve(this._type.substring(1));
    },

    /**
     * @param {?Object} context
     * @return {boolean}
     */
    isApplicable: function(context)
    {
        return this._module._manager.isExtensionApplicableToContext(this, context);
    },

    /**
     * @return {!Promise.<!Object>}
     */
    instancePromise: function()
    {
        if (!this._className)
            return Promise.reject(new Error("No class name in extension"));
        var className = this._className;
        if (this._instance)
            return Promise.resolve(this._instance);

        return this._module._loadPromise().then(constructInstance.bind(this));

        /**
         * @return {!Object}
         * @this {Runtime.Extension}
         */
        function constructInstance()
        {
            var result = this._module._instance(className, this);
            if (!result)
                return Promise.reject("Could not instantiate: " + className);
            return result;
        }
    },

    /**
     * @param {string} platform
     * @return {string}
     */
    title: function(platform)
    {
        // FIXME: should be WebInspector.UIString() but runtime is not l10n aware yet.
        return this._descriptor["title-" + platform] || this._descriptor["title"];
    }
}

/**
 * @constructor
 */
Runtime.ExperimentsSupport = function()
{
    this._supportEnabled = Runtime.queryParam("experiments") !== null;
    this._experiments = [];
    this._experimentNames = {};
    this._enabledTransiently = {};
}

Runtime.ExperimentsSupport.prototype = {
    /**
     * @return {!Array.<!Runtime.Experiment>}
     */
    allConfigurableExperiments: function()
    {
        var result = [];
        for (var i = 0; i < this._experiments.length; i++) {
            var experiment = this._experiments[i];
            if (!this._enabledTransiently[experiment.name])
                result.push(experiment);
        }
        return result;
    },

    /**
     * @return {boolean}
     */
    supportEnabled: function()
    {
        return this._supportEnabled;
    },

    /**
     * @param {!Object} value
     */
    _setExperimentsSetting: function(value)
    {
        if (!self.localStorage)
            return;
        self.localStorage["experiments"] = JSON.stringify(value);
    },

    /**
     * @param {string} experimentName
     * @param {string} experimentTitle
     * @param {boolean=} hidden
     */
    register: function(experimentName, experimentTitle, hidden)
    {
        Runtime._assert(!this._experimentNames[experimentName], "Duplicate registration of experiment " + experimentName);
        this._experimentNames[experimentName] = true;
        this._experiments.push(new Runtime.Experiment(this, experimentName, experimentTitle, !!hidden));
    },

    /**
     * @param {string} experimentName
     * @return {boolean}
     */
    isEnabled: function(experimentName)
    {
        this._checkExperiment(experimentName);

        if (this._enabledTransiently[experimentName])
            return true;
        if (!this.supportEnabled())
            return false;

        return !!Runtime._experimentsSetting()[experimentName];
    },

    /**
     * @param {string} experimentName
     * @param {boolean} enabled
     */
    setEnabled: function(experimentName, enabled)
    {
        this._checkExperiment(experimentName);
        var experimentsSetting = Runtime._experimentsSetting();
        experimentsSetting[experimentName] = enabled;
        this._setExperimentsSetting(experimentsSetting);
    },

    /**
     * @param {!Array.<string>} experimentNames
     */
    setDefaultExperiments: function(experimentNames)
    {
        for (var i = 0; i < experimentNames.length; ++i) {
            this._checkExperiment(experimentNames[i]);
            this._enabledTransiently[experimentNames[i]] = true;
        }
    },

    /**
     * @param {string} experimentName
     */
    enableForTest: function(experimentName)
    {
        this._checkExperiment(experimentName);
        this._enabledTransiently[experimentName] = true;
    },

    clearForTest: function()
    {
        this._experiments = [];
        this._experimentNames = {};
        this._enabledTransiently = {};
    },

    cleanUpStaleExperiments: function()
    {
        var experimentsSetting = Runtime._experimentsSetting();
        var cleanedUpExperimentSetting = {};
        for (var i = 0; i < this._experiments.length; ++i) {
            var experimentName = this._experiments[i].name;
            if (experimentsSetting[experimentName])
                cleanedUpExperimentSetting[experimentName] = true;
        }
        this._setExperimentsSetting(cleanedUpExperimentSetting);
    },

    /**
     * @param {string} experimentName
     */
    _checkExperiment: function(experimentName)
    {
        Runtime._assert(this._experimentNames[experimentName], "Unknown experiment " + experimentName);
    }
}

/**
 * @constructor
 * @param {!Runtime.ExperimentsSupport} experiments
 * @param {string} name
 * @param {string} title
 * @param {boolean} hidden
 */
Runtime.Experiment = function(experiments, name, title, hidden)
{
    this.name = name;
    this.title = title;
    this.hidden = hidden;
    this._experiments = experiments;
}

Runtime.Experiment.prototype = {
    /**
     * @return {boolean}
     */
    isEnabled: function()
    {
        return this._experiments.isEnabled(this.name);
    },

    /**
     * @param {boolean} enabled
     */
    setEnabled: function(enabled)
    {
        this._experiments.setEnabled(this.name, enabled);
    }
}

{(function parseQueryParameters()
{
    var queryParams = location.search;
    if (!queryParams)
        return;
    var params = queryParams.substring(1).split("&");
    for (var i = 0; i < params.length; ++i) {
        var pair = params[i].split("=");
        var name = pair.shift();
        Runtime._queryParamsObject[name] = pair.join("=");
    }
})();}


// This must be constructed after the query parameters have been parsed.
Runtime.experiments = new Runtime.ExperimentsSupport();

/**
 * @type {?string}
 */
Runtime._remoteBase = Runtime.queryParam("remoteBase");
{(function validateRemoteBase()
{
    if (Runtime._remoteBase && !Runtime._remoteBase.startsWith("https://chrome-devtools-frontend.appspot.com/"))
        Runtime._remoteBase = null;
})();}

/**
 * @param {string} path
 * @return {string}
 */
Runtime.resolveSourceURL = function(path)
{
    var sourceURL = window.location.href;
    if (window.location.search)
        sourceURL = sourceURL.replace(window.location.search, "");
    sourceURL = sourceURL.substring(0, sourceURL.lastIndexOf("/") + 1) + path;
    return "\n/*# sourceURL=" + sourceURL + " */";
}

/** @type {!Runtime} */
var runtime;

/* Autostart modules */

/* Module platform */
/* utilities.js */
/*
 * Copyright (C) 2007 Apple Inc.  All rights reserved.
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// FIXME: This performance optimization should be moved to blink so that all developers could enjoy it.
// console is retrieved with V8Window.getAttribute method which is slow. Here we copy it to a js variable for faster access.
console = console;
console.__originalAssert = console.assert;
console.assert = function(value, message)
{
    if (value)
        return;
    console.__originalAssert(value, message);
}

/** @typedef {Array|NodeList|Arguments|{length: number}} */
var ArrayLike;

/**
 * @param {!Object} obj
 * @return {boolean}
 */
Object.isEmpty = function(obj)
{
    for (var i in obj)
        return false;
    return true;
}

/**
 * @param {!Object.<string,!T>} obj
 * @return {!Array.<!T>}
 * @template T
 */
Object.values = function(obj)
{
    var result = Object.keys(obj);
    var length = result.length;
    for (var i = 0; i < length; ++i)
        result[i] = obj[result[i]];
    return result;
}

/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
function mod(m, n)
{
    return ((m % n) + n) % n;
}

/**
 * @param {string} string
 * @return {!Array.<number>}
 */
String.prototype.findAll = function(string)
{
    var matches = [];
    var i = this.indexOf(string);
    while (i !== -1) {
        matches.push(i);
        i = this.indexOf(string, i + string.length);
    }
    return matches;
}

/**
 * @return {string}
 */
String.prototype.replaceControlCharacters = function()
{
    // Replace C0 and C1 control character sets with printable character.
    // Do not replace '\t', \n' and '\r'.
    return this.replace(/[\u0000-\u0008\u000b\u000c\u000e-\u001f\u0080-\u009f]/g, "�");
}

/**
 * @return {boolean}
 */
String.prototype.isWhitespace = function()
{
    return /^\s*$/.test(this);
}

/**
 * @return {!Array.<number>}
 */
String.prototype.lineEndings = function()
{
    if (!this._lineEndings) {
        this._lineEndings = this.findAll("\n");
        this._lineEndings.push(this.length);
    }
    return this._lineEndings;
}

/**
 * @return {number}
 */
String.prototype.lineCount = function()
{
    var lineEndings = this.lineEndings();
    return lineEndings.length;
}

/**
 * @return {string}
 */
String.prototype.lineAt = function(lineNumber)
{
    var lineEndings = this.lineEndings();
    var lineStart = lineNumber > 0 ? lineEndings[lineNumber - 1] + 1 : 0;
    var lineEnd = lineEndings[lineNumber];
    var lineContent = this.substring(lineStart, lineEnd);
    if (lineContent.length > 0 && lineContent.charAt(lineContent.length - 1) === "\r")
        lineContent = lineContent.substring(0, lineContent.length - 1);
    return lineContent;
}

/**
 * @param {string} chars
 * @return {string}
 */
String.prototype.escapeCharacters = function(chars)
{
    var foundChar = false;
    for (var i = 0; i < chars.length; ++i) {
        if (this.indexOf(chars.charAt(i)) !== -1) {
            foundChar = true;
            break;
        }
    }

    if (!foundChar)
        return String(this);

    var result = "";
    for (var i = 0; i < this.length; ++i) {
        if (chars.indexOf(this.charAt(i)) !== -1)
            result += "\\";
        result += this.charAt(i);
    }

    return result;
}

/**
 * @return {string}
 */
String.regexSpecialCharacters = function()
{
    return "^[]{}()\\.^$*+?|-,";
}

/**
 * @return {string}
 */
String.prototype.escapeForRegExp = function()
{
    return this.escapeCharacters(String.regexSpecialCharacters());
}

/**
 * @return {string}
 */
String.prototype.escapeHTML = function()
{
    return this.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;"); //" doublequotes just for editor
}

/**
 * @return {string}
 */
String.prototype.unescapeHTML = function()
{
    return this.replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">")
        .replace(/&#58;/g, ":")
        .replace(/&quot;/g, "\"")
        .replace(/&#60;/g, "<")
        .replace(/&#62;/g, ">")
        .replace(/&amp;/g, "&");
}

/**
 * @return {string}
 */
String.prototype.collapseWhitespace = function()
{
    return this.replace(/[\s\xA0]+/g, " ");
}

/**
 * @param {number} maxLength
 * @return {string}
 */
String.prototype.trimMiddle = function(maxLength)
{
    if (this.length <= maxLength)
        return String(this);
    var leftHalf = maxLength >> 1;
    var rightHalf = maxLength - leftHalf - 1;
    return this.substr(0, leftHalf) + "\u2026" + this.substr(this.length - rightHalf, rightHalf);
}

/**
 * @param {number} maxLength
 * @return {string}
 */
String.prototype.trimEnd = function(maxLength)
{
    if (this.length <= maxLength)
        return String(this);
    return this.substr(0, maxLength - 1) + "\u2026";
}

/**
 * @param {?string=} baseURLDomain
 * @return {string}
 */
String.prototype.trimURL = function(baseURLDomain)
{
    var result = this.replace(/^(https|http|file):\/\//i, "");
    if (baseURLDomain) {
        if (result.toLowerCase().startsWith(baseURLDomain.toLowerCase()))
            result = result.substr(baseURLDomain.length);
    }
    return result;
}

/**
 * @return {string}
 */
String.prototype.toTitleCase = function()
{
    return this.substring(0, 1).toUpperCase() + this.substring(1);
}

/**
 * @param {string} other
 * @return {number}
 */
String.prototype.compareTo = function(other)
{
    if (this > other)
        return 1;
    if (this < other)
        return -1;
    return 0;
}

/**
 * @param {string} href
 * @return {?string}
 */
function sanitizeHref(href)
{
    return href && href.trim().toLowerCase().startsWith("javascript:") ? null : href;
}

/**
 * @return {string}
 */
String.prototype.removeURLFragment = function()
{
    var fragmentIndex = this.indexOf("#");
    if (fragmentIndex == -1)
        fragmentIndex = this.length;
    return this.substring(0, fragmentIndex);
}

/**
 * @param {string|undefined} string
 * @return {number}
 */
String.hashCode = function(string)
{
    if (!string)
        return 0;
    var result = 0;
    for (var i = 0; i < string.length; ++i)
        result = (result * 31 + string.charCodeAt(i)) | 0;
    return Math.abs(result);
}

/**
 * @param {string} string
 * @param {number} index
 * @return {boolean}
 */
String.isDigitAt = function(string, index)
{
    var c = string.charCodeAt(index);
    return 48 <= c && c <= 57;
}

/**
 * @return {string}
 */
String.prototype.toBase64 = function()
{
    /**
     * @param {number} b
     * @return {number}
     */
    function encodeBits(b)
    {
        return b < 26 ? b + 65 : b < 52 ? b + 71 : b < 62 ? b - 4 : b === 62 ? 43 : b === 63 ? 47 : 65;
    }
    var encoder = new TextEncoder();
    var data = encoder.encode(this.toString());
    var n = data.length;
    var encoded = "";
    if (n === 0)
        return encoded;
    var shift;
    var v = 0;
    for (var i = 0; i < n; i++) {
        shift = i % 3;
        v |= data[i] << (16 >>> shift & 24);
        if (shift === 2) {
            encoded += String.fromCharCode(encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), encodeBits(v >>> 6 & 63), encodeBits(v & 63));
            v = 0;
        }
    }
    if (shift === 0)
        encoded += String.fromCharCode(encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), 61, 61);
    else if (shift === 1)
        encoded += String.fromCharCode(encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), encodeBits(v >>> 6 & 63), 61);
    return encoded;
}

/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */
String.naturalOrderComparator = function(a, b)
{
    var chunk = /^\d+|^\D+/;
    var chunka, chunkb, anum, bnum;
    while (1) {
        if (a) {
            if (!b)
                return 1;
        } else {
            if (b)
                return -1;
            else
                return 0;
        }
        chunka = a.match(chunk)[0];
        chunkb = b.match(chunk)[0];
        anum = !isNaN(chunka);
        bnum = !isNaN(chunkb);
        if (anum && !bnum)
            return -1;
        if (bnum && !anum)
            return 1;
        if (anum && bnum) {
            var diff = chunka - chunkb;
            if (diff)
                return diff;
            if (chunka.length !== chunkb.length) {
                if (!+chunka && !+chunkb) // chunks are strings of all 0s (special case)
                    return chunka.length - chunkb.length;
                else
                    return chunkb.length - chunka.length;
            }
        } else if (chunka !== chunkb)
            return (chunka < chunkb) ? -1 : 1;
        a = a.substring(chunka.length);
        b = b.substring(chunkb.length);
    }
}

/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */
String.caseInsensetiveComparator = function(a, b)
{
    a = a.toUpperCase();
    b = b.toUpperCase();
    if (a === b)
        return 0;
    return a > b ? 1 : -1;
}

/**
 * @param {number} num
 * @param {number} min
 * @param {number} max
 * @return {number}
 */
Number.constrain = function(num, min, max)
{
    if (num < min)
        num = min;
    else if (num > max)
        num = max;
    return num;
}

/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
Number.gcd = function(a, b)
{
    if (b === 0)
        return a;
    else
        return Number.gcd(b, a % b);
}

/**
 * @param {string} value
 * @return {string}
 */
Number.toFixedIfFloating = function(value)
{
    if (!value || isNaN(value))
        return value;
    var number = Number(value);
    return number % 1 ? number.toFixed(3) : String(number);
}

/**
 * @return {string}
 */
Date.prototype.toISO8601Compact = function()
{
    /**
     * @param {number} x
     * @return {string}
     */
    function leadZero(x)
    {
        return (x > 9 ? "" : "0") + x;
    }
    return this.getFullYear() +
           leadZero(this.getMonth() + 1) +
           leadZero(this.getDate()) + "T" +
           leadZero(this.getHours()) +
           leadZero(this.getMinutes()) +
           leadZero(this.getSeconds());
}

/**
 * @return {string}
 */
Date.prototype.toConsoleTime = function()
{
    /**
     * @param {number} x
     * @return {string}
     */
    function leadZero2(x)
    {
        return (x > 9 ? "" : "0") + x;
    }

    /**
     * @param {number} x
     * @return {string}
     */
    function leadZero3(x)
    {
        return "0".repeat(3 - x.toString().length) + x;
    }

    return this.getFullYear() + "-" +
           leadZero2(this.getMonth() + 1) + "-" +
           leadZero2(this.getDate()) + " " +
           leadZero2(this.getHours()) + ":" +
           leadZero2(this.getMinutes()) + ":" +
           leadZero2(this.getSeconds()) + "." +
           leadZero3(this.getMilliseconds());
}

Object.defineProperty(Array.prototype, "remove",
{
    /**
     * @param {!T} value
     * @param {boolean=} firstOnly
     * @return {boolean}
     * @this {Array.<!T>}
     * @template T
     */
    value: function(value, firstOnly)
    {
        var index = this.indexOf(value);
        if (index === -1)
            return false;
        if (firstOnly) {
            this.splice(index, 1);
            return true;
        }
        for (var i = index + 1, n = this.length; i < n; ++i) {
            if (this[i] !== value)
                this[index++] = this[i];
        }
        this.length = index;
        return true;
    }
});

Object.defineProperty(Array.prototype, "keySet",
{
    /**
     * @return {!Object.<string, boolean>}
     * @this {Array.<*>}
     */
    value: function()
    {
        var keys = {};
        for (var i = 0; i < this.length; ++i)
            keys[this[i]] = true;
        return keys;
    }
});

Object.defineProperty(Array.prototype, "pushAll",
{
    /**
     * @param {!Array.<!T>} array
     * @this {Array.<!T>}
     * @template T
     */
    value: function(array)
    {
        Array.prototype.push.apply(this, array);
    }
});

Object.defineProperty(Array.prototype, "rotate",
{
    /**
     * @param {number} index
     * @return {!Array.<!T>}
     * @this {Array.<!T>}
     * @template T
     */
    value: function(index)
    {
        var result = [];
        for (var i = index; i < index + this.length; ++i)
            result.push(this[i % this.length]);
        return result;
    }
});

Object.defineProperty(Array.prototype, "sortNumbers",
{
    /**
     * @this {Array.<number>}
     */
    value: function()
    {
        /**
         * @param {number} a
         * @param {number} b
         * @return {number}
         */
        function numericComparator(a, b)
        {
            return a - b;
        }

        this.sort(numericComparator);
    }
});

Object.defineProperty(Uint32Array.prototype, "sort", {
    value: Array.prototype.sort
});

(function() {
var partition = {
    /**
     * @this {Array.<number>}
     * @param {function(number, number): number} comparator
     * @param {number} left
     * @param {number} right
     * @param {number} pivotIndex
     */
    value: function(comparator, left, right, pivotIndex)
    {
        function swap(array, i1, i2)
        {
            var temp = array[i1];
            array[i1] = array[i2];
            array[i2] = temp;
        }

        var pivotValue = this[pivotIndex];
        swap(this, right, pivotIndex);
        var storeIndex = left;
        for (var i = left; i < right; ++i) {
            if (comparator(this[i], pivotValue) < 0) {
                swap(this, storeIndex, i);
                ++storeIndex;
            }
        }
        swap(this, right, storeIndex);
        return storeIndex;
    }
};
Object.defineProperty(Array.prototype, "partition", partition);
Object.defineProperty(Uint32Array.prototype, "partition", partition);

var sortRange = {
    /**
     * @param {function(number, number): number} comparator
     * @param {number} leftBound
     * @param {number} rightBound
     * @param {number} sortWindowLeft
     * @param {number} sortWindowRight
     * @return {!Array.<number>}
     * @this {Array.<number>}
     */
    value: function(comparator, leftBound, rightBound, sortWindowLeft, sortWindowRight)
    {
        function quickSortRange(array, comparator, left, right, sortWindowLeft, sortWindowRight)
        {
            if (right <= left)
                return;
            var pivotIndex = Math.floor(Math.random() * (right - left)) + left;
            var pivotNewIndex = array.partition(comparator, left, right, pivotIndex);
            if (sortWindowLeft < pivotNewIndex)
                quickSortRange(array, comparator, left, pivotNewIndex - 1, sortWindowLeft, sortWindowRight);
            if (pivotNewIndex < sortWindowRight)
                quickSortRange(array, comparator, pivotNewIndex + 1, right, sortWindowLeft, sortWindowRight);
        }
        if (leftBound === 0 && rightBound === (this.length - 1) && sortWindowLeft === 0 && sortWindowRight >= rightBound)
            this.sort(comparator);
        else
            quickSortRange(this, comparator, leftBound, rightBound, sortWindowLeft, sortWindowRight);
        return this;
    }
}
Object.defineProperty(Array.prototype, "sortRange", sortRange);
Object.defineProperty(Uint32Array.prototype, "sortRange", sortRange);
})();

Object.defineProperty(Array.prototype, "stableSort",
{
    /**
     * @param {function(?T, ?T): number=} comparator
     * @return {!Array.<?T>}
     * @this {Array.<?T>}
     * @template T
     */
    value: function(comparator)
    {
        function defaultComparator(a, b)
        {
            return a < b ? -1 : (a > b ? 1 : 0);
        }
        comparator = comparator || defaultComparator;

        var indices = new Array(this.length);
        for (var i = 0; i < this.length; ++i)
            indices[i] = i;
        var self = this;
        /**
         * @param {number} a
         * @param {number} b
         * @return {number}
         */
        function indexComparator(a, b)
        {
            var result = comparator(self[a], self[b]);
            return result ? result : a - b;
        }
        indices.sort(indexComparator);

        for (var i = 0; i < this.length; ++i) {
            if (indices[i] < 0 || i === indices[i])
                continue;
            var cyclical = i;
            var saved = this[i];
            while (true) {
                var next = indices[cyclical];
                indices[cyclical] = -1;
                if (next === i) {
                    this[cyclical] = saved;
                    break;
                } else {
                    this[cyclical] = this[next];
                    cyclical = next;
                }
            }
        }
        return this;
    }
});

Object.defineProperty(Array.prototype, "qselect",
{
    /**
     * @param {number} k
     * @param {function(number, number): number=} comparator
     * @return {number|undefined}
     * @this {Array.<number>}
     */
    value: function(k, comparator)
    {
        if (k < 0 || k >= this.length)
            return;
        if (!comparator)
            comparator = function(a, b) { return a - b; }

        var low = 0;
        var high = this.length - 1;
        for (;;) {
            var pivotPosition = this.partition(comparator, low, high, Math.floor((high + low) / 2));
            if (pivotPosition === k)
                return this[k];
            else if (pivotPosition > k)
                high = pivotPosition - 1;
            else
                low = pivotPosition + 1;
        }
    }
});

Object.defineProperty(Array.prototype, "lowerBound",
{
    /**
     * Return index of the leftmost element that is equal or greater
     * than the specimen object. If there's no such element (i.e. all
     * elements are smaller than the specimen) returns right bound.
     * The function works for sorted array.
     * When specified, |left| (inclusive) and |right| (exclusive) indices
     * define the search window.
     *
     * @param {!T} object
     * @param {function(!T,!S):number=} comparator
     * @param {number=} left
     * @param {number=} right
     * @return {number}
     * @this {Array.<!S>}
     * @template T,S
     */
    value: function(object, comparator, left, right)
    {
        function defaultComparator(a, b)
        {
            return a < b ? -1 : (a > b ? 1 : 0);
        }
        comparator = comparator || defaultComparator;
        var l = left || 0;
        var r = right !== undefined ? right : this.length;
        while (l < r) {
            var m = (l + r) >> 1;
            if (comparator(object, this[m]) > 0)
                l = m + 1;
            else
                r = m;
        }
        return r;
    }
});

Object.defineProperty(Array.prototype, "upperBound",
{
    /**
     * Return index of the leftmost element that is greater
     * than the specimen object. If there's no such element (i.e. all
     * elements are smaller or equal to the specimen) returns right bound.
     * The function works for sorted array.
     * When specified, |left| (inclusive) and |right| (exclusive) indices
     * define the search window.
     *
     * @param {!T} object
     * @param {function(!T,!S):number=} comparator
     * @param {number=} left
     * @param {number=} right
     * @return {number}
     * @this {Array.<!S>}
     * @template T,S
     */
    value: function(object, comparator, left, right)
    {
        function defaultComparator(a, b)
        {
            return a < b ? -1 : (a > b ? 1 : 0);
        }
        comparator = comparator || defaultComparator;
        var l = left || 0;
        var r = right !== undefined ? right : this.length;
        while (l < r) {
            var m = (l + r) >> 1;
            if (comparator(object, this[m]) >= 0)
                l = m + 1;
            else
                r = m;
        }
        return r;
    }
});

Object.defineProperty(Uint32Array.prototype, "lowerBound", {
    value: Array.prototype.lowerBound
});

Object.defineProperty(Uint32Array.prototype, "upperBound", {
    value: Array.prototype.upperBound
});

Object.defineProperty(Float64Array.prototype, "lowerBound", {
    value: Array.prototype.lowerBound
});

Object.defineProperty(Array.prototype, "binaryIndexOf",
{
    /**
     * @param {!T} value
     * @param {function(!T,!S):number} comparator
     * @return {number}
     * @this {Array.<!S>}
     * @template T,S
     */
    value: function(value, comparator)
    {
        var index = this.lowerBound(value, comparator);
        return index < this.length && comparator(value, this[index]) === 0 ? index : -1;
    }
});

Object.defineProperty(Array.prototype, "select",
{
    /**
     * @param {string} field
     * @return {!Array.<!T>}
     * @this {Array.<!Object.<string,!T>>}
     * @template T
     */
    value: function(field)
    {
        var result = new Array(this.length);
        for (var i = 0; i < this.length; ++i)
            result[i] = this[i][field];
        return result;
    }
});

Object.defineProperty(Array.prototype, "peekLast",
{
    /**
     * @return {!T|undefined}
     * @this {Array.<!T>}
     * @template T
     */
    value: function()
    {
        return this[this.length - 1];
    }
});

(function(){

/**
 * @param {!Array.<T>} array1
 * @param {!Array.<T>} array2
 * @param {function(T,T):number} comparator
 * @param {boolean} mergeNotIntersect
 * @return {!Array.<T>}
 * @template T
 */
function mergeOrIntersect(array1, array2, comparator, mergeNotIntersect)
{
    var result = [];
    var i = 0;
    var j = 0;
    while (i < array1.length && j < array2.length) {
        var compareValue = comparator(array1[i], array2[j]);
        if (mergeNotIntersect || !compareValue)
            result.push(compareValue <= 0 ? array1[i] : array2[j]);
        if (compareValue <= 0)
            i++;
        if (compareValue >= 0)
            j++;
    }
    if (mergeNotIntersect) {
        while (i < array1.length)
            result.push(array1[i++]);
        while (j < array2.length)
            result.push(array2[j++]);
    }
    return result;
}

Object.defineProperty(Array.prototype, "intersectOrdered",
{
    /**
     * @param {!Array.<T>} array
     * @param {function(T,T):number} comparator
     * @return {!Array.<T>}
     * @this {!Array.<T>}
     * @template T
     */
    value: function(array, comparator)
    {
        return mergeOrIntersect(this, array, comparator, false);
    }
});

Object.defineProperty(Array.prototype, "mergeOrdered",
{
    /**
     * @param {!Array.<T>} array
     * @param {function(T,T):number} comparator
     * @return {!Array.<T>}
     * @this {!Array.<T>}
     * @template T
     */
    value: function(array, comparator)
    {
        return mergeOrIntersect(this, array, comparator, true);
    }
});

}());


/**
 * @param {!T} object
 * @param {!Array.<!S>} list
 * @param {function(!T,!S):number=} comparator
 * @param {boolean=} insertionIndexAfter
 * @return {number}
 * @template T,S
 */
function insertionIndexForObjectInListSortedByFunction(object, list, comparator, insertionIndexAfter)
{
    if (insertionIndexAfter)
        return list.upperBound(object, comparator);
    else
        return list.lowerBound(object, comparator);
}

/**
 * @param {string} format
 * @param {...*} var_arg
 * @return {string}
 */
String.sprintf = function(format, var_arg)
{
    return String.vsprintf(format, Array.prototype.slice.call(arguments, 1));
}

/**
 * @param {string} format
 * @param {!Object.<string, function(string, ...):*>} formatters
 * @return {!Array.<!Object>}
 */
String.tokenizeFormatString = function(format, formatters)
{
    var tokens = [];
    var substitutionIndex = 0;

    function addStringToken(str)
    {
        if (tokens.length && tokens[tokens.length - 1].type === "string")
            tokens[tokens.length - 1].value += str;
        else
            tokens.push({ type: "string", value: str });
    }

    function addSpecifierToken(specifier, precision, substitutionIndex)
    {
        tokens.push({ type: "specifier", specifier: specifier, precision: precision, substitutionIndex: substitutionIndex });
    }

    var index = 0;
    for (var precentIndex = format.indexOf("%", index); precentIndex !== -1; precentIndex = format.indexOf("%", index)) {
        if (format.length === index)  // unescaped % sign at the end of the format string.
            break;
        addStringToken(format.substring(index, precentIndex));
        index = precentIndex + 1;

        if (format[index] === "%") {
            // %% escape sequence.
            addStringToken("%");
            ++index;
            continue;
        }

        if (String.isDigitAt(format, index)) {
            // The first character is a number, it might be a substitution index.
            var number = parseInt(format.substring(index), 10);
            while (String.isDigitAt(format, index))
                ++index;

            // If the number is greater than zero and ends with a "$",
            // then this is a substitution index.
            if (number > 0 && format[index] === "$") {
                substitutionIndex = (number - 1);
                ++index;
            }
        }

        var precision = -1;
        if (format[index] === ".") {
            // This is a precision specifier. If no digit follows the ".",
            // then the precision should be zero.
            ++index;
            precision = parseInt(format.substring(index), 10);
            if (isNaN(precision))
                precision = 0;

            while (String.isDigitAt(format, index))
                ++index;
        }

        if (!(format[index] in formatters)) {
            addStringToken(format.substring(precentIndex, index + 1));
            ++index;
            continue;
        }

        addSpecifierToken(format[index], precision, substitutionIndex);

        ++substitutionIndex;
        ++index;
    }

    addStringToken(format.substring(index));

    return tokens;
}

String.standardFormatters = {
    /**
     * @return {number}
     */
    d: function(substitution)
    {
        return !isNaN(substitution) ? substitution : 0;
    },

    /**
     * @return {number}
     */
    f: function(substitution, token)
    {
        if (substitution && token.precision > -1)
            substitution = substitution.toFixed(token.precision);
        return !isNaN(substitution) ? substitution : (token.precision > -1 ? Number(0).toFixed(token.precision) : 0);
    },

    /**
     * @return {string}
     */
    s: function(substitution)
    {
        return substitution;
    }
}

/**
 * @param {string} format
 * @param {!Array.<*>} substitutions
 * @return {string}
 */
String.vsprintf = function(format, substitutions)
{
    return String.format(format, substitutions, String.standardFormatters, "", function(a, b) { return a + b; }).formattedResult;
}

/**
 * @param {string} format
 * @param {?ArrayLike} substitutions
 * @param {!Object.<string, function(string, ...):Q>} formatters
 * @param {!T} initialValue
 * @param {function(T, Q): T|undefined} append
 * @param {!Array.<!Object>=} tokenizedFormat
 * @return {!{formattedResult: T, unusedSubstitutions: ?ArrayLike}};
 * @template T, Q
 */
String.format = function(format, substitutions, formatters, initialValue, append, tokenizedFormat)
{
    if (!format || !substitutions || !substitutions.length)
        return { formattedResult: append(initialValue, format), unusedSubstitutions: substitutions };

    function prettyFunctionName()
    {
        return "String.format(\"" + format + "\", \"" + Array.prototype.join.call(substitutions, "\", \"") + "\")";
    }

    function warn(msg)
    {
        console.warn(prettyFunctionName() + ": " + msg);
    }

    function error(msg)
    {
        console.error(prettyFunctionName() + ": " + msg);
    }

    var result = initialValue;
    var tokens = tokenizedFormat || String.tokenizeFormatString(format, formatters);
    var usedSubstitutionIndexes = {};

    for (var i = 0; i < tokens.length; ++i) {
        var token = tokens[i];

        if (token.type === "string") {
            result = append(result, token.value);
            continue;
        }

        if (token.type !== "specifier") {
            error("Unknown token type \"" + token.type + "\" found.");
            continue;
        }

        if (token.substitutionIndex >= substitutions.length) {
            // If there are not enough substitutions for the current substitutionIndex
            // just output the format specifier literally and move on.
            error("not enough substitution arguments. Had " + substitutions.length + " but needed " + (token.substitutionIndex + 1) + ", so substitution was skipped.");
            result = append(result, "%" + (token.precision > -1 ? token.precision : "") + token.specifier);
            continue;
        }

        usedSubstitutionIndexes[token.substitutionIndex] = true;

        if (!(token.specifier in formatters)) {
            // Encountered an unsupported format character, treat as a string.
            warn("unsupported format character \u201C" + token.specifier + "\u201D. Treating as a string.");
            result = append(result, substitutions[token.substitutionIndex]);
            continue;
        }

        result = append(result, formatters[token.specifier](substitutions[token.substitutionIndex], token));
    }

    var unusedSubstitutions = [];
    for (var i = 0; i < substitutions.length; ++i) {
        if (i in usedSubstitutionIndexes)
            continue;
        unusedSubstitutions.push(substitutions[i]);
    }

    return { formattedResult: result, unusedSubstitutions: unusedSubstitutions };
}

/**
 * @param {string} query
 * @param {boolean} caseSensitive
 * @param {boolean} isRegex
 * @return {!RegExp}
 */
function createSearchRegex(query, caseSensitive, isRegex)
{
    var regexFlags = caseSensitive ? "g" : "gi";
    var regexObject;

    if (isRegex) {
        try {
            regexObject = new RegExp(query, regexFlags);
        } catch (e) {
            // Silent catch.
        }
    }

    if (!regexObject)
        regexObject = createPlainTextSearchRegex(query, regexFlags);

    return regexObject;
}

/**
 * @param {string} query
 * @param {string=} flags
 * @return {!RegExp}
 */
function createPlainTextSearchRegex(query, flags)
{
    // This should be kept the same as the one in V8StringUtil.cpp.
    var regexSpecialCharacters = String.regexSpecialCharacters();
    var regex = "";
    for (var i = 0; i < query.length; ++i) {
        var c = query.charAt(i);
        if (regexSpecialCharacters.indexOf(c) != -1)
            regex += "\\";
        regex += c;
    }
    return new RegExp(regex, flags || "");
}

/**
 * @param {!RegExp} regex
 * @param {string} content
 * @return {number}
 */
function countRegexMatches(regex, content)
{
    var text = content;
    var result = 0;
    var match;
    while (text && (match = regex.exec(text))) {
        if (match[0].length > 0)
            ++result;
        text = text.substring(match.index + 1);
    }
    return result;
}

/**
 * @param {number} spacesCount
 * @return {string}
 */
function spacesPadding(spacesCount)
{
    return "\u00a0".repeat(spacesCount);
}

/**
 * @param {number} value
 * @param {number} symbolsCount
 * @return {string}
 */
function numberToStringWithSpacesPadding(value, symbolsCount)
{
    var numberString = value.toString();
    var paddingLength = Math.max(0, symbolsCount - numberString.length);
    return spacesPadding(paddingLength) + numberString;
}

/**
 * @param {!Iterator.<T>} iterator
 * @return {!Array.<T>}
 * @template T
 */
Array.from = function(iterator)
{
    var values = [];
    for (var iteratorValue = iterator.next(); !iteratorValue.done; iteratorValue = iterator.next())
        values.push(iteratorValue.value);
    return values;
}

/**
 * @return {!Array.<T>}
 * @template T
 */
Set.prototype.valuesArray = function()
{
    return Array.from(this.values());
}

/**
 * @param {!Iterable<T>} iterable
 * @template T
 */
Set.prototype.addAll = function(iterable)
{
    for (var e of iterable)
        this.add(e);
}

/**
 * @return {T}
 * @template T
 */
Map.prototype.remove = function(key)
{
    var value = this.get(key);
    this.delete(key);
    return value;
}

/**
 * @return {!Array.<V>}
 * @template K, V
 * @this {Map.<K, V>}
 */
Map.prototype.valuesArray = function()
{
    return Array.from(this.values());
}

/**
 * @return {!Array.<K>}
 * @template K, V
 * @this {Map.<K, V>}
 */
Map.prototype.keysArray = function()
{
    return Array.from(this.keys());
}

/**
 * @constructor
 * @template K, V
 */
var Multimap = function()
{
    /** @type {!Map.<K, !Set.<!V>>} */
    this._map = new Map();
}

Multimap.prototype = {
    /**
     * @param {K} key
     * @param {V} value
     */
    set: function(key, value)
    {
        var set = this._map.get(key);
        if (!set) {
            set = new Set();
            this._map.set(key, set);
        }
        set.add(value);
    },

    /**
     * @param {K} key
     * @return {!Set.<!V>}
     */
    get: function(key)
    {
        var result = this._map.get(key);
        if (!result)
            result = new Set();
        return result;
    },

    /**
     * @param {K} key
     * @return {boolean}
     */
    has: function(key)
    {
        return this._map.has(key);
    },

    /**
     * @return {number}
     */
    get size()
    {
        return this._map.size;
    },

    /**
     * @param {K} key
     * @param {V} value
     */
    remove: function(key, value)
    {
        var values = this.get(key);
        values.delete(value);
        if (!values.size)
            this._map.delete(key);
    },

    /**
     * @param {K} key
     */
    removeAll: function(key)
    {
        this._map.delete(key);
    },

    /**
     * @return {!Array.<K>}
     */
    keysArray: function()
    {
        return this._map.keysArray();
    },

    /**
     * @return {!Array.<!V>}
     */
    valuesArray: function()
    {
        var result = [];
        var keys = this.keysArray();
        for (var i = 0; i < keys.length; ++i)
            result.pushAll(this.get(keys[i]).valuesArray());
        return result;
    },

    clear: function()
    {
        this._map.clear();
    }
}

/**
 * @param {string} url
 * @return {!Promise.<string>}
 */
function loadXHR(url)
{
    return new Promise(load);

    function load(successCallback, failureCallback)
    {
        function onReadyStateChanged()
        {
            if (xhr.readyState !== XMLHttpRequest.DONE)
                return;
            if (xhr.status !== 200) {
                xhr.onreadystatechange = null;
                failureCallback(new Error(xhr.status));
                return;
            }
            xhr.onreadystatechange = null;
            successCallback(xhr.responseText);
        }

        var xhr = new XMLHttpRequest();
        xhr.withCredentials = false;
        xhr.open("GET", url, true);
        xhr.onreadystatechange = onReadyStateChanged;
        xhr.send(null);
    }
}

/**
 * @constructor
 */
function CallbackBarrier()
{
    this._pendingIncomingCallbacksCount = 0;
}

CallbackBarrier.prototype = {
    /**
     * @param {function(...)=} userCallback
     * @return {function(...)}
     */
    createCallback: function(userCallback)
    {
        console.assert(!this._outgoingCallback, "CallbackBarrier.createCallback() is called after CallbackBarrier.callWhenDone()");
        ++this._pendingIncomingCallbacksCount;
        return this._incomingCallback.bind(this, userCallback);
    },

    /**
     * @param {function()} callback
     */
    callWhenDone: function(callback)
    {
        console.assert(!this._outgoingCallback, "CallbackBarrier.callWhenDone() is called multiple times");
        this._outgoingCallback = callback;
        if (!this._pendingIncomingCallbacksCount)
            this._outgoingCallback();
    },

    /**
     * @return {!Promise.<undefined>}
     */
    donePromise: function()
    {
        return new Promise(promiseConstructor.bind(this));

        /**
         * @param {function()} success
         * @this {CallbackBarrier}
         */
        function promiseConstructor(success)
        {
            this.callWhenDone(success);
        }
    },

    /**
     * @param {function(...)=} userCallback
     */
    _incomingCallback: function(userCallback)
    {
        console.assert(this._pendingIncomingCallbacksCount > 0);
        if (userCallback) {
            var args = Array.prototype.slice.call(arguments, 1);
            userCallback.apply(null, args);
        }
        if (!--this._pendingIncomingCallbacksCount && this._outgoingCallback)
            this._outgoingCallback();
    }
}

/**
 * @param {*} value
 */
function suppressUnused(value)
{
}

/**
 * @param {function()} callback
 * @return {number}
 */
self.setImmediate = function(callback)
{
    Promise.resolve().then(callback);
    return 0;
}

/**
 * @param {function(...?)} callback
 * @return {!Promise.<T>}
 * @template T
 */
Promise.prototype.spread = function(callback)
{
    return this.then(spreadPromise);

    function spreadPromise(arg)
    {
        return callback.apply(null, arg);
    }
}

/**
 * @param {T} defaultValue
 * @return {!Promise.<T>}
 * @template T
 */
Promise.prototype.catchException = function(defaultValue) {
    return this.catch(function (error) {
        console.error(error);
        return defaultValue;
    });
}

/**
 * @constructor
 * @param {(function(!Segment, !Segment): ?Segment)=} mergeCallback
 */
function SegmentedRange(mergeCallback)
{
    /** @type {!Array<!Segment>} */
    this._segments = [];
    this._mergeCallback = mergeCallback;
}

/**
 * @constructor
 * @param {number} begin
 * @param {number} end
 * @param {*} data
 */
function Segment(begin, end, data)
{
    if (begin > end)
        console.assert(false, "Invalid segment");
    this.begin = begin;
    this.end = end;
    this.data = data;
}

Segment.prototype = {
    /**
     * @param {!Segment} that
     * @return {boolean}
     */
    intersects: function(that)
    {
        return this.begin < that.end && that.begin < this.end;
    }
};

SegmentedRange.prototype = {
    /**
     * @param {!Segment} newSegment
     */
    append: function(newSegment)
    {
        // 1. Find the proper insertion point for new segment
        var startIndex = this._segments.lowerBound(newSegment, (a, b) => a.begin - b.begin);
        var endIndex = startIndex;
        var merged = null;
        if (startIndex > 0) {
            // 2. Try mering the preceding segment
            var precedingSegment = this._segments[startIndex - 1];
            merged = this._tryMerge(precedingSegment, newSegment);
            if (merged) {
                --startIndex;
                newSegment = merged;
            } else if (this._segments[startIndex - 1].end >= newSegment.begin) {
                // 2a. If merge failed and segments overlap, adjust preceding segment.
                // If an old segment entirely contains new one, split it in two.
                if (newSegment.end < precedingSegment.end)
                    this._segments.splice(startIndex, 0, new Segment(newSegment.end, precedingSegment.end, precedingSegment.data));
                precedingSegment.end = newSegment.begin;
            }
        }
        // 3. Consume all segments that are entirely covered by the new one.
        while (endIndex < this._segments.length && this._segments[endIndex].end <= newSegment.end)
            ++endIndex;
        // 4. Merge or adjust the succeeding segment if it overlaps.
        if (endIndex < this._segments.length) {
            merged = this._tryMerge(newSegment, this._segments[endIndex]);
            if (merged) {
                endIndex++;
                newSegment = merged;
            } else if (newSegment.intersects(this._segments[endIndex]))
                this._segments[endIndex].begin = newSegment.end;
        }
        this._segments.splice(startIndex, endIndex - startIndex, newSegment);
    },

    /**
     * @param {!SegmentedRange} that
     */
    appendRange: function(that)
    {
        that.segments().forEach(segment => this.append(segment));
    },

    /**
     * @return {!Array<!Segment>}
     */
    segments: function()
    {
        return this._segments;
    },

    /**
     * @param {!Segment} first
     * @param {!Segment} second
     * @return {?Segment}
     */
    _tryMerge: function(first, second)
    {
        var merged = this._mergeCallback && this._mergeCallback(first, second);
        if (!merged)
            return null;
        merged.begin = first.begin;
        merged.end = Math.max(first.end, second.end);
        return merged;
    }
}
;/* DOMExtension.js */
/*
 * Copyright (C) 2007 Apple Inc.  All rights reserved.
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Contains diff method based on Javascript Diff Algorithm By John Resig
 * http://ejohn.org/files/jsdiff.js (released under the MIT license).
 */

/**
 * @param {number} offset
 * @param {string} stopCharacters
 * @param {!Node} stayWithinNode
 * @param {string=} direction
 * @return {!Range}
 */
Node.prototype.rangeOfWord = function(offset, stopCharacters, stayWithinNode, direction)
{
    var startNode;
    var startOffset = 0;
    var endNode;
    var endOffset = 0;

    if (!stayWithinNode)
        stayWithinNode = this;

    if (!direction || direction === "backward" || direction === "both") {
        var node = this;
        while (node) {
            if (node === stayWithinNode) {
                if (!startNode)
                    startNode = stayWithinNode;
                break;
            }

            if (node.nodeType === Node.TEXT_NODE) {
                var start = (node === this ? (offset - 1) : (node.nodeValue.length - 1));
                for (var i = start; i >= 0; --i) {
                    if (stopCharacters.indexOf(node.nodeValue[i]) !== -1) {
                        startNode = node;
                        startOffset = i + 1;
                        break;
                    }
                }
            }

            if (startNode)
                break;

            node = node.traversePreviousNode(stayWithinNode);
        }

        if (!startNode) {
            startNode = stayWithinNode;
            startOffset = 0;
        }
    } else {
        startNode = this;
        startOffset = offset;
    }

    if (!direction || direction === "forward" || direction === "both") {
        node = this;
        while (node) {
            if (node === stayWithinNode) {
                if (!endNode)
                    endNode = stayWithinNode;
                break;
            }

            if (node.nodeType === Node.TEXT_NODE) {
                var start = (node === this ? offset : 0);
                for (var i = start; i < node.nodeValue.length; ++i) {
                    if (stopCharacters.indexOf(node.nodeValue[i]) !== -1) {
                        endNode = node;
                        endOffset = i;
                        break;
                    }
                }
            }

            if (endNode)
                break;

            node = node.traverseNextNode(stayWithinNode);
        }

        if (!endNode) {
            endNode = stayWithinNode;
            endOffset = stayWithinNode.nodeType === Node.TEXT_NODE ? stayWithinNode.nodeValue.length : stayWithinNode.childNodes.length;
        }
    } else {
        endNode = this;
        endOffset = offset;
    }

    var result = this.ownerDocument.createRange();
    result.setStart(startNode, startOffset);
    result.setEnd(endNode, endOffset);

    return result;
}

/**
 * @param {!Node=} stayWithin
 * @return {?Node}
 */
Node.prototype.traverseNextTextNode = function(stayWithin)
{
    var node = this.traverseNextNode(stayWithin);
    if (!node)
        return null;
    var nonTextTags = { "STYLE": 1, "SCRIPT": 1 };
    while (node && (node.nodeType !== Node.TEXT_NODE || nonTextTags[node.parentElement.nodeName]))
        node = node.traverseNextNode(stayWithin);

    return node;
}

/**
 * @param {number|undefined} x
 * @param {number|undefined} y
 * @param {!Element=} relativeTo
 */
Element.prototype.positionAt = function(x, y, relativeTo)
{
    var shift = {x: 0, y: 0};
    if (relativeTo)
       shift = relativeTo.boxInWindow(this.ownerDocument.defaultView);

    if (typeof x === "number")
        this.style.setProperty("left", (shift.x + x) + "px");
    else
        this.style.removeProperty("left");

    if (typeof y === "number")
        this.style.setProperty("top", (shift.y + y) + "px");
    else
        this.style.removeProperty("top");

    if (typeof x === "number" || typeof y === "number")
        this.style.setProperty("position", "absolute");
    else
        this.style.removeProperty("position");
}

/**
 * @return {boolean}
 */
Element.prototype.isScrolledToBottom = function()
{
    // This code works only for 0-width border.
    // The scrollTop, clientHeight and scrollHeight are computed in double values internally.
    // However, they are exposed to javascript differently, each being either rounded (via
    // round, ceil or floor functions) or left intouch.
    // This adds up a total error up to 2.
    return Math.abs(this.scrollTop + this.clientHeight - this.scrollHeight) <= 2;
}

/**
 * @param {!Node} fromNode
 * @param {!Node} toNode
 */
function removeSubsequentNodes(fromNode, toNode)
{
    for (var node = fromNode; node && node !== toNode; ) {
        var nodeToRemove = node;
        node = node.nextSibling;
        nodeToRemove.remove();
    }
}

/**
 * @param {!Event} event
 * @return {boolean}
 */
Element.prototype.containsEventPoint = function(event)
{
    var box = this.getBoundingClientRect();
    return box.left < event.x  && event.x < box.right &&
           box.top < event.y && event.y < box.bottom;
}

/**
 * @param {!Array.<string>} nameArray
 * @return {?Node}
 */
Node.prototype.enclosingNodeOrSelfWithNodeNameInArray = function(nameArray)
{
    for (var node = this; node && node !== this.ownerDocument; node = node.parentNodeOrShadowHost()) {
        for (var i = 0; i < nameArray.length; ++i) {
            if (node.nodeName.toLowerCase() === nameArray[i].toLowerCase())
                return node;
        }
    }
    return null;
}

/**
 * @param {string} nodeName
 * @return {?Node}
 */
Node.prototype.enclosingNodeOrSelfWithNodeName = function(nodeName)
{
    return this.enclosingNodeOrSelfWithNodeNameInArray([nodeName]);
}

/**
 * @param {string} className
 * @param {!Element=} stayWithin
 * @return {?Element}
 */
Node.prototype.enclosingNodeOrSelfWithClass = function(className, stayWithin)
{
    return this.enclosingNodeOrSelfWithClassList([className], stayWithin);
}

/**
 * @param {!Array.<string>} classNames
 * @param {!Element=} stayWithin
 * @return {?Element}
 */
Node.prototype.enclosingNodeOrSelfWithClassList = function(classNames, stayWithin)
{
    for (var node = this; node && node !== stayWithin && node !== this.ownerDocument; node = node.parentNodeOrShadowHost()) {
        if (node.nodeType === Node.ELEMENT_NODE) {
            var containsAll = true;
            for (var i = 0; i < classNames.length && containsAll; ++i) {
                if (!node.classList.contains(classNames[i]))
                    containsAll = false;
            }
            if (containsAll)
                return /** @type {!Element} */ (node);
        }
    }
    return null;
}

/**
 * @return {?Element}
 */
Node.prototype.parentElementOrShadowHost = function()
{
    var node = this.parentNode;
    if (!node)
        return null;
    if (node.nodeType === Node.ELEMENT_NODE)
        return /** @type {!Element} */ (node);
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
        return /** @type {!Element} */ (node.host);
    return null;
}

/**
 * @return {?Node}
 */
Node.prototype.parentNodeOrShadowHost = function()
{
    return this.parentNode || this.host || null;
}

/**
 * @return {?Selection}
 */
Node.prototype.getComponentSelection = function()
{
    var parent = this.parentNode;
    while (parent && parent.nodeType !== Node.DOCUMENT_FRAGMENT_NODE)
        parent = parent.parentNode;
    return parent instanceof ShadowRoot ? parent.getSelection() : this.window().getSelection();
}


/**
 * @return {boolean}
 */
Node.prototype.isComponentSelectionCollapsed = function()
{
    // FIXME: crbug.com/447523, use selection.isCollapsed when it is fixed for shadow dom.
    var selection = this.getComponentSelection();
    return selection && selection.rangeCount ? selection.getRangeAt(0).collapsed : true;
}

/**
 * @return {!Selection}
 */
Node.prototype.getDeepSelection = function()
{
    var activeElement = this.ownerDocument.activeElement;
    var shadowRoot = null;
    while (activeElement && activeElement.shadowRoot) {
        shadowRoot = activeElement.shadowRoot;
        activeElement = shadowRoot.activeElement;
    }

    return shadowRoot ? shadowRoot.getSelection() : this.window().getSelection();
}

/**
 * @return {!Window}
 */
Node.prototype.window = function()
{
    return this.ownerDocument.defaultView;
}

/**
 * @param {string} query
 * @return {?Node}
 */
Element.prototype.query = function(query)
{
    return this.ownerDocument.evaluate(query, this, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
}

Element.prototype.removeChildren = function()
{
    if (this.firstChild)
        this.textContent = "";
}

/**
 * @return {boolean}
 */
Element.prototype.isInsertionCaretInside = function()
{
    var selection = this.getComponentSelection();
    if (!selection.rangeCount || !selection.isCollapsed)
        return false;
    var selectionRange = selection.getRangeAt(0);
    return selectionRange.startContainer.isSelfOrDescendant(this);
}

/**
 * @param {string} tagName
 * @param {string=} customElementType
 * @return {!Element}
 * @suppressGlobalPropertiesCheck
 */
function createElement(tagName, customElementType)
{
    return document.createElement(tagName, customElementType || "");
}

/**
 * @param {string} type
 * @param {boolean} bubbles
 * @param {boolean} cancelable
 * @return {!Event}
 * @suppressGlobalPropertiesCheck
 */
function createEvent(type, bubbles, cancelable)
{
    var event = document.createEvent("Event");
    event.initEvent(type, bubbles, cancelable);
    return event;
}

/**
 * @param {number|string} data
 * @return {!Text}
 * @suppressGlobalPropertiesCheck
 */
function createTextNode(data)
{
    return document.createTextNode(data);
}

/**
 * @param {string} elementName
 * @param {string=} className
 * @param {string=} customElementType
 * @return {!Element}
 */
Document.prototype.createElementWithClass = function(elementName, className, customElementType)
{
    var element = this.createElement(elementName, customElementType || "");
    if (className)
        element.className = className;
    return element;
}

/**
 * @param {string} elementName
 * @param {string=} className
 * @param {string=} customElementType
 * @return {!Element}
 * @suppressGlobalPropertiesCheck
 */
function createElementWithClass(elementName, className, customElementType)
{
    return document.createElementWithClass(elementName, className, customElementType);
}

/**
 * @param {string} childType
 * @param {string=} className
 * @return {!Element}
 */
Document.prototype.createSVGElement = function(childType, className)
{
    var element = this.createElementNS("http://www.w3.org/2000/svg", childType);
    if (className)
        element.setAttribute("class", className);
    return element;
}

/**
 * @param {string} childType
 * @param {string=} className
 * @return {!Element}
 * @suppressGlobalPropertiesCheck
 */
function createSVGElement(childType, className)
{
    return document.createSVGElement(childType, className);
}

/**
 * @return {!DocumentFragment}
 * @suppressGlobalPropertiesCheck
 */
function createDocumentFragment()
{
    return document.createDocumentFragment();
}

/**
 * @param {string} elementName
 * @param {string=} className
 * @param {string=} customElementType
 * @return {!Element}
 */
Element.prototype.createChild = function(elementName, className, customElementType)
{
    var element = this.ownerDocument.createElementWithClass(elementName, className, customElementType);
    this.appendChild(element);
    return element;
}

DocumentFragment.prototype.createChild = Element.prototype.createChild;

/**
 * @param {string} text
 * @return {!Text}
 */
Element.prototype.createTextChild = function(text)
{
    var element = this.ownerDocument.createTextNode(text);
    this.appendChild(element);
    return element;
}

DocumentFragment.prototype.createTextChild = Element.prototype.createTextChild;

/**
 * @param {...string} var_args
 */
Element.prototype.createTextChildren = function(var_args)
{
    for (var i = 0, n = arguments.length; i < n; ++i)
        this.createTextChild(arguments[i]);
}

DocumentFragment.prototype.createTextChildren = Element.prototype.createTextChildren;

/**
 * @return {number}
 */
Element.prototype.totalOffsetLeft = function()
{
    return this.totalOffset().left;
}

/**
 * @return {number}
 */
Element.prototype.totalOffsetTop = function()
{
    return this.totalOffset().top;
}

/**
 * @return {!{left: number, top: number}}
 */
Element.prototype.totalOffset = function()
{
    var rect = this.getBoundingClientRect();
    return { left: rect.left, top: rect.top };
}

/**
 * @return {!{left: number, top: number}}
 */
Element.prototype.scrollOffset = function()
{
    var curLeft = 0;
    var curTop = 0;
    for (var element = this; element; element = element.scrollParent) {
        curLeft += element.scrollLeft;
        curTop += element.scrollTop;
    }
    return { left: curLeft, top: curTop };
}

/**
 * @param {string} childType
 * @param {string=} className
 * @return {!Element}
 */
Element.prototype.createSVGChild = function(childType, className)
{
    var child = this.ownerDocument.createSVGElement(childType, className);
    this.appendChild(child);
    return child;
}

/**
 * @constructor
 * @param {number=} x
 * @param {number=} y
 * @param {number=} width
 * @param {number=} height
 */
function AnchorBox(x, y, width, height)
{
    this.x = x || 0;
    this.y = y || 0;
    this.width = width || 0;
    this.height = height || 0;
}

/**
 * @param {!AnchorBox} box
 * @return {!AnchorBox}
 */
AnchorBox.prototype.relativeTo = function(box)
{
    return new AnchorBox(
        this.x - box.x, this.y - box.y, this.width, this.height);
}

/**
 * @param {!Element} element
 * @return {!AnchorBox}
 */
AnchorBox.prototype.relativeToElement = function(element)
{
    return this.relativeTo(element.boxInWindow(element.ownerDocument.defaultView));
}

/**
 * @param {?AnchorBox} anchorBox
 * @return {boolean}
 */
AnchorBox.prototype.equals = function(anchorBox)
{
    return !!anchorBox && this.x === anchorBox.x && this.y === anchorBox.y && this.width === anchorBox.width && this.height === anchorBox.height;
}

/**
 * @param {!Window} targetWindow
 * @return {!AnchorBox}
 */
Element.prototype.offsetRelativeToWindow = function(targetWindow)
{
    var elementOffset = new AnchorBox();
    var curElement = this;
    var curWindow = this.ownerDocument.defaultView;
    while (curWindow && curElement) {
        elementOffset.x += curElement.totalOffsetLeft();
        elementOffset.y += curElement.totalOffsetTop();
        if (curWindow === targetWindow)
            break;

        curElement = curWindow.frameElement;
        curWindow = curWindow.parent;
    }

    return elementOffset;
}

/**
 * @param {!Window=} targetWindow
 * @return {!AnchorBox}
 */
Element.prototype.boxInWindow = function(targetWindow)
{
    targetWindow = targetWindow || this.ownerDocument.defaultView;

    var anchorBox = this.offsetRelativeToWindow(window);
    anchorBox.width = Math.min(this.offsetWidth, window.innerWidth - anchorBox.x);
    anchorBox.height = Math.min(this.offsetHeight, window.innerHeight - anchorBox.y);

    return anchorBox;
}

/**
 * @param {string} text
 */
Element.prototype.setTextAndTitle = function(text)
{
    this.textContent = text;
    this.title = text;
}

KeyboardEvent.prototype.__defineGetter__("data", function()
{
    // Emulate "data" attribute from DOM 3 TextInput event.
    // See http://www.w3.org/TR/DOM-Level-3-Events/#events-Events-TextEvent-data
    switch (this.type) {
        case "keypress":
            if (!this.ctrlKey && !this.metaKey)
                return String.fromCharCode(this.charCode);
            else
                return "";
        case "keydown":
        case "keyup":
            if (!this.ctrlKey && !this.metaKey && !this.altKey)
                return String.fromCharCode(this.which);
            else
                return "";
    }
});

/**
 * @param {boolean=} preventDefault
 */
Event.prototype.consume = function(preventDefault)
{
    this.stopImmediatePropagation();
    if (preventDefault)
        this.preventDefault();
    this.handled = true;
}

/**
 * @param {number=} start
 * @param {number=} end
 * @return {!Text}
 */
Text.prototype.select = function(start, end)
{
    start = start || 0;
    end = end || this.textContent.length;

    if (start < 0)
        start = end + start;

    var selection = this.getComponentSelection();
    selection.removeAllRanges();
    var range = this.ownerDocument.createRange();
    range.setStart(this, start);
    range.setEnd(this, end);
    selection.addRange(range);
    return this;
}

/**
 * @return {?number}
 */
Element.prototype.selectionLeftOffset = function()
{
    // Calculate selection offset relative to the current element.

    var selection = this.getComponentSelection();
    if (!selection.containsNode(this, true))
        return null;

    var leftOffset = selection.anchorOffset;
    var node = selection.anchorNode;

    while (node !== this) {
        while (node.previousSibling) {
            node = node.previousSibling;
            leftOffset += node.textContent.length;
        }
        node = node.parentNodeOrShadowHost();
    }

    return leftOffset;
}

/**
 * @this {!HTMLImageElement} element
 * @return {!Promise<!HTMLImageElement>}
 */
HTMLImageElement.prototype.completePromise = function()
{
    var element = this;
    if (element.complete)
        return Promise.resolve(element);
    return new Promise(promiseBody);

    /**
     * @param {function(!HTMLImageElement)} resolve
     */
    function promiseBody(resolve)
    {
        element.addEventListener("load", oncomplete);
        element.addEventListener("error", oncomplete);

        function oncomplete()
        {
            resolve(element);
        }
    }
}

/**
 * @param {...!Node} var_args
 */
Node.prototype.appendChildren = function(var_args)
{
    for (var i = 0, n = arguments.length; i < n; ++i)
        this.appendChild(arguments[i]);
}

/**
 * @return {string}
 */
Node.prototype.deepTextContent = function()
{
    return this.childTextNodes().map(function (node) { return node.textContent; }).join("");
}

/**
 * @return {!Array.<!Node>}
 */
Node.prototype.childTextNodes = function()
{
    var node = this.traverseNextTextNode(this);
    var result = [];
    var nonTextTags = { "STYLE": 1, "SCRIPT": 1 };
    while (node) {
        if (!nonTextTags[node.parentElement.nodeName])
            result.push(node);
        node = node.traverseNextTextNode(this);
    }
    return result;
}

/**
 * @param {?Node} node
 * @return {boolean}
 */
Node.prototype.isAncestor = function(node)
{
    if (!node)
        return false;

    var currentNode = node.parentNodeOrShadowHost();
    while (currentNode) {
        if (this === currentNode)
            return true;
        currentNode = currentNode.parentNodeOrShadowHost();
    }
    return false;
}

/**
 * @param {?Node} descendant
 * @return {boolean}
 */
Node.prototype.isDescendant = function(descendant)
{
    return !!descendant && descendant.isAncestor(this);
}

/**
 * @param {?Node} node
 * @return {boolean}
 */
Node.prototype.isSelfOrAncestor = function(node)
{
    return !!node && (node === this || this.isAncestor(node));
}

/**
 * @param {?Node} node
 * @return {boolean}
 */
Node.prototype.isSelfOrDescendant = function(node)
{
    return !!node && (node === this || this.isDescendant(node));
}

/**
 * @param {!Node=} stayWithin
 * @return {?Node}
 */
Node.prototype.traverseNextNode = function(stayWithin)
{
    if (this.shadowRoot)
        return this.shadowRoot;

    var distributedNodes = this.getDistributedNodes ? this.getDistributedNodes() : [];

    if (distributedNodes.length)
        return distributedNodes[0];

    if (this.firstChild)
        return this.firstChild;

    var node = this;
    while (node) {
        if (stayWithin && node === stayWithin)
            return null;

        var sibling = nextSibling(node);
        if (sibling)
            return sibling;

        node = insertionPoint(node) || node.parentNodeOrShadowHost();
    }

    /**
     * @param {!Node} node
     * @return {?Node}
     */
    function nextSibling(node)
    {
        var parent = insertionPoint(node);
        if (!parent)
            return node.nextSibling;
        var distributedNodes = parent.getDistributedNodes ? parent.getDistributedNodes() : [];

        var position = Array.prototype.indexOf.call(distributedNodes, node);
        if (position + 1 < distributedNodes.length)
            return distributedNodes[position + 1];
        return null;
    }

    /**
     * @param {!Node} node
     * @return {?Node}
     */
    function insertionPoint(node)
    {
        var insertionPoints =  node.getDestinationInsertionPoints  ? node.getDestinationInsertionPoints() : [];
        return insertionPoints.length > 0 ? insertionPoints[insertionPoints.length - 1] : null;
    }

    return null;
}

/**
 * @param {!Node=} stayWithin
 * @return {?Node}
 */
Node.prototype.traversePreviousNode = function(stayWithin)
{
    if (stayWithin && this === stayWithin)
        return null;
    var node = this.previousSibling;
    while (node && node.lastChild)
        node = node.lastChild;
    if (node)
        return node;
    return this.parentNodeOrShadowHost();
}

/**
 * @param {*} text
 * @param {string=} placeholder
 * @return {boolean} true if was truncated
 */
Node.prototype.setTextContentTruncatedIfNeeded = function(text, placeholder)
{
    // Huge texts in the UI reduce rendering performance drastically.
    // Moreover, Blink/WebKit uses <unsigned short> internally for storing text content
    // length, so texts longer than 65535 are inherently displayed incorrectly.
    const maxTextContentLength = 10000;

    if (typeof text === "string" && text.length > maxTextContentLength) {
        this.textContent = typeof placeholder === "string" ? placeholder : text.trimMiddle(maxTextContentLength);
        return true;
    }

    this.textContent = text;
    return false;
}

/**
 * @return {?Node}
 */
Event.prototype.deepElementFromPoint = function()
{
    // 1. climb to the component root.
    var node = this.target;
    while (node && node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE && node.nodeType !== Node.DOCUMENT_NODE)
        node = node.parentNode;

    if (!node)
        return null;

    // 2. Find deepest node by coordinates.
    node = node.elementFromPoint(this.pageX, this.pageY);
    while (node && node.shadowRoot)
        node = node.shadowRoot.elementFromPoint(this.pageX, this.pageY);
    return node;
}

/**
 * @return {?Element}
 */
Event.prototype.deepActiveElement = function()
{
    var activeElement = this.target && this.target.ownerDocument ? this.target.ownerDocument.activeElement : null;
    while (activeElement && activeElement.shadowRoot)
        activeElement = activeElement.shadowRoot.activeElement;
    return activeElement;
}

/**
 * @param {number} x
 * @param {number} y
 * @return {?Node}
 */
Document.prototype.deepElementFromPoint = function(x, y)
{
    var node = this.elementFromPoint(x, y);
    while (node && node.shadowRoot)
        node = node.shadowRoot.elementFromPoint(x, y);
    return node;
}

/**
 * @param {!Event} event
 * @return {boolean}
 */
function isEnterKey(event)
{
    // Check if in IME.
    return event.keyCode !== 229 && event.key === "Enter";
}

/**
 * @param {!Event} event
 * @return {boolean}
 */
function isEscKey(event)
{
    return event.keyCode === 27;
}

function consumeEvent(e)
{
    e.consume();
}

/**
 * @param {function()} callback
 * @suppressGlobalPropertiesCheck
 */
function runOnWindowLoad(callback)
{
    /**
     * @suppressGlobalPropertiesCheck
     */
    function windowLoaded()
    {
        window.removeEventListener("DOMContentLoaded", windowLoaded, false);
        callback();
    }

    if (document.readyState === "complete" || document.readyState === "interactive")
        callback();
    else
        window.addEventListener("DOMContentLoaded", windowLoaded, false);
}
;
/* Module common */
/* WorkerRuntime.js */
/*
 * Copyright (C) 2014 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var WorkerRuntime = {};

/**
 * @param {string} moduleName
 * @param {string} workerName
 * @return {!Promise.<!SharedWorker>}
 */
WorkerRuntime.startSharedWorker = function(moduleName, workerName)
{
    if (Runtime.isReleaseMode()) {
        try {
            var worker = new SharedWorker(moduleName + "_module.js", workerName);
            return Promise.resolve(worker);
        } catch (e) {
            return Promise.reject(e);
        }
    }

    return loadResourcePromise(moduleName + "/module.json").then(start, start.bind(null, undefined));

    /**
     * @param {string=} content
     * @return {!SharedWorker}
     */
    function start(content)
    {
        if (!content)
            throw new Error("Worker is not defined: " + moduleName + " " + new Error().stack);
        var scripts = JSON.parse(content)["scripts"];
        if (scripts.length !== 1)
            throw new Error("WorkerRuntime.startSharedWorker supports modules with only one script!");
        return new SharedWorker(moduleName + "/" + scripts[0], workerName);
    }
}

/**
 * @param {string} moduleName
 * @return {!Promise.<!Worker>}
 */
WorkerRuntime.startWorker = function(moduleName)
{
    if (Runtime.isReleaseMode())
        return Promise.resolve(new Worker(moduleName + "_module.js"));

    /**
     * @suppress {checkTypes}
     */
    var loader = function() {
        self.onmessage = function(event) {
            self.onmessage = null;
            var scripts = event.data;
            for (var i = 0; i < scripts.length; ++i) {
                var source = scripts[i]["source"];
                self.eval(source + "\n//# sourceURL=" + scripts[i]["url"]);
            }
        };
    };

    return loadResourcePromise(moduleName + "/module.json").then(start, start.bind(null, undefined));

    /**
     * @param {string=} content
     */
    function start(content)
    {
        if (!content)
            throw new Error("Worker is not defined: " + moduleName + " " + new Error().stack);
        var message = [];
        var scripts = JSON.parse(content)["scripts"];
        var promise = Promise.resolve();
        for (var i = 0; i < scripts.length; ++i) {
            var url = self._importScriptPathPrefix + moduleName + "/" + scripts[i];
            var parts = url.split("://");
            url = parts.length === 1 ? url : parts[0] + "://" + normalizePath(parts[1]);
            promise = promise.then(promiseGetter(loadResourcePromise(moduleName + "/" + scripts[i]))).then(pushSource.bind(null, url), pushSource.bind(null, null, null));
        }

        return promise.then(createWorker);

        function promiseGetter(promise)
        {
            return function() {
                return promise;
            };
        }

        /**
         * @param {?string} url
         * @param {?string} source
         */
        function pushSource(url, source)
        {
            if (!url) {
                console.error("Failed to load " + url);
                return;
            }
            message.push({ source: source, url: url });
        }

        /**
         * @return {!Worker}
         */
        function createWorker()
        {
            var blob = new Blob(["(" + loader.toString() + ")()\n//# sourceURL=" + moduleName], { type: "text/javascript" });
            var workerURL = window.URL.createObjectURL(blob);
            try {
                var worker = new Worker(workerURL);
                worker.postMessage(message);
                return worker;
            } finally {
                window.URL.revokeObjectURL(workerURL);
            }
        }
    }
}

/**
 * @constructor
 * @param {string} moduleName
 * @param {string=} workerName
 */
WorkerRuntime.Worker = function(moduleName, workerName)
{
    this._workerPromise = workerName ? WorkerRuntime.startSharedWorker(moduleName, /** @type {string} */ (workerName)) : WorkerRuntime.startWorker(moduleName);
}

WorkerRuntime.Worker.prototype = {
    /**
     * @param {*} message
     */
    postMessage: function(message)
    {
        this._workerPromise.then(postToWorker.bind(this));

        /**
         * @param {!Worker|!SharedWorker} worker
         * @this {WorkerRuntime.Worker}
         */
        function postToWorker(worker)
        {
            if (!this._disposed)
                worker.postMessage(message);
        }
    },

    dispose: function()
    {
        this._disposed = true;
        this._workerPromise.then(terminate);

        /**
         * @param {!Worker|!SharedWorker} worker
         */
        function terminate(worker)
        {
            worker.terminate();
        }
    },

    terminate: function()
    {
        this.dispose();
    },

    /**
     * @param {?function(!MessageEvent.<*>)} listener
     */
    set onmessage(listener)
    {
        this._workerPromise.then(setOnMessage);

        /**
         * @param {!Worker|!SharedWorker} worker
         */
        function setOnMessage(worker)
        {
            worker.onmessage = listener;
        }
    },

    /**
     * @param {?function(!Event)} listener
     */
    set onerror(listener)
    {
        this._workerPromise.then(setOnError);

        /**
         * @param {!Worker|!SharedWorker} worker
         */
        function setOnError(worker)
        {
            worker.onerror = listener;
        }
    },

    get port()
    {
        return new WorkerRuntime.Worker.FuturePort(this);
    }
}

/**
 * @constructor
 * @param {!WorkerRuntime.Worker} worker
 */
WorkerRuntime.Worker.FuturePort = function(worker)
{
    this._worker = worker;
}

WorkerRuntime.Worker.FuturePort.prototype = {
    /**
     * @param {?function(!MessageEvent.<?>)} listener
     */
    set onmessage(listener)
    {
        this._worker._workerPromise.then(setOnMessage);

        /**
         * @param {!SharedWorker} worker
         */
        function setOnMessage(worker)
        {
            worker.port.onmessage = listener;
        }
    },

    /**
     * @param {?function(!Event)} listener
     */
    set onerror(listener)
    {
        this._worker._workerPromise.then(setOnError);

        /**
         * @param {!SharedWorker} worker
         */
        function setOnError(worker)
        {
            worker.port.onerror = listener;
        }
    }
}
;/* WebInspector.js */
/*
 * Copyright 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

self.WebInspector = {}
;/* TextDictionary.js */
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 */
WebInspector.TextDictionary = function()
{
    this._words = {};
}

WebInspector.TextDictionary.prototype = {
    /**
     * @param {string} word
     */
    addWord: function(word)
    {
        if (!this._words[word])
            this._words[word] = 1;
        else
            ++this._words[word];
    },

    /**
     * @param {string} word
     */
    removeWord: function(word)
    {
        if (!this._words[word])
            return;
        if (this._words[word] === 1)
            delete this._words[word];
        else
            --this._words[word];
    },

    /**
     * @param {string} prefix
     * @return {!Array.<string>}
     */
    wordsWithPrefix: function(prefix)
    {
        var words = [];
        for(var i in this._words) {
            if (i.startsWith(prefix))
                words.push(i);
        }
        return words;
    },

    /**
     * @param {string} word
     * @return {boolean}
     */
    hasWord: function(word)
    {
        return !!this._words[word];
    },

    /**
     * @param {string} word
     * @return {number}
     */
    wordCount: function(word)
    {
        return this._words[word] ? this._words[word] : 0;
    },

    reset: function()
    {
        this._words = {};
    }
}
;/* Object.js */
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @implements {WebInspector.EventTarget}
 */
WebInspector.Object = function() {
}

WebInspector.Object.prototype = {
    /**
     * @override
     * @param {string} eventType
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     * @return {!WebInspector.EventTarget.EventDescriptor}
     */
    addEventListener: function(eventType, listener, thisObject)
    {
        if (!listener)
            console.assert(false);

        if (!this._listeners)
            this._listeners = new Map();
        if (!this._listeners.has(eventType))
            this._listeners.set(eventType, []);
        this._listeners.get(eventType).push({ thisObject: thisObject, listener: listener });
        return new WebInspector.EventTarget.EventDescriptor(this, eventType, thisObject, listener);
    },

    /**
     * @override
     * @param {string} eventType
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    removeEventListener: function(eventType, listener, thisObject)
    {
        console.assert(listener);

        if (!this._listeners || !this._listeners.has(eventType))
            return;
        var listeners = this._listeners.get(eventType);
        for (var i = 0; i < listeners.length; ++i) {
            if (listeners[i].listener === listener && listeners[i].thisObject === thisObject)
                listeners.splice(i--, 1);
        }

        if (!listeners.length)
            this._listeners.delete(eventType);
    },

    /**
     * @override
     */
    removeAllListeners: function()
    {
        delete this._listeners;
    },

    /**
     * @override
     * @param {string} eventType
     * @return {boolean}
     */
    hasEventListeners: function(eventType)
    {
        if (!this._listeners || !this._listeners.has(eventType))
            return false;
        return true;
    },

    /**
     * @override
     * @param {string} eventType
     * @param {*=} eventData
     * @return {boolean}
     */
    dispatchEventToListeners: function(eventType, eventData)
    {
        if (!this._listeners || !this._listeners.has(eventType))
            return false;

        var event = new WebInspector.Event(this, eventType, eventData);
        var listeners = this._listeners.get(eventType).slice(0);
        for (var i = 0; i < listeners.length; ++i) {
            listeners[i].listener.call(listeners[i].thisObject, event);
            if (event._stoppedPropagation)
                break;
        }

        return event.defaultPrevented;
    }
}

/**
 * @constructor
 * @param {!WebInspector.EventTarget} target
 * @param {string} type
 * @param {*=} data
 */
WebInspector.Event = function(target, type, data)
{
    this.target = target;
    this.type = type;
    this.data = data;
    this.defaultPrevented = false;
    this._stoppedPropagation = false;
}

WebInspector.Event.prototype = {
    stopPropagation: function()
    {
        this._stoppedPropagation = true;
    },

    preventDefault: function()
    {
        this.defaultPrevented = true;
    },

    /**
     * @param {boolean=} preventDefault
     */
    consume: function(preventDefault)
    {
        this.stopPropagation();
        if (preventDefault)
            this.preventDefault();
    }
}

/**
 * @interface
 */
WebInspector.EventTarget = function()
{
}

/**
 * @param {!Array<!WebInspector.EventTarget.EventDescriptor>} eventList
 */
WebInspector.EventTarget.removeEventListeners = function(eventList)
{
    for (var i = 0; i < eventList.length; ++i) {
        var eventInfo = eventList[i];
        eventInfo.eventTarget.removeEventListener(eventInfo.eventType, eventInfo.method, eventInfo.receiver);
    }
}

WebInspector.EventTarget.prototype = {
    /**
     * @param {string} eventType
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     * @return {!WebInspector.EventTarget.EventDescriptor}
     */
    addEventListener: function(eventType, listener, thisObject) { },

    /**
     * @param {string} eventType
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    removeEventListener: function(eventType, listener, thisObject) { },

    removeAllListeners: function() { },

    /**
     * @param {string} eventType
     * @return {boolean}
     */
    hasEventListeners: function(eventType) { },

    /**
     * @param {string} eventType
     * @param {*=} eventData
     * @return {boolean}
     */
    dispatchEventToListeners: function(eventType, eventData) { },
}

/**
 * @constructor
 * @param {!WebInspector.EventTarget} eventTarget
 * @param {string} eventType
 * @param {(!Object|undefined)} receiver
 * @param {function(?):?} method
 */
WebInspector.EventTarget.EventDescriptor = function(eventTarget, eventType, receiver, method)
{
    this.eventTarget = eventTarget;
    this.eventType = eventType;
    this.receiver = receiver;
    this.method = method;
}
;/* NotificationService.js */
/*
 * Copyright 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/**
 * @constructor
 * @extends {WebInspector.Object}
 */
WebInspector.NotificationService = function() { }

WebInspector.NotificationService.prototype = {
    __proto__: WebInspector.Object.prototype
}

WebInspector.NotificationService.Events = {
    InspectorAgentEnabledForTests: "InspectorAgentEnabledForTests",
    SelectedNodeChanged: "SelectedNodeChanged"
}

WebInspector.notifications = new WebInspector.NotificationService();
;/* Color.js */
/*
 * Copyright (C) 2009 Apple Inc.  All rights reserved.
 * Copyright (C) 2009 Joseph Pecoraro
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @param {!Array.<number>} rgba
 * @param {!WebInspector.Color.Format} format
 * @param {string=} originalText
 * @constructor
 */
WebInspector.Color = function(rgba, format, originalText)
{
    this._rgba = rgba;
    this._originalText = originalText || null;
    this._originalTextIsValid = !!this._originalText;
    this._format = format;
    if (typeof this._rgba[3] === "undefined")
        this._rgba[3] = 1;

    for (var i = 0; i < 4; ++i) {
        if (this._rgba[i] < 0) {
            this._rgba[i] = 0;
            this._originalTextIsValid = false;
        }
        if (this._rgba[i] > 1) {
            this._rgba[i] = 1;
            this._originalTextIsValid = false;
        }
    }
}

/**
 * @enum {string}
 */
WebInspector.Color.Format = {
    Original: "original",
    Nickname: "nickname",
    HEX: "hex",
    ShortHEX: "shorthex",
    RGB: "rgb",
    RGBA: "rgba",
    HSL: "hsl",
    HSLA: "hsla"
}

/**
 * @param {string} text
 * @return {?WebInspector.Color}
 */
WebInspector.Color.parse = function(text)
{
    // Simple - #hex, rgb(), nickname, hsl()
    var value = text.toLowerCase().replace(/\s+/g, "");
    var simple = /^(?:#([0-9a-f]{3}|[0-9a-f]{6})|rgb\(((?:-?\d+%?,){2}-?\d+%?)\)|(\w+)|hsl\((-?\d+\.?\d*(?:,-?\d+\.?\d*%){2})\))$/i;
    var match = value.match(simple);
    if (match) {
        if (match[1]) { // hex
            var hex = match[1].toUpperCase();
            var format;
            if (hex.length === 3) {
                format = WebInspector.Color.Format.ShortHEX;
                hex = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);
            } else
                format = WebInspector.Color.Format.HEX;
            var r = parseInt(hex.substring(0,2), 16);
            var g = parseInt(hex.substring(2,4), 16);
            var b = parseInt(hex.substring(4,6), 16);
            return new WebInspector.Color([r / 255, g / 255, b / 255, 1], format, text);
        }

        if (match[2]) { // rgb
            var rgbString = match[2].split(/\s*,\s*/);
            var rgba = [ WebInspector.Color._parseRgbNumeric(rgbString[0]),
                         WebInspector.Color._parseRgbNumeric(rgbString[1]),
                         WebInspector.Color._parseRgbNumeric(rgbString[2]), 1 ];
            return new WebInspector.Color(rgba, WebInspector.Color.Format.RGB, text);
        }

        if (match[3]) { // nickname
            var nickname = match[3].toLowerCase();
            if (nickname in WebInspector.Color.Nicknames) {
                var rgba = WebInspector.Color.Nicknames[nickname];
                var color = WebInspector.Color.fromRGBA(rgba);
                color._format = WebInspector.Color.Format.Nickname;
                color._originalText = text;
                return color;
            }
            return null;
        }

        if (match[4]) { // hsl
            var hslString = match[4].replace(/%/g, "").split(/\s*,\s*/);
            var hsla = [ WebInspector.Color._parseHueNumeric(hslString[0]),
                         WebInspector.Color._parseSatLightNumeric(hslString[1]),
                         WebInspector.Color._parseSatLightNumeric(hslString[2]), 1 ];
            var rgba = [];
            WebInspector.Color.hsl2rgb(hsla, rgba);
            return new WebInspector.Color(rgba, WebInspector.Color.Format.HSL, text);
        }

        return null;
    }

    // Advanced - rgba(), hsla()
    var advanced = /^(?:rgba\(((?:-?\d+%?,){3}-?(?:\d+|\d*\.\d+))\)|hsla\((-?(?:\d+|\d*\.\d+)(?:,-?(?:\d+|\d*\.\d+)*%){2},-?(?:\d+|\d*\.\d+))\))$/;
    match = value.match(advanced);
    if (match) {
        if (match[1]) { // rgba
            var rgbaString = match[1].split(/\s*,\s*/);
            var rgba = [ WebInspector.Color._parseRgbNumeric(rgbaString[0]),
                         WebInspector.Color._parseRgbNumeric(rgbaString[1]),
                         WebInspector.Color._parseRgbNumeric(rgbaString[2]),
                         WebInspector.Color._parseAlphaNumeric(rgbaString[3]) ];
            return new WebInspector.Color(rgba, WebInspector.Color.Format.RGBA, text);
        }

        if (match[2]) { // hsla
            var hslaString = match[2].replace(/%/g, "").split(/\s*,\s*/);
            var hsla = [ WebInspector.Color._parseHueNumeric(hslaString[0]),
                         WebInspector.Color._parseSatLightNumeric(hslaString[1]),
                         WebInspector.Color._parseSatLightNumeric(hslaString[2]),
                         WebInspector.Color._parseAlphaNumeric(hslaString[3]) ];
            var rgba = [];
            WebInspector.Color.hsl2rgb(hsla, rgba);
            return new WebInspector.Color(rgba, WebInspector.Color.Format.HSLA, text);
        }
    }

    return null;
}

/**
 * @param {!Array.<number>} rgba
 * @return {!WebInspector.Color}
 */
WebInspector.Color.fromRGBA = function(rgba)
{
    return new WebInspector.Color([rgba[0] / 255, rgba[1] / 255, rgba[2] / 255, rgba[3]], WebInspector.Color.Format.RGBA);
}

/**
 * @param {!Array.<number>} hsva
 * @return {!WebInspector.Color}
 */
WebInspector.Color.fromHSVA = function(hsva)
{
    var rgba = [];
    WebInspector.Color.hsva2rgba(hsva, rgba);
    return new WebInspector.Color(rgba, WebInspector.Color.Format.HSLA);
}

WebInspector.Color.prototype = {
    /**
     * @return {!WebInspector.Color.Format}
     */
    format: function()
    {
        return this._format;
    },

    /**
     * @return {!Array.<number>} HSLA with components within [0..1]
     */
    hsla: function()
    {
        if (this._hsla)
            return this._hsla;
        var r = this._rgba[0];
        var g = this._rgba[1];
        var b = this._rgba[2];
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var diff = max - min;
        var add = max + min;

        if (min === max)
            var h = 0;
        else if (r === max)
            var h = ((1/6 * (g - b) / diff) + 1) % 1;
        else if (g === max)
            var h = (1/6 * (b - r) / diff) + 1/3;
        else
            var h = (1/6 * (r - g) / diff) + 2/3;

        var l = 0.5 * add;

        if (l === 0)
            var s = 0;
        else if (l === 1)
            var s = 0;
        else if (l <= 0.5)
            var s = diff / add;
        else
            var s = diff / (2 - add);

        this._hsla = [h, s, l, this._rgba[3]];
        return this._hsla;
    },

    /**
     * @return {!Array.<number>}
     */
    canonicalHSLA: function()
    {
        var hsla = this.hsla();
        return [Math.round(hsla[0] * 360), Math.round(hsla[1] * 100), Math.round(hsla[2] * 100), hsla[3]];
    },

    /**
     * @return {!Array.<number>} HSVA with components within [0..1]
     */
    hsva: function()
    {
        var hsla = this.hsla();
        var h = hsla[0];
        var s = hsla[1];
        var l = hsla[2];

        s *= l < 0.5 ? l : 1 - l;
        return [h, s !== 0 ? 2 * s / (l + s) : 0, (l + s), hsla[3]];
    },

    /**
     * @return {boolean}
     */
    hasAlpha: function()
    {
        return this._rgba[3] !== 1;
    },

    /**
     * @return {boolean}
     */
    canBeShortHex: function()
    {
        if (this.hasAlpha())
            return false;
        for (var i = 0; i < 3; ++i) {
            var c = Math.round(this._rgba[i] * 255);
            if (c % 17)
                return false;
        }
        return true;
    },

    /**
     * @return {?string}
     */
    asString: function(format)
    {
        if (format === this._format && this._originalTextIsValid)
            return this._originalText;

        if (!format)
            format = this._format;

        /**
         * @param {number} value
         * @return {number}
         */
        function toRgbValue(value)
        {
            return Math.round(value * 255);
        }

        /**
         * @param {number} value
         * @return {string}
         */
        function toHexValue(value)
        {
            var hex = Math.round(value * 255).toString(16);
            return hex.length === 1 ? "0" + hex : hex;
        }

        /**
         * @param {number} value
         * @return {string}
         */
        function toShortHexValue(value)
        {
            return (Math.round(value * 255) / 17).toString(16);
        }

        switch (format) {
        case WebInspector.Color.Format.Original:
            return this._originalText;
        case WebInspector.Color.Format.RGB:
            if (this.hasAlpha())
                return null;
            return String.sprintf("rgb(%d, %d, %d)", toRgbValue(this._rgba[0]), toRgbValue(this._rgba[1]), toRgbValue(this._rgba[2]));
        case WebInspector.Color.Format.RGBA:
            return String.sprintf("rgba(%d, %d, %d, %f)", toRgbValue(this._rgba[0]), toRgbValue(this._rgba[1]), toRgbValue(this._rgba[2]), this._rgba[3]);
        case WebInspector.Color.Format.HSL:
            if (this.hasAlpha())
                return null;
            var hsl = this.hsla();
            return String.sprintf("hsl(%d, %d%, %d%)", Math.round(hsl[0] * 360), Math.round(hsl[1] * 100), Math.round(hsl[2] * 100));
        case WebInspector.Color.Format.HSLA:
            var hsla = this.hsla();
            return String.sprintf("hsla(%d, %d%, %d%, %f)", Math.round(hsla[0] * 360), Math.round(hsla[1] * 100), Math.round(hsla[2] * 100), hsla[3]);
        case WebInspector.Color.Format.HEX:
            if (this.hasAlpha())
                return null;
            return String.sprintf("#%s%s%s", toHexValue(this._rgba[0]), toHexValue(this._rgba[1]), toHexValue(this._rgba[2])).toUpperCase();
        case WebInspector.Color.Format.ShortHEX:
            if (!this.canBeShortHex())
                return null;
            return String.sprintf("#%s%s%s", toShortHexValue(this._rgba[0]), toShortHexValue(this._rgba[1]), toShortHexValue(this._rgba[2])).toUpperCase();
        case WebInspector.Color.Format.Nickname:
            return this.nickname();
        }

        return this._originalText;
    },


    /**
     * @return {!Array<number>}
     */
    rgba: function()
    {
        return this._rgba.slice();
    },

    /**
     * @return {!Array.<number>}
     */
    canonicalRGBA: function()
    {
        var rgba = new Array(4);
        for (var i = 0; i < 3; ++i)
            rgba[i] = Math.round(this._rgba[i] * 255);
        rgba[3] = this._rgba[3];
        return rgba;
    },

    /**
     * @return {?string} nickname
     */
    nickname: function()
    {
        if (!WebInspector.Color._rgbaToNickname) {
            WebInspector.Color._rgbaToNickname = {};
            for (var nickname in WebInspector.Color.Nicknames) {
                var rgba = WebInspector.Color.Nicknames[nickname];
                if (rgba.length !== 4)
                    rgba = rgba.concat(1);
                WebInspector.Color._rgbaToNickname[rgba] = nickname;
            }
        }

        return WebInspector.Color._rgbaToNickname[this.canonicalRGBA()] || null;
    },

    /**
     * @return {!DOMAgent.RGBA}
     */
    toProtocolRGBA: function()
    {
        var rgba = this.canonicalRGBA();
        var result = { r: rgba[0], g: rgba[1], b: rgba[2] };
        if (rgba[3] !== 1)
            result.a = rgba[3];
        return result;
    },

    /**
     * @return {!WebInspector.Color}
     */
    invert: function()
    {
        var rgba = [];
        rgba[0] = 1 - this._rgba[0];
        rgba[1] = 1 - this._rgba[1];
        rgba[2] = 1 - this._rgba[2];
        rgba[3] = this._rgba[3];
        return new WebInspector.Color(rgba, WebInspector.Color.Format.RGBA);
    },

    /**
     * @param {number} alpha
     * @return {!WebInspector.Color}
     */
     setAlpha: function(alpha)
     {
         var rgba = this._rgba.slice();
         rgba[3] = alpha;
         return new WebInspector.Color(rgba, WebInspector.Color.Format.RGBA);
     }
}

/**
 * @param {string} value
 * return {number}
 */
WebInspector.Color._parseRgbNumeric = function(value)
{
    var parsed = parseInt(value, 10);
    if (value.indexOf("%") !== -1)
        parsed /= 100;
    else
        parsed /= 255;
    return parsed;
}

/**
 * @param {string} value
 * return {number}
 */
WebInspector.Color._parseHueNumeric = function(value)
{
    return isNaN(value) ? 0 : (parseFloat(value) / 360) % 1;
}

/**
 * @param {string} value
 * return {number}
 */
WebInspector.Color._parseSatLightNumeric = function(value)
{
    return Math.min(1, parseFloat(value) / 100);
}

/**
 * @param {string} value
 * return {number}
 */
WebInspector.Color._parseAlphaNumeric = function(value)
{
    return isNaN(value) ? 0 : parseFloat(value);
}

/**
 * @param {!Array.<number>} hsva
 * @param {!Array.<number>} out_hsla
 */
WebInspector.Color._hsva2hsla = function(hsva, out_hsla)
{
    var h = hsva[0];
    var s = hsva[1];
    var v = hsva[2];

    var t = (2 - s) * v;
    if (v === 0 || s === 0)
        s = 0;
    else
        s *= v / (t < 1 ? t : 2 - t);

    out_hsla[0] = h;
    out_hsla[1] = s;
    out_hsla[2] = t/2;
    out_hsla[3] = hsva[3];
}

/**
 * @param {!Array.<number>} hsl
 * @param {!Array.<number>} out_rgb
 */
WebInspector.Color.hsl2rgb = function(hsl, out_rgb)
{
    var h = hsl[0];
    var s = hsl[1];
    var l = hsl[2];

    function hue2rgb(p, q, h)
    {
        if (h < 0)
            h += 1;
        else if (h > 1)
            h -= 1;

        if ((h * 6) < 1)
            return p + (q - p) * h * 6;
        else if ((h * 2) < 1)
            return q;
        else if ((h * 3) < 2)
            return p + (q - p) * ((2 / 3) - h) * 6;
        else
            return p;
    }

    if (s < 0)
        s = 0;

    if (l <= 0.5)
        var q = l * (1 + s);
    else
        var q = l + s - (l * s);

    var p = 2 * l - q;

    var tr = h + (1 / 3);
    var tg = h;
    var tb = h - (1 / 3);

    out_rgb[0] = hue2rgb(p, q, tr);
    out_rgb[1] = hue2rgb(p, q, tg);
    out_rgb[2] = hue2rgb(p, q, tb);
    out_rgb[3] = hsl[3];
}

/**
 * @param {!Array<number>} hsva
 * @param {!Array<number>} out_rgba
 */
WebInspector.Color.hsva2rgba = function(hsva, out_rgba)
{
    WebInspector.Color._hsva2hsla(hsva, WebInspector.Color.hsva2rgba._tmpHSLA);
    WebInspector.Color.hsl2rgb(WebInspector.Color.hsva2rgba._tmpHSLA, out_rgba);

    for (var i = 0; i < WebInspector.Color.hsva2rgba._tmpHSLA.length; i++)
        WebInspector.Color.hsva2rgba._tmpHSLA[i] = 0;
};

/** @type {!Array<number>} */
WebInspector.Color.hsva2rgba._tmpHSLA = [0, 0, 0, 0];


/**
 * Calculate the luminance of this color using the WCAG algorithm.
 * See http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
 * @param {!Array<number>} rgba
 * @return {number}
 */
WebInspector.Color.luminance = function(rgba)
{
    var rSRGB = rgba[0];
    var gSRGB = rgba[1];
    var bSRGB = rgba[2];

    var r = rSRGB <= 0.03928 ? rSRGB / 12.92 : Math.pow(((rSRGB + 0.055)/1.055), 2.4);
    var g = gSRGB <= 0.03928 ? gSRGB / 12.92 : Math.pow(((gSRGB + 0.055)/1.055), 2.4);
    var b = bSRGB <= 0.03928 ? bSRGB / 12.92 : Math.pow(((bSRGB + 0.055)/1.055), 2.4);

    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

/**
 * Combine the two given color according to alpha blending.
 * @param {!Array<number>} fgRGBA
 * @param {!Array<number>} bgRGBA
 * @param {!Array<number>} out_blended
 */
WebInspector.Color.blendColors = function(fgRGBA, bgRGBA, out_blended)
{
    var alpha = fgRGBA[3];

    out_blended[0] = ((1 - alpha) * bgRGBA[0]) + (alpha * fgRGBA[0]);
    out_blended[1] = ((1 - alpha) * bgRGBA[1]) + (alpha * fgRGBA[1]);
    out_blended[2] = ((1 - alpha) * bgRGBA[2]) + (alpha * fgRGBA[2]);
    out_blended[3] = alpha + (bgRGBA[3] * (1 - alpha));
}

/**
 * Calculate the contrast ratio between a foreground and a background color.
 * Returns the ratio to 1, for example for two two colors with a contrast ratio of 21:1, this function will return 21.
 * See http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
 * @param {!Array<number>} fgRGBA
 * @param {!Array<number>} bgRGBA
 * @return {number}
 */
WebInspector.Color.calculateContrastRatio = function(fgRGBA, bgRGBA)
{
    WebInspector.Color.blendColors(fgRGBA, bgRGBA, WebInspector.Color.calculateContrastRatio._blendedFg);

    var fgLuminance = WebInspector.Color.luminance(WebInspector.Color.calculateContrastRatio._blendedFg);
    var bgLuminance = WebInspector.Color.luminance(bgRGBA);
    var contrastRatio = (Math.max(fgLuminance, bgLuminance) + 0.05) /
        (Math.min(fgLuminance, bgLuminance) + 0.05);

    for (var i = 0; i < WebInspector.Color.calculateContrastRatio._blendedFg.length; i++)
        WebInspector.Color.calculateContrastRatio._blendedFg[i] = 0;

    return contrastRatio;
}

WebInspector.Color.calculateContrastRatio._blendedFg = [0, 0, 0, 0];

/**
 * Compute a desired luminance given a given luminance and a desired contrast
 * ratio.
 * @param {number} luminance The given luminance.
 * @param {number} contrast The desired contrast ratio.
 * @param {boolean} lighter Whether the desired luminance is lighter or darker
 * than the given luminance. If no luminance can be found which meets this
 * requirement, a luminance which meets the inverse requirement will be
 * returned.
 * @return {number} The desired luminance.
 */
WebInspector.Color.desiredLuminance = function(luminance, contrast, lighter)
{
    function computeLuminance()
    {
        if (lighter)
            return (luminance + 0.05) * contrast - 0.05;
        else
            return (luminance + 0.05) / contrast - 0.05;
    }
    var desiredLuminance = computeLuminance();
    if (desiredLuminance < 0 || desiredLuminance > 1) {
        lighter = !lighter;
        desiredLuminance = computeLuminance();
    }
    return desiredLuminance;
};


WebInspector.Color.Nicknames = {
    "aliceblue":          [240,248,255],
    "antiquewhite":       [250,235,215],
    "aqua":               [0,255,255],
    "aquamarine":         [127,255,212],
    "azure":              [240,255,255],
    "beige":              [245,245,220],
    "bisque":             [255,228,196],
    "black":              [0,0,0],
    "blanchedalmond":     [255,235,205],
    "blue":               [0,0,255],
    "blueviolet":         [138,43,226],
    "brown":              [165,42,42],
    "burlywood":          [222,184,135],
    "cadetblue":          [95,158,160],
    "chartreuse":         [127,255,0],
    "chocolate":          [210,105,30],
    "coral":              [255,127,80],
    "cornflowerblue":     [100,149,237],
    "cornsilk":           [255,248,220],
    "crimson":            [237,20,61],
    "cyan":               [0,255,255],
    "darkblue":           [0,0,139],
    "darkcyan":           [0,139,139],
    "darkgoldenrod":      [184,134,11],
    "darkgray":           [169,169,169],
    "darkgrey":           [169,169,169],
    "darkgreen":          [0,100,0],
    "darkkhaki":          [189,183,107],
    "darkmagenta":        [139,0,139],
    "darkolivegreen":     [85,107,47],
    "darkorange":         [255,140,0],
    "darkorchid":         [153,50,204],
    "darkred":            [139,0,0],
    "darksalmon":         [233,150,122],
    "darkseagreen":       [143,188,143],
    "darkslateblue":      [72,61,139],
    "darkslategray":      [47,79,79],
    "darkslategrey":      [47,79,79],
    "darkturquoise":      [0,206,209],
    "darkviolet":         [148,0,211],
    "deeppink":           [255,20,147],
    "deepskyblue":        [0,191,255],
    "dimgray":            [105,105,105],
    "dimgrey":            [105,105,105],
    "dodgerblue":         [30,144,255],
    "firebrick":          [178,34,34],
    "floralwhite":        [255,250,240],
    "forestgreen":        [34,139,34],
    "fuchsia":            [255,0,255],
    "gainsboro":          [220,220,220],
    "ghostwhite":         [248,248,255],
    "gold":               [255,215,0],
    "goldenrod":          [218,165,32],
    "gray":               [128,128,128],
    "grey":               [128,128,128],
    "green":              [0,128,0],
    "greenyellow":        [173,255,47],
    "honeydew":           [240,255,240],
    "hotpink":            [255,105,180],
    "indianred":          [205,92,92],
    "indigo":             [75,0,130],
    "ivory":              [255,255,240],
    "khaki":              [240,230,140],
    "lavender":           [230,230,250],
    "lavenderblush":      [255,240,245],
    "lawngreen":          [124,252,0],
    "lemonchiffon":       [255,250,205],
    "lightblue":          [173,216,230],
    "lightcoral":         [240,128,128],
    "lightcyan":          [224,255,255],
    "lightgoldenrodyellow":[250,250,210],
    "lightgreen":         [144,238,144],
    "lightgray":          [211,211,211],
    "lightgrey":          [211,211,211],
    "lightpink":          [255,182,193],
    "lightsalmon":        [255,160,122],
    "lightseagreen":      [32,178,170],
    "lightskyblue":       [135,206,250],
    "lightslategray":     [119,136,153],
    "lightslategrey":     [119,136,153],
    "lightsteelblue":     [176,196,222],
    "lightyellow":        [255,255,224],
    "lime":               [0,255,0],
    "limegreen":          [50,205,50],
    "linen":              [250,240,230],
    "magenta":            [255,0,255],
    "maroon":             [128,0,0],
    "mediumaquamarine":   [102,205,170],
    "mediumblue":         [0,0,205],
    "mediumorchid":       [186,85,211],
    "mediumpurple":       [147,112,219],
    "mediumseagreen":     [60,179,113],
    "mediumslateblue":    [123,104,238],
    "mediumspringgreen":  [0,250,154],
    "mediumturquoise":    [72,209,204],
    "mediumvioletred":    [199,21,133],
    "midnightblue":       [25,25,112],
    "mintcream":          [245,255,250],
    "mistyrose":          [255,228,225],
    "moccasin":           [255,228,181],
    "navajowhite":        [255,222,173],
    "navy":               [0,0,128],
    "oldlace":            [253,245,230],
    "olive":              [128,128,0],
    "olivedrab":          [107,142,35],
    "orange":             [255,165,0],
    "orangered":          [255,69,0],
    "orchid":             [218,112,214],
    "palegoldenrod":      [238,232,170],
    "palegreen":          [152,251,152],
    "paleturquoise":      [175,238,238],
    "palevioletred":      [219,112,147],
    "papayawhip":         [255,239,213],
    "peachpuff":          [255,218,185],
    "peru":               [205,133,63],
    "pink":               [255,192,203],
    "plum":               [221,160,221],
    "powderblue":         [176,224,230],
    "purple":             [128,0,128],
    "rebeccapurple":      [102,51,153],
    "red":                [255,0,0],
    "rosybrown":          [188,143,143],
    "royalblue":          [65,105,225],
    "saddlebrown":        [139,69,19],
    "salmon":             [250,128,114],
    "sandybrown":         [244,164,96],
    "seagreen":           [46,139,87],
    "seashell":           [255,245,238],
    "sienna":             [160,82,45],
    "silver":             [192,192,192],
    "skyblue":            [135,206,235],
    "slateblue":          [106,90,205],
    "slategray":          [112,128,144],
    "slategrey":          [112,128,144],
    "snow":               [255,250,250],
    "springgreen":        [0,255,127],
    "steelblue":          [70,130,180],
    "tan":                [210,180,140],
    "teal":               [0,128,128],
    "thistle":            [216,191,216],
    "tomato":             [255,99,71],
    "turquoise":          [64,224,208],
    "violet":             [238,130,238],
    "wheat":              [245,222,179],
    "white":              [255,255,255],
    "whitesmoke":         [245,245,245],
    "yellow":             [255,255,0],
    "yellowgreen":        [154,205,50],
    "transparent":        [0, 0, 0, 0],
};

WebInspector.Color.PageHighlight = {
    Content: WebInspector.Color.fromRGBA([111, 168, 220, .66]),
    ContentLight: WebInspector.Color.fromRGBA([111, 168, 220, .5]),
    ContentOutline: WebInspector.Color.fromRGBA([9, 83, 148]),
    Padding: WebInspector.Color.fromRGBA([147, 196, 125, .55]),
    PaddingLight: WebInspector.Color.fromRGBA([147, 196, 125, .4]),
    Border: WebInspector.Color.fromRGBA([255, 229, 153, .66]),
    BorderLight: WebInspector.Color.fromRGBA([255, 229, 153, .5]),
    Margin: WebInspector.Color.fromRGBA([246, 178, 107, .66]),
    MarginLight: WebInspector.Color.fromRGBA([246, 178, 107, .5]),
    EventTarget: WebInspector.Color.fromRGBA([255, 196, 196, .66]),
    Shape: WebInspector.Color.fromRGBA([96, 82, 177, 0.8]),
    ShapeMargin: WebInspector.Color.fromRGBA([96, 82, 127, .6])
}

/**
 * @param {!WebInspector.Color} color
 * @return {!WebInspector.Color.Format}
 */
WebInspector.Color.detectColorFormat = function(color)
{
    const cf = WebInspector.Color.Format;
    var format;
    var formatSetting = WebInspector.moduleSetting("colorFormat").get();
    if (formatSetting === cf.Original)
        format = cf.Original;
    else if (formatSetting === cf.RGB)
        format = (color.hasAlpha() ? cf.RGBA : cf.RGB);
    else if (formatSetting === cf.HSL)
        format = (color.hasAlpha() ? cf.HSLA : cf.HSL);
    else if (!color.hasAlpha())
        format = (color.canBeShortHex() ? cf.ShortHEX : cf.HEX);
    else
        format = cf.RGBA;

    return format;
};/* Geometry.js */
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

WebInspector.Geometry = {};

/**
 * @type {number}
 */
WebInspector.Geometry._Eps = 1e-5;

/**
 * @constructor
 * @param {number} x
 * @param {number} y
 * @param {number} z
 */
WebInspector.Geometry.Vector = function(x, y, z)
{
    this.x = x;
    this.y = y;
    this.z = z;
}

WebInspector.Geometry.Vector.prototype = {
    /**
     * @return {number}
     */
    length: function()
    {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },

    normalize: function()
    {
        var length = this.length();
        if (length <= WebInspector.Geometry._Eps)
            return;

        this.x /= length;
        this.y /= length;
        this.z /= length;
    }
}

/**
 * @constructor
 * @param {number} x
 * @param {number} y
 */
WebInspector.Geometry.Point = function(x, y) {
    this.x = x;
    this.y = y;
}

WebInspector.Geometry.Point.prototype = {
    /**
     * @param {!WebInspector.Geometry.Point} p
     * @return {number}
     */
    distanceTo: function(p)
    {
        return Math.sqrt(Math.pow(p.x - this.x, 2) + Math.pow(p.y - this.y, 2));
    },

    /**
     * @override
     * @return {string}
     */
    toString: function()
    {
       return Math.round(this.x * 100) / 100 + ", " + Math.round(this.y * 100) / 100;
    }
}

/**
 * @constructor
 * @param {!WebInspector.Geometry.Point} point1
 * @param {!WebInspector.Geometry.Point} point2
 */
WebInspector.Geometry.CubicBezier = function(point1, point2)
{
    this.controlPoints = [point1, point2];
}

WebInspector.Geometry.CubicBezier.KeywordValues = {
    "linear": "cubic-bezier(0, 0, 1, 1)",
    "ease": "cubic-bezier(0.25, 0.1, 0.25, 1)",
    "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
    "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)",
    "ease-out": "cubic-bezier(0, 0, 0.58, 1)"
}

/**
 * @param {string} text
 * @return {?WebInspector.Geometry.CubicBezier}
 */
WebInspector.Geometry.CubicBezier.parse = function(text)
{
    var keywordValues = WebInspector.Geometry.CubicBezier.KeywordValues;
    var value = text.toLowerCase().replace(/\s+/g, "");
    if (Object.keys(keywordValues).indexOf(value) != -1)
        return WebInspector.Geometry.CubicBezier.parse(keywordValues[value]);
    var bezierRegex = /^cubic-bezier\(([^,]+),([^,]+),([^,]+),([^,]+)\)$/;
    var match = value.match(bezierRegex);
    if (match) {
        var control1 = new WebInspector.Geometry.Point(parseFloat(match[1]), parseFloat(match[2]));
        var control2 = new WebInspector.Geometry.Point(parseFloat(match[3]), parseFloat(match[4]));
        return new WebInspector.Geometry.CubicBezier(control1, control2);
    }
    return null;
}


WebInspector.Geometry.CubicBezier.prototype = {
    /**
     * @param {number} t
     * @return {!WebInspector.Geometry.Point}
     */
    evaluateAt: function(t)
    {
        /**
         * @param {number} v1
         * @param {number} v2
         * @param {number} t
         */
        function evaluate(v1, v2, t)
        {
            return 3 * (1 - t) * (1 - t) * t * v1 + 3 * (1 - t) * t * t * v2 + Math.pow(t, 3);
        }

        var x = evaluate(this.controlPoints[0].x, this.controlPoints[1].x, t);
        var y = evaluate(this.controlPoints[0].y, this.controlPoints[1].y, t);
        return new WebInspector.Geometry.Point(x, y);
    },

    /**
     * @return {string}
     */
    asCSSText: function()
    {
        var raw = "cubic-bezier(" + this.controlPoints.join(", ") + ")";
        var keywordValues = WebInspector.Geometry.CubicBezier.KeywordValues;
        for (var keyword in keywordValues) {
            if (raw === keywordValues[keyword])
                return keyword;
        }
        return raw;
    }
}

/**
 * @constructor
 * @param {number} alpha
 * @param {number} beta
 * @param {number} gamma
 */
WebInspector.Geometry.EulerAngles = function(alpha, beta, gamma)
{
    this.alpha = alpha;
    this.beta = beta;
    this.gamma = gamma;
}

/**
 * @param {!CSSMatrix} rotationMatrix
 * @return {!WebInspector.Geometry.EulerAngles}
 */
WebInspector.Geometry.EulerAngles.fromRotationMatrix = function(rotationMatrix)
{
    var beta = Math.atan2(rotationMatrix.m23, rotationMatrix.m33);
    var gamma = Math.atan2(-rotationMatrix.m13, Math.sqrt(rotationMatrix.m11 * rotationMatrix.m11 + rotationMatrix.m12 * rotationMatrix.m12));
    var alpha = Math.atan2(rotationMatrix.m12, rotationMatrix.m11);
    return new WebInspector.Geometry.EulerAngles(WebInspector.Geometry.radToDeg(alpha), WebInspector.Geometry.radToDeg(beta), WebInspector.Geometry.radToDeg(gamma));
}

/**
 * @param {!WebInspector.Geometry.Vector} u
 * @param {!WebInspector.Geometry.Vector} v
 * @return {number}
 */
WebInspector.Geometry.scalarProduct = function(u, v)
{
    return u.x * v.x + u.y * v.y + u.z * v.z;
}

/**
 * @param {!WebInspector.Geometry.Vector} u
 * @param {!WebInspector.Geometry.Vector} v
 * @return {!WebInspector.Geometry.Vector}
 */
WebInspector.Geometry.crossProduct = function(u, v)
{
    var x = u.y * v.z - u.z * v.y;
    var y = u.z * v.x - u.x * v.z;
    var z = u.x * v.y - u.y * v.x;
    return new WebInspector.Geometry.Vector(x, y, z);
}

/**
 * @param {!WebInspector.Geometry.Vector} u
 * @param {!WebInspector.Geometry.Vector} v
 * @return {!WebInspector.Geometry.Vector}
 */
WebInspector.Geometry.subtract = function(u, v)
{
    var x = u.x - v.x;
    var y = u.y - v.y;
    var z = u.z - v.z;
    return new WebInspector.Geometry.Vector(x, y, z);
}

/**
 * @param {!WebInspector.Geometry.Vector} v
 * @param {!CSSMatrix} m
 * @return {!WebInspector.Geometry.Vector}
 */
WebInspector.Geometry.multiplyVectorByMatrixAndNormalize = function(v, m)
{
    var t = v.x * m.m14 + v.y * m.m24 + v.z * m.m34 + m.m44;
    var x = (v.x * m.m11 + v.y * m.m21 + v.z * m.m31 + m.m41) / t;
    var y = (v.x * m.m12 + v.y * m.m22 + v.z * m.m32 + m.m42) / t;
    var z = (v.x * m.m13 + v.y * m.m23 + v.z * m.m33 + m.m43) / t;
    return new WebInspector.Geometry.Vector(x, y, z);
}

/**
 * @param {!WebInspector.Geometry.Vector} u
 * @param {!WebInspector.Geometry.Vector} v
 * @return {number}
 */
WebInspector.Geometry.calculateAngle = function(u, v)
{
    var uLength = u.length();
    var vLength = v.length();
    if (uLength <= WebInspector.Geometry._Eps || vLength <= WebInspector.Geometry._Eps)
        return 0;
    var cos = WebInspector.Geometry.scalarProduct(u, v) / uLength / vLength;
    if (Math.abs(cos) > 1)
        return 0;
    return WebInspector.Geometry.radToDeg(Math.acos(cos));
}

/**
 * @param {number} rad
 * @return {number}
 */
WebInspector.Geometry.radToDeg = function(rad)
{
    return rad * 180 / Math.PI;
}

/**
 * @param {!CSSMatrix} matrix
 * @param {!Array.<number>} points
 * @param {{minX: number, maxX: number, minY: number, maxY: number}=} aggregateBounds
 * @return {!{minX: number, maxX: number, minY: number, maxY: number}}
 */
WebInspector.Geometry.boundsForTransformedPoints = function(matrix, points, aggregateBounds)
{
    if (!aggregateBounds)
        aggregateBounds = {minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity};
    if (points.length % 3)
        console.assert("Invalid size of points array");
    for (var p = 0; p < points.length; p += 3) {
        var vector = new WebInspector.Geometry.Vector(points[p], points[p + 1], points[p + 2]);
        vector = WebInspector.Geometry.multiplyVectorByMatrixAndNormalize(vector, matrix);
        aggregateBounds.minX = Math.min(aggregateBounds.minX, vector.x);
        aggregateBounds.maxX = Math.max(aggregateBounds.maxX, vector.x);
        aggregateBounds.minY = Math.min(aggregateBounds.minY, vector.y);
        aggregateBounds.maxY = Math.max(aggregateBounds.maxY, vector.y);
    }
    return aggregateBounds;
}

/**
 * @constructor
 * @param {number} width
 * @param {number} height
 */
function Size(width, height)
{
    this.width = width;
    this.height = height;
}

/**
 * @param {?Size} size
 * @return {boolean}
 */
Size.prototype.isEqual = function(size)
{
    return !!size && this.width === size.width && this.height === size.height;
};

/**
 * @param {!Size|number} size
 * @return {!Size}
 */
Size.prototype.widthToMax = function(size)
{
    return new Size(Math.max(this.width, (typeof size === "number" ? size : size.width)), this.height);
};

/**
 * @param {!Size|number} size
 * @return {!Size}
 */
Size.prototype.addWidth = function(size)
{
    return new Size(this.width + (typeof size === "number" ? size : size.width), this.height);
};

/**
 * @param {!Size|number} size
 * @return {!Size}
 */
Size.prototype.heightToMax = function(size)
{
    return new Size(this.width, Math.max(this.height, (typeof size === "number" ? size : size.height)));
};

/**
 * @param {!Size|number} size
 * @return {!Size}
 */
Size.prototype.addHeight = function(size)
{
    return new Size(this.width, this.height + (typeof size === "number" ? size : size.height));
};


/**
 * @constructor
 * @param {number} left
 * @param {number} top
 * @param {number} right
 * @param {number} bottom
 */
function Insets(left, top, right, bottom)
{
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
}

Insets.prototype = {
    /**
     * @param {?Insets} insets
     * @return {boolean}
     */
    isEqual: function(insets)
    {
        return !!insets && this.left === insets.left && this.top === insets.top && this.right == insets.right && this.bottom == insets.bottom;
    }
}


/**
 * @constructor
 * @param {number} left
 * @param {number} top
 * @param {number} width
 * @param {number} height
 */
WebInspector.Rect = function(left, top, width, height)
{
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
}

WebInspector.Rect.prototype = {
    /**
     * @param {?WebInspector.Rect} rect
     * @return {boolean}
     */
    isEqual: function(rect)
    {
        return !!rect && this.left === rect.left && this.top === rect.top && this.width == rect.width && this.height == rect.height;
    },

    /**
     * @param {number} scale
     * @return {!WebInspector.Rect}
     */
    scale: function(scale)
    {
        return new WebInspector.Rect(this.left * scale, this.top * scale, this.width * scale, this.height * scale);
    },

    /**
     * @return {!Size}
     */
    size: function()
    {
        return new Size(this.width, this.height);
    }
}


/**
 * @constructor
 * @param {!Size=} minimum
 * @param {?Size=} preferred
 */
function Constraints(minimum, preferred)
{
    /**
     * @type {!Size}
     */
    this.minimum = minimum || new Size(0, 0);

    /**
     * @type {!Size}
     */
    this.preferred = preferred || this.minimum;

    if (this.minimum.width > this.preferred.width || this.minimum.height > this.preferred.height)
        throw new Error("Minimum size is greater than preferred.");
}

/**
 * @param {?Constraints} constraints
 * @return {boolean}
 */
Constraints.prototype.isEqual = function(constraints)
{
    return !!constraints && this.minimum.isEqual(constraints.minimum) && this.preferred.isEqual(constraints.preferred);
}

/**
 * @param {!Constraints|number} value
 * @return {!Constraints}
 */
Constraints.prototype.widthToMax = function(value)
{
    if (typeof value === "number")
        return new Constraints(this.minimum.widthToMax(value), this.preferred.widthToMax(value));
    return new Constraints(this.minimum.widthToMax(value.minimum), this.preferred.widthToMax(value.preferred));
}

/**
 * @param {!Constraints|number} value
 * @return {!Constraints}
 */
Constraints.prototype.addWidth = function(value)
{
    if (typeof value === "number")
        return new Constraints(this.minimum.addWidth(value), this.preferred.addWidth(value));
    return new Constraints(this.minimum.addWidth(value.minimum), this.preferred.addWidth(value.preferred));
}

/**
 * @param {!Constraints|number} value
 * @return {!Constraints}
 */
Constraints.prototype.heightToMax = function(value)
{
    if (typeof value === "number")
        return new Constraints(this.minimum.heightToMax(value), this.preferred.heightToMax(value));
    return new Constraints(this.minimum.heightToMax(value.minimum), this.preferred.heightToMax(value.preferred));
}

/**
 * @param {!Constraints|number} value
 * @return {!Constraints}
 */
Constraints.prototype.addHeight = function(value)
{
    if (typeof value === "number")
        return new Constraints(this.minimum.addHeight(value), this.preferred.addHeight(value));
    return new Constraints(this.minimum.addHeight(value.minimum), this.preferred.addHeight(value.preferred));
}
;/* Console.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.Object}
 */
WebInspector.Console = function()
{
    /** @type {!Array.<!WebInspector.Console.Message>} */
    this._messages = [];
}

/**
 * @enum {string}
 */
WebInspector.Console.Events = {
    MessageAdded: "messageAdded"
}

/**
 * @enum {string}
 */
WebInspector.Console.MessageLevel = {
    Log: "log",
    Warning: "warning",
    Error: "error"
}

/**
 * @constructor
 * @param {string} text
 * @param {!WebInspector.Console.MessageLevel} level
 * @param {number} timestamp
 * @param {boolean} show
 */
WebInspector.Console.Message = function(text, level, timestamp, show)
{
    this.text = text;
    this.level = level;
    this.timestamp = (typeof timestamp === "number") ? timestamp : Date.now();
    this.show = show;
}

/**
 * @interface
 */
WebInspector.Console.UIDelegate = function()
{
}

WebInspector.Console.UIDelegate.prototype = {
    /**
     * @return {!Promise.<undefined>}
     */
    showConsole: function() { }
}

WebInspector.Console.prototype = {
    /**
     * @param {!WebInspector.Console.UIDelegate} uiDelegate
     */
    setUIDelegate: function(uiDelegate)
    {
        this._uiDelegate = uiDelegate;
    },

    /**
     * @param {string} text
     * @param {!WebInspector.Console.MessageLevel} level
     * @param {boolean=} show
     */
    addMessage: function(text, level, show)
    {
        var message = new WebInspector.Console.Message(text, level || WebInspector.Console.MessageLevel.Log, Date.now(), show || false);
        this._messages.push(message);
        this.dispatchEventToListeners(WebInspector.Console.Events.MessageAdded, message);
    },

    /**
     * @param {string} text
     */
    log: function(text)
    {
        this.addMessage(text, WebInspector.Console.MessageLevel.Log);
    },

    /**
     * @param {string} text
     */
    warn: function(text)
    {
        this.addMessage(text, WebInspector.Console.MessageLevel.Warning);
    },

    /**
     * @param {string} text
     */
    error: function(text)
    {
        this.addMessage(text, WebInspector.Console.MessageLevel.Error, true);
    },

    /**
     * @return {!Array.<!WebInspector.Console.Message>}
     */
    messages: function()
    {
        return this._messages;
    },

    show: function()
    {
        this.showPromise();
    },

    /**
     * @return {!Promise.<undefined>}
     */
    showPromise: function()
    {
        if (this._uiDelegate)
            return this._uiDelegate.showConsole();
        return Promise.reject();
    },

    __proto__: WebInspector.Object.prototype
}

WebInspector.console = new WebInspector.Console();
;/* ContentProvider.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @interface
 */
WebInspector.ContentProvider = function() { }

WebInspector.ContentProvider.prototype = {
    /**
     * @return {string}
     */
    contentURL: function() { },

    /**
     * @return {!WebInspector.ResourceType}
     */
    contentType: function() { },

    /**
     * @return {!Promise<?string>}
     */
    requestContent: function() { },

    /**
     * @param {string} query
     * @param {boolean} caseSensitive
     * @param {boolean} isRegex
     * @param {function(!Array.<!WebInspector.ContentProvider.SearchMatch>)} callback
     */
    searchInContent: function(query, caseSensitive, isRegex, callback) { }
}

/**
 * @constructor
 * @param {number} lineNumber
 * @param {string} lineContent
 */
WebInspector.ContentProvider.SearchMatch = function(lineNumber, lineContent) {
    this.lineNumber = lineNumber;
    this.lineContent = lineContent;
}

/**
 * @param {string} content
 * @param {string} query
 * @param {boolean} caseSensitive
 * @param {boolean} isRegex
 * @return {!Array.<!WebInspector.ContentProvider.SearchMatch>}
 */
WebInspector.ContentProvider.performSearchInContent = function(content, query, caseSensitive, isRegex)
{
    var regex = createSearchRegex(query, caseSensitive, isRegex);

    var contentString = new String(content);
    var result = [];
    for (var i = 0; i < contentString.lineCount(); ++i) {
        var lineContent = contentString.lineAt(i);
        regex.lastIndex = 0;
        if (regex.exec(lineContent))
            result.push(new WebInspector.ContentProvider.SearchMatch(i, lineContent));
    }
    return result;
}
;/* ParsedURL.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. AND ITS CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE INC.
 * OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {string} url
 */
WebInspector.ParsedURL = function(url)
{
    this.isValid = false;
    this.url = url;
    this.scheme = "";
    this.host = "";
    this.port = "";
    this.path = "";
    this.queryParams = "";
    this.fragment = "";
    this.folderPathComponents = "";
    this.lastPathComponent = "";

    // RegExp groups:
    // 1 - scheme (using the RFC3986 grammar)
    // 2 - hostname
    // 3 - ?port
    // 4 - ?path
    // 5 - ?fragment
    var match = url.match(/^([A-Za-z][A-Za-z0-9+.-]*):\/\/([^\s\/:]*)(?::([\d]+))?(?:(\/[^#]*)(?:#(.*))?)?$/i);
    if (match) {
        this.isValid = true;
        this.scheme = match[1].toLowerCase();
        this.host = match[2];
        this.port = match[3];
        this.path = match[4] || "/";
        this.fragment = match[5];
    } else {
        if (this.url.startsWith("data:")) {
            this.scheme = "data";
            return;
        }
        if (this.url === "about:blank") {
            this.scheme = "about";
            return;
        }
        this.path = this.url;
    }

    // First cut the query params.
    var path = this.path;
    var indexOfQuery = path.indexOf("?");
    if (indexOfQuery !== -1) {
        this.queryParams = path.substring(indexOfQuery + 1);
        path = path.substring(0, indexOfQuery);
    }

    // Then take last path component.
    var lastSlashIndex = path.lastIndexOf("/");
    if (lastSlashIndex !== -1) {
        this.folderPathComponents = path.substring(0, lastSlashIndex);
        this.lastPathComponent = path.substring(lastSlashIndex + 1);
    } else
        this.lastPathComponent = path;
}

/**
 * @param {string} url
 * @return {!Array.<string>}
 */
WebInspector.ParsedURL.splitURLIntoPathComponents = function(url)
{
    var parsedURL = new WebInspector.ParsedURL(url);
    var origin;
    var folderPath;
    var name;
    if (parsedURL.isValid) {
        origin = parsedURL.scheme + "://" + parsedURL.host;
        if (parsedURL.port)
            origin += ":" + parsedURL.port;
        folderPath = parsedURL.folderPathComponents;
        name = parsedURL.lastPathComponent;
        if (parsedURL.queryParams)
            name += "?" + parsedURL.queryParams;
    } else {
        origin = "";
        folderPath = "";
        name = url;
    }
    var result = [origin];
    var splittedPath = folderPath.split("/");
    for (var i = 1; i < splittedPath.length; ++i) {
        if (!splittedPath[i])
            continue;
        result.push(splittedPath[i]);
    }
    result.push(name);
    return result;
}

/**
 * @param {string} url
 * @return {string}
 */
WebInspector.ParsedURL.extractOrigin = function(url)
{
    var parsedURL = new WebInspector.ParsedURL(url);
    if (!parsedURL.isValid)
        return "";

    var origin = parsedURL.scheme + "://" + parsedURL.host;
    if (parsedURL.port)
        origin += ":" + parsedURL.port;
    return origin;
}

/**
 * @param {string} baseURL
 * @param {string} href
 * @return {?string}
 */
WebInspector.ParsedURL.completeURL = function(baseURL, href)
{
    if (href) {
        // Return special URLs as-is.
        var trimmedHref = href.trim();
        if (trimmedHref.startsWith("data:") || trimmedHref.startsWith("blob:") || trimmedHref.startsWith("javascript:"))
            return href;

        // Return absolute URLs as-is.
        var parsedHref = trimmedHref.asParsedURL();
        if (parsedHref && parsedHref.scheme)
            return trimmedHref;
    } else {
        return baseURL;
    }

    var parsedURL = baseURL.asParsedURL();
    if (parsedURL) {
        if (parsedURL.isDataURL())
            return href;
        var path = href;

        var query = path.indexOf("?");
        var postfix = "";
        if (query !== -1) {
            postfix = path.substring(query);
            path = path.substring(0, query);
        } else {
            var fragment = path.indexOf("#");
            if (fragment !== -1) {
                postfix = path.substring(fragment);
                path = path.substring(0, fragment);
            }
        }

        if (!path) {  // empty path, must be postfix
            var basePath = parsedURL.path;
            if (postfix.charAt(0) === "?") {
                // A href of "?foo=bar" implies "basePath?foo=bar".
                // With "basePath?a=b" and "?foo=bar" we should get "basePath?foo=bar".
                var baseQuery = parsedURL.path.indexOf("?");
                if (baseQuery !== -1)
                    basePath = basePath.substring(0, baseQuery);
            } // else it must be a fragment
            return parsedURL.scheme + "://" + parsedURL.host + (parsedURL.port ? (":" + parsedURL.port) : "") + basePath + postfix;
        } else if (path.charAt(0) !== "/") {  // relative path
            var prefix = parsedURL.path;
            var prefixQuery = prefix.indexOf("?");
            if (prefixQuery !== -1)
                prefix = prefix.substring(0, prefixQuery);
            prefix = prefix.substring(0, prefix.lastIndexOf("/")) + "/";
            path = prefix + path;
        } else if (path.length > 1 && path.charAt(1) === "/") {
            // href starts with "//" which is a full URL with the protocol dropped (use the baseURL protocol).
            return parsedURL.scheme + ":" + path + postfix;
        }  // else absolute path
        return parsedURL.scheme + "://" + parsedURL.host + (parsedURL.port ? (":" + parsedURL.port) : "") + normalizePath(path) + postfix;
    }
    return null;
}

WebInspector.ParsedURL.prototype = {
    get displayName()
    {
        if (this._displayName)
            return this._displayName;

        if (this.isDataURL())
            return this.dataURLDisplayName();
        if (this.isAboutBlank())
            return this.url;

        this._displayName = this.lastPathComponent;
        if (!this._displayName)
            this._displayName = (this.host || "") + "/";
        if (this._displayName === "/")
            this._displayName = this.url;
        return this._displayName;
    },

    /**
     * @return {string}
     */
    dataURLDisplayName: function()
    {
        if (this._dataURLDisplayName)
            return this._dataURLDisplayName;
        if (!this.isDataURL())
            return "";
        this._dataURLDisplayName = this.url.trimEnd(20);
        return this._dataURLDisplayName;
    },

    /**
     * @return {boolean}
     */
    isAboutBlank: function()
    {
        return this.url === "about:blank";
    },

    /**
     * @return {boolean}
     */
    isDataURL: function()
    {
        return this.scheme === "data";
    },

    /**
     * @return {string}
     */
    lastPathComponentWithFragment: function()
    {
       return this.lastPathComponent + (this.fragment ? "#" + this.fragment : "");
    },

    /**
     * @return {string}
     */
    domain: function()
    {
        return this.host + (this.port ? ":" + this.port : "");
    },

    /**
     * @return {string}
     */
    urlWithoutScheme: function()
    {
        if (this.scheme && this.url.startsWith(this.scheme + "://"))
            return this.url.substring(this.scheme.length + 3);
        return this.url;
    },
}

/**
 * @param {string} string
 * @return {!{url: string, lineNumber: (number|undefined), columnNumber: (number|undefined)}}
 */
WebInspector.ParsedURL.splitLineAndColumn = function(string)
{
    var lineColumnRegEx = /(?::(\d+))?(?::(\d+))?$/;
    var lineColumnMatch = lineColumnRegEx.exec(string);
    var lineNumber;
    var columnNumber;
    console.assert(lineColumnMatch);

    if (typeof(lineColumnMatch[1]) === "string") {
        lineNumber = parseInt(lineColumnMatch[1], 10);
        // Immediately convert line and column to 0-based numbers.
        lineNumber = isNaN(lineNumber) ? undefined : lineNumber - 1;
    }
    if (typeof(lineColumnMatch[2]) === "string") {
        columnNumber = parseInt(lineColumnMatch[2], 10);
        columnNumber = isNaN(columnNumber) ? undefined : columnNumber - 1;
    }

    return {url: string.substring(0, string.length - lineColumnMatch[0].length), lineNumber: lineNumber, columnNumber: columnNumber};
}

/**
 * @return {?WebInspector.ParsedURL}
 */
String.prototype.asParsedURL = function()
{
    var parsedURL = new WebInspector.ParsedURL(this.toString());
    if (parsedURL.isValid)
        return parsedURL;
    return null;
}
;/* Progress.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @interface
 */
WebInspector.Progress = function()
{
}

WebInspector.Progress.prototype = {
    /**
     * @param {number} totalWork
     */
    setTotalWork: function(totalWork) { },

    /**
     * @param {string} title
     */
    setTitle: function(title) { },

    /**
     * @param {number} worked
     * @param {string=} title
     */
    setWorked: function(worked, title) { },

    /**
     * @param {number=} worked
     */
    worked: function(worked) { },

    done: function() { },

    /**
     * @return {boolean}
     */
    isCanceled: function() { return false; },
}

/**
 * @constructor
 * @param {!WebInspector.Progress} parent
 */
WebInspector.CompositeProgress = function(parent)
{
    this._parent = parent;
    this._children = [];
    this._childrenDone = 0;
    this._parent.setTotalWork(1);
    this._parent.setWorked(0);
}

WebInspector.CompositeProgress.prototype = {
    _childDone: function()
    {
        if (++this._childrenDone !== this._children.length)
            return;
        this._parent.done();
    },

    /**
     * @param {number=} weight
     * @return {!WebInspector.SubProgress}
     */
    createSubProgress: function(weight)
    {
        var child = new WebInspector.SubProgress(this, weight);
        this._children.push(child);
        return child;
    },

    _update: function()
    {
        var totalWeights = 0;
        var done = 0;

        for (var i = 0; i < this._children.length; ++i) {
            var child = this._children[i];
            if (child._totalWork)
                done += child._weight * child._worked / child._totalWork;
            totalWeights += child._weight;
        }
        this._parent.setWorked(done / totalWeights);
    }
}

/**
 * @constructor
 * @implements {WebInspector.Progress}
 * @param {!WebInspector.CompositeProgress} composite
 * @param {number=} weight
 */
WebInspector.SubProgress = function(composite, weight)
{
    this._composite = composite;
    this._weight = weight || 1;
    this._worked = 0;
}

WebInspector.SubProgress.prototype = {
    /**
     * @override
     * @return {boolean}
     */
    isCanceled: function()
    {
        return this._composite._parent.isCanceled();
    },

    /**
     * @override
     * @param {string} title
     */
    setTitle: function(title)
    {
        this._composite._parent.setTitle(title);
    },

    /**
     * @override
     */
    done: function()
    {
        this.setWorked(this._totalWork);
        this._composite._childDone();
    },

    /**
     * @override
     * @param {number} totalWork
     */
    setTotalWork: function(totalWork)
    {
        this._totalWork = totalWork;
        this._composite._update();
    },

    /**
     * @override
     * @param {number} worked
     * @param {string=} title
     */
    setWorked: function(worked, title)
    {
        this._worked = worked;
        if (typeof title !== "undefined")
            this.setTitle(title);
        this._composite._update();
    },

    /**
     * @override
     * @param {number=} worked
     */
    worked: function(worked)
    {
        this.setWorked(this._worked + (worked || 1));
    }
}

/**
 * @constructor
 * @implements {WebInspector.Progress}
 * @param {?WebInspector.Progress} delegate
 * @param {function()=} doneCallback
 */
WebInspector.ProgressProxy = function(delegate, doneCallback)
{
    this._delegate = delegate;
    this._doneCallback = doneCallback;
}

WebInspector.ProgressProxy.prototype = {
    /**
     * @override
     * @return {boolean}
     */
    isCanceled: function()
    {
        return this._delegate ? this._delegate.isCanceled() : false;
    },

    /**
     * @override
     * @param {string} title
     */
    setTitle: function(title)
    {
        if (this._delegate)
            this._delegate.setTitle(title);
    },

    /**
     * @override
     */
    done: function()
    {
        if (this._delegate)
            this._delegate.done();
        if (this._doneCallback)
            this._doneCallback();
    },

    /**
     * @override
     * @param {number} totalWork
     */
    setTotalWork: function(totalWork)
    {
        if (this._delegate)
            this._delegate.setTotalWork(totalWork);
    },

    /**
     * @override
     * @param {number} worked
     * @param {string=} title
     */
    setWorked: function(worked, title)
    {
        if (this._delegate)
            this._delegate.setWorked(worked, title);
    },

    /**
     * @override
     * @param {number=} worked
     */
    worked: function(worked)
    {
        if (this._delegate)
            this._delegate.worked(worked);
    }
}
;/* ResourceType.js */
/*
 * Copyright (C) 2012 Google Inc.  All rights reserved.
 * Copyright (C) 2007, 2008 Apple Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {string} name
 * @param {string} title
 * @param {!WebInspector.ResourceCategory} category
 * @param {boolean} isTextType
 */
WebInspector.ResourceType = function(name, title, category, isTextType)
{
    this._name = name;
    this._title = title;
    this._category = category;
    this._isTextType = isTextType;
}

WebInspector.ResourceType.prototype = {
    /**
     * @return {string}
     */
    name: function()
    {
        return this._name;
    },

    /**
     * @return {string}
     */
    title: function()
    {
        return this._title;
    },

    /**
     * @return {!WebInspector.ResourceCategory}
     */
    category: function()
    {
        return this._category;
    },

    /**
     * @return {boolean}
     */
    isTextType: function()
    {
        return this._isTextType;
    },

    /**
     * @return {boolean}
     */
    isScript: function()
    {
        return this._name === "script" || this._name === "sm-script";
    },

    /**
     * @return {boolean}
     */
    hasScripts: function()
    {
        return this.isScript() || this.isDocument();
    },

    /**
     * @return {boolean}
     */
    isStyleSheet: function()
    {
        return this._name === "stylesheet" || this._name === "sm-stylesheet";
    },

    /**
     * @return {boolean}
     */
    isDocument: function()
    {
        return this._name === "document";
    },

    /**
     * @return {boolean}
     */
    isDocumentOrScriptOrStyleSheet: function()
    {
        return this.isDocument() || this.isScript() || this.isStyleSheet();
    },

    /**
     * @return {boolean}
     */
    isFromSourceMap: function()
    {
        return this._name.startsWith("sm-");
    },

    /**
     * @override
     * @return {string}
     */
    toString: function()
    {
        return this._name;
    },

    /**
     * @return {string}
     */
    canonicalMimeType: function()
    {
        if (this.isDocument())
            return "text/html";
        if (this.isScript())
            return "text/javascript";
        if (this.isStyleSheet())
            return "text/css";
        return "";
    }
}

/**
 * @constructor
 * @param {string} title
 * @param {string} shortTitle
 */
WebInspector.ResourceCategory = function(title, shortTitle)
{
    this.title = title;
    this.shortTitle = shortTitle;
}

WebInspector.resourceCategories = {
    XHR: new WebInspector.ResourceCategory("XHR and Fetch", "XHR"),
    Script: new WebInspector.ResourceCategory("Scripts", "JS"),
    Stylesheet: new WebInspector.ResourceCategory("Stylesheets", "CSS"),
    Image: new WebInspector.ResourceCategory("Images", "Img"),
    Media: new WebInspector.ResourceCategory("Media", "Media"),
    Font: new WebInspector.ResourceCategory("Fonts", "Font"),
    Document: new WebInspector.ResourceCategory("Documents", "Doc"),
    WebSocket: new WebInspector.ResourceCategory("WebSockets", "WS"),
    Manifest: new WebInspector.ResourceCategory("Manifest", "Manifest"),
    Other: new WebInspector.ResourceCategory("Other", "Other")
}

/**
 * Keep these in sync with WebCore::InspectorPageAgent::resourceTypeJson
 * @enum {!WebInspector.ResourceType}
 */
WebInspector.resourceTypes = {
    XHR: new WebInspector.ResourceType("xhr", "XHR", WebInspector.resourceCategories.XHR, true),
    Fetch: new WebInspector.ResourceType("fetch", "Fetch", WebInspector.resourceCategories.XHR, true),
    EventSource: new WebInspector.ResourceType("eventsource", "EventSource", WebInspector.resourceCategories.XHR, true),
    Script: new WebInspector.ResourceType("script", "Script", WebInspector.resourceCategories.Script, true),
    Stylesheet: new WebInspector.ResourceType("stylesheet", "Stylesheet", WebInspector.resourceCategories.Stylesheet, true),
    Image: new WebInspector.ResourceType("image", "Image", WebInspector.resourceCategories.Image, false),
    Media: new WebInspector.ResourceType("media", "Media", WebInspector.resourceCategories.Media, false),
    Font: new WebInspector.ResourceType("font", "Font", WebInspector.resourceCategories.Font, false),
    Document: new WebInspector.ResourceType("document", "Document", WebInspector.resourceCategories.Document, true),
    TextTrack: new WebInspector.ResourceType("texttrack", "TextTrack", WebInspector.resourceCategories.Other, true),
    WebSocket: new WebInspector.ResourceType("websocket", "WebSocket", WebInspector.resourceCategories.WebSocket, false),
    Other: new WebInspector.ResourceType("other", "Other", WebInspector.resourceCategories.Other, false),
    SourceMapScript: new WebInspector.ResourceType("sm-script", "Script", WebInspector.resourceCategories.Script, false),
    SourceMapStyleSheet: new WebInspector.ResourceType("sm-stylesheet", "Stylesheet", WebInspector.resourceCategories.Stylesheet, false),
    Manifest: new WebInspector.ResourceType("manifest", "Manifest", WebInspector.resourceCategories.Manifest, false),
}

/**
 * @param {string} url
 * @return {string}
 */
WebInspector.ResourceType.mimeFromURL = function(url)
{
    var name = WebInspector.TextUtils.fileName(url);
    if (WebInspector.ResourceType.mimeTypeByName[name]) {
        return WebInspector.ResourceType.mimeTypeByName[name];
    }
    var ext = WebInspector.TextUtils.extension(url).toLowerCase();
    return WebInspector.ResourceType.mimeTypeByExtension[ext];
}

WebInspector.ResourceType.mimeTypeByName = {
    // CoffeeScript
    "Cakefile": "text/x-coffeescript"
}

WebInspector.ResourceType.mimeTypeByExtension = {
    // Web extensions
    "js": "text/javascript",
    "jsx": "text/javascript",
    "css": "text/css",
    "html": "text/html",
    "htm": "text/html",
    "xml": "application/xml",
    "xsl": "application/xml",

    // HTML Embedded Scripts: ASP, JSP
    "asp": "application/x-aspx",
    "aspx": "application/x-aspx",
    "jsp": "application/x-jsp",

    // C/C++
    "c": "text/x-c++src",
    "cc": "text/x-c++src",
    "cpp": "text/x-c++src",
    "h": "text/x-c++src",
    "m": "text/x-c++src",
    "mm": "text/x-c++src",

    // CoffeeScript
    "coffee": "text/x-coffeescript",

    // Dart
    "dart": "text/javascript",

    // TypeScript
    "ts": "text/typescript",
    "tsx": "text/typescript",

    // JSON
    "json": "application/json",
    "gyp": "application/json",
    "gypi": "application/json",

    // C#
    "cs": "text/x-csharp",

    // Java
    "java": "text/x-java",

    // Less
    "less": "text/x-less",

    // PHP
    "php": "text/x-php",
    "phtml": "application/x-httpd-php",

    // Python
    "py": "text/x-python",

    // Shell
    "sh": "text/x-sh",

    // SCSS
    "scss": "text/x-scss",

    // Video Text Tracks.
    "vtt": "text/vtt",

    // LiveScript
    "ls": "text/x-livescript",

    // ClojureScript
    "cljs": "text/x-clojure",
    "cljc": "text/x-clojure",
    "cljx": "text/x-clojure",

    // Stylus
    "styl": "text/x-styl",

    // Image
    "jpeg": "image/jpeg",
    "jpg": "image/jpeg",
    "svg": "image/svg",
    "gif": "image/gif",
    "webp": "image/webp",
    "png": "image/png",
    "ico": "image/ico",
    "tiff": "image/tiff",
    "tif": "image/tif",
    "bmp": "image/bmp",

    // Font
    "ttf": "font/opentype",
    "otf": "font/opentype",
    "ttc": "font/opentype",
    "woff": "application/font-woff"
}
;/* Settings.js */
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {!WebInspector.SettingsStorage} storage
 */
WebInspector.Settings = function(storage)
{
    this._settingsStorage = storage;
    var clearLocalStorage = window.localStorage ? window.localStorage.clear.bind(window.localStorage) : undefined;
    this._localStorage = new WebInspector.SettingsStorage(window.localStorage || {}, undefined, undefined, clearLocalStorage);

    this._eventSupport = new WebInspector.Object();
    /** @type {!Map<string, !WebInspector.Setting>} */
    this._registry = new Map();
    /** @type {!Map<string, !WebInspector.Setting>} */
    this._moduleSettings = new Map();
    self.runtime.extensions("setting").forEach(this._registerModuleSetting.bind(this));
}

WebInspector.Settings.prototype = {
    /**
     * @param {!Runtime.Extension} extension
     */
    _registerModuleSetting: function(extension)
    {
        var descriptor = extension.descriptor();
        var settingName = descriptor["settingName"];
        var settingType = descriptor["settingType"];
        var defaultValue = descriptor["defaultValue"];
        var isLocal = !!descriptor["local"];
        var setting = settingType === "regex" ? this.createRegExpSetting(settingName, defaultValue, undefined, isLocal) : this.createSetting(settingName, defaultValue, isLocal);
        this._moduleSettings.set(settingName, setting);
    },

    /**
     * @param {string} settingName
     * @return {!WebInspector.Setting}
     */
    moduleSetting: function(settingName)
    {
        var setting = this._moduleSettings.get(settingName);
        if (!setting)
            throw new Error("No setting registered: " + settingName);
        return setting;
    },

    /**
     * @param {string} settingName
     * @return {!WebInspector.Setting}
     */
    settingForTest: function(settingName)
    {
        var setting = this._registry.get(settingName);
        if (!setting)
            throw new Error("No setting registered: " + settingName);
        return setting;
    },

    /**
     * @param {string} key
     * @param {*} defaultValue
     * @param {boolean=} isLocal
     * @return {!WebInspector.Setting}
     */
    createSetting: function(key, defaultValue, isLocal)
    {
        if (!this._registry.get(key))
            this._registry.set(key, new WebInspector.Setting(this, key, defaultValue, this._eventSupport, isLocal ? this._localStorage : this._settingsStorage));
        return /** @type {!WebInspector.Setting} */ (this._registry.get(key));
    },

    /**
     * @param {string} key
     * @param {*} defaultValue
     * @return {!WebInspector.Setting}
     */
    createLocalSetting: function(key, defaultValue)
    {
        return this.createSetting(key, defaultValue, true);
    },

    /**
     * @param {string} key
     * @param {string} defaultValue
     * @param {string=} regexFlags
     * @param {boolean=} isLocal
     * @return {!WebInspector.RegExpSetting}
     */
    createRegExpSetting: function(key, defaultValue, regexFlags, isLocal)
    {
        if (!this._registry.get(key))
            this._registry.set(key, new WebInspector.RegExpSetting(this, key, defaultValue, this._eventSupport, isLocal ? this._localStorage : this._settingsStorage, regexFlags));
        return /** @type {!WebInspector.RegExpSetting} */ (this._registry.get(key));
    },

    clearAll: function()
    {
        this._settingsStorage.removeAll();
        this._localStorage.removeAll();
        var versionSetting = WebInspector.settings.createSetting(WebInspector.VersionController._currentVersionName, 0);
        versionSetting.set(WebInspector.VersionController.currentVersion);
    }
}

/**
 * @constructor
 * @param {!Object} object
 * @param {function(string, string)=} setCallback
 * @param {function(string)=} removeCallback
 * @param {function(string)=} removeAllCallback
 */
WebInspector.SettingsStorage = function(object, setCallback, removeCallback, removeAllCallback)
{
    this._object = object;
    this._setCallback = setCallback || function() {};
    this._removeCallback = removeCallback || function() {};
    this._removeAllCallback = removeAllCallback || function() {};
}

WebInspector.SettingsStorage.prototype = {
    /**
     * @param {string} name
     * @param {string} value
     */
    set: function(name, value)
    {
        this._object[name] = value;
        this._setCallback(name, value);
    },

    /**
     * @param {string} name
     * @return {boolean}
     */
    has: function(name)
    {
        return name in this._object;
    },

    /**
     * @param {string} name
     * @return {string}
     */
    get: function(name)
    {
        return this._object[name];
    },

    /**
     * @param {string} name
     */
    remove: function(name)
    {
        delete this._object[name];
        this._removeCallback(name);
    },

    removeAll: function()
    {
        this._object = {};
        this._removeAllCallback();
    },

    _dumpSizes: function()
    {
        WebInspector.console.log("Ten largest settings: ");

        var sizes = { __proto__: null };
        for (var key in this._object)
            sizes[key] = this._object[key].length;
        var keys = Object.keys(sizes);

        function comparator(key1, key2)
        {
            return sizes[key2] - sizes[key1];
        }

        keys.sort(comparator);

        for (var i = 0; i < 10 && i < keys.length; ++i)
            WebInspector.console.log("Setting: '" + keys[i] + "', size: " + sizes[keys[i]]);
    }
}

/**
 * @constructor
 * @param {!WebInspector.Settings} settings
 * @param {string} name
 * @param {V} defaultValue
 * @param {!WebInspector.Object} eventSupport
 * @param {!WebInspector.SettingsStorage} storage
 * @template V
 */
WebInspector.Setting = function(settings, name, defaultValue, eventSupport, storage)
{
    this._settings = settings;
    this._name = name;
    this._defaultValue = defaultValue;
    this._eventSupport = eventSupport;
    this._storage = storage;
}

WebInspector.Setting.prototype = {
    /**
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    addChangeListener: function(listener, thisObject)
    {
        this._eventSupport.addEventListener(this._name, listener, thisObject);
    },

    /**
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    removeChangeListener: function(listener, thisObject)
    {
        this._eventSupport.removeEventListener(this._name, listener, thisObject);
    },

    get name()
    {
        return this._name;
    },

    /**
     * @return {V}
     */
    get: function()
    {
        if (typeof this._value !== "undefined")
            return this._value;

        this._value = this._defaultValue;
        if (this._storage.has(this._name)) {
            try {
                this._value = JSON.parse(this._storage.get(this._name));
            } catch(e) {
                this._storage.remove(this._name);
            }
        }
        return this._value;
    },

    /**
     * @param {V} value
     */
    set: function(value)
    {
        this._value = value;
        try {
            var settingString = JSON.stringify(value);
            try {
                this._storage.set(this._name, settingString);
            } catch(e) {
                this._printSettingsSavingError(e.message, this._name, settingString);
            }
        } catch(e) {
            WebInspector.console.error("Cannot stringify setting with name: " + this._name + ", error: " + e.message);
        }
        this._eventSupport.dispatchEventToListeners(this._name, value);
    },

    remove: function()
    {
        this._settings._registry.delete(this._name);
        this._settings._moduleSettings.delete(this._name);
        this._storage.remove(this._name);
    },

    /**
     * @param {string} message
     * @param {string} name
     * @param {string} value
     */
    _printSettingsSavingError: function(message, name, value)
    {
        var errorMessage = "Error saving setting with name: " + this._name + ", value length: " + value.length + ". Error: " + message;
        console.error(errorMessage);
        WebInspector.console.error(errorMessage);
        this._storage._dumpSizes();
    }
}

/**
 * @constructor
 * @extends {WebInspector.Setting}
 * @param {!WebInspector.Settings} settings
 * @param {string} name
 * @param {string} defaultValue
 * @param {!WebInspector.Object} eventSupport
 * @param {!WebInspector.SettingsStorage} storage
 * @param {string=} regexFlags
 */
WebInspector.RegExpSetting = function(settings, name, defaultValue, eventSupport, storage, regexFlags)
{
    WebInspector.Setting.call(this, settings, name, defaultValue ? [{ pattern: defaultValue }] : [], eventSupport, storage);
    this._regexFlags = regexFlags;
}

WebInspector.RegExpSetting.prototype = {
    /**
     * @override
     * @return {string}
     */
    get: function()
    {
        var result = [];
        var items = this.getAsArray();
        for (var i = 0; i < items.length; ++i) {
            var item = items[i];
            if (item.pattern && !item.disabled)
                result.push(item.pattern);
        }
        return result.join("|");
    },

    /**
     * @return {!Array.<{pattern: string, disabled: (boolean|undefined)}>}
     */
    getAsArray: function()
    {
        return WebInspector.Setting.prototype.get.call(this);
    },

    /**
     * @override
     * @param {string} value
     */
    set: function(value)
    {
        this.setAsArray([{ pattern: value }]);
    },

    /**
     * @param {!Array.<{pattern: string, disabled: (boolean|undefined)}>} value
     */
    setAsArray: function(value)
    {
        delete this._regex;
        WebInspector.Setting.prototype.set.call(this, value);
    },

    /**
     * @return {?RegExp}
     */
    asRegExp: function()
    {
        if (typeof this._regex !== "undefined")
            return this._regex;
        this._regex = null;
        try {
            var pattern = this.get();
            if (pattern)
                this._regex = new RegExp(pattern, this._regexFlags || "");
        } catch (e) {
        }
        return this._regex;
    },

    __proto__: WebInspector.Setting.prototype
}

/**
 * @constructor
 */
WebInspector.VersionController = function()
{
}

WebInspector.VersionController._currentVersionName = "inspectorVersion";
WebInspector.VersionController.currentVersion = 18;

WebInspector.VersionController.prototype = {
    updateVersion: function()
    {
        var localStorageVersion = window.localStorage ? window.localStorage[WebInspector.VersionController._currentVersionName] : 0;
        var versionSetting = WebInspector.settings.createSetting(WebInspector.VersionController._currentVersionName, 0);
        var currentVersion = WebInspector.VersionController.currentVersion;
        // While localStorage version exists, treat it as the main one. It'll be erased once migrated to prefs.
        var oldVersion = parseInt(localStorageVersion || "0", 10) || versionSetting.get();
        if (oldVersion === 0) {
            // First run, no need to do anything.
            versionSetting.set(currentVersion);
            return;
        }
        var methodsToRun = this._methodsToRunToUpdateVersion(oldVersion, currentVersion);
        for (var i = 0; i < methodsToRun.length; ++i)
            this[methodsToRun[i]].call(this);
        versionSetting.set(currentVersion);
    },

    /**
     * @param {number} oldVersion
     * @param {number} currentVersion
     */
    _methodsToRunToUpdateVersion: function(oldVersion, currentVersion)
    {
        var result = [];
        for (var i = oldVersion; i < currentVersion; ++i)
            result.push("_updateVersionFrom" + i + "To" + (i + 1));
        return result;
    },

    _updateVersionFrom0To1: function()
    {
        this._clearBreakpointsWhenTooMany(WebInspector.settings.createLocalSetting("breakpoints", []), 500000);
    },

    _updateVersionFrom1To2: function()
    {
        WebInspector.settings.createSetting("previouslyViewedFiles", []).set([]);
    },

    _updateVersionFrom2To3: function()
    {
        WebInspector.settings.createSetting("fileSystemMapping", {}).set({});
        WebInspector.settings.createSetting("fileMappingEntries", []).remove();
    },

    _updateVersionFrom3To4: function()
    {
        var advancedMode = WebInspector.settings.createSetting("showHeaSnapshotObjectsHiddenProperties", false);
        WebInspector.moduleSetting("showAdvancedHeapSnapshotProperties").set(advancedMode.get());
        advancedMode.remove();
    },

    _updateVersionFrom4To5: function()
    {
        var settingNames = {
            "FileSystemViewSidebarWidth": "fileSystemViewSplitViewState",
            "elementsSidebarWidth": "elementsPanelSplitViewState",
            "StylesPaneSplitRatio": "stylesPaneSplitViewState",
            "heapSnapshotRetainersViewSize": "heapSnapshotSplitViewState",
            "InspectorView.splitView": "InspectorView.splitViewState",
            "InspectorView.screencastSplitView": "InspectorView.screencastSplitViewState",
            "Inspector.drawerSplitView": "Inspector.drawerSplitViewState",
            "layerDetailsSplitView": "layerDetailsSplitViewState",
            "networkSidebarWidth": "networkPanelSplitViewState",
            "sourcesSidebarWidth": "sourcesPanelSplitViewState",
            "scriptsPanelNavigatorSidebarWidth": "sourcesPanelNavigatorSplitViewState",
            "sourcesPanelSplitSidebarRatio": "sourcesPanelDebuggerSidebarSplitViewState",
            "timeline-details": "timelinePanelDetailsSplitViewState",
            "timeline-split": "timelinePanelRecorsSplitViewState",
            "timeline-view": "timelinePanelTimelineStackSplitViewState",
            "auditsSidebarWidth": "auditsPanelSplitViewState",
            "layersSidebarWidth": "layersPanelSplitViewState",
            "profilesSidebarWidth": "profilesPanelSplitViewState",
            "resourcesSidebarWidth": "resourcesPanelSplitViewState"
        };
        var empty = {};
        for (var oldName in settingNames) {
            var newName = settingNames[oldName];
            var oldNameH = oldName + "H";

            var newValue = null;
            var oldSetting = WebInspector.settings.createSetting(oldName, empty);
            if (oldSetting.get() !== empty) {
                newValue = newValue || {};
                newValue.vertical = {};
                newValue.vertical.size = oldSetting.get();
                oldSetting.remove();
            }
            var oldSettingH = WebInspector.settings.createSetting(oldNameH, empty);
            if (oldSettingH.get() !== empty) {
                newValue = newValue || {};
                newValue.horizontal = {};
                newValue.horizontal.size = oldSettingH.get();
                oldSettingH.remove();
            }
            if (newValue)
                WebInspector.settings.createSetting(newName, {}).set(newValue);
        }
    },

    _updateVersionFrom5To6: function()
    {
        var settingNames = {
            "debuggerSidebarHidden": "sourcesPanelSplitViewState",
            "navigatorHidden": "sourcesPanelNavigatorSplitViewState",
            "WebInspector.Drawer.showOnLoad": "Inspector.drawerSplitViewState"
        };

        for (var oldName in settingNames) {
            var oldSetting = WebInspector.settings.createSetting(oldName, null);
            if (oldSetting.get() === null) {
                oldSetting.remove();
                continue;
            }

            var newName = settingNames[oldName];
            var invert = "WebInspector.Drawer.showOnLoad" === oldName;
            var hidden = oldSetting.get() !== invert;
            oldSetting.remove();
            var showMode = hidden ? "OnlyMain" : "Both";

            var newSetting = WebInspector.settings.createSetting(newName, {});
            var newValue = newSetting.get() || {};
            newValue.vertical = newValue.vertical || {};
            newValue.vertical.showMode = showMode;
            newValue.horizontal = newValue.horizontal || {};
            newValue.horizontal.showMode = showMode;
            newSetting.set(newValue);
        }
    },

    _updateVersionFrom6To7: function()
    {
        var settingNames = {
            "sourcesPanelNavigatorSplitViewState": "sourcesPanelNavigatorSplitViewState",
            "elementsPanelSplitViewState": "elementsPanelSplitViewState",
            "stylesPaneSplitViewState": "stylesPaneSplitViewState",
            "sourcesPanelDebuggerSidebarSplitViewState": "sourcesPanelDebuggerSidebarSplitViewState"
        };

        var empty = {};
        for (var name in settingNames) {
            var setting = WebInspector.settings.createSetting(name, empty);
            var value = setting.get();
            if (value === empty)
                continue;
            // Zero out saved percentage sizes, and they will be restored to defaults.
            if (value.vertical && value.vertical.size && value.vertical.size < 1)
                value.vertical.size = 0;
            if (value.horizontal && value.horizontal.size && value.horizontal.size < 1)
                value.horizontal.size = 0;
            setting.set(value);
        }
    },

    _updateVersionFrom7To8: function()
    {
    },

    _updateVersionFrom8To9: function()
    {
        var settingNames = [
            "skipStackFramesPattern",
            "workspaceFolderExcludePattern"
        ];

        for (var i = 0; i < settingNames.length; ++i) {
            var setting = WebInspector.settings.createSetting(settingNames[i], "");
            var value = setting.get();
            if (!value)
                return;
            if (typeof value === "string")
                value = [value];
            for (var j = 0; j < value.length; ++j) {
                if (typeof value[j] === "string")
                    value[j] = { pattern: value[j] };
            }
            setting.set(value);
        }
    },

    _updateVersionFrom9To10: function()
    {
        // This one is localStorage specific, which is fine.
        if (!window.localStorage)
            return;
        for (var key in window.localStorage) {
            if (key.startsWith("revision-history"))
                window.localStorage.removeItem(key);
        }
    },

    _updateVersionFrom10To11: function()
    {
        var oldSettingName = "customDevicePresets";
        var newSettingName = "customEmulatedDeviceList";
        var oldSetting = WebInspector.settings.createSetting(oldSettingName, undefined);
        var list = oldSetting.get();
        if (!Array.isArray(list))
            return;
        var newList = [];
        for (var i = 0; i < list.length; ++i) {
            var value = list[i];
            var device = {};
            device["title"] = value["title"];
            device["type"] = "unknown";
            device["user-agent"] = value["userAgent"];
            device["capabilities"] = [];
            if (value["touch"])
                device["capabilities"].push("touch");
            if (value["mobile"])
                device["capabilities"].push("mobile");
            device["screen"] = {};
            device["screen"]["vertical"] = {width: value["width"], height: value["height"]};
            device["screen"]["horizontal"] = {width: value["height"], height: value["width"]};
            device["screen"]["device-pixel-ratio"] = value["deviceScaleFactor"];
            device["modes"] = [];
            device["show-by-default"] = true;
            device["show"] = "Default";
            newList.push(device);
        }
        if (newList.length)
            WebInspector.settings.createSetting(newSettingName, []).set(newList);
        oldSetting.remove();
    },

    _updateVersionFrom11To12: function()
    {
        this._migrateSettingsFromLocalStorage();
    },

    _updateVersionFrom12To13: function()
    {
        this._migrateSettingsFromLocalStorage();
        WebInspector.settings.createSetting("timelineOverviewMode", "").remove();
    },

    _updateVersionFrom13To14: function()
    {
        var defaultValue = { "throughput": -1, "latency": 0 };
        WebInspector.settings.createSetting("networkConditions", defaultValue).set(defaultValue);
    },

    _updateVersionFrom14To15: function()
    {
        var setting = WebInspector.settings.createLocalSetting("workspaceExcludedFolders", {});
        var oldValue = setting.get();
        var newValue = {};
        for (var fileSystemPath in oldValue) {
            newValue[fileSystemPath] = [];
            for (var entry of oldValue[fileSystemPath])
                newValue[fileSystemPath].push(entry.path);
        }
        setting.set(newValue);
    },

    _updateVersionFrom15To16: function()
    {
        var setting = WebInspector.settings.createSetting("InspectorView.panelOrder", {});
        var tabOrders = setting.get();
        for (var key of Object.keys(tabOrders))
            tabOrders[key] = (tabOrders[key] + 1) * 10;
        setting.set(tabOrders);
    },

    _updateVersionFrom16To17: function()
    {
        var setting = WebInspector.settings.createSetting("networkConditionsCustomProfiles", []);
        var oldValue = setting.get();
        var newValue = [];
        if (Array.isArray(oldValue)) {
            for (var preset of oldValue) {
                if (typeof preset.title === "string" && typeof preset.value === "object" && typeof preset.value.throughput === "number" && typeof preset.value.latency === "number")
                    newValue.push({title: preset.title, value: {download: preset.value.throughput, upload: preset.value.throughput, latency: preset.value.latency}});
            }
        }
        setting.set(newValue);
    },

    _updateVersionFrom17To18: function()
    {
        var setting = WebInspector.settings.createLocalSetting("workspaceExcludedFolders", {});
        var oldValue = setting.get();
        var newValue = {};
        for (var oldKey in oldValue) {
            var newKey = oldKey.replace(/\\/g, "/");
            if (!newKey.startsWith("file://")) {
                if (newKey.startsWith("/"))
                    newKey = "file://" + newKey;
                else
                    newKey = "file:///" + newKey;
            }
            newValue[newKey] = oldValue[oldKey];
        }
        setting.set(newValue);
    },

    _migrateSettingsFromLocalStorage: function()
    {
        // This step migrates all the settings except for the ones below into the browser profile.
        var localSettings = [ "advancedSearchConfig", "breakpoints", "consoleHistory", "domBreakpoints", "eventListenerBreakpoints",
                              "fileSystemMapping", "lastSelectedSourcesSidebarPaneTab", "previouslyViewedFiles",
                              "savedURLs", "watchExpressions", "workspaceExcludedFolders", "xhrBreakpoints" ].keySet();
        if (!window.localStorage)
            return;

        for (var key in window.localStorage) {
            if (key in localSettings)
                continue;
            var value = window.localStorage[key];
            window.localStorage.removeItem(key);
            WebInspector.settings._settingsStorage[key] = value;
        }
    },

    /**
     * @param {!WebInspector.Setting} breakpointsSetting
     * @param {number} maxBreakpointsCount
     */
    _clearBreakpointsWhenTooMany: function(breakpointsSetting, maxBreakpointsCount)
    {
        // If there are too many breakpoints in a storage, it is likely due to a recent bug that caused
        // periodical breakpoints duplication leading to inspector slowness.
        if (breakpointsSetting.get().length > maxBreakpointsCount)
            breakpointsSetting.set([]);
    }
}

/**
 * @type {!WebInspector.Settings}
 */
WebInspector.settings;

/**
 * @param {string} settingName
 * @return {!WebInspector.Setting}
 */
WebInspector.moduleSetting = function(settingName)
{
    return WebInspector.settings.moduleSetting(settingName);
}

/**
 * @param {string} settingName
 * @return {!WebInspector.Setting}
 */
WebInspector.settingForTest = function(settingName)
{
    return WebInspector.settings.settingForTest(settingName);
}
;/* StaticContentProvider.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @implements {WebInspector.ContentProvider}
 * @param {!WebInspector.ResourceType} contentType
 * @param {string} content
 * @param {string=} contentURL
 */
WebInspector.StaticContentProvider = function(contentType, content, contentURL)
{
    this._content = content;
    this._contentType = contentType;
    this._contentURL = contentURL || "";
}

/**
 * @param {string} content
 * @param {string} query
 * @param {boolean} caseSensitive
 * @param {boolean} isRegex
 * @param {function(!Array.<!WebInspector.ContentProvider.SearchMatch>)} callback
 */
WebInspector.StaticContentProvider.searchInContent = function(content, query, caseSensitive, isRegex, callback)
{
    function performSearch()
    {
        callback(WebInspector.ContentProvider.performSearchInContent(content, query, caseSensitive, isRegex));
    }

    // searchInContent should call back later.
    setTimeout(performSearch.bind(null), 0);
}

WebInspector.StaticContentProvider.prototype = {
    /**
     * @override
     * @return {string}
     */
    contentURL: function()
    {
        return this._contentURL;
    },

    /**
     * @override
     * @return {!WebInspector.ResourceType}
     */
    contentType: function()
    {
        return this._contentType;
    },

    /**
     * @override
     * @return {!Promise<?string>}
     */
    requestContent: function()
    {
        return Promise.resolve(/** @type {?string} */(this._content));
    },

    /**
     * @override
     * @param {string} query
     * @param {boolean} caseSensitive
     * @param {boolean} isRegex
     * @param {function(!Array.<!WebInspector.ContentProvider.SearchMatch>)} callback
     */
    searchInContent: function(query, caseSensitive, isRegex, callback)
    {
        WebInspector.StaticContentProvider.searchInContent(this._content, query, caseSensitive, isRegex, callback);
    }
}
;/* OutputStream.js */
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @interface
 */
WebInspector.OutputStream = function()
{
}

WebInspector.OutputStream.prototype = {
    /**
     * @param {string} data
     * @param {function(!WebInspector.OutputStream)=} callback
     */
    write: function(data, callback) { },

    close: function() { }
}

/**
 * @constructor
 * @implements {WebInspector.OutputStream}
 */
WebInspector.StringOutputStream = function()
{
    this._data = "";
}

WebInspector.StringOutputStream.prototype = {
    /**
     * @override
     * @param {string} chunk
     * @param {function(!WebInspector.OutputStream)=} callback
     */
    write: function(chunk, callback)
    {
        this._data += chunk;
    },

    /**
     * @override
     */
    close: function()
    {
    },

    /**
     * @return {string}
     */
    data: function()
    {
        return this._data;
    }
};/* TestBase.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Test suite for interactive UI tests.
 * @constructor
 * @param {Object} domAutomationController DomAutomationController instance.
 */
WebInspector.TestBase = function(domAutomationController)
{
    this.domAutomationController_ = domAutomationController;
    this.controlTaken_ = false;
    this.timerId_ = -1;
};


/**
 * Reports test failure.
 * @param {string} message Failure description.
 */
WebInspector.TestBase.prototype.fail = function(message)
{
    if (this.controlTaken_)
        this.reportFailure_(message);
    else
        throw message;
};


/**
 * Equals assertion tests that expected === actual.
 * @param {!Object|boolean} expected Expected object.
 * @param {!Object|boolean} actual Actual object.
 * @param {string} opt_message User message to print if the test fails.
 */
WebInspector.TestBase.prototype.assertEquals = function(expected, actual, opt_message)
{
    if (expected !== actual) {
        var message = "Expected: '" + expected + "', but was '" + actual + "'";
        if (opt_message)
            message = opt_message + "(" + message + ")";
        this.fail(message);
    }
};


/**
 * True assertion tests that value == true.
 * @param {!Object} value Actual object.
 * @param {string} opt_message User message to print if the test fails.
 */
WebInspector.TestBase.prototype.assertTrue = function(value, opt_message)
{
    this.assertEquals(true, !!value, opt_message);
};


/**
 * Takes control over execution.
 */
WebInspector.TestBase.prototype.takeControl = function()
{
    this.controlTaken_ = true;
    // Set up guard timer.
    var self = this;
    this.timerId_ = setTimeout(function() {
        self.reportFailure_("Timeout exceeded: 20 sec");
    }, 20000);
};


/**
 * Releases control over execution.
 */
WebInspector.TestBase.prototype.releaseControl = function()
{
    if (this.timerId_ !== -1) {
        clearTimeout(this.timerId_);
        this.timerId_ = -1;
    }
    this.controlTaken_ = false;
    this.reportOk_();
};


/**
 * Async tests use this one to report that they are completed.
 */
WebInspector.TestBase.prototype.reportOk_ = function()
{
    this.domAutomationController_.send("[OK]");
};


/**
 * Async tests use this one to report failures.
 */
WebInspector.TestBase.prototype.reportFailure_ = function(error)
{
    if (this.timerId_ !== -1) {
        clearTimeout(this.timerId_);
        this.timerId_ = -1;
    }
    this.domAutomationController_.send("[FAILED] " + error);
};


/**
 * Run specified test on a fresh instance of the test suite.
 * @param {Array<string>} args method name followed by its parameters.
 */
WebInspector.TestBase.prototype.dispatch = function(args)
{
    var methodName = args.shift();
    try {
        this[methodName].apply(this, args);
        if (!this.controlTaken_)
            this.reportOk_();
    } catch (e) {
        this.reportFailure_(e);
    }
};


/**
 * Wrap an async method with TestBase.{takeControl(), releaseControl()}
 * and invoke TestBase.reportOk_ upon completion.
 * @param {Array<string>} args method name followed by its parameters.
 */
WebInspector.TestBase.prototype.waitForAsync = function(var_args)
{
    var args = Array.prototype.slice.call(arguments);
    this.takeControl();
    args.push(this.releaseControl.bind(this));
    this.dispatch(args);
};

/**
 * Overrides the method with specified name until it's called first time.
 * @param {!Object} receiver An object whose method to override.
 * @param {string} methodName Name of the method to override.
 * @param {!Function} override A function that should be called right after the
 *     overridden method returns.
 * @param {?boolean} opt_sticky Whether restore original method after first run
 *     or not.
 */
WebInspector.TestBase.prototype.addSniffer = function(receiver, methodName, override, opt_sticky)
{
    var orig = receiver[methodName];
    if (typeof orig !== "function")
        this.fail("Cannot find method to override: " + methodName);
    var test = this;
    receiver[methodName] = function(var_args) {
        try {
            var result = orig.apply(this, arguments);
        } finally {
            if (!opt_sticky)
                receiver[methodName] = orig;
        }
        // In case of exception the override won't be called.
        try {
            override.apply(this, arguments);
        } catch (e) {
            test.fail("Exception in overriden method '" + methodName + "': " + e);
        }
        return result;
    };
};

/**
 * Waits for current throttler invocations, if any.
 * @param {!WebInspector.Throttler} throttler
 * @param {function()} callback
 */
WebInspector.TestBase.prototype.waitForThrottler = function(throttler, callback)
{
    var test = this;
    var scheduleShouldFail = true;
    test.addSniffer(throttler, "schedule", onSchedule);

    function hasSomethingScheduled()
    {
        return throttler._isRunningProcess || throttler._process;
    }

    function checkState()
    {
        if (!hasSomethingScheduled()) {
            scheduleShouldFail = false;
            callback();
            return;
        }

        test.addSniffer(throttler, "_processCompletedForTests", checkState);
    }

    function onSchedule()
    {
        if (scheduleShouldFail)
            test.fail("Unexpected Throttler.schedule");
    }

    checkState();
};
;/* TextRange.js */
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {number} startLine
 * @param {number} startColumn
 * @param {number} endLine
 * @param {number} endColumn
 */
WebInspector.TextRange = function(startLine, startColumn, endLine, endColumn)
{
    this.startLine = startLine;
    this.startColumn = startColumn;
    this.endLine = endLine;
    this.endColumn = endColumn;
}

/**
 * @param {number} line
 * @param {number} column
 * @return {!WebInspector.TextRange}
 */
WebInspector.TextRange.createFromLocation = function(line, column)
{
    return new WebInspector.TextRange(line, column, line, column);
}

/**
 * @param {!Object} serializedTextRange
 * @return {!WebInspector.TextRange}
 */
WebInspector.TextRange.fromObject = function(serializedTextRange)
{
    return new WebInspector.TextRange(serializedTextRange.startLine, serializedTextRange.startColumn, serializedTextRange.endLine, serializedTextRange.endColumn);
}

/**
 * @param {!WebInspector.TextRange} range1
 * @param {!WebInspector.TextRange} range2
 * @return {number}
 */
WebInspector.TextRange.comparator = function(range1, range2)
{
    return range1.compareTo(range2);
}

WebInspector.TextRange.prototype = {
    /**
     * @return {boolean}
     */
    isEmpty: function()
    {
        return this.startLine === this.endLine && this.startColumn === this.endColumn;
    },

    /**
     * @param {!WebInspector.TextRange} range
     * @return {boolean}
     */
    immediatelyPrecedes: function(range)
    {
        if (!range)
            return false;
        return this.endLine === range.startLine && this.endColumn === range.startColumn;
    },

    /**
     * @param {!WebInspector.TextRange} range
     * @return {boolean}
     */
    immediatelyFollows: function(range)
    {
        if (!range)
            return false;
        return range.immediatelyPrecedes(this);
    },

    /**
     * @param {!WebInspector.TextRange} range
     * @return {boolean}
     */
    follows: function(range)
    {
        return (range.endLine === this.startLine && range.endColumn <= this.startColumn)
            || range.endLine < this.startLine;
    },

    /**
     * @return {number}
     */
    get linesCount()
    {
        return this.endLine - this.startLine;
    },

    /**
     * @return {!WebInspector.TextRange}
     */
    collapseToEnd: function()
    {
        return new WebInspector.TextRange(this.endLine, this.endColumn, this.endLine, this.endColumn);
    },

    /**
     * @return {!WebInspector.TextRange}
     */
    collapseToStart: function()
    {
        return new WebInspector.TextRange(this.startLine, this.startColumn, this.startLine, this.startColumn);
    },

    /**
     * @return {!WebInspector.TextRange}
     */
    normalize: function()
    {
        if (this.startLine > this.endLine || (this.startLine === this.endLine && this.startColumn > this.endColumn))
            return new WebInspector.TextRange(this.endLine, this.endColumn, this.startLine, this.startColumn);
        else
            return this.clone();
    },

    /**
     * @return {!WebInspector.TextRange}
     */
    clone: function()
    {
        return new WebInspector.TextRange(this.startLine, this.startColumn, this.endLine, this.endColumn);
    },

    /**
     * @return {!{startLine: number, startColumn: number, endLine: number, endColumn: number}}
     */
    serializeToObject: function()
    {
        var serializedTextRange = {};
        serializedTextRange.startLine = this.startLine;
        serializedTextRange.startColumn = this.startColumn;
        serializedTextRange.endLine = this.endLine;
        serializedTextRange.endColumn = this.endColumn;
        return serializedTextRange;
    },

    /**
     * @param {!WebInspector.TextRange} other
     * @return {number}
     */
    compareTo: function(other)
    {
        if (this.startLine > other.startLine)
            return 1;
        if (this.startLine < other.startLine)
            return -1;
        if (this.startColumn > other.startColumn)
            return 1;
        if (this.startColumn < other.startColumn)
            return -1;
        return 0;
    },

    /**
     * @param {!WebInspector.TextRange} other
     * @return {boolean}
     */
    equal: function(other)
    {
        return this.startLine === other.startLine && this.endLine === other.endLine &&
            this.startColumn === other.startColumn && this.endColumn === other.endColumn;
    },

    /**
     * @param {number} lineOffset
     * @return {!WebInspector.TextRange}
     */
    shift: function(lineOffset)
    {
        return new WebInspector.TextRange(this.startLine + lineOffset, this.startColumn, this.endLine + lineOffset, this.endColumn);
    },

    /**
     * @param {number} line
     * @param {number} column
     * @return {!WebInspector.TextRange}
     */
    relativeTo: function(line, column)
    {
        var relative = this.clone();

        if (this.startLine == line)
            relative.startColumn -= column;
        if (this.endLine == line)
            relative.endColumn -= column;

        relative.startLine -= line;
        relative.endLine -= line;
        return relative;
    },

    /**
     * @param {string} text
     * @return {!WebInspector.SourceRange}
     */
    toSourceRange: function(text)
    {
        var start = (this.startLine ? text.lineEndings()[this.startLine - 1] + 1 : 0) + this.startColumn;
        var end = (this.endLine ? text.lineEndings()[this.endLine - 1] + 1 : 0) + this.endColumn;
        return new WebInspector.SourceRange(start, end - start);
    },

    /**
     * @param {!WebInspector.TextRange} originalRange
     * @param {!WebInspector.TextRange} editedRange
     * @return {!WebInspector.TextRange}
     */
    rebaseAfterTextEdit: function(originalRange, editedRange)
    {
        console.assert(originalRange.startLine === editedRange.startLine);
        console.assert(originalRange.startColumn === editedRange.startColumn);
        var rebase = this.clone();
        if (!this.follows(originalRange))
            return rebase;
        var lineDelta = editedRange.endLine - originalRange.endLine;
        var columnDelta = editedRange.endColumn - originalRange.endColumn;
        rebase.startLine += lineDelta;
        rebase.endLine += lineDelta;
        if (rebase.startLine === editedRange.endLine)
            rebase.startColumn += columnDelta;
        if (rebase.endLine === editedRange.endLine)
            rebase.endColumn += columnDelta;
        return rebase;
    },

    /**
     * @override
     * @return {string}
     */
    toString: function()
    {
        return JSON.stringify(this);
    },

    /**
     * @param {string} text
     * @param {string} replacement
     * @return {string}
     */
    replaceInText: function(text, replacement)
    {
        var sourceRange = this.toSourceRange(text);
        return text.substring(0, sourceRange.offset) + replacement + text.substring(sourceRange.offset + sourceRange.length);
    },

    /**
     * @param {string} text
     * @return {string}
     */
    extract: function(text)
    {
        var sourceRange = this.toSourceRange(text);
        return text.substr(sourceRange.offset, sourceRange.length);
    },

    /**
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {boolean}
     */
    containsLocation: function(lineNumber, columnNumber)
    {
        if (this.startLine === this.endLine)
            return this.startLine === lineNumber && this.startColumn <= columnNumber && columnNumber <= this.endColumn;
        if (this.startLine === lineNumber)
            return this.startColumn <= columnNumber;
        if (this.endLine === lineNumber)
            return columnNumber <= this.endColumn;
        return this.startLine < lineNumber && lineNumber < this.endLine;
    }
}

/**
 * @constructor
 * @param {number} offset
 * @param {number} length
 */
WebInspector.SourceRange = function(offset, length)
{
    this.offset = offset;
    this.length = length;
}

WebInspector.SourceRange.prototype = {
    /**
     * @param {string} text
     * @return {!WebInspector.TextRange}
     */
    toTextRange: function(text)
    {
        var p1 = fromOffset(text, this.offset);
        var p2 = fromOffset(text, this.offset + this.length);
        return new WebInspector.TextRange(p1.lineNumber, p1.columnNumber, p2.lineNumber, p2.columnNumber);

        /**
         * @param {string} text
         * @param {number} offset
         * @return {!{lineNumber: number, columnNumber: number}}
         */
        function fromOffset(text, offset)
        {
            var lineEndings = text.lineEndings();
            var lineNumber = lineEndings.lowerBound(offset);
            var columnNumber = lineNumber === 0 ? offset : offset - lineEndings[lineNumber - 1] - 1;
            return {lineNumber: lineNumber, columnNumber: columnNumber};
        }
    }
}

/**
 * @constructor
 * @param {string} sourceURL
 * @param {!WebInspector.TextRange} oldRange
 * @param {string} newText
 */
WebInspector.SourceEdit = function(sourceURL, oldRange, newText)
{
    this.sourceURL = sourceURL;
    this.oldRange = oldRange;
    this.newText = newText;
}

WebInspector.SourceEdit.prototype = {
    /**
     * @return {!WebInspector.TextRange}
     */
    newRange: function()
    {
        var endLine = this.oldRange.startLine;
        var endColumn = this.oldRange.startColumn + this.newText.length;
        var lineEndings = this.newText.lineEndings();
        if (lineEndings.length > 1) {
            endLine = this.oldRange.startLine + lineEndings.length - 1;
            var len = lineEndings.length;
            endColumn = lineEndings[len - 1] - lineEndings[len - 2] - 1;
        }
        return new WebInspector.TextRange(
            this.oldRange.startLine,
            this.oldRange.startColumn,
            endLine,
            endColumn);
    },

    /**
     * @param {string} text
     * @return {string}
     */
    applyToText: function(text)
    {
        return this.oldRange.replaceInText(text, this.newText);
    },
}
;/* TextUtils.js */
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

WebInspector.TextUtils = {
    /**
     * @param {string} char
     * @return {boolean}
     */
    isStopChar: function(char)
    {
        return (char > " " && char < "0") ||
            (char > "9" && char < "A") ||
            (char > "Z" && char < "_") ||
            (char > "_" && char < "a") ||
            (char > "z" && char <= "~");
    },

    /**
     * @param {string} char
     * @return {boolean}
     */
    isWordChar: function(char)
    {
        return !WebInspector.TextUtils.isStopChar(char) && !WebInspector.TextUtils.isSpaceChar(char);
    },

    /**
     * @param {string} char
     * @return {boolean}
     */
    isSpaceChar: function(char)
    {
        return WebInspector.TextUtils._SpaceCharRegex.test(char);
    },

    /**
     * @param {string} word
     * @return {boolean}
     */
    isWord: function(word)
    {
        for (var i = 0; i < word.length; ++i) {
            if (!WebInspector.TextUtils.isWordChar(word.charAt(i)))
                return false;
        }
        return true;
    },

    /**
     * @param {string} char
     * @return {boolean}
     */
    isOpeningBraceChar: function(char)
    {
        return char === "(" || char === "{";
    },

    /**
     * @param {string} char
     * @return {boolean}
     */
    isClosingBraceChar: function(char)
    {
        return char === ")" || char === "}";
    },

    /**
     * @param {string} char
     * @return {boolean}
     */
    isBraceChar: function(char)
    {
        return WebInspector.TextUtils.isOpeningBraceChar(char) || WebInspector.TextUtils.isClosingBraceChar(char);
    },

    /**
     * @param {string} text
     * @param {function(string):boolean} isWordChar
     * @param {function(string)} wordCallback
     */
    textToWords: function(text, isWordChar, wordCallback)
    {
        var startWord = -1;
        for(var i = 0; i < text.length; ++i) {
            if (!isWordChar(text.charAt(i))) {
                if (startWord !== -1)
                    wordCallback(text.substring(startWord, i));
                startWord = -1;
            } else if (startWord === -1)
                startWord = i;
        }
        if (startWord !== -1)
            wordCallback(text.substring(startWord));
    },

    /**
     * @param {string} line
     * @return {string}
     */
    lineIndent: function(line)
    {
        var indentation = 0;
        while (indentation < line.length && WebInspector.TextUtils.isSpaceChar(line.charAt(indentation)))
            ++indentation;
        return line.substr(0, indentation);
    },

    /**
     * @param {string} text
     * @return {boolean}
     */
    isUpperCase: function(text)
    {
        return text === text.toUpperCase();
    },

    /**
     * @param {string} text
     * @return {boolean}
     */
    isLowerCase: function(text)
    {
        return text === text.toLowerCase();
    },

    /**
     * @param {string} text
     * @param {string} delimiter
     * @return {string}
     */
    _lastSectionBeforeQuery: function(text, delimiter)
    {
        var lastIndexOfDot = text.lastIndexOf(delimiter);
        var extension = lastIndexOfDot !== -1 ? text.substr(lastIndexOfDot + 1) : "";
        var indexOfQuestionMark = extension.indexOf("?");
        if (indexOfQuestionMark !== -1)
            extension = extension.substr(0, indexOfQuestionMark);
        return extension;
    },

    /**
     * @param {string} text
     * @return {string}
     */
    extension: function(text)
    {
        return WebInspector.TextUtils._lastSectionBeforeQuery(text, ".");
    },

    /**
     * @param {string} text
     * @return {string}
     */
    fileName: function(text)
    {
        return WebInspector.TextUtils._lastSectionBeforeQuery(text, "/");
    }
}

WebInspector.TextUtils._SpaceCharRegex = /\s/;

/**
 * @enum {string}
 */
WebInspector.TextUtils.Indent = {
    TwoSpaces: "  ",
    FourSpaces: "    ",
    EightSpaces: "        ",
    TabCharacter: "\t"
}

/**
 * @constructor
 * @param {function(string)} callback
 * @param {boolean=} findMultiple
 */
WebInspector.TextUtils.BalancedJSONTokenizer = function(callback, findMultiple)
{
    this._callback = callback;
    this._index = 0;
    this._balance = 0;
    this._buffer = "";
    this._findMultiple = findMultiple || false;
    this._closingDoubleQuoteRegex = /[^\\](?:\\\\)*"/g;
}

WebInspector.TextUtils.BalancedJSONTokenizer.prototype = {
    /**
     * @param {string} chunk
     */
    write: function(chunk)
    {
        this._buffer += chunk;
        var lastIndex = this._buffer.length;
        var buffer = this._buffer;
        for (var index = this._index; index < lastIndex; ++index) {
            var character = buffer[index];
            if (character === "\"") {
                this._closingDoubleQuoteRegex.lastIndex = index;
                if (!this._closingDoubleQuoteRegex.test(buffer))
                    break;
                index = this._closingDoubleQuoteRegex.lastIndex - 1;
            } else if (character === "{") {
                ++this._balance;
            } else if (character === "}") {
                if (--this._balance === 0) {
                    this._lastBalancedIndex = index + 1;
                    if (!this._findMultiple)
                        break;
                }
            }
        }
        this._index = index;
        this._reportBalanced();
    },

    _reportBalanced: function()
    {
        if (!this._lastBalancedIndex)
            return;
        this._callback(this._buffer.slice(0, this._lastBalancedIndex));
        this._buffer = this._buffer.slice(this._lastBalancedIndex);
        this._index -= this._lastBalancedIndex;
        this._lastBalancedIndex = 0;
    },

    /**
     * @return {string}
     */
    remainder: function()
    {
        return this._buffer;
    }
}

/**
 * @interface
 */
WebInspector.TokenizerFactory = function() { }

WebInspector.TokenizerFactory.prototype = {
    /**
     * @param {string} mimeType
     * @return {function(string, function(string, ?string, number, number))}
     */
    createTokenizer: function(mimeType) { }
}
;/* Throttler.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {number} timeout
 */
WebInspector.Throttler = function(timeout)
{
    this._timeout = timeout;
    this._isRunningProcess = false;
    this._asSoonAsPossible = false;
    /** @type {?function():(!Promise.<?>)} */
    this._process = null;
}

WebInspector.Throttler.prototype = {
    _processCompleted: function()
    {
        this._isRunningProcess = false;
        if (this._process)
            this._innerSchedule(false);
        this._processCompletedForTests();
    },

    _processCompletedForTests: function()
    {
        // For sniffing in tests.
    },

    _onTimeout: function()
    {
        delete this._processTimeout;
        this._asSoonAsPossible = false;
        this._isRunningProcess = true;

        Promise.resolve()
            .then(this._process)
            .catch(console.error.bind(console))
            .then(this._processCompleted.bind(this));
        this._process = null;
    },

    /**
     * @param {function():(!Promise.<?>)} process
     * @param {boolean=} asSoonAsPossible
     */
    schedule: function(process, asSoonAsPossible)
    {
        // Deliberately skip previous process.
        this._process = process;

        // Run the first scheduled task instantly.
        var hasScheduledTasks = !!this._processTimeout || this._isRunningProcess;
        asSoonAsPossible = !!asSoonAsPossible || !hasScheduledTasks;

        var forceTimerUpdate = asSoonAsPossible && !this._asSoonAsPossible;
        this._asSoonAsPossible = this._asSoonAsPossible || asSoonAsPossible;

        this._innerSchedule(forceTimerUpdate);
    },

    /**
     * @param {boolean} forceTimerUpdate
     */
    _innerSchedule: function(forceTimerUpdate)
    {
        if (this._isRunningProcess)
            return;
        if (this._processTimeout && !forceTimerUpdate)
            return;
        if (this._processTimeout)
            this._clearTimeout(this._processTimeout);

        var timeout = this._asSoonAsPossible ? 0 : this._timeout;
        this._processTimeout = this._setTimeout(this._onTimeout.bind(this), timeout);
    },

    /**
     *  @param {number} timeoutId
     */
    _clearTimeout: function(timeoutId)
    {
        clearTimeout(timeoutId);
    },

    /**
     * @param {function()} operation
     * @param {number} timeout
     * @return {number}
     */
    _setTimeout: function(operation, timeout)
    {
        return setTimeout(operation, timeout);
    }
}

/** @typedef {function(!Error=)} */
WebInspector.Throttler.FinishCallback;
;/* UIString.js */
/*
 * Copyright (C) 2011 Google Inc.  All rights reserved.
 * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.
 * Copyright (C) 2007 Matt Lilek (pewtermoose@gmail.com).
 * Copyright (C) 2009 Joseph Pecoraro
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @param {string} string
 * @param {...*} vararg
 * @return {string}
 */
WebInspector.UIString = function(string, vararg)
{
    return String.vsprintf(WebInspector.localize(string), Array.prototype.slice.call(arguments, 1));
}

/**
 * @param {string} string
 * @param {...*} vararg
 * @return {string}
 */
WebInspector.UIString.capitalize = function(string, vararg)
{
    if (WebInspector._useLowerCaseMenuTitles === undefined)
        throw "WebInspector.setLocalizationPlatform() has not been called";

    var localized = WebInspector.localize(string);
    var capitalized;
    if (WebInspector._useLowerCaseMenuTitles)
        capitalized = localized.replace(/\^(.)/g, "$1");
    else
        capitalized = localized.replace(/\^(.)/g, function(str, char) { return char.toUpperCase(); });
    return String.vsprintf(capitalized, Array.prototype.slice.call(arguments, 1));
}

/**
 * @param {string} platform
 */
WebInspector.setLocalizationPlatform = function(platform)
{
    WebInspector._useLowerCaseMenuTitles = platform === "windows";
}

/**
 * @param {string} string
 * @return {string}
 */
WebInspector.localize = function(string)
{
    return string;
}

/**
 * @constructor
 * @param {string} format
 */
WebInspector.UIStringFormat = function(format)
{
    /** @type {string} */
    this._localizedFormat = WebInspector.localize(format);
    /** @type {!Array.<!Object>} */
    this._tokenizedFormat = String.tokenizeFormatString(this._localizedFormat, String.standardFormatters);
}

/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
WebInspector.UIStringFormat._append = function(a, b)
{
    return a + b;
}

WebInspector.UIStringFormat.prototype = {
    /**
     * @param {...*} vararg
     * @return {string}
     */
    format: function(vararg)
    {
        return String.format(this._localizedFormat, arguments,
            String.standardFormatters, "", WebInspector.UIStringFormat._append, this._tokenizedFormat).formattedResult;
    }
}
;/* ModuleExtensionInterfaces.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @interface
 */
WebInspector.Renderer = function()
{
}

WebInspector.Renderer.prototype = {
    /**
     * @param {!Object} object
     * @return {!Promise.<!Element>}
     */
    render: function(object) {}
}

/**
 * @param {!Object} object
 * @return {!Promise.<!Element>}
 */
WebInspector.Renderer.renderPromise = function(object)
{
    if (!object)
        return Promise.reject(new Error("Can't render " + object));

    return self.runtime.instancePromise(WebInspector.Renderer, object).then(render);

    /**
     * @param {!WebInspector.Renderer} renderer
     */
    function render(renderer)
    {
        return renderer.render(object);
    }
}

/**
 * @interface
 */
WebInspector.Revealer = function()
{
}

/**
 * @param {?Object} revealable
 * @param {number=} lineNumber
 */
WebInspector.Revealer.reveal = function(revealable, lineNumber)
{
    WebInspector.Revealer.revealPromise(revealable, lineNumber);
}

/**
 * @param {?Object} revealable
 * @param {number=} lineNumber
 * @return {!Promise.<undefined>}
 */
WebInspector.Revealer.revealPromise = function(revealable, lineNumber)
{
    if (!revealable)
        return Promise.reject(new Error("Can't reveal " + revealable));
    return self.runtime.instancesPromise(WebInspector.Revealer, revealable).then(reveal);

    /**
     * @param {!Array.<!WebInspector.Revealer>} revealers
     * @return {!Promise.<undefined>}
     */
    function reveal(revealers)
    {
        var promises = [];
        for (var i = 0; i < revealers.length; ++i)
            promises.push(revealers[i].reveal(/** @type {!Object} */ (revealable), lineNumber));
        return Promise.race(promises);
    }
}

WebInspector.Revealer.prototype = {
    /**
     * @param {!Object} object
     * @param {number=} lineNumber
     * @return {!Promise}
     */
    reveal: function(object, lineNumber) {}
}

/**
 * @interface
 */
WebInspector.App = function()
{
}

WebInspector.App.prototype = {
    /**
     * @param {!Document} document
     */
    presentUI: function(document) { }
}

/**
 * @interface
 */
WebInspector.AppProvider = function()
{
}

WebInspector.AppProvider.prototype = {
    /**
     * @return {!WebInspector.App}
     */
    createApp: function() { }
}

/**
 * @interface
 */
WebInspector.QueryParamHandler = function()
{
}

WebInspector.QueryParamHandler.prototype = {
    /**
     * @param {string} value
     */
    handleQueryParam: function(value) { }
}
;
/* Module host */
/* InspectorFrontendHostAPI.js */
// Copyright (c) 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


/** @interface */
function InspectorFrontendHostAPI()
{
}

/** @typedef
{{
    type: string,
    id: (number|undefined),
    label: (string|undefined),
    enabled: (boolean|undefined),
    checked: (boolean|undefined),
    subItems: (!Array.<!InspectorFrontendHostAPI.ContextMenuDescriptor>|undefined)
}} */
InspectorFrontendHostAPI.ContextMenuDescriptor;

/** @typedef
{{
    statusCode: number,
    headers: (!Object.<string, string>|undefined)
}} */
InspectorFrontendHostAPI.LoadNetworkResourceResult;

InspectorFrontendHostAPI.Events = {
    AddExtensions: "addExtensions",
    AppendedToURL: "appendedToURL",
    CanceledSaveURL: "canceledSaveURL",
    ContextMenuCleared: "contextMenuCleared",
    ContextMenuItemSelected: "contextMenuItemSelected",
    DeviceCountUpdated: "deviceCountUpdated",
    DevicesDiscoveryConfigChanged: "devicesDiscoveryConfigChanged",
    DevicesPortForwardingStatusChanged: "devicesPortForwardingStatusChanged",
    DevicesUpdated: "devicesUpdated",
    DispatchMessage: "dispatchMessage",
    DispatchMessageChunk: "dispatchMessageChunk",
    DispatchFrontendAPIMessage: "dispatchFrontendAPIMessage",
    EnterInspectElementMode: "enterInspectElementMode",
    FileSystemsLoaded: "fileSystemsLoaded",
    FileSystemRemoved: "fileSystemRemoved",
    FileSystemAdded: "fileSystemAdded",
    FileSystemFilesChanged: "fileSystemFilesChanged",
    FrontendAPIAttached: "frontendAPIAttached",
    FrontendAPIDetached: "frontendAPIDetached",
    IndexingTotalWorkCalculated: "indexingTotalWorkCalculated",
    IndexingWorked: "indexingWorked",
    IndexingDone: "indexingDone",
    KeyEventUnhandled: "keyEventUnhandled",
    ReloadInspectedPage: "reloadInspectedPage",
    RevealSourceLine: "revealSourceLine",
    SavedURL: "savedURL",
    SearchCompleted: "searchCompleted",
    SetInspectedTabId: "setInspectedTabId",
    SetUseSoftMenu: "setUseSoftMenu",
    ShowPanel: "showPanel"
}

InspectorFrontendHostAPI.EventDescriptors = [
    [InspectorFrontendHostAPI.Events.AddExtensions, ["extensions"]],
    [InspectorFrontendHostAPI.Events.AppendedToURL, ["url"]],
    [InspectorFrontendHostAPI.Events.CanceledSaveURL, ["url"]],
    [InspectorFrontendHostAPI.Events.ContextMenuCleared, []],
    [InspectorFrontendHostAPI.Events.ContextMenuItemSelected, ["id"]],
    [InspectorFrontendHostAPI.Events.DeviceCountUpdated, ["count"]],
    [InspectorFrontendHostAPI.Events.DevicesDiscoveryConfigChanged, ["discoverUsbDevices", "portForwardingEnabled", "portForwardingConfig"]],
    [InspectorFrontendHostAPI.Events.DevicesPortForwardingStatusChanged, ["status"]],
    [InspectorFrontendHostAPI.Events.DevicesUpdated, ["devices"]],
    [InspectorFrontendHostAPI.Events.DispatchMessage, ["messageObject"]],
    [InspectorFrontendHostAPI.Events.DispatchMessageChunk, ["messageChunk", "messageSize"]],
    [InspectorFrontendHostAPI.Events.DispatchFrontendAPIMessage, ["messageObject"]],
    [InspectorFrontendHostAPI.Events.EnterInspectElementMode, []],
    [InspectorFrontendHostAPI.Events.FileSystemsLoaded, ["fileSystems"]],
    [InspectorFrontendHostAPI.Events.FileSystemRemoved, ["fileSystemPath"]],
    [InspectorFrontendHostAPI.Events.FileSystemAdded, ["errorMessage", "fileSystem"]],
    [InspectorFrontendHostAPI.Events.FileSystemFilesChanged, ["paths"]],
    [InspectorFrontendHostAPI.Events.FrontendAPIAttached, ["frontendAPIAttached"]],
    [InspectorFrontendHostAPI.Events.FrontendAPIDetached, ["frontendAPIDetached"]],
    [InspectorFrontendHostAPI.Events.IndexingTotalWorkCalculated, ["requestId", "fileSystemPath", "totalWork"]],
    [InspectorFrontendHostAPI.Events.IndexingWorked, ["requestId", "fileSystemPath", "worked"]],
    [InspectorFrontendHostAPI.Events.IndexingDone, ["requestId", "fileSystemPath"]],
    [InspectorFrontendHostAPI.Events.KeyEventUnhandled, ["event"]],
    [InspectorFrontendHostAPI.Events.ReloadInspectedPage, ["hard"]],
    [InspectorFrontendHostAPI.Events.RevealSourceLine, ["url", "lineNumber", "columnNumber"]],
    [InspectorFrontendHostAPI.Events.SavedURL, ["url"]],
    [InspectorFrontendHostAPI.Events.SearchCompleted, ["requestId", "fileSystemPath", "files"]],
    [InspectorFrontendHostAPI.Events.SetInspectedTabId, ["tabId"]],
    [InspectorFrontendHostAPI.Events.SetUseSoftMenu, ["useSoftMenu"]],
    [InspectorFrontendHostAPI.Events.ShowPanel, ["panelName"]]
];

InspectorFrontendHostAPI.prototype = {
    /**
     * @param {string=} fileSystemPath
     */
    addFileSystem: function(fileSystemPath) { },

    /**
     * @param {string} url
     * @param {string} content
     */
    append: function(url, content) { },

    loadCompleted: function() { },

    /**
     * @param {number} requestId
     * @param {string} fileSystemPath
     */
    indexPath: function(requestId, fileSystemPath) { },

    /**
     * @return {string}
     */
    getSelectionBackgroundColor: function() { },

    /**
     * @return {string}
     */
    getSelectionForegroundColor: function() { },

    /**
     * Requests inspected page to be placed atop of the inspector frontend with specified bounds.
     * @param {{x: number, y: number, width: number, height: number}} bounds
     */
    setInspectedPageBounds: function(bounds) { },

    /**
     * @param {string} shortcuts
     */
    setWhitelistedShortcuts: function(shortcuts) { },

    inspectElementCompleted: function() { },

    /**
     * @param {string} url
     */
    openInNewTab: function(url) { },

    /**
     * @param {string} fileSystemPath
     */
    removeFileSystem: function(fileSystemPath) { },

    requestFileSystems: function() { },

    /**
     * @param {string} url
     * @param {string} content
     * @param {boolean} forceSaveAs
     */
    save: function(url, content, forceSaveAs) { },

    /**
     * @param {number} requestId
     * @param {string} fileSystemPath
     * @param {string} query
     */
    searchInPath: function(requestId, fileSystemPath, query) { },

    /**
     * @param {number} requestId
     */
    stopIndexing: function(requestId) { },

    bringToFront: function() { },

    closeWindow: function() { },

    copyText: function(text) { },

    /**
     * @param {string} url
     */
    inspectedURLChanged: function(url) { },

    /**
     * @param {string} fileSystemId
     * @param {string} registeredName
     * @return {?DOMFileSystem}
     */
    isolatedFileSystem: function(fileSystemId, registeredName) { },

    /**
     * @param {string} url
     * @param {string} headers
     * @param {number} streamId
     * @param {function(!InspectorFrontendHostAPI.LoadNetworkResourceResult)} callback
     */
    loadNetworkResource: function(url, headers, streamId, callback) { },

    /**
     * @param {function(!Object<string, string>)} callback
     */
    getPreferences: function(callback) { },

    /**
     * @param {string} name
     * @param {string} value
     */
    setPreference: function(name, value) { },

    /**
     * @param {string} name
     */
    removePreference: function(name) { },

    clearPreferences: function() { },

    /**
     * @param {!FileSystem} fileSystem
     */
    upgradeDraggedFileSystemPermissions: function(fileSystem) { },

    /**
     * @return {string}
     */
    platform: function() { },

    /**
     * @param {string} actionName
     * @param {number} actionCode
     * @param {number} bucketSize
     */
    recordEnumeratedHistogram: function(actionName, actionCode, bucketSize) { },

    /**
     * @param {string} message
     */
    sendMessageToBackend: function(message) { },

    /**
     * @param {boolean} discoverUsbDevices
     * @param {boolean} portForwardingEnabled
     * @param {!Adb.PortForwardingConfig} portForwardingConfig
     */
    setDevicesDiscoveryConfig: function(discoverUsbDevices, portForwardingEnabled, portForwardingConfig) { },

    /**
     * @param {boolean} enabled
     */
    setDevicesUpdatesEnabled: function(enabled) { },

    /**
     * @param {string} pageId
     * @param {string} action
     */
    performActionOnRemotePage: function(pageId, action) { },

    /**
     * @param {string} browserId
     * @param {string} url
     */
    openRemotePage: function(browserId, url) { },

    /**
     * @param {string} origin
     * @param {string} script
     */
    setInjectedScriptForOrigin: function(origin, script) { },

    /**
     * @param {boolean} isDocked
     * @param {function()} callback
     */
    setIsDocked: function(isDocked, callback) { },

    /**
     * @return {number}
     */
    zoomFactor: function() { },

    zoomIn: function() { },

    zoomOut: function() { },

    resetZoom: function() { },

    /**
     * @param {number} x
     * @param {number} y
     * @param {!Array.<!InspectorFrontendHostAPI.ContextMenuDescriptor>} items
     * @param {!Document} document
     */
    showContextMenuAtPoint: function(x, y, items, document) { },

    /**
     * @return {boolean}
     */
    isUnderTest: function() { },

    /**
     * @return {boolean}
     */
    isHostedMode: function() { },

    /**
     * @param {string} message
     */
    sendFrontendAPINotification: function(message) { }
}
;/* InspectorFrontendHost.js */
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @implements {InspectorFrontendHostAPI}
 * @suppressGlobalPropertiesCheck
 */
WebInspector.InspectorFrontendHostStub = function()
{
    /**
     * @param {!Event} event
     */
    function stopEventPropagation(event)
    {
        // Let browser handle Ctrl+/Ctrl- shortcuts in hosted mode.
        var zoomModifier = WebInspector.isMac() ? event.metaKey : event.ctrlKey;
        if (zoomModifier && (event.keyCode === 187 || event.keyCode === 189))
            event.stopPropagation();
    }
    document.addEventListener("keydown", stopEventPropagation, true);
}

WebInspector.InspectorFrontendHostStub.prototype = {
    /**
     * @override
     * @return {string}
     */
    getSelectionBackgroundColor: function()
    {
        return "#6e86ff";
    },

    /**
     * @override
     * @return {string}
     */
    getSelectionForegroundColor: function()
    {
        return "#ffffff";
    },

    /**
     * @override
     * @return {string}
     */
    platform: function()
    {
        var match = navigator.userAgent.match(/Windows NT/);
        if (match)
            return "windows";
        match = navigator.userAgent.match(/Mac OS X/);
        if (match)
            return "mac";
        return "linux";
    },

    /**
     * @override
     */
    loadCompleted: function()
    {
    },

    /**
     * @override
     */
    bringToFront: function()
    {
        this._windowVisible = true;
    },

    /**
     * @override
     */
    closeWindow: function()
    {
        this._windowVisible = false;
    },

    /**
     * @override
     * @param {boolean} isDocked
     * @param {function()} callback
     */
    setIsDocked: function(isDocked, callback)
    {
        setTimeout(callback, 0);
    },

    /**
     * Requests inspected page to be placed atop of the inspector frontend with specified bounds.
     * @override
     * @param {{x: number, y: number, width: number, height: number}} bounds
     */
    setInspectedPageBounds: function(bounds)
    {
    },

    /**
     * @override
     */
    inspectElementCompleted: function()
    {
    },

    /**
     * @override
     * @param {string} origin
     * @param {string} script
     */
    setInjectedScriptForOrigin: function(origin, script)
    {
    },

    /**
     * @override
     * @param {string} url
     * @suppressGlobalPropertiesCheck
     */
    inspectedURLChanged: function(url)
    {
        document.title = WebInspector.UIString("Developer Tools - %s", url);
    },

    /**
     * @override
     * @param {string} text
     */
    copyText: function(text)
    {
        WebInspector.console.error("Clipboard is not enabled in hosted mode. Please inspect using chrome://inspect");
    },

    /**
     * @override
     * @param {string} url
     */
    openInNewTab: function(url)
    {
        window.open(url, "_blank");
    },

    /**
     * @override
     * @param {string} url
     * @param {string} content
     * @param {boolean} forceSaveAs
     */
    save: function(url, content, forceSaveAs)
    {
        WebInspector.console.error("Saving files is not enabled in hosted mode. Please inspect using chrome://inspect");
        this.events.dispatchEventToListeners(InspectorFrontendHostAPI.Events.CanceledSaveURL, url);
    },

    /**
     * @override
     * @param {string} url
     * @param {string} content
     */
    append: function(url, content)
    {
        WebInspector.console.error("Saving files is not enabled in hosted mode. Please inspect using chrome://inspect");
    },

    /**
     * @override
     * @param {string} message
     */
    sendMessageToBackend: function(message)
    {
    },

    /**
     * @override
     * @param {string} actionName
     * @param {number} actionCode
     * @param {number} bucketSize
     */
    recordEnumeratedHistogram: function(actionName, actionCode, bucketSize)
    {
    },

    /**
     * @override
     */
    requestFileSystems: function()
    {
        this.events.dispatchEventToListeners(InspectorFrontendHostAPI.Events.FileSystemsLoaded, []);
    },

    /**
     * @override
     * @param {string=} fileSystemPath
     */
    addFileSystem: function(fileSystemPath)
    {
    },

    /**
     * @override
     * @param {string} fileSystemPath
     */
    removeFileSystem: function(fileSystemPath)
    {
    },

    /**
     * @override
     * @param {string} fileSystemId
     * @param {string} registeredName
     * @return {?DOMFileSystem}
     */
    isolatedFileSystem: function(fileSystemId, registeredName)
    {
        return null;
    },

    /**
     * @override
     * @param {string} url
     * @param {string} headers
     * @param {number} streamId
     * @param {function(!InspectorFrontendHostAPI.LoadNetworkResourceResult)} callback
     */
    loadNetworkResource: function(url, headers, streamId, callback)
    {
        loadResourcePromise(url).then(function(text) {
            WebInspector.ResourceLoader.streamWrite(streamId, text);
            callback({statusCode : 200});
        }).catch(function() {
            callback({statusCode : 404});
        });
    },

    /**
     * @override
     * @param {function(!Object<string, string>)} callback
     */
    getPreferences: function(callback)
    {
        var prefs = {};
        for (var name in window.localStorage)
            prefs[name] = window.localStorage[name];
        callback(prefs);
    },

    /**
     * @override
     * @param {string} name
     * @param {string} value
     */
    setPreference: function(name, value)
    {
        window.localStorage[name] = value;
    },

    /**
     * @override
     * @param {string} name
     */
    removePreference: function(name)
    {
        delete window.localStorage[name];
    },

    /**
     * @override
     */
    clearPreferences: function()
    {
        window.localStorage.clear();
    },

    /**
     * @override
     * @param {!FileSystem} fileSystem
     */
    upgradeDraggedFileSystemPermissions: function(fileSystem)
    {
    },

    /**
     * @override
     * @param {number} requestId
     * @param {string} fileSystemPath
     */
    indexPath: function(requestId, fileSystemPath)
    {
    },

    /**
     * @override
     * @param {number} requestId
     */
    stopIndexing: function(requestId)
    {
    },

    /**
     * @override
     * @param {number} requestId
     * @param {string} fileSystemPath
     * @param {string} query
     */
    searchInPath: function(requestId, fileSystemPath, query)
    {
    },

    /**
     * @override
     * @return {number}
     */
    zoomFactor: function()
    {
        return 1;
    },

    /**
     * @override
     */
    zoomIn: function()
    {
    },

    /**
     * @override
     */
    zoomOut: function()
    {
    },

    /**
     * @override
     */
    resetZoom: function()
    {
    },

    /**
     * @override
     * @param {string} shortcuts
     */
    setWhitelistedShortcuts: function(shortcuts)
    {
    },

    /**
     * @override
     * @return {boolean}
     */
    isUnderTest: function()
    {
        return false;
    },

    /**
     * @override
     * @param {boolean} discoverUsbDevices
     * @param {boolean} portForwardingEnabled
     * @param {!Adb.PortForwardingConfig} portForwardingConfig
     */
    setDevicesDiscoveryConfig: function(discoverUsbDevices, portForwardingEnabled, portForwardingConfig)
    {
    },

    /**
     * @override
     * @param {boolean} enabled
     */
    setDevicesUpdatesEnabled: function(enabled)
    {
    },

    /**
     * @override
     * @param {string} pageId
     * @param {string} action
     */
    performActionOnRemotePage: function(pageId, action)
    {
    },

    /**
     * @override
     * @param {string} browserId
     * @param {string} url
     */
    openRemotePage: function(browserId, url)
    {
    },

    /**
     * @override
     * @param {number} x
     * @param {number} y
     * @param {!Array.<!InspectorFrontendHostAPI.ContextMenuDescriptor>} items
     * @param {!Document} document
     */
    showContextMenuAtPoint: function(x, y, items, document)
    {
        throw "Soft context menu should be used";
    },

    /**
     * @override
     * @return {boolean}
     */
    isHostedMode: function()
    {
        return true;
    },

    /**
     * @override
     * @param {string} message
     */
    sendFrontendAPINotification: function(message)
    {
    }
};

/**
 * @type {!InspectorFrontendHostAPI}
 */
var InspectorFrontendHost = window.InspectorFrontendHost || null;

(function(){

    function initializeInspectorFrontendHost()
    {
        if (!InspectorFrontendHost) {
            // Instantiate stub for web-hosted mode if necessary.
            InspectorFrontendHost = new WebInspector.InspectorFrontendHostStub();
        } else {
            // Otherwise add stubs for missing methods that are declared in the interface.
            var proto = WebInspector.InspectorFrontendHostStub.prototype;
            for (var name in proto) {
                var value = proto[name];
                if (typeof value !== "function" || InspectorFrontendHost[name])
                    continue;

                InspectorFrontendHost[name] = stub.bind(null, name);
            }
        }

        /**
         * @param {string} name
         * @return {?}
         */
        function stub(name)
        {
            console.error("Incompatible embedder: method InspectorFrontendHost." + name + " is missing. Using stub instead.");
            var args = Array.prototype.slice.call(arguments, 1);
            return proto[name].apply(InspectorFrontendHost, args);
        }

        // Attach the events object.
        InspectorFrontendHost.events = new WebInspector.Object();
    }

    /**
     * @constructor
     */
    function InspectorFrontendAPIImpl()
    {
        this._debugFrontend = !!Runtime.queryParam("debugFrontend") || (window["InspectorTest"] && window["InspectorTest"]["debugTest"]);

        var descriptors = InspectorFrontendHostAPI.EventDescriptors;
        for (var i = 0; i < descriptors.length; ++i)
            this[descriptors[i][0]] = this._dispatch.bind(this, descriptors[i][0], descriptors[i][1], descriptors[i][2]);
    }

    InspectorFrontendAPIImpl.prototype = {
        /**
         * @param {string} name
         * @param {!Array.<string>} signature
         * @param {boolean} runOnceLoaded
         */
        _dispatch: function(name, signature, runOnceLoaded)
        {
            var params = Array.prototype.slice.call(arguments, 3);

            if (this._debugFrontend)
                setImmediate(innerDispatch);
            else
                innerDispatch();

            function innerDispatch()
            {
                // Single argument methods get dispatched with the param.
                if (signature.length < 2) {
                    try {
                        InspectorFrontendHost.events.dispatchEventToListeners(name, params[0]);
                    } catch(e) {
                        console.error(e + " " + e.stack);
                    }
                    return;
                }
                var data = {};
                for (var i = 0; i < signature.length; ++i)
                    data[signature[i]] = params[i];
                try {
                    InspectorFrontendHost.events.dispatchEventToListeners(name, data);
                } catch(e) {
                    console.error(e + " " + e.stack);
                }
            }
        },

        /**
         * @param {number} id
         * @param {string} chunk
         */
        streamWrite: function(id, chunk)
        {
            WebInspector.ResourceLoader.streamWrite(id, chunk);
        }
    }

    // FIXME: This file is included into both apps, since the devtools_app needs the InspectorFrontendHostAPI only,
    // so the host instance should not initialized there.
    initializeInspectorFrontendHost();
    window.InspectorFrontendAPI = new InspectorFrontendAPIImpl();
    WebInspector.setLocalizationPlatform(InspectorFrontendHost.platform());
})();

/**
 * @type {!WebInspector.EventTarget}
 */
InspectorFrontendHost.events;
;/* Platform.js */
/*
 * Copyright (C) 2014 Google Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @return {string}
 */
WebInspector.platform = function()
{
    if (!WebInspector._platform)
        WebInspector._platform = InspectorFrontendHost.platform();
    return WebInspector._platform;
}

/**
 * @return {boolean}
 */
WebInspector.isMac = function()
{
    if (typeof WebInspector._isMac === "undefined")
        WebInspector._isMac = WebInspector.platform() === "mac";

    return WebInspector._isMac;
}

/**
 * @return {boolean}
 */
WebInspector.isWin = function()
{
    if (typeof WebInspector._isWin === "undefined")
        WebInspector._isWin = WebInspector.platform() === "windows";

    return WebInspector._isWin;
}

/**
 * @return {string}
 */
WebInspector.fontFamily = function()
{
    if (WebInspector._fontFamily)
        return WebInspector._fontFamily;
    switch (WebInspector.platform()) {
    case "linux":
        WebInspector._fontFamily = "Ubuntu, Arial, sans-serif";
        break;
    case "mac":
        WebInspector._fontFamily = "'Lucida Grande', sans-serif";
        break;
    case "windows":
        WebInspector._fontFamily = "'Segoe UI', Tahoma, sans-serif";
        break;
    }
    return WebInspector._fontFamily;
}

/**
 * @return {string}
 */
WebInspector.monospaceFontFamily = function()
{
    if (WebInspector._monospaceFontFamily)
        return WebInspector._monospaceFontFamily;
    switch (WebInspector.platform()) {
    case "linux":
        WebInspector._monospaceFontFamily = "dejavu sans mono, monospace";
        break;
    case "mac":
        WebInspector._monospaceFontFamily = "Menlo, monospace";
        break;
    case "windows":
        WebInspector._monospaceFontFamily = "Consolas, monospace";
        break;
    }
    return WebInspector._monospaceFontFamily;
}
;/* ResourceLoader.js */
// Copyright (c) 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

WebInspector.ResourceLoader = {}

WebInspector.ResourceLoader._lastStreamId = 0;
/** @type {!Object.<number, !WebInspector.OutputStream>} */
WebInspector.ResourceLoader._boundStreams = {};

/**
 * @param {!WebInspector.OutputStream} stream
 * @return {number}
 */
WebInspector.ResourceLoader._bindOutputStream = function(stream)
{
    WebInspector.ResourceLoader._boundStreams[++WebInspector.ResourceLoader._lastStreamId] = stream;
    return WebInspector.ResourceLoader._lastStreamId;
}

/**
 * @param {number} id
 */
WebInspector.ResourceLoader._discardOutputStream = function(id)
{
    WebInspector.ResourceLoader._boundStreams[id].close();
    delete WebInspector.ResourceLoader._boundStreams[id];
}

/**
 * @param {number} id
 * @param {string} chunk
 */
WebInspector.ResourceLoader.streamWrite = function(id, chunk)
{
    WebInspector.ResourceLoader._boundStreams[id].write(chunk);
}

/**
 * @param {string} url
 * @param {?Object.<string, string>} headers
 * @param {function(number, !Object.<string, string>, string)} callback
 */
WebInspector.ResourceLoader.load = function(url, headers, callback)
{
    var stream = new WebInspector.StringOutputStream();
    WebInspector.ResourceLoader.loadAsStream(url, headers, stream, mycallback);

    /**
     * @param {number} statusCode
     * @param {!Object.<string, string>} headers
     */
    function mycallback(statusCode, headers)
    {
        callback(statusCode, headers, stream.data());
    }
}

/**
 * @param {string} url
 * @param {?Object.<string, string>} headers
 * @param {!WebInspector.OutputStream} stream
 * @param {function(number, !Object.<string, string>)=} callback
 */
WebInspector.ResourceLoader.loadAsStream = function(url, headers, stream, callback)
{
    var streamId = WebInspector.ResourceLoader._bindOutputStream(stream);
    var parsedURL = new WebInspector.ParsedURL(url);
    if (parsedURL.isDataURL()) {
        loadXHR(url)
            .then(dataURLDecodeSuccessful)
            .catch(dataURLDecodeFailed);
        return;
    }

    var rawHeaders = [];
    if (headers) {
        for (var key in headers)
            rawHeaders.push(key + ": " + headers[key]);
    }
    InspectorFrontendHost.loadNetworkResource(url, rawHeaders.join("\r\n"), streamId, finishedCallback);

    /**
     * @param {!InspectorFrontendHostAPI.LoadNetworkResourceResult} response
     */
    function finishedCallback(response)
    {
        if (callback)
            callback(response.statusCode, response.headers || {});
        WebInspector.ResourceLoader._discardOutputStream(streamId);
    }

    /**
     * @param {string} text
     */
    function dataURLDecodeSuccessful(text)
    {
        WebInspector.ResourceLoader.streamWrite(streamId, text);
        finishedCallback(/** @type {!InspectorFrontendHostAPI.LoadNetworkResourceResult} */ ({statusCode : 200}));
    }

    function dataURLDecodeFailed()
    {
        finishedCallback(/** @type {!InspectorFrontendHostAPI.LoadNetworkResourceResult} */ ({statusCode : 404}));
    }
}
;/* UserMetrics.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 */
WebInspector.UserMetrics = function()
{
}

// Codes below are used to collect UMA histograms in the Chromium port.
// Do not change the values below, additional actions are needed on the Chromium side
// in order to add more codes.

/** @enum {number} */
WebInspector.UserMetrics.Action = {
    WindowDocked: 1,
    WindowUndocked: 2,
    ScriptsBreakpointSet: 3,
    TimelineStarted: 4,
    ProfilesCPUProfileTaken: 5,
    ProfilesHeapProfileTaken: 6,
    AuditsStarted: 7,
    ConsoleEvaluated: 8,
    FileSavedInWorkspace: 9,
    DeviceModeEnabled: 10,
    AnimationsPlaybackRateChanged: 11,
    RevisionApplied: 12,
    FileSystemDirectoryContentReceived: 13,
    StyleRuleEdited: 14,
    CommandEvaluatedInConsolePanel: 15,
    DOMPropertiesExpanded: 16,
    ResizedViewInResponsiveMode: 17
}

WebInspector.UserMetrics._PanelCodes = {
    elements: 1,
    resources: 2,
    network: 3,
    sources: 4,
    timeline: 5,
    profiles: 6,
    audits: 7,
    console: 8,
    layers: 9,
    "drawer-console": 10,
    "drawer-animations": 11,
    "drawer-network.config": 12,
    "drawer-rendering": 13,
    "drawer-sensors": 14,
    "drawer-sources.search": 15
}

WebInspector.UserMetrics.prototype = {
    /**
     * @param {string} panelName
     */
    panelShown: function(panelName)
    {
        var code = WebInspector.UserMetrics._PanelCodes[panelName] || 0;
        var size = Object.keys(WebInspector.UserMetrics._PanelCodes).length + 1;
        InspectorFrontendHost.recordEnumeratedHistogram("DevTools.PanelShown", code, size);
    },

    /**
     * @param {string} drawerId
     */
    drawerShown: function(drawerId)
    {
        this.panelShown("drawer-" + drawerId);
    },

    /**
     * @param {!WebInspector.UserMetrics.Action} action
     */
    actionTaken: function(action)
    {
        var size = Object.keys(WebInspector.UserMetrics.Action).length + 1;
        InspectorFrontendHost.recordEnumeratedHistogram("DevTools.ActionTaken", action, size);
    }
}

/** @type {!WebInspector.UserMetrics} */
WebInspector.userMetrics = new WebInspector.UserMetrics();
;
/* Module ui */
/* Widget.js */
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 * Copyright (C) 2011 Google Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @param {boolean=} isWebComponent
 */
WebInspector.Widget = function(isWebComponent)
{
    this.contentElement = createElementWithClass("div", "widget");
    if (isWebComponent) {
        this.element = createElementWithClass("div", "vbox flex-auto");
        this._shadowRoot = WebInspector.createShadowRootWithCoreStyles(this.element);
        this._shadowRoot.appendChild(this.contentElement);
    } else {
        this.element = this.contentElement;
    }
    this._isWebComponent = isWebComponent;
    this.element.__widget = this;
    this._visible = true;
    this._isRoot = false;
    this._isShowing = false;
    this._children = [];
    this._hideOnDetach = false;
    this._notificationDepth = 0;
}

WebInspector.Widget.prototype = {
    markAsRoot: function()
    {
        WebInspector.Widget.__assert(!this.element.parentElement, "Attempt to mark as root attached node");
        this._isRoot = true;
    },

    /**
     * @return {?WebInspector.Widget}
     */
    parentWidget: function()
    {
        return this._parentWidget;
    },

    /**
     * @return {!Array.<!WebInspector.Widget>}
     */
    children: function()
    {
        return this._children;
    },

    /**
     * @param {!WebInspector.Widget} widget
     * @protected
     */
    childWasDetached: function(widget)
    {
    },

    /**
     * @return {boolean}
     */
    isShowing: function()
    {
        return this._isShowing;
    },

    /**
     * @return {boolean}
     */
    shouldHideOnDetach: function()
    {
        if (this._hideOnDetach)
            return true;
        for (var child of this._children) {
            if (child.shouldHideOnDetach())
                return true;
        }
        return false;
    },

    setHideOnDetach: function()
    {
        this._hideOnDetach = true;
    },

    /**
     * @return {boolean}
     */
    _inNotification: function()
    {
        return !!this._notificationDepth || (this._parentWidget && this._parentWidget._inNotification());
    },

    _parentIsShowing: function()
    {
        if (this._isRoot)
            return true;
        return this._parentWidget && this._parentWidget.isShowing();
    },

    /**
     * @param {function(this:WebInspector.Widget)} method
     */
    _callOnVisibleChildren: function(method)
    {
        var copy = this._children.slice();
        for (var i = 0; i < copy.length; ++i) {
            if (copy[i]._parentWidget === this && copy[i]._visible)
                method.call(copy[i]);
        }
    },

    _processWillShow: function()
    {
        this._callOnVisibleChildren(this._processWillShow);
        this._isShowing = true;
    },

    _processWasShown: function()
    {
        if (this._inNotification())
            return;
        this.restoreScrollPositions();
        this._notify(this.wasShown);
        this._callOnVisibleChildren(this._processWasShown);
    },

    _processWillHide: function()
    {
        if (this._inNotification())
            return;
        this.storeScrollPositions();

        this._callOnVisibleChildren(this._processWillHide);
        this._notify(this.willHide);
        this._isShowing = false;
    },

    _processWasHidden: function()
    {
        this._callOnVisibleChildren(this._processWasHidden);
    },

    _processOnResize: function()
    {
        if (this._inNotification())
            return;
        if (!this.isShowing())
            return;
        this._notify(this.onResize);
        this._callOnVisibleChildren(this._processOnResize);
    },

    /**
     * @param {function(this:WebInspector.Widget)} notification
     */
    _notify: function(notification)
    {
        ++this._notificationDepth;
        try {
            notification.call(this);
        } finally {
            --this._notificationDepth;
        }
    },

    wasShown: function()
    {
    },

    willHide: function()
    {
    },

    onResize: function()
    {
    },

    onLayout: function()
    {
    },

    /**
     * @param {?Element} parentElement
     * @param {?Element=} insertBefore
     */
    show: function(parentElement, insertBefore)
    {
        WebInspector.Widget.__assert(parentElement, "Attempt to attach widget with no parent element");

        // Update widget hierarchy.
        if (this.element.parentElement !== parentElement) {
            if (this.element.parentElement)
                this.detach();

            var currentParent = parentElement;
            while (currentParent && !currentParent.__widget)
                currentParent = currentParent.parentElementOrShadowHost();

            if (currentParent) {
                this._parentWidget = currentParent.__widget;
                this._parentWidget._children.push(this);
                this._isRoot = false;
            } else
                WebInspector.Widget.__assert(this._isRoot, "Attempt to attach widget to orphan node");
        } else if (this._visible) {
            return;
        }

        this._visible = true;

        if (this._parentIsShowing())
            this._processWillShow();

        this.element.classList.remove("hidden");

        // Reparent
        if (this.element.parentElement !== parentElement) {
            WebInspector.Widget._incrementWidgetCounter(parentElement, this.element);
            if (insertBefore)
                WebInspector.Widget._originalInsertBefore.call(parentElement, this.element, insertBefore);
            else
                WebInspector.Widget._originalAppendChild.call(parentElement, this.element);
        }

        if (this._parentIsShowing())
            this._processWasShown();

        if (this._parentWidget && this._hasNonZeroConstraints())
            this._parentWidget.invalidateConstraints();
        else
            this._processOnResize();
    },

    /**
     * @param {boolean=} overrideHideOnDetach
     */
    detach: function(overrideHideOnDetach)
    {
        var parentElement = this.element.parentElement;
        if (!parentElement)
            return;

        if (this._parentIsShowing())
            this._processWillHide();

        if (!overrideHideOnDetach && this.shouldHideOnDetach()) {
            this.element.classList.add("hidden");
            this._visible = false;
            if (this._parentIsShowing())
                this._processWasHidden();
            if (this._parentWidget && this._hasNonZeroConstraints())
                this._parentWidget.invalidateConstraints();
            return;
        }

        // Force legal removal
        WebInspector.Widget._decrementWidgetCounter(parentElement, this.element);
        WebInspector.Widget._originalRemoveChild.call(parentElement, this.element);

        this._visible = false;
        if (this._parentIsShowing())
            this._processWasHidden();

        // Update widget hierarchy.
        if (this._parentWidget) {
            var childIndex = this._parentWidget._children.indexOf(this);
            WebInspector.Widget.__assert(childIndex >= 0, "Attempt to remove non-child widget");
            this._parentWidget._children.splice(childIndex, 1);
            this._parentWidget.childWasDetached(this);
            var parent = this._parentWidget;
            this._parentWidget = null;
            if (this._hasNonZeroConstraints())
                parent.invalidateConstraints();
        } else
            WebInspector.Widget.__assert(this._isRoot, "Removing non-root widget from DOM");
    },

    detachChildWidgets: function()
    {
        var children = this._children.slice();
        for (var i = 0; i < children.length; ++i)
            children[i].detach();
    },

    /**
     * @return {!Array.<!Element>}
     */
    elementsToRestoreScrollPositionsFor: function()
    {
        return [this.element];
    },

    storeScrollPositions: function()
    {
        var elements = this.elementsToRestoreScrollPositionsFor();
        for (var i = 0; i < elements.length; ++i) {
            var container = elements[i];
            container._scrollTop = container.scrollTop;
            container._scrollLeft = container.scrollLeft;
        }
    },

    restoreScrollPositions: function()
    {
        var elements = this.elementsToRestoreScrollPositionsFor();
        for (var i = 0; i < elements.length; ++i) {
            var container = elements[i];
            if (container._scrollTop)
                container.scrollTop = container._scrollTop;
            if (container._scrollLeft)
                container.scrollLeft = container._scrollLeft;
        }
    },

    doResize: function()
    {
        if (!this.isShowing())
            return;
        // No matter what notification we are in, dispatching onResize is not needed.
        if (!this._inNotification())
            this._callOnVisibleChildren(this._processOnResize);
    },

    doLayout: function()
    {
        if (!this.isShowing())
            return;
        this._notify(this.onLayout);
        this.doResize();
    },

    /**
     * @param {string} cssFile
     */
    registerRequiredCSS: function(cssFile)
    {
        WebInspector.appendStyle(this._isWebComponent ? this._shadowRoot : this.element, cssFile);
    },

    printWidgetHierarchy: function()
    {
        var lines = [];
        this._collectWidgetHierarchy("", lines);
        console.log(lines.join("\n"));
    },

    _collectWidgetHierarchy: function(prefix, lines)
    {
        lines.push(prefix + "[" + this.element.className + "]" + (this._children.length ? " {" : ""));

        for (var i = 0; i < this._children.length; ++i)
            this._children[i]._collectWidgetHierarchy(prefix + "    ", lines);

        if (this._children.length)
            lines.push(prefix + "}");
    },

    /**
     * @return {!Element}
     */
    defaultFocusedElement: function()
    {
        return this._defaultFocusedElement || this.element;
    },

    /**
     * @param {!Element} element
     */
    setDefaultFocusedElement: function(element)
    {
        this._defaultFocusedElement = element;
    },

    focus: function()
    {
        var element = this.defaultFocusedElement();
        if (!element || element.isAncestor(this.element.ownerDocument.activeElement))
            return;

        WebInspector.setCurrentFocusElement(element);
    },

    /**
     * @return {boolean}
     */
    hasFocus: function()
    {
        var activeElement = this.element.ownerDocument.activeElement;
        return activeElement && activeElement.isSelfOrDescendant(this.element);
    },

    /**
     * @return {!Size}
     */
    measurePreferredSize: function()
    {
        var document = this.element.ownerDocument;
        WebInspector.Widget._originalAppendChild.call(document.body, this.element);
        this.element.positionAt(0, 0);
        var result = new Size(this.element.offsetWidth, this.element.offsetHeight);
        this.element.positionAt(undefined, undefined);
        WebInspector.Widget._originalRemoveChild.call(document.body, this.element);
        return result;
    },

    /**
     * @return {!Constraints}
     */
    calculateConstraints: function()
    {
        return new Constraints();
    },

    /**
     * @return {!Constraints}
     */
    constraints: function()
    {
        if (typeof this._constraints !== "undefined")
            return this._constraints;
        if (typeof this._cachedConstraints === "undefined")
            this._cachedConstraints = this.calculateConstraints();
        return this._cachedConstraints;
    },

    /**
     * @param {number} width
     * @param {number} height
     * @param {number} preferredWidth
     * @param {number} preferredHeight
     */
    setMinimumAndPreferredSizes: function(width, height, preferredWidth, preferredHeight)
    {
        this._constraints = new Constraints(new Size(width, height), new Size(preferredWidth, preferredHeight));
        this.invalidateConstraints();
    },

    /**
     * @param {number} width
     * @param {number} height
     */
    setMinimumSize: function(width, height)
    {
        this._constraints = new Constraints(new Size(width, height));
        this.invalidateConstraints();
    },

    /**
     * @return {boolean}
     */
    _hasNonZeroConstraints: function()
    {
        var constraints = this.constraints();
        return !!(constraints.minimum.width || constraints.minimum.height || constraints.preferred.width || constraints.preferred.height);
    },

    invalidateConstraints: function()
    {
        var cached = this._cachedConstraints;
        delete this._cachedConstraints;
        var actual = this.constraints();
        if (!actual.isEqual(cached) && this._parentWidget)
            this._parentWidget.invalidateConstraints();
        else
            this.doLayout();
    },

    invalidateSize: function()
    {
        if (this._parentWidget)
            this._parentWidget.doLayout();
    },

    __proto__: WebInspector.Object.prototype
}

WebInspector.Widget._originalAppendChild = Element.prototype.appendChild;
WebInspector.Widget._originalInsertBefore = Element.prototype.insertBefore;
WebInspector.Widget._originalRemoveChild = Element.prototype.removeChild;
WebInspector.Widget._originalRemoveChildren = Element.prototype.removeChildren;

WebInspector.Widget._incrementWidgetCounter = function(parentElement, childElement)
{
    var count = (childElement.__widgetCounter || 0) + (childElement.__widget ? 1 : 0);
    if (!count)
        return;

    while (parentElement) {
        parentElement.__widgetCounter = (parentElement.__widgetCounter || 0) + count;
        parentElement = parentElement.parentElementOrShadowHost();
    }
}

WebInspector.Widget._decrementWidgetCounter = function(parentElement, childElement)
{
    var count = (childElement.__widgetCounter || 0) + (childElement.__widget ? 1 : 0);
    if (!count)
        return;

    while (parentElement) {
        parentElement.__widgetCounter -= count;
        parentElement = parentElement.parentElementOrShadowHost();
    }
}

WebInspector.Widget.__assert = function(condition, message)
{
    if (!condition) {
        console.trace();
        throw new Error(message);
    }
}

/**
 * @constructor
 * @extends {WebInspector.Widget}
 * @param {boolean=} isWebComponent
 */
WebInspector.VBox = function(isWebComponent)
{
    WebInspector.Widget.call(this, isWebComponent);
    this.contentElement.classList.add("vbox");
};

WebInspector.VBox.prototype = {
    /**
     * @override
     * @return {!Constraints}
     */
    calculateConstraints: function()
    {
        var constraints = new Constraints();

        /**
         * @this {!WebInspector.Widget}
         * @suppressReceiverCheck
         */
        function updateForChild()
        {
            var child = this.constraints();
            constraints = constraints.widthToMax(child);
            constraints = constraints.addHeight(child);
        }

        this._callOnVisibleChildren(updateForChild);
        return constraints;
    },

    __proto__: WebInspector.Widget.prototype
};

/**
 * @constructor
 * @extends {WebInspector.Widget}
 * @param {boolean=} isWebComponent
 */
WebInspector.HBox = function(isWebComponent)
{
    WebInspector.Widget.call(this, isWebComponent);
    this.contentElement.classList.add("hbox");
};

WebInspector.HBox.prototype = {
    /**
     * @override
     * @return {!Constraints}
     */
    calculateConstraints: function()
    {
        var constraints = new Constraints();

        /**
         * @this {!WebInspector.Widget}
         * @suppressReceiverCheck
         */
        function updateForChild()
        {
            var child = this.constraints();
            constraints = constraints.addWidth(child);
            constraints = constraints.heightToMax(child);
        }

        this._callOnVisibleChildren(updateForChild);
        return constraints;
    },

    __proto__: WebInspector.Widget.prototype
};

/**
 * @constructor
 * @extends {WebInspector.VBox}
 * @param {function()} resizeCallback
 */
WebInspector.VBoxWithResizeCallback = function(resizeCallback)
{
    WebInspector.VBox.call(this);
    this._resizeCallback = resizeCallback;
}

WebInspector.VBoxWithResizeCallback.prototype = {
    onResize: function()
    {
        this._resizeCallback();
    },

    __proto__: WebInspector.VBox.prototype
}

/**
 * @constructor
 * @extends {WebInspector.VBox}
 */
WebInspector.VBoxWithToolbarItems = function()
{
    WebInspector.VBox.call(this);
}

WebInspector.VBoxWithToolbarItems.prototype = {
    /**
     * @return {!Array<!WebInspector.ToolbarItem>}
     */
    toolbarItems: function()
    {
        return [];
    },

    __proto__: WebInspector.VBox.prototype
}

/**
 * @override
 * @param {?Node} child
 * @return {?Node}
 * @suppress {duplicate}
 */
Element.prototype.appendChild = function(child)
{
    WebInspector.Widget.__assert(!child.__widget || child.parentElement === this, "Attempt to add widget via regular DOM operation.");
    return WebInspector.Widget._originalAppendChild.call(this, child);
}

/**
 * @override
 * @param {?Node} child
 * @param {?Node} anchor
 * @return {!Node}
 * @suppress {duplicate}
 */
Element.prototype.insertBefore = function(child, anchor)
{
    WebInspector.Widget.__assert(!child.__widget || child.parentElement === this, "Attempt to add widget via regular DOM operation.");
    return WebInspector.Widget._originalInsertBefore.call(this, child, anchor);
}

/**
 * @override
 * @param {?Node} child
 * @return {!Node}
 * @suppress {duplicate}
 */
Element.prototype.removeChild = function(child)
{
    WebInspector.Widget.__assert(!child.__widgetCounter && !child.__widget, "Attempt to remove element containing widget via regular DOM operation");
    return WebInspector.Widget._originalRemoveChild.call(this, child);
}

Element.prototype.removeChildren = function()
{
    WebInspector.Widget.__assert(!this.__widgetCounter, "Attempt to remove element containing widget via regular DOM operation");
    WebInspector.Widget._originalRemoveChildren.call(this);
}
;/* treeoutline.js */
/*
 * Copyright (C) 2007 Apple Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @param {boolean=} nonFocusable
 */
function TreeOutline(nonFocusable)
{
    this._createRootElement();

    this.selectedTreeElement = null;
    this.expandTreeElementsWhenArrowing = false;
    /** @type {?function(!TreeElement, !TreeElement):number} */
    this._comparator = null;

    this._contentElement = this._rootElement._childrenListNode;
    this._contentElement.addEventListener("keydown", this._treeKeyDown.bind(this), true);

    this.setFocusable(!nonFocusable);

    this.element = this._contentElement;
}

TreeOutline.Events = {
    ElementAttached: "ElementAttached",
    ElementExpanded: "ElementExpanded",
    ElementCollapsed: "ElementCollapsed",
    ElementSelected: "ElementSelected"
}

TreeOutline.prototype = {
    _createRootElement: function()
    {
        this._rootElement = new TreeElement();
        this._rootElement.treeOutline = this;
        this._rootElement.root = true;
        this._rootElement.selectable = false;
        this._rootElement.expanded = true;
        this._rootElement._childrenListNode.classList.remove("children");
    },

    /**
     * @return {!TreeElement}
     */
    rootElement: function()
    {
        return this._rootElement;
    },

    /**
     * @return {?TreeElement}
     */
    firstChild: function()
    {
        return this._rootElement.firstChild();
    },

    /**
     * @param {!TreeElement} child
     */
    appendChild: function(child)
    {
        this._rootElement.appendChild(child);
    },

    /**
     * @param {!TreeElement} child
     * @param {number} index
     */
    insertChild: function(child, index)
    {
        this._rootElement.insertChild(child, index);
    },

    /**
     * @param {!TreeElement} child
     */
    removeChild: function(child)
    {
        this._rootElement.removeChild(child);
    },

    removeChildren: function()
    {
        this._rootElement.removeChildren();
    },

    /**
     * @param {number} x
     * @param {number} y
     * @return {?TreeElement}
     */
    treeElementFromPoint: function(x, y)
    {
        var node = this._contentElement.ownerDocument.deepElementFromPoint(x, y);
        if (!node)
            return null;

        var listNode = node.enclosingNodeOrSelfWithNodeNameInArray(["ol", "li"]);
        if (listNode)
            return listNode.parentTreeElement || listNode.treeElement;
        return null;
    },

    /**
     * @param {?Event} event
     * @return {?TreeElement}
     */
    treeElementFromEvent: function(event)
    {
        return event ? this.treeElementFromPoint(event.pageX, event.pageY) : null;
    },

    /**
     * @param {?function(!TreeElement, !TreeElement):number} comparator
     */
    setComparator: function(comparator)
    {
        this._comparator = comparator;
    },

    /**
     * @param {boolean} focusable
     */
    setFocusable: function(focusable)
    {
        if (focusable)
            this._contentElement.setAttribute("tabIndex", 0);
        else
            this._contentElement.removeAttribute("tabIndex");
    },

    focus: function()
    {
        this._contentElement.focus();
    },

    /**
     * @param {!TreeElement} element
     */
    _bindTreeElement: function(element)
    {
        if (element.treeOutline)
            console.error("Binding element for the second time: " + new Error().stack);
        element.treeOutline = this;
        element.onbind();
    },

    /**
     * @param {!TreeElement} element
     */
    _unbindTreeElement: function(element)
    {
        if (!element.treeOutline)
            console.error("Unbinding element that was not bound: " + new Error().stack);

        element.deselect();
        element.onunbind();
        element.treeOutline = null;
    },

    /**
     * @return {boolean}
     */
    selectPrevious: function()
    {
        var nextSelectedElement = this.selectedTreeElement.traversePreviousTreeElement(true);
        while (nextSelectedElement && !nextSelectedElement.selectable)
            nextSelectedElement = nextSelectedElement.traversePreviousTreeElement(!this.expandTreeElementsWhenArrowing);
        if (nextSelectedElement) {
            nextSelectedElement.reveal();
            nextSelectedElement.select(false, true);
            return true;
        }
        return false;
    },

    /**
     * @return {boolean}
     */
    selectNext: function()
    {
        var nextSelectedElement = this.selectedTreeElement.traverseNextTreeElement(true);
        while (nextSelectedElement && !nextSelectedElement.selectable)
            nextSelectedElement = nextSelectedElement.traverseNextTreeElement(!this.expandTreeElementsWhenArrowing);
        if (nextSelectedElement) {
            nextSelectedElement.reveal();
            nextSelectedElement.select(false, true);
            return true;
        }
        return false;
    },

    /**
     * @param {!Event} event
     */
    _treeKeyDown: function(event)
    {
        if (event.target !== this._contentElement)
            return;

        if (!this.selectedTreeElement || event.shiftKey || event.metaKey || event.ctrlKey)
            return;

        var handled = false;
        var nextSelectedElement;
        if (event.keyIdentifier === "Up" && !event.altKey) {
            handled = this.selectPrevious();
        } else if (event.keyIdentifier === "Down" && !event.altKey) {
            handled = this.selectNext();
        } else if (event.keyIdentifier === "Left") {
            if (this.selectedTreeElement.expanded) {
                if (event.altKey)
                    this.selectedTreeElement.collapseRecursively();
                else
                    this.selectedTreeElement.collapse();
                handled = true;
            } else if (this.selectedTreeElement.parent && !this.selectedTreeElement.parent.root) {
                handled = true;
                if (this.selectedTreeElement.parent.selectable) {
                    nextSelectedElement = this.selectedTreeElement.parent;
                    while (nextSelectedElement && !nextSelectedElement.selectable)
                        nextSelectedElement = nextSelectedElement.parent;
                    handled = nextSelectedElement ? true : false;
                } else if (this.selectedTreeElement.parent)
                    this.selectedTreeElement.parent.collapse();
            }
        } else if (event.keyIdentifier === "Right") {
            if (!this.selectedTreeElement.revealed()) {
                this.selectedTreeElement.reveal();
                handled = true;
            } else if (this.selectedTreeElement._expandable) {
                handled = true;
                if (this.selectedTreeElement.expanded) {
                    nextSelectedElement = this.selectedTreeElement.firstChild();
                    while (nextSelectedElement && !nextSelectedElement.selectable)
                        nextSelectedElement = nextSelectedElement.nextSibling;
                    handled = nextSelectedElement ? true : false;
                } else {
                    if (event.altKey)
                        this.selectedTreeElement.expandRecursively();
                    else
                        this.selectedTreeElement.expand();
                }
            }
        } else if (event.keyCode === 8 /* Backspace */ || event.keyCode === 46 /* Delete */)
            handled = this.selectedTreeElement.ondelete();
        else if (isEnterKey(event))
            handled = this.selectedTreeElement.onenter();
        else if (event.keyCode === WebInspector.KeyboardShortcut.Keys.Space.code)
            handled = this.selectedTreeElement.onspace();

        if (nextSelectedElement) {
            nextSelectedElement.reveal();
            nextSelectedElement.select(false, true);
        }

        if (handled)
            event.consume(true);
    },

    /**
     * @param {!TreeElement} treeElement
     * @param {boolean} center
     */
    _deferredScrollIntoView: function(treeElement, center)
    {
        if (!this._treeElementToScrollIntoView)
            this.element.window().requestAnimationFrame(deferredScrollIntoView.bind(this));
        this._treeElementToScrollIntoView = treeElement;
        this._centerUponScrollIntoView = center;
        /**
         * @this {TreeOutline}
         */
        function deferredScrollIntoView()
        {
            this._treeElementToScrollIntoView.listItemElement.scrollIntoViewIfNeeded(this._centerUponScrollIntoView);
            delete this._treeElementToScrollIntoView;
            delete this._centerUponScrollIntoView;
        }
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @constructor
 * @extends {TreeOutline}
 */
function TreeOutlineInShadow()
{
    TreeOutline.call(this);
    var innerElement = this.element;
    innerElement.classList.add("tree-outline");

    // Redefine element to the external one.
    this.element = createElement("div");
    this._shadowRoot = WebInspector.createShadowRootWithCoreStyles(this.element, "ui/treeoutline.css");
    this._disclosureElement = this._shadowRoot.createChild("div", "tree-outline-disclosure");
    this._disclosureElement.appendChild(innerElement);
    this._renderSelection = true;
}

TreeOutlineInShadow.prototype = {
    /**
     * @param {string} cssFile
     */
    registerRequiredCSS: function(cssFile)
    {
        WebInspector.appendStyle(this._shadowRoot, cssFile);
    },

    hideOverflow: function()
    {
        this._disclosureElement.classList.add("tree-outline-disclosure-hide-overflow");
    },

    __proto__: TreeOutline.prototype
}

/**
 * @constructor
 * @param {(string|!Node)=} title
 * @param {boolean=} expandable
 */
function TreeElement(title, expandable)
{
    /** @type {?TreeOutline} */
    this.treeOutline = null;
    this.parent = null;
    this.previousSibling = null;
    this.nextSibling = null;

    this._listItemNode = createElement("li");
    this._listItemNode.treeElement = this;
    if (title)
        this.title = title;
    this._listItemNode.addEventListener("mousedown", this._handleMouseDown.bind(this), false);
    this._listItemNode.addEventListener("selectstart", this._treeElementSelectStart.bind(this), false);
    this._listItemNode.addEventListener("click", this._treeElementToggled.bind(this), false);
    this._listItemNode.addEventListener("dblclick", this._handleDoubleClick.bind(this), false);

    this._childrenListNode = createElement("ol");
    this._childrenListNode.parentTreeElement = this;
    this._childrenListNode.classList.add("children");

    this._hidden = false;
    this._selectable = true;
    this.expanded = false;
    this.selected = false;
    this.setExpandable(expandable || false);
    this._collapsible = true;
}

/** @const */
TreeElement._ArrowToggleWidth = 10;

TreeElement.prototype = {
    /**
     * @param {?TreeElement} ancestor
     * @return {boolean}
     */
    hasAncestor: function(ancestor)
    {
        if (!ancestor)
            return false;

        var currentNode = this.parent;
        while (currentNode) {
            if (ancestor === currentNode)
                return true;
            currentNode = currentNode.parent;
        }

        return false;
    },

    /**
     * @param {?TreeElement} ancestor
     * @return {boolean}
     */
    hasAncestorOrSelf: function(ancestor)
    {
        return this === ancestor || this.hasAncestor(ancestor);
    },

    /**
     * @return {!Array.<!TreeElement>}
     */
    children: function()
    {
        return this._children || [];
    },

    /**
     * @return {number}
     */
    childCount: function()
    {
        return this._children ? this._children.length : 0;
    },

    /**
     * @return {?TreeElement}
     */
    firstChild: function()
    {
        return this._children ? this._children[0] : null;
    },

    /**
     * @return {?TreeElement}
     */
    lastChild: function()
    {
        return this._children ? this._children[this._children.length - 1] : null;
    },

    /**
     * @param {number} index
     * @return {?TreeElement}
     */
    childAt: function(index)
    {
        return this._children ? this._children[index] : null;
    },

    /**
     * @param {!TreeElement} child
     * @return {number}
     */
    indexOfChild: function(child)
    {
        return this._children ? this._children.indexOf(child) : -1;
    },

    /**
     * @param {!TreeElement} child
     */
    appendChild: function(child)
    {
        if (!this._children)
            this._children = [];

        var insertionIndex;
        if (this.treeOutline && this.treeOutline._comparator)
            insertionIndex = insertionIndexForObjectInListSortedByFunction(child, this._children, this.treeOutline._comparator);
        else
            insertionIndex = this._children.length;
        this.insertChild(child, insertionIndex);
    },

    /**
     * @param {!TreeElement} child
     * @param {number} index
     */
    insertChild: function(child, index)
    {
        if (!this._children)
            this._children = [];

        if (!child)
            throw("child can't be undefined or null");

        console.assert(!child.parent, "Attempting to insert a child that is already in the tree, reparenting is not supported.");

        var previousChild = (index > 0 ? this._children[index - 1] : null);
        if (previousChild) {
            previousChild.nextSibling = child;
            child.previousSibling = previousChild;
        } else {
            child.previousSibling = null;
        }

        var nextChild = this._children[index];
        if (nextChild) {
            nextChild.previousSibling = child;
            child.nextSibling = nextChild;
        } else {
            child.nextSibling = null;
        }

        this._children.splice(index, 0, child);

        this.setExpandable(true);
        child.parent = this;

        if (this.treeOutline)
            this.treeOutline._bindTreeElement(child);
        for (var current = child.firstChild(); this.treeOutline && current; current = current.traverseNextTreeElement(false, child, true))
            this.treeOutline._bindTreeElement(current);
        child.onattach();
        child._ensureSelection();
        if (this.treeOutline)
            this.treeOutline.dispatchEventToListeners(TreeOutline.Events.ElementAttached, child);
        var nextSibling = child.nextSibling ? child.nextSibling._listItemNode : null;
        this._childrenListNode.insertBefore(child._listItemNode, nextSibling);
        this._childrenListNode.insertBefore(child._childrenListNode, nextSibling);
        if (child.selected)
            child.select();
        if (child.expanded)
            child.expand();
    },

    /**
     * @param {number} childIndex
     */
    removeChildAtIndex: function(childIndex)
    {
        if (childIndex < 0 || childIndex >= this._children.length)
            throw("childIndex out of range");

        var child = this._children[childIndex];
        this._children.splice(childIndex, 1);

        var parent = child.parent;
        if (this.treeOutline && this.treeOutline.selectedTreeElement && this.treeOutline.selectedTreeElement.hasAncestorOrSelf(child)) {
            if (child.nextSibling)
                child.nextSibling.select(true);
            else if (child.previousSibling)
                child.previousSibling.select(true);
            else if (parent)
                parent.select(true);
        }

        if (child.previousSibling)
            child.previousSibling.nextSibling = child.nextSibling;
        if (child.nextSibling)
            child.nextSibling.previousSibling = child.previousSibling;
        child.parent = null;

        if (this.treeOutline)
            this.treeOutline._unbindTreeElement(child);
        for (var current = child.firstChild(); this.treeOutline && current; current = current.traverseNextTreeElement(false, child, true))
            this.treeOutline._unbindTreeElement(current);

        child._detach();
    },

    /**
     * @param {!TreeElement} child
     */
    removeChild: function(child)
    {
        if (!child)
            throw("child can't be undefined or null");
        if (child.parent !== this)
            return;

        var childIndex = this._children.indexOf(child);
        if (childIndex === -1)
            throw("child not found in this node's children");

        this.removeChildAtIndex(childIndex);
    },

    removeChildren: function()
    {
        if (!this.root && this.treeOutline && this.treeOutline.selectedTreeElement && this.treeOutline.selectedTreeElement.hasAncestorOrSelf(this))
            this.select(true);

        for (var i = 0; this._children && i < this._children.length; ++i) {
            var child = this._children[i];
            child.previousSibling = null
            child.nextSibling = null;
            child.parent = null;

            if (this.treeOutline)
                this.treeOutline._unbindTreeElement(child);
            for (var current = child.firstChild(); this.treeOutline && current; current = current.traverseNextTreeElement(false, child, true))
                this.treeOutline._unbindTreeElement(current);
            child._detach();
        }
        this._children = [];
    },

    get selectable()
    {
        if (this._hidden)
            return false;
        return this._selectable;
    },

    set selectable(x)
    {
        this._selectable = x;
    },

    get listItemElement()
    {
        return this._listItemNode;
    },

    get childrenListElement()
    {
        return this._childrenListNode;
    },

    get title()
    {
        return this._title;
    },

    /**
     * @param {string|!Node} x
     */
    set title(x)
    {
        if (this._title === x)
            return;
        this._title = x;

        if (typeof x === "string") {
            this._titleElement = createElementWithClass("span", "tree-element-title");
            this._titleElement.textContent = x;
            this.tooltip = x;
        } else {
            this._titleElement = x;
            this.tooltip = "";
        }

        this._listItemNode.removeChildren();
        if (this._iconElement)
            this._listItemNode.appendChild(this._iconElement);

        this._listItemNode.appendChild(this._titleElement);
        this._ensureSelection();
    },

    /**
     * @param {!WebInspector.InplaceEditor.Config} editingConfig
     */
    startEditingTitle: function(editingConfig)
    {
        WebInspector.InplaceEditor.startEditing(this._titleElement, editingConfig);
        this.treeOutline._shadowRoot.getSelection().setBaseAndExtent(this._titleElement, 0, this._titleElement, 1);
    },

    createIcon()
    {
        if (!this._iconElement) {
            this._iconElement = createElementWithClass("div", "icon");
            this._listItemNode.insertBefore(this._iconElement, this._listItemNode.firstChild);
            this._ensureSelection();
        }
    },

    get tooltip()
    {
        return this._tooltip || "";
    },

    /**
     * @param {string} x
     */
    set tooltip(x)
    {
        if (this._tooltip === x)
            return;
        this._tooltip = x;
        this._listItemNode.title = x;
    },

    /**
     * @return {boolean}
     */
    isExpandable: function()
    {
        return this._expandable;
    },

    /**
     * @param {boolean} expandable
     */
    setExpandable: function(expandable)
    {
        if (this._expandable === expandable)
            return;

        this._expandable = expandable;

        this._listItemNode.classList.toggle("parent", expandable);
        if (!expandable)
            this.collapse();
    },

    /**
     * @param {boolean} collapsible
     */
    setCollapsible: function(collapsible)
    {
        if (this._collapsible === collapsible)
            return;

        this._collapsible = collapsible;

        this._listItemNode.classList.toggle("always-parent", !collapsible);
        if (!collapsible)
            this.expand();
    },

    get hidden()
    {
        return this._hidden;
    },

    set hidden(x)
    {
        if (this._hidden === x)
            return;

        this._hidden = x;

        this._listItemNode.classList.toggle("hidden", x);
        this._childrenListNode.classList.toggle("hidden", x);
    },

    invalidateChildren: function()
    {
        if (this._children) {
            this.removeChildren();
            this._children = null;
        }
    },

    _ensureSelection: function()
    {
        if (!this.treeOutline || !this.treeOutline._renderSelection)
            return;
        if (!this._selectionElement)
            this._selectionElement = createElementWithClass("div", "selection fill");
        this._listItemNode.insertBefore(this._selectionElement, this.listItemElement.firstChild);
    },

    /**
     * @param {!Event} event
     */
    _treeElementSelectStart: function(event)
    {
        event.currentTarget._selectionStarted = true;
    },

    /**
     * @param {!Event} event
     */
    _treeElementToggled: function(event)
    {
        var element = event.currentTarget;
        if (element._selectionStarted) {
            delete element._selectionStarted;
            var selection = element.getComponentSelection();
            if (selection && !selection.isCollapsed && element.isSelfOrAncestor(selection.anchorNode) && element.isSelfOrAncestor(selection.focusNode))
                return;
        }

        if (element.treeElement !== this)
            return;

        var toggleOnClick = this.toggleOnClick && !this.selectable;
        var isInTriangle = this.isEventWithinDisclosureTriangle(event);
        if (!toggleOnClick && !isInTriangle)
            return;

        if (event.target && event.target.enclosingNodeOrSelfWithNodeName("a"))
            return;

        if (this.expanded) {
            if (event.altKey)
                this.collapseRecursively();
            else
                this.collapse();
        } else {
            if (event.altKey)
                this.expandRecursively();
            else
                this.expand();
        }
        event.consume();
    },

    /**
     * @param {!Event} event
     */
    _handleMouseDown: function(event)
    {
        var element = event.currentTarget;
        if (!element)
            return;
        delete element._selectionStarted;

        if (!this.selectable)
            return;
        if (element.treeElement !== this)
            return;

        if (this.isEventWithinDisclosureTriangle(event))
            return;

        this.selectOnMouseDown(event);
    },

    /**
     * @param {!Event} event
     */
    _handleDoubleClick: function(event)
    {
        var element = event.currentTarget;
        if (!element || element.treeElement !== this)
            return;

        var handled = this.ondblclick(event);
        if (handled)
            return;
        if (this._expandable && !this.expanded)
            this.expand();
    },

    _detach: function()
    {
        this._listItemNode.remove();
        this._childrenListNode.remove();
    },

    collapse: function()
    {
        if (!this.expanded || !this._collapsible)
            return;
        this._listItemNode.classList.remove("expanded");
        this._childrenListNode.classList.remove("expanded");
        this.expanded = false;
        this.oncollapse();
        if (this.treeOutline)
            this.treeOutline.dispatchEventToListeners(TreeOutline.Events.ElementCollapsed, this);
    },

    collapseRecursively: function()
    {
        var item = this;
        while (item) {
            if (item.expanded)
                item.collapse();
            item = item.traverseNextTreeElement(false, this, true);
        }
    },

    expand: function()
    {
        if (!this._expandable || (this.expanded && this._children))
            return;

        // Set this before onpopulate. Since onpopulate can add elements, this makes
        // sure the expanded flag is true before calling those functions. This prevents the possibility
        // of an infinite loop if onpopulate were to call expand.

        this.expanded = true;

        this._populateIfNeeded();
        this._listItemNode.classList.add("expanded");
        this._childrenListNode.classList.add("expanded");

        if (this.treeOutline) {
            this.onexpand();
            this.treeOutline.dispatchEventToListeners(TreeOutline.Events.ElementExpanded, this);
        }
    },

    /**
     * @param {number=} maxDepth
     */
    expandRecursively: function(maxDepth)
    {
        var item = this;
        var info = {};
        var depth = 0;

        // The Inspector uses TreeOutlines to represents object properties, so recursive expansion
        // in some case can be infinite, since JavaScript objects can hold circular references.
        // So default to a recursion cap of 3 levels, since that gives fairly good results.
        if (isNaN(maxDepth))
            maxDepth = 3;

        while (item) {
            if (depth < maxDepth)
                item.expand();
            item = item.traverseNextTreeElement(false, this, (depth >= maxDepth), info);
            depth += info.depthChange;
        }
    },

    /**
     * @param {boolean=} center
     */
    reveal: function(center)
    {
        var currentAncestor = this.parent;
        while (currentAncestor && !currentAncestor.root) {
            if (!currentAncestor.expanded)
                currentAncestor.expand();
            currentAncestor = currentAncestor.parent;
        }

        this.treeOutline._deferredScrollIntoView(this, !!center);
    },

    /**
     * @return {boolean}
     */
    revealed: function()
    {
        var currentAncestor = this.parent;
        while (currentAncestor && !currentAncestor.root) {
            if (!currentAncestor.expanded)
                return false;
            currentAncestor = currentAncestor.parent;
        }

        return true;
    },

    selectOnMouseDown: function(event)
    {
        if (this.select(false, true))
            event.consume(true);
    },

    /**
     * @param {boolean=} omitFocus
     * @param {boolean=} selectedByUser
     * @return {boolean}
     */
    select: function(omitFocus, selectedByUser)
    {
        if (!this.treeOutline || !this.selectable || this.selected)
            return false;

        if (this.treeOutline.selectedTreeElement)
            this.treeOutline.selectedTreeElement.deselect();
        this.treeOutline.selectedTreeElement = null;

        if (this.treeOutline._rootElement === this)
            return false;

        this.selected = true;

        if (!omitFocus)
            this.treeOutline.focus();

        // Focusing on another node may detach "this" from tree.
        if (!this.treeOutline)
            return false;
        this.treeOutline.selectedTreeElement = this;
        this._listItemNode.classList.add("selected");
        this.treeOutline.dispatchEventToListeners(TreeOutline.Events.ElementSelected, this);
        return this.onselect(selectedByUser);
    },

    /**
     * @param {boolean=} omitFocus
     */
    revealAndSelect: function(omitFocus)
    {
        this.reveal(true);
        this.select(omitFocus);
    },

    /**
     * @param {boolean=} supressOnDeselect
     */
    deselect: function(supressOnDeselect)
    {
        if (!this.treeOutline || this.treeOutline.selectedTreeElement !== this || !this.selected)
            return;

        this.selected = false;
        this.treeOutline.selectedTreeElement = null;
        this._listItemNode.classList.remove("selected");
    },

    _populateIfNeeded: function()
    {
        if (this.treeOutline && this._expandable && !this._children) {
            this._children = [];
            this.onpopulate();
        }
    },

    onpopulate: function()
    {
        // Overridden by subclasses.
    },

    /**
     * @return {boolean}
     */
    onenter: function()
    {
        return false;
    },

    /**
     * @return {boolean}
     */
    ondelete: function()
    {
        return false;
    },

    /**
     * @return {boolean}
     */
    onspace: function()
    {
        return false;
    },

    onbind: function()
    {
    },

    onunbind: function()
    {
    },

    onattach: function()
    {
    },

    onexpand: function()
    {
    },

    oncollapse: function()
    {
    },

    /**
     * @param {!Event} e
     * @return {boolean}
     */
    ondblclick: function(e)
    {
        return false;
    },

    /**
     * @param {boolean=} selectedByUser
     * @return {boolean}
     */
    onselect: function(selectedByUser)
    {
        return false;
    },

    /**
     * @param {boolean} skipUnrevealed
     * @param {?TreeElement=} stayWithin
     * @param {boolean=} dontPopulate
     * @param {!Object=} info
     * @return {?TreeElement}
     */
    traverseNextTreeElement: function(skipUnrevealed, stayWithin, dontPopulate, info)
    {
        if (!dontPopulate)
            this._populateIfNeeded();

        if (info)
            info.depthChange = 0;

        var element = skipUnrevealed ? (this.revealed() ? this.firstChild() : null) : this.firstChild();
        if (element && (!skipUnrevealed || (skipUnrevealed && this.expanded))) {
            if (info)
                info.depthChange = 1;
            return element;
        }

        if (this === stayWithin)
            return null;

        element = skipUnrevealed ? (this.revealed() ? this.nextSibling : null) : this.nextSibling;
        if (element)
            return element;

        element = this;
        while (element && !element.root && !(skipUnrevealed ? (element.revealed() ? element.nextSibling : null) : element.nextSibling) && element.parent !== stayWithin) {
            if (info)
                info.depthChange -= 1;
            element = element.parent;
        }

        if (!element || element.root)
            return null;

        return (skipUnrevealed ? (element.revealed() ? element.nextSibling : null) : element.nextSibling);
    },

    /**
     * @param {boolean} skipUnrevealed
     * @param {boolean=} dontPopulate
     * @return {?TreeElement}
     */
    traversePreviousTreeElement: function(skipUnrevealed, dontPopulate)
    {
        var element = skipUnrevealed ? (this.revealed() ? this.previousSibling : null) : this.previousSibling;
        if (!dontPopulate && element)
            element._populateIfNeeded();

        while (element && (skipUnrevealed ? (element.revealed() && element.expanded ? element.lastChild() : null) : element.lastChild())) {
            if (!dontPopulate)
                element._populateIfNeeded();
            element = (skipUnrevealed ? (element.revealed() && element.expanded ? element.lastChild() : null) : element.lastChild());
        }

        if (element)
            return element;

        if (!this.parent || this.parent.root)
            return null;

        return this.parent;
    },

    /**
     * @return {boolean}
     */
    isEventWithinDisclosureTriangle: function(event)
    {
        // FIXME: We should not use getComputedStyle(). For that we need to get rid of using ::before for disclosure triangle. (http://webk.it/74446)
        var paddingLeftValue = window.getComputedStyle(this._listItemNode).paddingLeft;
        console.assert(paddingLeftValue.endsWith("px"));
        var computedLeftPadding = parseFloat(paddingLeftValue);
        var left = this._listItemNode.totalOffsetLeft() + computedLeftPadding;
        return event.pageX >= left && event.pageX <= left + TreeElement._ArrowToggleWidth && this._expandable;
    }
}
;/* ActionRegistry.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 */
WebInspector.ActionRegistry = function()
{
    /** @type {!Map.<string, !WebInspector.Action>} */
    this._actionsById = new Map();
    this._registerActions();
}

WebInspector.ActionRegistry.prototype = {
    _registerActions: function()
    {
        self.runtime.extensions(WebInspector.ActionDelegate).forEach(registerExtension, this);

        /**
         * @param {!Runtime.Extension} extension
         * @this {WebInspector.ActionRegistry}
         */
        function registerExtension(extension)
        {
            var actionId = extension.descriptor()["actionId"];
            console.assert(actionId);
            console.assert(!this._actionsById.get(actionId));
            this._actionsById.set(actionId, new WebInspector.Action(extension));
        }
    },

    /**
     * @param {!Array.<string>} actionIds
     * @param {!WebInspector.Context} context
     * @return {!Array.<!WebInspector.Action>}
     */
    applicableActions: function(actionIds, context)
    {
        var extensions = [];
        actionIds.forEach(function(actionId) {
           var action = this._actionsById.get(actionId);
           if (action)
               extensions.push(action._extension);
        }, this);
        return context.applicableExtensions(extensions).valuesArray().map(extensionToAction.bind(this));

        /**
         * @param {!Runtime.Extension} extension
         * @return {!WebInspector.Action}
         * @this {WebInspector.ActionRegistry}
         */
        function extensionToAction(extension)
        {
            return this.action(extension.descriptor()["actionId"]);
        }
    },

    /**
     * @param {string} actionId
     * @return {!WebInspector.Action}
     */
    action: function(actionId)
    {
        var action = this._actionsById.get(actionId);
        console.assert(action, "No action found for actionId '" + actionId + "'");
        return /** @type {!WebInspector.Action} */ (action);
    }
}

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @param {!Runtime.Extension} extension
 */
WebInspector.Action = function(extension)
{
    WebInspector.Object.call(this);
    this._extension = extension;
    this._enabled = true;
    this._toggled = false;
    this._title = this._extension.descriptor()["title"] || "";

    this._statesCount = this._extension.descriptor()["states"] || 2;
    if (this._statesCount == 2)
        this._state = WebInspector.Action._ToggleState.Off;
    else
        this._state = "0";
}

WebInspector.Action._ToggleState = {
    On: "on",
    Off: "off"
}

WebInspector.Action.Events = {
    Enabled: "Enabled",
    StateChanged: "StateChanged",
    TitleChanged: "TitleChanged",
}

WebInspector.Action.prototype = {

    /**
     * @return {number}
     */
    statesCount: function()
    {
        return this._statesCount;
    },

    /**
     * @return {string}
     */
    id: function()
    {
        return this._extension.descriptor()["actionId"];
    },

    /**
     * @return {!Promise.<boolean>}
     */
    execute: function()
    {
        return this._extension.instancePromise().then(handleAction.bind(this));

        /**
         * @param {!Object} actionDelegate
         * @return {boolean}
         * @this {WebInspector.Action}
         */
        function handleAction(actionDelegate)
        {
            var actionId = this._extension.descriptor()["actionId"];
            var delegate = /** @type {!WebInspector.ActionDelegate} */(actionDelegate);
            return delegate.handleAction(WebInspector.context, actionId);
        }
    },

    /**
     * @return {string}
     */
    icon: function()
    {
        return this._extension.descriptor()["iconClass"] || "";
    },

    /**
     * @param {boolean} enabled
     */
    setEnabled: function(enabled)
    {
        if (this._enabled === enabled)
            return;

        this._enabled = enabled;
        this.dispatchEventToListeners(WebInspector.Action.Events.Enabled, enabled);
    },

    /**
     * @return {boolean}
     */
    enabled: function()
    {
        return this._enabled;
    },

    /**
     * @param {string} title
     */
    setTitle: function(title)
    {
        if (this._title === title)
            return;

        this._title = title;
        this.dispatchEventToListeners(WebInspector.Action.Events.TitleChanged, this._title);
    },

    /**
     * @return {string}
     */
    title: function()
    {
        return this._title;
    },

    /**
     * @return {string}
     */
    state: function()
    {
        return this._state;
    },

    /**
     * @param {string} newState
     */
    setState: function(newState)
    {
        if (this._state === newState)
            return;

        var oldState = this._state;
        this._state = newState;
        this.dispatchEventToListeners(WebInspector.Action.Events.StateChanged, {oldState: oldState, newState: newState})
    },

    /**
     * @return {boolean}
     */
    toggled: function()
    {
        if (this._statesCount !== 2)
            throw("Only used toggled when there are 2 states, otherwise, use state");
        return this.state() === WebInspector.Action._ToggleState.On;
    },

    /**
     * @param {boolean} toggled
     */
    setToggled: function(toggled)
    {
        if (this._statesCount !== 2)
            throw("Only used toggled when there are 2 states, otherwise, use state");
        this.setState(toggled ? WebInspector.Action._ToggleState.On : WebInspector.Action._ToggleState.Off);
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @interface
 */
WebInspector.ActionDelegate = function()
{
}

WebInspector.ActionDelegate.prototype = {
    /**
     * @param {!WebInspector.Context} context
     * @param {string} actionId
     * @return {boolean}
     */
    handleAction: function(context, actionId) {}
}

/** @type {!WebInspector.ActionRegistry} */
WebInspector.actionRegistry;
;/* ShortcutRegistry.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {!WebInspector.ActionRegistry} actionRegistry
 * @param {!Document} document
 */
WebInspector.ShortcutRegistry = function(actionRegistry, document)
{
    this._actionRegistry = actionRegistry;
    /** @type {!Multimap.<string, string>} */
    this._defaultKeyToActions = new Multimap();
    /** @type {!Multimap.<string, !WebInspector.KeyboardShortcut.Descriptor>} */
    this._defaultActionToShortcut = new Multimap();
    this._registerBindings(document);
}

WebInspector.ShortcutRegistry.prototype = {
    /**
     * @param {number} key
     * @return {!Array.<!WebInspector.Action>}
     */
    _applicableActions: function(key)
    {
        return this._actionRegistry.applicableActions(this._defaultActionsForKey(key).valuesArray(), WebInspector.context);
    },

    /**
     * @param {number} key
     * @return {!Set.<string>}
     */
    _defaultActionsForKey: function(key)
    {
        return this._defaultKeyToActions.get(String(key));
    },

    /**
     * @param {string} actionId
     * @return {!Array.<!WebInspector.KeyboardShortcut.Descriptor>}
     */
    shortcutDescriptorsForAction: function(actionId)
    {
        return this._defaultActionToShortcut.get(actionId).valuesArray();
    },

    /**
     * @param {!Array.<string>} actionIds
     * @return {!Array.<number>}
     */
    keysForActions: function(actionIds)
    {
        var result = [];
        for (var i = 0; i < actionIds.length; ++i) {
            var descriptors = this.shortcutDescriptorsForAction(actionIds[i]);
            for (var j = 0; j < descriptors.length; ++j)
                result.push(descriptors[j].key);
        }
        return result;
    },

    /**
     * @param {string} actionId
     * @return {string|undefined}
     */
    shortcutTitleForAction: function(actionId)
    {
        var descriptors = this.shortcutDescriptorsForAction(actionId);
        if (descriptors.length)
            return descriptors[0].name;
    },

    /**
     * @param {!KeyboardEvent} event
     */
    handleShortcut: function(event)
    {
        this.handleKey(WebInspector.KeyboardShortcut.makeKeyFromEvent(event), event.keyIdentifier, event);
    },

    /**
     * @param {number} key
     * @param {string} keyIdentifier
     * @param {!KeyboardEvent=} event
     */
    handleKey: function(key, keyIdentifier, event)
    {
        var keyModifiers = key >> 8;
        var actions = this._applicableActions(key);
        if (!actions.length)
            return;
        if (WebInspector.GlassPane.DefaultFocusedViewStack.length > 1) {
            if (event && !isPossiblyInputKey())
                event.consume(true);
            return;
        }

        if (!isPossiblyInputKey()) {
            if (event)
                event.consume(true);
            processNextAction.call(this, false);
        } else {
            this._pendingActionTimer = setTimeout(processNextAction.bind(this, false), 0);
        }

        /**
         * @param {boolean} handled
         * @this {WebInspector.ShortcutRegistry}
         */
        function processNextAction(handled)
        {
            delete this._pendingActionTimer;
            var action = actions.shift();
            if (!action || handled)
                return;

            action.execute().then(processNextAction.bind(this));
        }

        /**
         * @return {boolean}
         */
        function isPossiblyInputKey()
        {
            if (!event || !WebInspector.isEditing() || /^F\d+|Control|Shift|Alt|Meta|Win|U\+001B$/.test(keyIdentifier))
                return false;

            if (!keyModifiers)
                return true;

            var modifiers = WebInspector.KeyboardShortcut.Modifiers;
            if ((keyModifiers & (modifiers.Ctrl | modifiers.Alt)) === (modifiers.Ctrl | modifiers.Alt))
                return WebInspector.isWin();

            return !hasModifier(modifiers.Ctrl) && !hasModifier(modifiers.Alt) && !hasModifier(modifiers.Meta);
        }

        /**
         * @param {number} mod
         * @return {boolean}
         */
        function hasModifier(mod)
        {
            return !!(keyModifiers & mod);
        }
    },

    /**
     * @param {string} actionId
     * @param {string} shortcut
     */
    registerShortcut: function(actionId, shortcut)
    {
        var descriptor = WebInspector.KeyboardShortcut.makeDescriptorFromBindingShortcut(shortcut);
        if (!descriptor)
            return;
        this._defaultActionToShortcut.set(actionId, descriptor);
        this._defaultKeyToActions.set(String(descriptor.key), actionId);
    },

    dismissPendingShortcutAction: function()
    {
        if (this._pendingActionTimer) {
            clearTimeout(this._pendingActionTimer);
            delete this._pendingActionTimer;
        }
    },

    /**
     * @param {!Document} document
     */
    _registerBindings: function(document)
    {
        document.addEventListener("input", this.dismissPendingShortcutAction.bind(this), true);
        var extensions = self.runtime.extensions(WebInspector.ActionDelegate);
        extensions.forEach(registerExtension, this);

        /**
         * @param {!Runtime.Extension} extension
         * @this {WebInspector.ShortcutRegistry}
         */
        function registerExtension(extension)
        {
            var descriptor = extension.descriptor();
            var bindings = descriptor["bindings"];
            for (var i = 0; bindings && i < bindings.length; ++i) {
                if (!platformMatches(bindings[i].platform))
                    continue;
                var shortcuts = bindings[i]["shortcut"].split(/\s+/);
                shortcuts.forEach(this.registerShortcut.bind(this, descriptor["actionId"]));
            }
        }

        /**
         * @param {string=} platformsString
         * @return {boolean}
         */
        function platformMatches(platformsString)
        {
            if (!platformsString)
                return true;
            var platforms = platformsString.split(",");
            var isMatch = false;
            var currentPlatform = WebInspector.platform();
            for (var i = 0; !isMatch && i < platforms.length; ++i)
                isMatch = platforms[i] === currentPlatform;
            return isMatch;
        }
    }
}

/**
 * @constructor
 */
WebInspector.ShortcutRegistry.ForwardedShortcut = function()
{
}

WebInspector.ShortcutRegistry.ForwardedShortcut.instance = new WebInspector.ShortcutRegistry.ForwardedShortcut();

/** @type {!WebInspector.ShortcutRegistry} */
WebInspector.shortcutRegistry;
;/* ColorSwatch.js */
// Copyright (c) 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {HTMLSpanElement}
 */
WebInspector.ColorSwatch = function()
{
}

/**
 * @return {!WebInspector.ColorSwatch}
 */
WebInspector.ColorSwatch.create = function()
{
    if (!WebInspector.ColorSwatch._constructor)
        WebInspector.ColorSwatch._constructor = registerCustomElement("span", "color-swatch", WebInspector.ColorSwatch.prototype);

    return /** @type {!WebInspector.ColorSwatch} */(new WebInspector.ColorSwatch._constructor());
}

WebInspector.ColorSwatch.prototype = {
    /**
     * @return {!WebInspector.Color} color
     */
    color: function()
    {
        return this._color;
    },

    /**
     * @param {string} colorText
     */
    setColorText: function(colorText)
    {
        this._color = WebInspector.Color.parse(colorText);
        console.assert(this._color, "Color text could not be parsed.");
        this._format = this._color.format();
        this._colorValueElement.textContent = this._color.asString(this._format);
        this._swatchInner.style.backgroundColor = colorText;
    },

    /**
     * @return {!WebInspector.Color.Format}
     */
    format: function()
    {
        return this._format;
    },

    /**
     * @param {!WebInspector.Color.Format} format
     */
    setFormat: function(format)
    {
        this._format = format;
        this._colorValueElement.textContent = this._color.asString(this._format);
    },

    toggleNextFormat: function()
    {
        do {
            this._format = WebInspector.ColorSwatch._nextColorFormat(this._color, this._format);
            var currentValue = this._color.asString(this._format);
        } while (currentValue === this._colorValueElement.textContent);
        this._colorValueElement.textContent = currentValue;
    },

    /**
     * @return {!Element}
     */
    iconElement: function()
    {
        return this._iconElement;
    },

    createdCallback: function()
    {
        var root = WebInspector.createShadowRootWithCoreStyles(this, "ui/colorSwatch.css");

        this._iconElement = root.createChild("span", "color-swatch");
        this._iconElement.title = WebInspector.UIString("Shift-click to change color format");
        this._swatchInner = this._iconElement.createChild("span", "color-swatch-inner");
        this._swatchInner.addEventListener("dblclick", consumeEvent, false);
        this._swatchInner.addEventListener("mousedown", consumeEvent, false);
        this._swatchInner.addEventListener("click", this._handleClick.bind(this), true);

        root.createChild("content");
        this._colorValueElement = this.createChild("span");

        this.setColorText("white");
    },

    /**
     * @param {!Event} event
     */
    _handleClick: function(event)
    {
        if (!event.shiftKey)
            return;
        event.target.parentNode.parentNode.host.toggleNextFormat();
        event.consume(true);
    },

    __proto__: HTMLSpanElement.prototype
}

/**
 * @param {!WebInspector.Color} color
 * @param {string} curFormat
 */
WebInspector.ColorSwatch._nextColorFormat = function(color, curFormat)
{
    // The format loop is as follows:
    // * original
    // * rgb(a)
    // * hsl(a)
    // * nickname (if the color has a nickname)
    // * if the color is simple:
    //   - shorthex (if has short hex)
    //   - hex
    var cf = WebInspector.Color.Format;

    switch (curFormat) {
        case cf.Original:
            return !color.hasAlpha() ? cf.RGB : cf.RGBA;

        case cf.RGB:
        case cf.RGBA:
            return !color.hasAlpha() ? cf.HSL : cf.HSLA;

        case cf.HSL:
        case cf.HSLA:
            if (color.nickname())
                return cf.Nickname;
            if (!color.hasAlpha())
                return color.canBeShortHex() ? cf.ShortHEX : cf.HEX;
            else
                return cf.Original;

        case cf.ShortHEX:
            return cf.HEX;

        case cf.HEX:
            return cf.Original;

        case cf.Nickname:
            if (!color.hasAlpha())
                return color.canBeShortHex() ? cf.ShortHEX : cf.HEX;
            else
                return cf.Original;

        default:
            return cf.RGBA;
    }
}
;/* Context.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 */
WebInspector.Context = function()
{
    this._flavors = new Map();
    this._eventDispatchers = new Map();
}

/**
 * @enum {string}
 */
WebInspector.Context.Events = {
    FlavorChanged: "FlavorChanged"
}

WebInspector.Context.prototype = {
    /**
     * @param {function(new:T, ...)} flavorType
     * @param {?T} flavorValue
     * @template T
     */
    setFlavor: function(flavorType, flavorValue)
    {
        var value = this._flavors.get(flavorType) || null;
        if (value === flavorValue)
            return;
        if (flavorValue)
            this._flavors.set(flavorType, flavorValue);
        else
            this._flavors.remove(flavorType);

        this._dispatchFlavorChange(flavorType, flavorValue);
    },

    /**
     * @param {function(new:T, ...)} flavorType
     * @param {?T} flavorValue
     * @template T
     */
    _dispatchFlavorChange: function(flavorType, flavorValue)
    {
        var dispatcher = this._eventDispatchers.get(flavorType);
        if (!dispatcher)
            return;
        dispatcher.dispatchEventToListeners(WebInspector.Context.Events.FlavorChanged, flavorValue);
    },

    /**
     * @param {function(new:Object, ...)} flavorType
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    addFlavorChangeListener: function(flavorType, listener, thisObject)
    {
        var dispatcher = this._eventDispatchers.get(flavorType);
        if (!dispatcher) {
            dispatcher = new WebInspector.Object();
            this._eventDispatchers.set(flavorType, dispatcher);
        }
        dispatcher.addEventListener(WebInspector.Context.Events.FlavorChanged, listener, thisObject);
    },

    /**
     * @param {function(new:Object, ...)} flavorType
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    removeFlavorChangeListener: function(flavorType, listener, thisObject)
    {
        var dispatcher = this._eventDispatchers.get(flavorType);
        if (!dispatcher)
            return;
        dispatcher.removeEventListener(WebInspector.Context.Events.FlavorChanged, listener, thisObject);
        if (!dispatcher.hasEventListeners(WebInspector.Context.Events.FlavorChanged))
            this._eventDispatchers.remove(flavorType);
    },

    /**
     * @param {function(new:T, ...)} flavorType
     * @return {?T}
     * @template T
     */
    flavor: function(flavorType)
    {
        return this._flavors.get(flavorType) || null;
    },

    /**
     * @return {!Set.<function(new:Object, ...)>}
     */
    flavors: function()
    {
        return new Set(this._flavors.keys());
    },

    /**
     * @param {!Array.<!Runtime.Extension>} extensions
     * @return {!Set.<!Runtime.Extension>}
     */
    applicableExtensions: function(extensions)
    {
        var targetExtensionSet = new Set();

        var availableFlavors = this.flavors();
        extensions.forEach(function(extension) {
            if (self.runtime.isExtensionApplicableToContextTypes(extension, availableFlavors))
                targetExtensionSet.add(extension);
        });

        return targetExtensionSet;
    }
}

WebInspector.context = new WebInspector.Context();;/* ContextMenu.js */
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {!WebInspector.ContextMenu} topLevelMenu
 * @param {string} type
 * @param {string=} label
 * @param {boolean=} disabled
 * @param {boolean=} checked
 */
WebInspector.ContextMenuItem = function(topLevelMenu, type, label, disabled, checked)
{
    this._type = type;
    this._label = label;
    this._disabled = disabled;
    this._checked = checked;
    this._contextMenu = topLevelMenu;
    if (type === "item" || type === "checkbox")
        this._id = topLevelMenu._nextId();
}

WebInspector.ContextMenuItem.prototype = {
    /**
     * @return {number}
     */
    id: function()
    {
        return this._id;
    },

    /**
     * @return {string}
     */
    type: function()
    {
        return this._type;
    },

    /**
     * @return {boolean}
     */
    isEnabled: function()
    {
        return !this._disabled;
    },

    /**
     * @param {boolean} enabled
     */
    setEnabled: function(enabled)
    {
        this._disabled = !enabled;
    },

    /**
     * @return {!InspectorFrontendHostAPI.ContextMenuDescriptor}
     */
    _buildDescriptor: function()
    {
        switch (this._type) {
        case "item":
            var result = { type: "item", id: this._id, label: this._label, enabled: !this._disabled };
            if (this._customElement)
                result.element = this._customElement;
            if (this._shortcut)
                result.shortcut = this._shortcut;
            return result;
        case "separator":
            return { type: "separator" };
        case "checkbox":
            return { type: "checkbox", id: this._id, label: this._label, checked: !!this._checked, enabled: !this._disabled };
        }
        throw new Error("Invalid item type:"  + this._type);
    },

    /**
     * @param {string} shortcut
     */
    setShortcut: function(shortcut)
    {
        this._shortcut = shortcut;
    }
}

/**
 * @constructor
 * @extends {WebInspector.ContextMenuItem}
 * @param {!WebInspector.ContextMenu} topLevelMenu
 * @param {string=} label
 * @param {boolean=} disabled
 */
WebInspector.ContextSubMenuItem = function(topLevelMenu, label, disabled)
{
    WebInspector.ContextMenuItem.call(this, topLevelMenu, "subMenu", label, disabled);
    /** @type {!Array.<!WebInspector.ContextMenuItem>} */
    this._items = [];
}

WebInspector.ContextSubMenuItem.prototype = {
    /**
     * @param {string} label
     * @param {function(?)} handler
     * @param {boolean=} disabled
     * @return {!WebInspector.ContextMenuItem}
     */
    appendItem: function(label, handler, disabled)
    {
        var item = new WebInspector.ContextMenuItem(this._contextMenu, "item", label, disabled);
        this._pushItem(item);
        this._contextMenu._setHandler(item.id(), handler);
        return item;
    },

    /**
     * @param {!Element} element
     * @return {!WebInspector.ContextMenuItem}
     */
    appendCustomItem: function(element)
    {
        var item = new WebInspector.ContextMenuItem(this._contextMenu, "item", "<custom>");
        item._customElement = element;
        this._pushItem(item);
        return item;
    },

    /**
     * @param {string} actionId
     * @param {string=} label
     * @return {!WebInspector.ContextMenuItem}
     */
    appendAction: function(actionId, label)
    {
        var action = WebInspector.actionRegistry.action(actionId);
        if (!label)
            label = action.title();
        var result = this.appendItem(label, action.execute.bind(action));
        var shortcut = WebInspector.shortcutRegistry.shortcutTitleForAction(actionId);
        if (shortcut)
            result.setShortcut(shortcut);
        return result;
    },

    /**
     * @param {string} label
     * @param {boolean=} disabled
     * @return {!WebInspector.ContextSubMenuItem}
     */
    appendSubMenuItem: function(label, disabled)
    {
        var item = new WebInspector.ContextSubMenuItem(this._contextMenu, label, disabled);
        this._pushItem(item);
        return item;
    },

    /**
     * @param {string} label
     * @param {function()} handler
     * @param {boolean=} checked
     * @param {boolean=} disabled
     * @return {!WebInspector.ContextMenuItem}
     */
    appendCheckboxItem: function(label, handler, checked, disabled)
    {
        var item = new WebInspector.ContextMenuItem(this._contextMenu, "checkbox", label, disabled, checked);
        this._pushItem(item);
        this._contextMenu._setHandler(item.id(), handler);
        return item;
    },

    appendSeparator: function()
    {
        if (this._items.length)
            this._pendingSeparator = true;
    },

    /**
     * @param {!WebInspector.ContextMenuItem} item
     */
    _pushItem: function(item)
    {
        if (this._pendingSeparator) {
            this._items.push(new WebInspector.ContextMenuItem(this._contextMenu, "separator"));
            delete this._pendingSeparator;
        }
        this._items.push(item);
    },

    /**
     * @return {boolean}
     */
    isEmpty: function()
    {
        return !this._items.length;
    },

    /**
     * @override
     * @return {!InspectorFrontendHostAPI.ContextMenuDescriptor}
     */
    _buildDescriptor: function()
    {
        var result = { type: "subMenu", label: this._label, enabled: !this._disabled, subItems: [] };
        for (var i = 0; i < this._items.length; ++i)
            result.subItems.push(this._items[i]._buildDescriptor());
        return result;
    },

    /**
     * @param {string} location
     */
    appendItemsAtLocation: function(location)
    {
        /**
         * @param {!WebInspector.ContextSubMenuItem} menu
         * @param {!Runtime.Extension} extension
         */
        function appendExtension(menu, extension)
        {
            var subMenuId = extension.descriptor()["subMenuId"];
            if (subMenuId) {
                var subMenuItem = menu.appendSubMenuItem(extension.title(WebInspector.platform()));
                subMenuItem.appendItemsAtLocation(subMenuId);
            } else {
                menu.appendAction(extension.descriptor()["actionId"]);
            }
        }

        // Hard-coded named groups for elements to maintain generic order.
        var groupWeights = ["new", "open", "clipboard", "navigate", "footer"];

        /** @type {!Map.<string, !Array.<!Runtime.Extension>>} */
        var groups = new Map();
        var extensions = self.runtime.extensions("context-menu-item");
        for (var extension of extensions) {
            var itemLocation = extension.descriptor()["location"] || "";
            if (!itemLocation.startsWith(location + "/"))
                continue;

            var itemGroup = itemLocation.substr(location.length + 1);
            if (!itemGroup || itemGroup.includes("/"))
                continue;
            var group = groups.get(itemGroup);
            if (!group) {
                group = [];
                groups.set(itemGroup, group);
                if (groupWeights.indexOf(itemGroup) === -1)
                    groupWeights.splice(4, 0, itemGroup);
            }
            group.push(extension);
        }
        for (var groupName of groupWeights) {
            var group = groups.get(groupName);
            if (!group)
                continue;
            group.forEach(appendExtension.bind(null, this));
            this.appendSeparator();
        }
    },

    __proto__: WebInspector.ContextMenuItem.prototype
}

/**
 * @constructor
 * @extends {WebInspector.ContextSubMenuItem}
 * @param {!Event} event
 * @param {boolean=} useSoftMenu
 * @param {number=} x
 * @param {number=} y
 */
WebInspector.ContextMenu = function(event, useSoftMenu, x, y)
{
    WebInspector.ContextSubMenuItem.call(this, this, "");
    /** @type {!Array.<!Promise.<!Array.<!WebInspector.ContextMenu.Provider>>>} */
    this._pendingPromises = [];
    /** @type {!Array.<!Promise.<!Object>>} */
    this._pendingTargets = [];
    this._event = event;
    this._useSoftMenu = !!useSoftMenu;
    this._x = x === undefined ? event.x : x;
    this._y = y === undefined ? event.y : y;
    this._handlers = {};
    this._id = 0;
}

WebInspector.ContextMenu.initialize = function()
{
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.SetUseSoftMenu, setUseSoftMenu);
    /**
     * @param {!WebInspector.Event} event
     */
    function setUseSoftMenu(event)
    {
        WebInspector.ContextMenu._useSoftMenu = /** @type {boolean} */ (event.data);
    }
}

/**
 * @param {!Document} doc
 */
WebInspector.ContextMenu.installHandler = function(doc)
{
    doc.body.addEventListener("contextmenu", handler, false);

    /**
     * @param {!Event} event
     */
    function handler(event)
    {
        var contextMenu = new WebInspector.ContextMenu(event);
        contextMenu.appendApplicableItems(/** @type {!Object} */ (event.deepElementFromPoint()));
        contextMenu.show();
    }
}

WebInspector.ContextMenu.prototype = {
    /**
     * @return {number}
     */
    _nextId: function()
    {
        return this._id++;
    },

    show: function()
    {
        Promise.all(this._pendingPromises).then(populateAndShow.bind(this));
        WebInspector.ContextMenu._pendingMenu = this;

        /**
         * @param {!Array.<!Array.<!WebInspector.ContextMenu.Provider>>} appendCallResults
         * @this {WebInspector.ContextMenu}
         */
        function populateAndShow(appendCallResults)
        {
            if (WebInspector.ContextMenu._pendingMenu !== this)
                return;
            delete WebInspector.ContextMenu._pendingMenu;

            for (var i = 0; i < appendCallResults.length; ++i) {
                var providers = appendCallResults[i];
                var target = this._pendingTargets[i];

                for (var j = 0; j < providers.length; ++j) {
                    var provider = /** @type {!WebInspector.ContextMenu.Provider} */ (providers[j]);
                    this.appendSeparator();
                    provider.appendApplicableItems(this._event, this, target);
                    this.appendSeparator();
                }
            }

            this._pendingPromises = [];
            this._pendingTargets = [];
            this._innerShow();
        }

        this._event.consume(true);
    },

    discard: function()
    {
        if (this._softMenu)
            this._softMenu.discard();
    },

    _innerShow: function()
    {
        var menuObject = this._buildDescriptors();

        WebInspector._contextMenu = this;
        if (this._useSoftMenu || WebInspector.ContextMenu._useSoftMenu || InspectorFrontendHost.isHostedMode()) {
            this._softMenu = new WebInspector.SoftContextMenu(menuObject, this._itemSelected.bind(this));
            this._softMenu.show(this._event.target.ownerDocument, this._x, this._y);
        } else {
            InspectorFrontendHost.showContextMenuAtPoint(this._x, this._y, menuObject, this._event.target.ownerDocument);

            /**
             * @this {WebInspector.ContextMenu}
             */
            function listenToEvents()
            {
                InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.ContextMenuCleared, this._menuCleared, this);
                InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.ContextMenuItemSelected, this._onItemSelected, this);
            }

            // showContextMenuAtPoint call above synchronously issues a clear event for previous context menu (if any),
            // so we skip it before subscribing to the clear event.
            setImmediate(listenToEvents.bind(this));
        }
    },

    /**
     * @param {number} id
     * @param {function(?)} handler
     */
    _setHandler: function(id, handler)
    {
        if (handler)
            this._handlers[id] = handler;
    },

    /**
     * @return {!Array.<!InspectorFrontendHostAPI.ContextMenuDescriptor>}
     */
    _buildDescriptors: function()
    {
        var result = [];
        for (var i = 0; i < this._items.length; ++i)
            result.push(this._items[i]._buildDescriptor());
        return result;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onItemSelected: function(event)
    {
        this._itemSelected(/** @type {string} */ (event.data));
    },

    /**
     * @param {string} id
     */
    _itemSelected: function(id)
    {
        if (this._handlers[id])
            this._handlers[id].call(this);
        this._menuCleared();
    },

    _menuCleared: function()
    {
        InspectorFrontendHost.events.removeEventListener(InspectorFrontendHostAPI.Events.ContextMenuCleared, this._menuCleared, this);
        InspectorFrontendHost.events.removeEventListener(InspectorFrontendHostAPI.Events.ContextMenuItemSelected, this._onItemSelected, this);
    },

    /**
     * @param {!Object} target
     */
    appendApplicableItems: function(target)
    {
        this._pendingPromises.push(self.runtime.instancesPromise(WebInspector.ContextMenu.Provider, target));
        this._pendingTargets.push(target);
    },

    __proto__: WebInspector.ContextSubMenuItem.prototype
}

/**
 * @interface
 */
WebInspector.ContextMenu.Provider = function() {
}

WebInspector.ContextMenu.Provider.prototype = {
    /**
     * @param {!Event} event
     * @param {!WebInspector.ContextMenu} contextMenu
     * @param {!Object} target
     */
    appendApplicableItems: function(event, contextMenu, target) { }
}
;/* Dialog.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Widget}
 */
WebInspector.Dialog = function()
{
    WebInspector.Widget.call(this, true);
    this.markAsRoot();
    this.registerRequiredCSS("ui/dialog.css");

    this.contentElement.createChild("content");
    this.contentElement.tabIndex = 0;
    this.contentElement.addEventListener("focus", this._onFocus.bind(this), false);
    this.contentElement.addEventListener("keydown", this._onKeyDown.bind(this), false);

    this._wrapsContent = false;
    this._dimmed = false;
    /** @type {!Map<!HTMLElement, number>} */
    this._tabIndexMap = new Map();
}

/**
 * TODO(dgozman): remove this method (it's only used for shortcuts handling).
 * @return {boolean}
 */
WebInspector.Dialog.hasInstance = function()
{
    return !!WebInspector.Dialog._instance;
}

WebInspector.Dialog.prototype = {
    /**
     * @override
     */
    show: function()
    {
        if (WebInspector.Dialog._instance)
            WebInspector.Dialog._instance.detach();
        WebInspector.Dialog._instance = this;

        var document = /** @type {!Document} */ (WebInspector.Dialog._modalHostView.element.ownerDocument);
        this._disableTabIndexOnElements(document);

        this._glassPane = new WebInspector.GlassPane(document, this._dimmed);
        this._glassPane.element.addEventListener("click", this._onGlassPaneClick.bind(this), false);
        WebInspector.GlassPane.DefaultFocusedViewStack.push(this);

        WebInspector.Widget.prototype.show.call(this, this._glassPane.element);

        this._position();
        this.focus();
    },

    /**
     * @override
     */
    detach: function()
    {
        WebInspector.Widget.prototype.detach.call(this);

        WebInspector.GlassPane.DefaultFocusedViewStack.pop();
        this._glassPane.dispose();
        delete this._glassPane;

        this._restoreTabIndexOnElements();

        delete WebInspector.Dialog._instance;
    },

    addCloseButton: function()
    {
        var closeButton = this.contentElement.createChild("div", "dialog-close-button", "dt-close-button");
        closeButton.gray = true;
        closeButton.addEventListener("click", this.detach.bind(this, false), false);
    },

    /**
     * @param {!Size} size
     */
    setMaxSize: function(size)
    {
        this._maxSize = size;
    },

    /**
     * @param {boolean} wraps
     */
    setWrapsContent: function(wraps)
    {
        this.element.classList.toggle("wraps-content", wraps);
        this._wrapsContent = wraps;
    },

    /**
     * @param {boolean} dimmed
     */
    setDimmed: function(dimmed)
    {
        this._dimmed = dimmed;
    },

    contentResized: function()
    {
        if (this._wrapsContent)
            this._position();
    },

    /**
     * @param {!Document} document
     */
    _disableTabIndexOnElements: function(document)
    {
        this._tabIndexMap.clear();
        for (var node = document; node; node = node.traverseNextNode(document)) {
            if (node instanceof HTMLElement) {
                var element = /** @type {!HTMLElement} */  (node);
                var tabIndex = element.tabIndex;
                if (tabIndex >= 0) {
                    this._tabIndexMap.set(element, tabIndex);
                    element.tabIndex = -1;
                }
            }
        }
    },

    _restoreTabIndexOnElements: function()
    {
        for (var element of this._tabIndexMap.keys())
            element.tabIndex = this._tabIndexMap.get(element);
        this._tabIndexMap.clear();
    },

    /**
     * @param {!Event} event
     */
    _onFocus: function(event)
    {
        this.focus();
    },

    /**
     * @param {!Event} event
     */
    _onGlassPaneClick: function(event)
    {
        if (!this.element.isSelfOrAncestor(/** @type {?Node} */ (event.target)))
            this.detach();
    },

    _position: function()
    {
        var container = WebInspector.Dialog._modalHostView.element;

        var width = container.offsetWidth - 10;
        var height = container.offsetHeight- 10;

        if (this._wrapsContent) {
            width = Math.min(width, this.contentElement.offsetWidth);
            height = Math.min(height, this.contentElement.offsetHeight);
        }

        if (this._maxSize) {
            width = Math.min(width, this._maxSize.width);
            height = Math.min(height, this._maxSize.height);
        }

        var positionX = (container.offsetWidth - width) / 2;
        positionX = Number.constrain(positionX, 0, container.offsetWidth - width);

        var positionY = (container.offsetHeight - height) / 2;
        positionY = Number.constrain(positionY, 0, container.offsetHeight - height);

        this.element.style.width = width + "px";
        this.element.style.height = height + "px";
        this.element.positionAt(positionX, positionY, container);
    },

    /**
     * @param {!Event} event
     */
    _onKeyDown: function(event)
    {
        if (event.keyCode === WebInspector.KeyboardShortcut.Keys.Esc.code) {
            event.consume(true);
            this.detach();
        }
    },

    /**
     * @override
     * @return {!Element}
     */
    defaultFocusedElement: function()
    {
        var children = this.children();
        if (children.length)
            return children[0].defaultFocusedElement();
        return this.element;
    },

    __proto__: WebInspector.Widget.prototype
};

/** @type {?WebInspector.Widget} */
WebInspector.Dialog._modalHostView = null;

/**
 * @param {!WebInspector.Widget} view
 */
WebInspector.Dialog.setModalHostView = function(view)
{
    WebInspector.Dialog._modalHostView = view;
};

/**
 * FIXME: make utility method in Dialog, so clients use it instead of this getter.
 * Method should be like Dialog.showModalElement(position params, reposition callback).
 * @return {?WebInspector.Widget}
 */
WebInspector.Dialog.modalHostView = function()
{
    return WebInspector.Dialog._modalHostView;
};

WebInspector.Dialog.modalHostRepositioned = function()
{
    if (WebInspector.Dialog._instance)
        WebInspector.Dialog._instance._position();
};

;/* DOMSyntaxHighlighter.js */
/*
 * Copyright (C) 2010 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {string} mimeType
 * @param {boolean} stripExtraWhitespace
 */
WebInspector.DOMSyntaxHighlighter = function(mimeType, stripExtraWhitespace)
{
    this._mimeType = mimeType;
    this._stripExtraWhitespace = stripExtraWhitespace;
}

WebInspector.DOMSyntaxHighlighter.prototype = {
    /**
     * @param {string} content
     * @param {string} className
     * @return {!Element}
     */
    createSpan: function(content, className)
    {
        var span = createElement("span");
        span.className = "cm-" + className;
        if (this._stripExtraWhitespace && className !== "whitespace")
            content = content.replace(/^[\n\r]*/, "").replace(/\s*$/, "");
        span.createTextChild(content);
        return span;
    },

    /**
     * @param {!Element} node
     * @return {!Promise.<undefined>}
     */
    syntaxHighlightNode: function(node)
    {
        var lines = node.textContent.split("\n");
        var plainTextStart;
        var line;

        return self.runtime.instancePromise(WebInspector.TokenizerFactory).then(processTokens.bind(this));

        /**
         * @param {!WebInspector.TokenizerFactory} tokenizerFactory
         * @this {WebInspector.DOMSyntaxHighlighter}
         */
        function processTokens(tokenizerFactory)
        {
            node.removeChildren();
            var tokenize = tokenizerFactory.createTokenizer(this._mimeType);
            for (var i = lines[0].length ? 0 : 1; i < lines.length; ++i) {
                line = lines[i];
                plainTextStart = 0;
                tokenize(line, processToken.bind(this));
                if (plainTextStart < line.length) {
                    var plainText = line.substring(plainTextStart, line.length);
                    node.createTextChild(plainText);
                }
                if (i < lines.length - 1)
                    node.createTextChild("\n");
            }
        }

        /**
         * @param {string} token
         * @param {?string} tokenType
         * @param {number} column
         * @param {number} newColumn
         * @this {WebInspector.DOMSyntaxHighlighter}
         */
        function processToken(token, tokenType, column, newColumn)
        {
            if (!tokenType)
                return;

            if (column > plainTextStart) {
                var plainText = line.substring(plainTextStart, column);
                node.createTextChild(plainText);
            }
            node.appendChild(this.createSpan(token, tokenType));
            plainTextStart = newColumn;
        }
    }
}
;/* DropDownMenu.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @param {!Element} element
 */
WebInspector.DropDownMenu = function(element)
{
    /** @type {!Array.<!WebInspector.DropDownMenu.Item>} */
    this._items = [];

    element.addEventListener("mousedown", this._onMouseDown.bind(this));
}

/** @typedef {{id: string, title: string}} */
WebInspector.DropDownMenu.Item;

/** @enum {string} */
WebInspector.DropDownMenu.Events = {
    ItemSelected: "ItemSelected"
}

WebInspector.DropDownMenu.prototype = {
    /**
     * @param {!Event} event
     */
    _onMouseDown: function(event)
    {
        if (event.which !== 1)
            return;
        var menu = new WebInspector.ContextMenu(event);
        for (var item of this._items)
            menu.appendCheckboxItem(item.title, this._itemHandler.bind(this, item.id), item.id === this._selectedItemId);
        menu.show();
    },

    /**
     * @param {string} id
     */
    _itemHandler: function(id)
    {
        this.dispatchEventToListeners(WebInspector.DropDownMenu.Events.ItemSelected, id);
    },

    /**
     * @param {string} id
     * @param {string} title
     */
    addItem: function(id, title)
    {
        this._items.push({id: id, title: title});
    },

    /**
     * @param {string} id
     */
    selectItem: function(id)
    {
        this._selectedItemId = id;
    },

    clear: function()
    {
        this._items = [];
        delete this._selectedItemId;
    },

    __proto__: WebInspector.Object.prototype
}
;/* DropTarget.js */
// Copyright (c) 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {!Element} element
 * @param {!Array.<string>} transferTypes
 * @param {string} messageText
 * @param {function(!DataTransfer)} handleDrop
 */
WebInspector.DropTarget = function(element, transferTypes, messageText, handleDrop)
{
    element.addEventListener("dragenter", this._onDragEnter.bind(this), true);
    element.addEventListener("dragover", this._onDragOver.bind(this), true);
    this._element = element;
    this._transferTypes = transferTypes;
    this._messageText = messageText;
    this._handleDrop = handleDrop;
    this._enabled = true;
}

WebInspector.DropTarget.Types = {
    Files: "Files",
    URIList: "text/uri-list"
}

WebInspector.DropTarget.prototype = {
    /**
     * @param {boolean} enabled
     */
    setEnabled: function(enabled)
    {
        this._enabled = enabled;
    },

    /**
     * @param {!Event} event
     */
    _onDragEnter: function(event)
    {
        if (this._enabled && this._hasMatchingType(event))
            event.consume(true);
    },

    /**
     * @param {!Event} event
     * @return {boolean}
     */
    _hasMatchingType: function(event)
    {
        for (var type of this._transferTypes) {
            if (event.dataTransfer.types.indexOf(type) !== -1)
                return true;
        }
        return false;
    },

    /**
     * @param {!Event} event
     */
    _onDragOver: function(event)
    {
        if (!this._enabled || !this._hasMatchingType(event))
            return;
        event.dataTransfer.dropEffect = "copy";
        event.consume(true);
        if (this._dragMaskElement)
            return;
        this._dragMaskElement = this._element.createChild("div", "");
        var shadowRoot = WebInspector.createShadowRootWithCoreStyles(this._dragMaskElement, "ui/dropTarget.css");
        shadowRoot.createChild("div", "drop-target-message").textContent = this._messageText;
        this._dragMaskElement.addEventListener("drop", this._onDrop.bind(this), true);
        this._dragMaskElement.addEventListener("dragleave", this._onDragLeave.bind(this), true);
    },

    /**
     * @param {!Event} event
     */
    _onDrop: function(event)
    {
        event.consume(true);
        this._removeMask();
        if (this._enabled)
            this._handleDrop(event.dataTransfer);
    },

    /**
     * @param {!Event} event
     */
    _onDragLeave: function(event)
    {
        event.consume(true);
        this._removeMask();
    },

    _removeMask: function()
    {
        this._dragMaskElement.remove();
        delete this._dragMaskElement;
    }
}
;/* EmptyWidget.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.VBox}
 */
WebInspector.EmptyWidget = function(text)
{
    WebInspector.VBox.call(this);
    this.registerRequiredCSS("ui/emptyWidget.css");
    this.element.classList.add("empty-view");
    this.textElement = this.element.createChild("span");
    this._text = text;
}

WebInspector.EmptyWidget.prototype = {
    wasShown: function()
    {
        this.textElement.textContent = this._text;
    },

    set text(text)
    {
        this._text = text;
        if (this.isShowing())
            this.textElement.textContent = this._text;
    },

    __proto__: WebInspector.VBox.prototype
}

;/* FilterBar.js */
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.HBox}
 * @param {string} name
 * @param {boolean=} visibleByDefault
 */
WebInspector.FilterBar = function(name, visibleByDefault)
{
    WebInspector.HBox.call(this);
    this.registerRequiredCSS("ui/filter.css");
    this._filtersShown = false;
    this._enabled = true;
    this.element.classList.add("filter-bar");

    this._filterButton = new WebInspector.ToolbarButton(WebInspector.UIString("Filter"), "filter-toolbar-item");
    this._filterButton.addEventListener("click", this._handleFilterButtonClick, this);

    this._filters = [];

    this._stateSetting = WebInspector.settings.createSetting("filterBar-" + name + "-toggled", !!visibleByDefault);
    this._setState(this._stateSetting.get());
}

WebInspector.FilterBar.FilterBarState = {
    Inactive : "inactive",
    Active : "active",
    Shown : "on"
};

WebInspector.FilterBar.Events = {
    Toggled: "Toggled"
};

WebInspector.FilterBar.prototype = {
    /**
     * @return {!WebInspector.ToolbarButton}
     */
    filterButton: function()
    {
        return this._filterButton;
    },

    /**
     * @param {!WebInspector.FilterUI} filter
     */
    addFilter: function(filter)
    {
        this._filters.push(filter);
        this.element.appendChild(filter.element());
        filter.addEventListener(WebInspector.FilterUI.Events.FilterChanged, this._filterChanged, this);
        this._updateFilterButton();
    },

    setEnabled: function(enabled)
    {
        this._enabled = enabled;
        this._filterButton.setEnabled(enabled);
        this._updateFilterBar();
    },

    forceShowFilterBar: function()
    {
        this._alwaysShowFilters = true;
        this._updateFilterBar();
    },

    /**
     * @override
     */
    wasShown: function()
    {
        this._updateFilterBar();
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _filterChanged: function(event)
    {
        this._updateFilterButton();
    },

    /**
     * @return {string}
     */
    _filterBarState: function()
    {
        if (this._filtersShown)
            return WebInspector.FilterBar.FilterBarState.Shown;
        var isActive = false;
        for (var i = 0; i < this._filters.length; ++i) {
            if (this._filters[i].isActive())
                return WebInspector.FilterBar.FilterBarState.Active;
        }
        return WebInspector.FilterBar.FilterBarState.Inactive;
    },

    _updateFilterBar: function()
    {
        var visible = this._alwaysShowFilters || (this._filtersShown && this._enabled);
        this.element.classList.toggle("hidden", !visible);
        if (visible) {
            for (var i = 0; i < this._filters.length; ++i) {
                if (this._filters[i] instanceof WebInspector.TextFilterUI) {
                    var textFilterUI = /** @type {!WebInspector.TextFilterUI} */ (this._filters[i]);
                    textFilterUI.focus();
                }
            }
        }
        this.invalidateSize();
    },

    _updateFilterButton: function()
    {
        this._filterButton.setState(this._filterBarState());
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _handleFilterButtonClick: function(event)
    {
        this._setState(!this._filtersShown);
    },

    /**
     * @param {boolean} filtersShown
     */
    _setState: function(filtersShown)
    {
        if (this._filtersShown === filtersShown)
            return;

        this._filtersShown = filtersShown;
        if (this._stateSetting)
            this._stateSetting.set(filtersShown);

        this._updateFilterButton();
        this._updateFilterBar();
        this.dispatchEventToListeners(WebInspector.FilterBar.Events.Toggled);
    },

    clear: function()
    {
        this.element.removeChildren();
        this._filters = [];
        this._updateFilterButton();
    },

    __proto__: WebInspector.HBox.prototype
}

/**
 * @interface
 * @extends {WebInspector.EventTarget}
 */
WebInspector.FilterUI = function()
{
}

WebInspector.FilterUI.Events = {
    FilterChanged: "FilterChanged"
}

WebInspector.FilterUI.prototype = {
    /**
     * @return {boolean}
     */
    isActive: function() { },

    /**
     * @return {!Element}
     */
    element: function() { }
}

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @implements {WebInspector.FilterUI}
 * @implements {WebInspector.SuggestBoxDelegate}
 * @param {boolean=} supportRegex
 */
WebInspector.TextFilterUI = function(supportRegex)
{
    this._supportRegex = !!supportRegex;
    this._regex = null;

    this._filterElement = createElement("div");
    this._filterElement.className = "filter-text-filter";

    this._filterInputElement = /** @type {!HTMLInputElement} */ (this._filterElement.createChild("input", "filter-input-field"));
    this._filterInputElement.placeholder = WebInspector.UIString("Filter");
    this._filterInputElement.id = "filter-input-field";
    this._filterInputElement.addEventListener("mousedown", this._onFilterFieldManualFocus.bind(this), false); // when the search field is manually selected
    this._filterInputElement.addEventListener("input", this._onInput.bind(this), false);
    this._filterInputElement.addEventListener("change", this._onChange.bind(this), false);
    this._filterInputElement.addEventListener("keydown", this._onInputKeyDown.bind(this), true);
    this._filterInputElement.addEventListener("blur", this._onBlur.bind(this), true);

    /** @type {?WebInspector.TextFilterUI.SuggestionBuilder} */
    this._suggestionBuilder = null;

    this._suggestBox = new WebInspector.SuggestBox(this);

    if (this._supportRegex) {
        this._filterElement.classList.add("supports-regex");
        var label = createCheckboxLabel(WebInspector.UIString("Regex"));
        this._regexCheckBox = label.checkboxElement;
        this._regexCheckBox.id = "text-filter-regex";
        this._regexCheckBox.addEventListener("change", this._onInput.bind(this), false);
        this._filterElement.appendChild(label);

        this._regexLabel = this._filterElement.textElement;
    }
}

WebInspector.TextFilterUI.prototype = {
    /**
     * @override
     * @return {boolean}
     */
    isActive: function()
    {
        return !!this._filterInputElement.value;
    },

    /**
     * @override
     * @return {!Element}
     */
    element: function()
    {
        return this._filterElement;
    },

    /**
     * @return {string}
     */
    value: function()
    {
        return this._filterInputElement.value;
    },

    /**
     * @param {string} value
     */
    setValue: function(value)
    {
        this._filterInputElement.value = value;
        this._valueChanged(false);
    },

    /**
     * @return {?RegExp}
     */
    regex: function()
    {
        return this._regex;
    },

    /**
     * @param {!Event} event
     */
    _onFilterFieldManualFocus: function(event)
    {
        WebInspector.setCurrentFocusElement(/** @type {?Node} */ (event.target));
    },

    /**
     * @param {!Event} event
     */
    _onBlur: function(event)
    {
        this._cancelSuggestion();
    },

    _cancelSuggestion: function()
    {
        if (this._suggestionBuilder && this._suggestBox.visible) {
            this._suggestionBuilder.unapplySuggestion(this._filterInputElement);
            this._suggestBox.hide();
        }
    },

    _onInput: function()
    {
        this._valueChanged(true);
    },

    _onChange: function()
    {
        this._valueChanged(false);
    },

    focus: function()
    {
        this._filterInputElement.focus();
    },

    /**
     * @param {?WebInspector.TextFilterUI.SuggestionBuilder} suggestionBuilder
     */
    setSuggestionBuilder: function(suggestionBuilder)
    {
        this._cancelSuggestion();
        this._suggestionBuilder = suggestionBuilder;
    },

    _updateSuggestions: function()
    {
        if (!this._suggestionBuilder)
            return;
        var suggestions = this._suggestionBuilder.buildSuggestions(this._filterInputElement);
        if (suggestions && suggestions.length) {
            if (this._suppressSuggestion)
                delete this._suppressSuggestion;
            else
                this._suggestionBuilder.applySuggestion(this._filterInputElement, suggestions[0], true);
            var anchorBox = this._filterInputElement.boxInWindow().relativeTo(new AnchorBox(-3, 0));
            this._suggestBox.updateSuggestions(anchorBox, suggestions.map(item => ({title: item})), 0, true, "");
        } else {
            this._suggestBox.hide();
        }
    },

    /**
     * @param {boolean} showSuggestions
     */
    _valueChanged: function(showSuggestions)
    {
        if (showSuggestions)
            this._updateSuggestions();
        else
            this._suggestBox.hide();

        var filterQuery = this.value();

        this._regex = null;
        this._filterInputElement.classList.remove("filter-text-invalid");
        if (filterQuery) {
            if (this._supportRegex && this._regexCheckBox.checked) {
                try {
                    this._regex = new RegExp(filterQuery, "i");
                } catch (e) {
                    this._filterInputElement.classList.add("filter-text-invalid");
                }
            } else {
                this._regex = createPlainTextSearchRegex(filterQuery, "i");
            }
        }

        this._dispatchFilterChanged();
    },

    _dispatchFilterChanged: function()
    {
        this.dispatchEventToListeners(WebInspector.FilterUI.Events.FilterChanged, null);
    },

    /**
     * @param {!Event} event
     * @return {boolean}
     */
    _onInputKeyDown: function(event)
    {
        var handled = false;
        if (event.keyIdentifier === "U+0008") { // Backspace
            this._suppressSuggestion = true;
        } else if (this._suggestBox.visible()) {
            if (event.keyIdentifier === "U+001B") { // Esc
                this._cancelSuggestion();
                handled = true;
            } else if (event.keyIdentifier === "U+0009") { // Tab
                this._suggestBox.acceptSuggestion();
                this._valueChanged(true);
                handled = true;
            } else {
                handled = this._suggestBox.keyPressed(/** @type {!KeyboardEvent} */ (event));
            }
        }
        if (handled)
            event.consume(true);
        return handled;
    },

    /**
     * @override
     * @param {string} suggestion
     * @param {boolean=} isIntermediateSuggestion
     */
    applySuggestion: function(suggestion, isIntermediateSuggestion)
    {
        if (!this._suggestionBuilder)
            return;
        this._suggestionBuilder.applySuggestion(this._filterInputElement, suggestion, !!isIntermediateSuggestion);
        if (isIntermediateSuggestion)
            this._dispatchFilterChanged();
    },

    /** @override */
    acceptSuggestion: function()
    {
        this._filterInputElement.scrollLeft = this._filterInputElement.scrollWidth;
        this._valueChanged(true);
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @interface
 */
WebInspector.TextFilterUI.SuggestionBuilder = function()
{
}

WebInspector.TextFilterUI.SuggestionBuilder.prototype = {
    /**
     * @param {!HTMLInputElement} input
     * @return {?Array.<string>}
     */
    buildSuggestions: function(input) { },

    /**
     * @param {!HTMLInputElement} input
     * @param {string} suggestion
     * @param {boolean} isIntermediate
     */
    applySuggestion: function(input, suggestion, isIntermediate) { },

    /**
     * @param {!HTMLInputElement} input
     */
    unapplySuggestion: function(input) { }
}

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @implements {WebInspector.FilterUI}
 * @param {!Array.<!WebInspector.NamedBitSetFilterUI.Item>} items
 * @param {!WebInspector.Setting=} setting
 */
WebInspector.NamedBitSetFilterUI = function(items, setting)
{
    this._filtersElement = createElementWithClass("div", "filter-bitset-filter");
    this._filtersElement.title = WebInspector.UIString("%sClick to select multiple types", WebInspector.KeyboardShortcut.shortcutToString("", WebInspector.KeyboardShortcut.Modifiers.CtrlOrMeta));

    this._allowedTypes = {};
    this._typeFilterElements = {};
    this._addBit(WebInspector.NamedBitSetFilterUI.ALL_TYPES, WebInspector.UIString("All"));
    this._filtersElement.createChild("div", "filter-bitset-filter-divider");

    for (var i = 0; i < items.length; ++i)
        this._addBit(items[i].name, items[i].label, items[i].title);

    if (setting) {
        this._setting = setting;
        setting.addChangeListener(this._settingChanged.bind(this));
        this._settingChanged();
    } else {
        this._toggleTypeFilter(WebInspector.NamedBitSetFilterUI.ALL_TYPES, false);
    }
}

/** @typedef {{name: string, label: string, title: (string|undefined)}} */
WebInspector.NamedBitSetFilterUI.Item;

WebInspector.NamedBitSetFilterUI.ALL_TYPES = "all";

WebInspector.NamedBitSetFilterUI.prototype = {
    /**
     * @override
     * @return {boolean}
     */
    isActive: function()
    {
        return !this._allowedTypes[WebInspector.NamedBitSetFilterUI.ALL_TYPES];
    },

    /**
     * @override
     * @return {!Element}
     */
    element: function()
    {
        return this._filtersElement;
    },

    /**
     * @param {string} typeName
     * @return {boolean}
     */
    accept: function(typeName)
    {
        return !!this._allowedTypes[WebInspector.NamedBitSetFilterUI.ALL_TYPES] || !!this._allowedTypes[typeName];
    },

    _settingChanged: function()
    {
        var allowedTypes = this._setting.get();
        this._allowedTypes = {};
        for (var typeName in this._typeFilterElements) {
            if (allowedTypes[typeName])
                this._allowedTypes[typeName] = true;
        }
        this._update();
    },

    _update: function()
    {
        if ((Object.keys(this._allowedTypes).length === 0) || this._allowedTypes[WebInspector.NamedBitSetFilterUI.ALL_TYPES]) {
            this._allowedTypes = {};
            this._allowedTypes[WebInspector.NamedBitSetFilterUI.ALL_TYPES] = true;
        }
        for (var typeName in this._typeFilterElements)
            this._typeFilterElements[typeName].classList.toggle("selected", this._allowedTypes[typeName]);
        this.dispatchEventToListeners(WebInspector.FilterUI.Events.FilterChanged, null);
    },

    /**
     * @param {string} name
     * @param {string} label
     * @param {string=} title
     */
    _addBit: function(name, label, title)
    {
        var typeFilterElement = this._filtersElement.createChild("li", name);
        typeFilterElement.typeName = name;
        typeFilterElement.createTextChild(label);
        if (title)
            typeFilterElement.title = title;
        typeFilterElement.addEventListener("click", this._onTypeFilterClicked.bind(this), false);
        this._typeFilterElements[name] = typeFilterElement;
    },

    /**
     * @param {!Event} e
     */
    _onTypeFilterClicked: function(e)
    {
        var toggle;
        if (WebInspector.isMac())
            toggle = e.metaKey && !e.ctrlKey && !e.altKey && !e.shiftKey;
        else
            toggle = e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey;
        this._toggleTypeFilter(e.target.typeName, toggle);
    },

    /**
     * @param {string} typeName
     * @param {boolean} allowMultiSelect
     */
    _toggleTypeFilter: function(typeName, allowMultiSelect)
    {
        if (allowMultiSelect && typeName !== WebInspector.NamedBitSetFilterUI.ALL_TYPES)
            this._allowedTypes[WebInspector.NamedBitSetFilterUI.ALL_TYPES] = false;
        else
            this._allowedTypes = {};

        this._allowedTypes[typeName] = !this._allowedTypes[typeName];

        if (this._setting)
            this._setting.set(this._allowedTypes);
        else
            this._update();
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @constructor
 * @implements {WebInspector.FilterUI}
 * @extends {WebInspector.Object}
 * @param {!Array.<!{value: *, label: string, title: string}>} options
 */
WebInspector.ComboBoxFilterUI = function(options)
{
    this._filterElement = createElement("div");
    this._filterElement.className = "filter-combobox-filter";

    this._options = options;
    this._filterComboBox = new WebInspector.ToolbarComboBox(this._filterChanged.bind(this));
    for (var i = 0; i < options.length; ++i) {
        var filterOption = options[i];
        var option = createElement("option");
        option.text = filterOption.label;
        option.title = filterOption.title;
        this._filterComboBox.addOption(option);
        this._filterComboBox.element.title = this._filterComboBox.selectedOption().title;
    }
    this._filterElement.appendChild(this._filterComboBox.element);
}

WebInspector.ComboBoxFilterUI.prototype = {
    /**
     * @override
     * @return {boolean}
     */
    isActive: function()
    {
        return this._filterComboBox.selectedIndex() !== 0;
    },

    /**
     * @override
     * @return {!Element}
     */
    element: function()
    {
        return this._filterElement;
    },

    /**
     * @return {*}
     */
    value: function()
    {
        var option = this._options[this._filterComboBox.selectedIndex()];
        return option.value;
    },

    /**
     * @param {number} index
     */
    setSelectedIndex: function(index)
    {
        this._filterComboBox.setSelectedIndex(index);
    },

    /**
     * @return {number}
     */
    selectedIndex: function(index)
    {
        return this._filterComboBox.selectedIndex();
    },

    /**
     * @param {!Event} event
     */
    _filterChanged: function(event)
    {
        var option = this._options[this._filterComboBox.selectedIndex()];
        this._filterComboBox.element.title = option.title;
        this.dispatchEventToListeners(WebInspector.FilterUI.Events.FilterChanged, null);
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @constructor
 * @implements {WebInspector.FilterUI}
 * @extends {WebInspector.Object}
 * @param {string} className
 * @param {string} title
 * @param {boolean=} activeWhenChecked
 * @param {!WebInspector.Setting=} setting
 */
WebInspector.CheckboxFilterUI = function(className, title, activeWhenChecked, setting)
{
    this._filterElement = createElementWithClass("div", "filter-checkbox-filter");
    this._activeWhenChecked = !!activeWhenChecked;
    this._label = createCheckboxLabel(title);
    this._filterElement.appendChild(this._label);
    this._checkboxElement = this._label.checkboxElement;
    if (setting)
        WebInspector.SettingsUI.bindCheckbox(this._checkboxElement, setting);
    else
        this._checkboxElement.checked = true;
    this._checkboxElement.addEventListener("change", this._fireUpdated.bind(this), false);
}

WebInspector.CheckboxFilterUI.prototype = {
    /**
     * @override
     * @return {boolean}
     */
    isActive: function()
    {
        return this._activeWhenChecked === this._checkboxElement.checked;
    },

    /**
     * @return {boolean}
     */
    checked: function()
    {
        return this._checkboxElement.checked;
    },

    /**
     * @override
     * @return {!Element}
     */
    element: function()
    {
        return this._filterElement;
    },

    /**
     * @return {!Element}
     */
    labelElement: function()
    {
        return this._label;
    },

    _fireUpdated: function()
    {
        this.dispatchEventToListeners(WebInspector.FilterUI.Events.FilterChanged, null);
    },

    /**
     * @param {string} backgroundColor
     * @param {string} borderColor
     */
    setColor: function(backgroundColor, borderColor)
    {
        this._label.backgroundColor = backgroundColor;
        this._label.borderColor = borderColor;
    },

    __proto__: WebInspector.Object.prototype
}
;/* ForwardedInputEventHandler.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 */
WebInspector.ForwardedInputEventHandler = function()
{
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.KeyEventUnhandled, this._onKeyEventUnhandled, this);
}

WebInspector.ForwardedInputEventHandler.prototype = {
    /**
     * @param {!WebInspector.Event} event
     */
    _onKeyEventUnhandled: function(event)
    {
        var data = event.data;
        var type = /** @type {string} */ (data.type);
        var keyIdentifier = /** @type {string} */ (data.keyIdentifier);
        var keyCode = /** @type {number} */ (data.keyCode);
        var modifiers =/** @type {number} */ (data.modifiers);

        if (type !== "keydown")
            return;

        WebInspector.context.setFlavor(WebInspector.ShortcutRegistry.ForwardedShortcut, WebInspector.ShortcutRegistry.ForwardedShortcut.instance);
        WebInspector.shortcutRegistry.handleKey(WebInspector.KeyboardShortcut.makeKey(keyCode, modifiers), keyIdentifier);
        WebInspector.context.setFlavor(WebInspector.ShortcutRegistry.ForwardedShortcut, null);
    }
}

/** @type {!WebInspector.ForwardedInputEventHandler} */
WebInspector.forwardedEventHandler = new WebInspector.ForwardedInputEventHandler();
;/* HistoryInput.js */
// Copyright (c) 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {HTMLInputElement}
 */
WebInspector.HistoryInput = function()
{
}

/**
 * @return {!WebInspector.HistoryInput}
 */
WebInspector.HistoryInput.create = function()
{
    if (!WebInspector.HistoryInput._constructor)
        WebInspector.HistoryInput._constructor = registerCustomElement("input", "history-input", WebInspector.HistoryInput.prototype);

    return /** @type {!WebInspector.HistoryInput} */(new WebInspector.HistoryInput._constructor());
}

WebInspector.HistoryInput.prototype = {
    createdCallback: function()
    {
        this._history = [""];
        this._historyPosition = 0;
        this.addEventListener("keydown", this._onKeyDown.bind(this), false);
        this.addEventListener("input", this._onInput.bind(this), false);
    },

    /**
     * @param {!Event} event
     */
    _onInput: function(event)
    {
        if (this._history.length === this._historyPosition + 1)
            this._history[this._history.length - 1] = this.value;
    },

    /**
     * @param {!Event} event
     */
    _onKeyDown: function(event)
    {
        if (event.keyCode === WebInspector.KeyboardShortcut.Keys.Up.code) {
            this._historyPosition = Math.max(this._historyPosition - 1, 0);
            this.value = this._history[this._historyPosition];
            this.dispatchEvent(createEvent("input", true, true));
            event.consume(true);
        } else if (event.keyCode === WebInspector.KeyboardShortcut.Keys.Down.code) {
            this._historyPosition = Math.min(this._historyPosition + 1, this._history.length - 1);
            this.value = this._history[this._historyPosition];
            this.dispatchEvent(createEvent("input", true, true));
            event.consume(true);
        } else if (event.keyCode === WebInspector.KeyboardShortcut.Keys.Enter.code) {
            this._saveToHistory();
        }
    },

    _saveToHistory: function()
    {
        if (this._history.length > 1 && this._history[this._history.length - 2] === this.value)
            return;
        this._history[this._history.length - 1] = this.value;
        this._historyPosition = this._history.length - 1;
        this._history.push("");
    },

    __proto__: HTMLInputElement.prototype
}

;/* Infobar.js */
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {!WebInspector.Infobar.Type} type
 * @param {string} text
 * @param {!WebInspector.Setting=} disableSetting
 */
WebInspector.Infobar = function(type, text, disableSetting)
{
    this.element = createElementWithClass("div", "flex-none");
    this._shadowRoot = WebInspector.createShadowRootWithCoreStyles(this.element, "ui/infobar.css");
    this._contentElement = this._shadowRoot.createChild("div", "infobar infobar-" + type);

    this._mainRow = this._contentElement.createChild("div", "infobar-main-row");
    this._mainRow.createChild("div", type + "-icon icon");
    this._mainRowText = this._mainRow.createChild("div", "infobar-main-title");
    this._mainRowText.textContent = text;
    this._detailsRows = this._contentElement.createChild("div", "infobar-details-rows hidden");

    this._toggleElement = this._mainRow.createChild("div", "infobar-toggle hidden");
    this._toggleElement.addEventListener("click", this._onToggleDetails.bind(this), false);
    this._toggleElement.textContent = WebInspector.UIString("more");

    /** @type {?WebInspector.Setting} */
    this._disableSetting = disableSetting || null;
    if (disableSetting) {
        var disableButton = this._mainRow.createChild("div", "infobar-toggle");
        disableButton.textContent = WebInspector.UIString("never show");
        disableButton.addEventListener("click", this._onDisable.bind(this), false);
    }

    this._closeButton = this._contentElement.createChild("div", "close-button", "dt-close-button");
    this._closeButton.addEventListener("click", this.dispose.bind(this), false);

    /** @type {?function()} */
    this._closeCallback = null;
}

/**
 * @param {!WebInspector.Infobar.Type} type
 * @param {string} text
 * @param {!WebInspector.Setting=} disableSetting
 * @return {?WebInspector.Infobar}
 */
WebInspector.Infobar.create = function(type, text, disableSetting)
{
    if (disableSetting && disableSetting.get())
        return null;
    return new WebInspector.Infobar(type, text, disableSetting);
}


/** @enum {string} */
WebInspector.Infobar.Type = {
    Warning: "warning",
    Info: "info"
}

WebInspector.Infobar.prototype = {
    dispose: function()
    {
        this.element.remove();
        this._onResize();
        if (this._closeCallback)
            this._closeCallback.call(null);
    },

    /**
     * @param {string} text
     */
    setText: function(text)
    {
        this._mainRowText.textContent = text;
        this._onResize();
    },

    /**
     * @param {?function()} callback
     */
    setCloseCallback: function(callback)
    {
        this._closeCallback = callback;
    },

    /**
     * @param {!WebInspector.Widget} parentView
     */
    setParentView: function(parentView)
    {
        this._parentView = parentView;
    },

    _onResize: function()
    {
        if (this._parentView)
            this._parentView.doResize();
    },

    _onDisable: function()
    {
        this._disableSetting.set(true);
        this.dispose();
    },

    _onToggleDetails: function()
    {
        this._detailsRows.classList.remove("hidden");
        this._toggleElement.remove();
        this._onResize();
    },

    /**
     * @param {string=} message
     * @return {!Element}
     */
    createDetailsRowMessage: function(message)
    {
        this._toggleElement.classList.remove("hidden");
        var infobarDetailsRow = this._detailsRows.createChild("div", "infobar-details-row");
        var detailsRowMessage = infobarDetailsRow.createChild("span", "infobar-row-message");
        detailsRowMessage.textContent = message || "";
        return detailsRowMessage;
    }
}
;/* InplaceEditor.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 */
WebInspector.InplaceEditor = function()
{
}

/**
 * @typedef {{cancel: function(), commit: function(), setWidth: function(number)}}
 */
WebInspector.InplaceEditor.Controller;

/**
 * @param {!Element} element
 * @param {!WebInspector.InplaceEditor.Config=} config
 * @return {?WebInspector.InplaceEditor.Controller}
 */
WebInspector.InplaceEditor.startEditing = function(element, config)
{
    if (!WebInspector.InplaceEditor._defaultInstance)
        WebInspector.InplaceEditor._defaultInstance = new WebInspector.InplaceEditor();
    return WebInspector.InplaceEditor._defaultInstance.startEditing(element, config);
}

/**
 * @param {!Element} element
 * @param {!WebInspector.InplaceEditor.Config=} config
 * @return {!Promise.<!WebInspector.InplaceEditor.Controller>}
 */
WebInspector.InplaceEditor.startMultilineEditing = function(element, config)
{
    return self.runtime.instancePromise(WebInspector.InplaceEditor).then(startEditing);

    /**
     * @param {!Object} inplaceEditor
     * @return {!WebInspector.InplaceEditor.Controller|!Promise.<!WebInspector.InplaceEditor.Controller>}
     */
    function startEditing(inplaceEditor)
    {
        var controller = /** @type {!WebInspector.InplaceEditor} */ (inplaceEditor).startEditing(element, config);
        if (!controller)
            return Promise.reject(new Error("Editing is already in progress"));
        return controller;
    }
}

WebInspector.InplaceEditor.prototype = {
    /**
     * @return {string}
     */
    editorContent: function(editingContext) {
        var element = editingContext.element;
        if (element.tagName === "INPUT" && element.type === "text")
            return element.value;

        return element.textContent;
    },

    setUpEditor: function(editingContext)
    {
        var element = editingContext.element;
        element.classList.add("editing");

        var oldTabIndex = element.getAttribute("tabIndex");
        if (typeof oldTabIndex !== "number" || oldTabIndex < 0)
            element.tabIndex = 0;
        WebInspector.setCurrentFocusElement(element);
        editingContext.oldTabIndex = oldTabIndex;
    },

    closeEditor: function(editingContext)
    {
        var element = editingContext.element;
        element.classList.remove("editing");

        if (typeof editingContext.oldTabIndex !== "number")
            element.removeAttribute("tabIndex");
        else
            element.tabIndex = editingContext.oldTabIndex;
        element.scrollTop = 0;
        element.scrollLeft = 0;
    },

    cancelEditing: function(editingContext)
    {
        var element = editingContext.element;
        if (element.tagName === "INPUT" && element.type === "text")
            element.value = editingContext.oldText;
        else
            element.textContent = editingContext.oldText;
    },

    augmentEditingHandle: function(editingContext, handle)
    {
    },

    /**
     * @param {!Element} element
     * @param {!WebInspector.InplaceEditor.Config=} config
     * @return {?WebInspector.InplaceEditor.Controller}
     */
    startEditing: function(element, config)
    {
        if (!WebInspector.markBeingEdited(element, true))
            return null;

        config = config || new WebInspector.InplaceEditor.Config(function() {}, function() {});
        var editingContext = { element: element, config: config };
        var committedCallback = config.commitHandler;
        var cancelledCallback = config.cancelHandler;
        var pasteCallback = config.pasteHandler;
        var context = config.context;
        var isMultiline = config.multiline || false;
        var moveDirection = "";
        var self = this;

        /**
         * @param {!Event} e
         */
        function consumeCopy(e)
        {
            e.consume();
        }

        this.setUpEditor(editingContext);

        editingContext.oldText = isMultiline ? config.initialValue : this.editorContent(editingContext);

        /**
         * @param {!Event=} e
         */
        function blurEventListener(e) {
            if (config.blurHandler && !config.blurHandler(element, e))
                return;
            if (!isMultiline || !e || !e.relatedTarget || !e.relatedTarget.isSelfOrDescendant(element))
                editingCommitted.call(element);
        }

        function cleanUpAfterEditing()
        {
            WebInspector.markBeingEdited(element, false);

            element.removeEventListener("blur", blurEventListener, isMultiline);
            element.removeEventListener("keydown", keyDownEventListener, true);
            if (pasteCallback)
                element.removeEventListener("paste", pasteEventListener, true);

            WebInspector.restoreFocusFromElement(element);
            self.closeEditor(editingContext);
        }

        /** @this {Element} */
        function editingCancelled()
        {
            self.cancelEditing(editingContext);
            cleanUpAfterEditing();
            cancelledCallback(this, context);
        }

        /** @this {Element} */
        function editingCommitted()
        {
            cleanUpAfterEditing();

            committedCallback(this, self.editorContent(editingContext), editingContext.oldText, context, moveDirection);
        }

        /**
         * @param {!Event} event
         * @return {string}
         */
        function defaultFinishHandler(event)
        {
            var isMetaOrCtrl = WebInspector.isMac() ?
                event.metaKey && !event.shiftKey && !event.ctrlKey && !event.altKey :
                event.ctrlKey && !event.shiftKey && !event.metaKey && !event.altKey;
            if (isEnterKey(event) && (event.isMetaOrCtrlForTest || !isMultiline || isMetaOrCtrl))
                return "commit";
            else if (event.keyCode === WebInspector.KeyboardShortcut.Keys.Esc.code || event.keyIdentifier === "U+001B")
                return "cancel";
            else if (!isMultiline && event.keyIdentifier === "U+0009") // Tab key
                return "move-" + (event.shiftKey ? "backward" : "forward");
            return "";
        }

        function handleEditingResult(result, event)
        {
            if (result === "commit") {
                editingCommitted.call(element);
                event.consume(true);
            } else if (result === "cancel") {
                editingCancelled.call(element);
                event.consume(true);
            } else if (result && result.startsWith("move-")) {
                moveDirection = result.substring(5);
                if (event.keyIdentifier !== "U+0009")
                    blurEventListener();
            }
        }

        /**
         * @param {!Event} event
         */
        function pasteEventListener(event)
        {
            var result = pasteCallback(event);
            handleEditingResult(result, event);
        }

        /**
         * @param {!Event} event
         */
        function keyDownEventListener(event)
        {
            var result = defaultFinishHandler(event);
            if (!result && config.postKeydownFinishHandler)
                result = config.postKeydownFinishHandler(event);
            handleEditingResult(result, event);
        }

        element.addEventListener("blur", blurEventListener, isMultiline);
        element.addEventListener("keydown", keyDownEventListener, true);
        if (pasteCallback)
            element.addEventListener("paste", pasteEventListener, true);

        var handle = {
            cancel: editingCancelled.bind(element),
            commit: editingCommitted.bind(element),
            setWidth: function() {}
        };
        this.augmentEditingHandle(editingContext, handle);
        return handle;
    }
}

/**
 * @constructor
 * @param {function(!Element,string,string,T,string)} commitHandler
 * @param {function(!Element,T)} cancelHandler
 * @param {T=} context
 * @param {function(!Element,!Event):boolean=} blurHandler
 * @template T
 */
WebInspector.InplaceEditor.Config = function(commitHandler, cancelHandler, context, blurHandler)
{
    this.commitHandler = commitHandler;
    this.cancelHandler = cancelHandler;
    this.context = context;
    this.blurHandler = blurHandler;

    /**
     * @type {function(!Event):string|undefined}
     */
    this.pasteHandler;

    /**
     * @type {boolean|undefined}
     */
    this.multiline;

    /**
     * @type {function(!Event):string|undefined}
     */
    this.postKeydownFinishHandler;
}

WebInspector.InplaceEditor.Config.prototype = {
    setPasteHandler: function(pasteHandler)
    {
        this.pasteHandler = pasteHandler;
    },

    /**
     * @param {string} initialValue
     * @param {!Object} mode
     * @param {string} theme
     * @param {boolean=} lineWrapping
     * @param {boolean=} smartIndent
     */
    setMultilineOptions: function(initialValue, mode, theme, lineWrapping, smartIndent)
    {
        this.multiline = true;
        this.initialValue = initialValue;
        this.mode = mode;
        this.theme = theme;
        this.lineWrapping = lineWrapping;
        this.smartIndent = smartIndent;
    },

    /**
     * @param {function(!Event):string} postKeydownFinishHandler
     */
    setPostKeydownFinishHandler: function(postKeydownFinishHandler)
    {
        this.postKeydownFinishHandler = postKeydownFinishHandler;
    }
}
;/* KeyboardShortcut.js */
/*
 * Copyright (C) 2009 Apple Inc. All rights reserved.
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 */
WebInspector.KeyboardShortcut = function()
{
}

/**
 * Constants for encoding modifier key set as a bit mask.
 * @see #_makeKeyFromCodeAndModifiers
 */
WebInspector.KeyboardShortcut.Modifiers = {
    None: 0,   // Constant for empty modifiers set.
    Shift: 1,
    Ctrl: 2,
    Alt: 4,
    Meta: 8,   // Command key on Mac, Win key on other platforms.
    get CtrlOrMeta()
    {
        // "default" command/ctrl key for platform, Command on Mac, Ctrl on other platforms
        return WebInspector.isMac() ? this.Meta : this.Ctrl;
    },
    get ShiftOrOption()
    {
        // Option on Mac, Shift on other platforms
        return WebInspector.isMac() ? this.Alt : this.Shift;
    }
};

/** @typedef {!{code: number, name: (string|!Object.<string, string>)}} */
WebInspector.KeyboardShortcut.Key;

/** @type {!Object.<string, !WebInspector.KeyboardShortcut.Key>} */
WebInspector.KeyboardShortcut.Keys = {
    Backspace: { code: 8, name: "\u21a4" },
    Tab: { code: 9, name: { mac: "\u21e5", other: "Tab" } },
    Enter: { code: 13, name: { mac: "\u21a9", other: "Enter" } },
    Shift: { code: 16, name: { mac: "\u21e7", other: "Shift" } },
    Ctrl: { code: 17, name: "Ctrl" },
    Esc: { code: 27, name: "Esc" },
    Space: { code: 32, name: "Space" },
    PageUp: { code: 33,  name: { mac: "\u21de", other: "PageUp" } },      // also NUM_NORTH_EAST
    PageDown: { code: 34, name: { mac: "\u21df", other: "PageDown" } },   // also NUM_SOUTH_EAST
    End: { code: 35, name: { mac: "\u2197", other: "End" } },             // also NUM_SOUTH_WEST
    Home: { code: 36, name: { mac: "\u2196", other: "Home" } },           // also NUM_NORTH_WEST
    Left: { code: 37, name: "\u2190" },           // also NUM_WEST
    Up: { code: 38, name: "\u2191" },             // also NUM_NORTH
    Right: { code: 39, name: "\u2192" },          // also NUM_EAST
    Down: { code: 40, name: "\u2193" },           // also NUM_SOUTH
    Delete: { code: 46, name: "Del" },
    Zero: { code: 48, name: "0" },
    H: { code: 72, name: "H" },
    Meta: { code: 91, name: "Meta" },
    F1: { code: 112, name: "F1" },
    F2: { code: 113, name: "F2" },
    F3: { code: 114, name: "F3" },
    F4: { code: 115, name: "F4" },
    F5: { code: 116, name: "F5" },
    F6: { code: 117, name: "F6" },
    F7: { code: 118, name: "F7" },
    F8: { code: 119, name: "F8" },
    F9: { code: 120, name: "F9" },
    F10: { code: 121, name: "F10" },
    F11: { code: 122, name: "F11" },
    F12: { code: 123, name: "F12" },
    Semicolon: { code: 186, name: ";" },
    NumpadPlus: { code: 107, name: "Numpad +" },
    NumpadMinus: { code: 109, name: "Numpad -" },
    Numpad0: { code: 96, name: "Numpad 0" },
    Plus: { code: 187, name: "+" },
    Comma: { code: 188, name: "," },
    Minus: { code: 189, name: "-" },
    Period: { code: 190, name: "." },
    Slash: { code: 191, name: "/" },
    QuestionMark: { code: 191, name: "?" },
    Apostrophe: { code: 192, name: "`" },
    Tilde: { code: 192, name: "Tilde" },
    LeftSquareBracket: { code: 219, name: "[" },
    RightSquareBracket: { code: 221, name: "]" },
    Backslash: { code: 220, name: "\\" },
    SingleQuote: { code: 222, name: "\'" },
    get CtrlOrMeta()
    {
        // "default" command/ctrl key for platform, Command on Mac, Ctrl on other platforms
        return WebInspector.isMac() ? this.Meta : this.Ctrl;
    },
};

WebInspector.KeyboardShortcut.KeyBindings = {};

(function() {
    for (var key in WebInspector.KeyboardShortcut.Keys) {
        var descriptor = WebInspector.KeyboardShortcut.Keys[key];
        if (typeof descriptor === "object" && descriptor["code"]) {
            var name = typeof descriptor["name"] === "string" ? descriptor["name"] : key;
            WebInspector.KeyboardShortcut.KeyBindings[name] = descriptor;
        }
    }
})();

/**
 * Creates a number encoding keyCode in the lower 8 bits and modifiers mask in the higher 8 bits.
 * It is useful for matching pressed keys.
 *
 * @param {number|string} keyCode The code of the key, or a character "a-z" which is converted to a keyCode value.
 * @param {number=} modifiers Optional list of modifiers passed as additional parameters.
 * @return {number}
 */
WebInspector.KeyboardShortcut.makeKey = function(keyCode, modifiers)
{
    if (typeof keyCode === "string")
        keyCode = keyCode.charCodeAt(0) - (/^[a-z]/.test(keyCode) ? 32 : 0);
    modifiers = modifiers || WebInspector.KeyboardShortcut.Modifiers.None;
    return WebInspector.KeyboardShortcut._makeKeyFromCodeAndModifiers(keyCode, modifiers);
}

/**
 * @param {?KeyboardEvent} keyboardEvent
 * @return {number}
 */
WebInspector.KeyboardShortcut.makeKeyFromEvent = function(keyboardEvent)
{
    var modifiers = WebInspector.KeyboardShortcut.Modifiers.None;
    if (keyboardEvent.shiftKey)
        modifiers |= WebInspector.KeyboardShortcut.Modifiers.Shift;
    if (keyboardEvent.ctrlKey)
        modifiers |= WebInspector.KeyboardShortcut.Modifiers.Ctrl;
    if (keyboardEvent.altKey)
        modifiers |= WebInspector.KeyboardShortcut.Modifiers.Alt;
    if (keyboardEvent.metaKey)
        modifiers |= WebInspector.KeyboardShortcut.Modifiers.Meta;

    // Use either a real or a synthetic keyCode (for events originating from extensions).
    var keyCode = keyboardEvent.keyCode || keyboardEvent["__keyCode"];
    return WebInspector.KeyboardShortcut._makeKeyFromCodeAndModifiers(keyCode, modifiers);
}

/**
 * @param {?KeyboardEvent} keyboardEvent
 * @return {number}
 */
WebInspector.KeyboardShortcut.makeKeyFromEventIgnoringModifiers = function(keyboardEvent)
{
    var keyCode = keyboardEvent.keyCode || keyboardEvent["__keyCode"];
    return WebInspector.KeyboardShortcut._makeKeyFromCodeAndModifiers(keyCode, WebInspector.KeyboardShortcut.Modifiers.None);
}

/**
 * @param {(?KeyboardEvent|?MouseEvent)} event
 * @return {boolean}
 */
WebInspector.KeyboardShortcut.eventHasCtrlOrMeta = function(event)
{
    return WebInspector.isMac() ? event.metaKey && !event.ctrlKey : event.ctrlKey && !event.metaKey;
}

/**
 * @param {!Event} event
 * @return {boolean}
 */
WebInspector.KeyboardShortcut.hasNoModifiers = function(event)
{
    return !event.ctrlKey && !event.shiftKey && !event.altKey && !event.metaKey;
}

/** @typedef {!{key: number, name: string}} */
WebInspector.KeyboardShortcut.Descriptor;

/**
 * @param {string|!WebInspector.KeyboardShortcut.Key} key
 * @param {number=} modifiers
 * @return {!WebInspector.KeyboardShortcut.Descriptor}
 */
WebInspector.KeyboardShortcut.makeDescriptor = function(key, modifiers)
{
    return {
        key: WebInspector.KeyboardShortcut.makeKey(typeof key === "string" ? key : key.code, modifiers),
        name: WebInspector.KeyboardShortcut.shortcutToString(key, modifiers)
    };
}

/**
 * @param {string} shortcut
 * @return {?WebInspector.KeyboardShortcut.Descriptor}
 */
WebInspector.KeyboardShortcut.makeDescriptorFromBindingShortcut = function(shortcut)
{
    var parts = shortcut.split(/\+(?!$)/);
    var modifiers = 0;
    var keyString;
    for (var i = 0; i < parts.length; ++i) {
        if (typeof WebInspector.KeyboardShortcut.Modifiers[parts[i]] !== "undefined") {
            modifiers |= WebInspector.KeyboardShortcut.Modifiers[parts[i]];
            continue;
        }
        console.assert(i === parts.length - 1, "Only one key other than modifier is allowed in shortcut <" + shortcut + ">");
        keyString = parts[i];
        break;
    }
    console.assert(keyString, "Modifiers-only shortcuts are not allowed (encountered <" + shortcut + ">)");
    if (!keyString)
        return null;

    var key = WebInspector.KeyboardShortcut.Keys[keyString] || WebInspector.KeyboardShortcut.KeyBindings[keyString];
    if (key && key.shiftKey)
        modifiers |= WebInspector.KeyboardShortcut.Modifiers.Shift;
    return WebInspector.KeyboardShortcut.makeDescriptor(key ? key : keyString, modifiers);
}

/**
 * @param {string|!WebInspector.KeyboardShortcut.Key} key
 * @param {number=} modifiers
 * @return {string}
 */
WebInspector.KeyboardShortcut.shortcutToString = function(key, modifiers)
{
    return WebInspector.KeyboardShortcut._modifiersToString(modifiers) + WebInspector.KeyboardShortcut._keyName(key);
}

/**
 * @param {string|!WebInspector.KeyboardShortcut.Key} key
 * @return {string}
 */
WebInspector.KeyboardShortcut._keyName = function(key)
{
    if (typeof key === "string")
        return key.toUpperCase();
    if (typeof key.name === "string")
        return key.name;
    return key.name[WebInspector.platform()] || key.name.other || '';
}

/**
 * @param {number} keyCode
 * @param {?number} modifiers
 * @return {number}
 */
WebInspector.KeyboardShortcut._makeKeyFromCodeAndModifiers = function(keyCode, modifiers)
{
    return (keyCode & 255) | (modifiers << 8);
};

/**
 * @param {number} key
 * @return {!{keyCode: number, modifiers: number}}
 */
WebInspector.KeyboardShortcut.keyCodeAndModifiersFromKey = function(key)
{
    return { keyCode: key & 255, modifiers: key >> 8 };
}

/**
 * @param {number|undefined} modifiers
 * @return {string}
 */
WebInspector.KeyboardShortcut._modifiersToString = function(modifiers)
{
    var isMac = WebInspector.isMac();
    var m = WebInspector.KeyboardShortcut.Modifiers;
    var modifierNames = new Map([
        [m.Ctrl, isMac ? "Ctrl\u2004" : "Ctrl\u200A+\u200A"],
        [m.Alt, isMac ? "opt\u2004" : "Alt\u200A+\u200A"],
        [m.Shift, isMac ? "\u21e7\u2004" : "Shift\u200A+\u200A"],
        [m.Meta, isMac ? "\u2318\u2004" : "Win\u200A+\u200A"]
    ]);
    return [m.Meta, m.Ctrl, m.Alt, m.Shift].map(mapModifiers).join("");

    /**
     * @param {number} m
     * @return {string}
     */
    function mapModifiers(m)
    {
        return modifiers & m ? /** @type {string} */ (modifierNames.get(m)) : "";
    }
};

WebInspector.KeyboardShortcut.SelectAll = WebInspector.KeyboardShortcut.makeKey("a", WebInspector.KeyboardShortcut.Modifiers.CtrlOrMeta);
;/* ListWidget.js */
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.VBox}
 * @param {!WebInspector.ListWidget.Delegate} delegate
 */
WebInspector.ListWidget = function(delegate)
{
    WebInspector.VBox.call(this, true);
    this.registerRequiredCSS("ui/listWidget.css");
    this._delegate = delegate;

    this._list = this.contentElement.createChild("div", "list");

    /** @type {?WebInspector.ListWidget.Editor} */
    this._editor = null;
    /** @type {*|null} */
    this._editItem = null;
    /** @type {?Element} */
    this._editElement = null;

    /** @type {?Element} */
    this._emptyPlaceholder = null;

    this.clear();
}

/**
 * @interface
 */
WebInspector.ListWidget.Delegate = function()
{
}

WebInspector.ListWidget.Delegate.prototype = {
    /**
     * @param {*} item
     * @param {boolean} editable
     * @return {!Element}
     */
    renderItem: function(item, editable) { },

    /**
     * @param {*} item
     * @param {number} index
     */
    removeItemRequested: function(item, index) { },

    /**
     * @param {*} item
     * @return {!WebInspector.ListWidget.Editor}
     */
    beginEdit: function(item) { },

    /**
     * @param {*} item
     * @param {!WebInspector.ListWidget.Editor} editor
     * @param {boolean} isNew
     */
    commitEdit: function(item, editor, isNew) { }
}

WebInspector.ListWidget.prototype = {
    clear: function()
    {
        this._items = [];
        this._editable = [];
        this._elements = [];
        this._lastSeparator = false;
        this._list.removeChildren();
        this._updatePlaceholder();
        this._stopEditing();
    },

    /**
     * @param {*} item
     * @param {boolean} editable
     */
    appendItem: function(item, editable)
    {
        if (this._lastSeparator && this._items.length)
            this._list.appendChild(createElementWithClass("div", "list-separator"));
        this._lastSeparator = false;

        this._items.push(item);
        this._editable.push(editable);

        var element = this._list.createChild("div", "list-item");
        element.appendChild(this._delegate.renderItem(item, editable));
        if (editable) {
            element.classList.add("editable");
            element.appendChild(this._createControls(item, element));
        }
        this._elements.push(element);
        this._updatePlaceholder();
    },

    appendSeparator: function()
    {
        this._lastSeparator = true;
    },

    /**
     * @param {number} index
     */
    removeItem: function(index)
    {
        if (this._editItem === this._items[index])
            this._stopEditing();

        var element = this._elements[index];

        var previous = element.previousElementSibling;
        var previousIsSeparator = previous && previous.classList.contains("list-separator");

        var next = element.nextElementSibling;
        var nextIsSeparator = next && next.classList.contains("list-separator");

        if (previousIsSeparator && (nextIsSeparator || !next))
            previous.remove();
        if (nextIsSeparator && !previous)
            next.remove();
        element.remove();

        this._elements.splice(index, 1);
        this._items.splice(index, 1);
        this._editable.splice(index, 1);
        this._updatePlaceholder();
    },

    /**
     * @param {number} index
     * @param {*} item
     */
    addNewItem: function(index, item)
    {
        this._startEditing(item, null, this._elements[index] || null);
    },

    /**
     * @param {?Element} element
     */
    setEmptyPlaceholder: function(element)
    {
        this._emptyPlaceholder = element;
        this._updatePlaceholder();
    },

    /**
     * @param {*} item
     * @param {!Element} element
     * @return {!Element}
     */
    _createControls: function(item, element)
    {
        var controls = createElementWithClass("div", "controls-container fill");
        var gradient = controls.createChild("div", "controls-gradient");
        var buttons = controls.createChild("div", "controls-buttons");

        var editButton = buttons.createChild("div", "edit-button");
        editButton.title = WebInspector.UIString("Edit");
        editButton.addEventListener("click", onEditClicked.bind(this), false);

        var removeButton = buttons.createChild("div", "remove-button");
        removeButton.title = WebInspector.UIString("Remove");
        removeButton.addEventListener("click", onRemoveClicked.bind(this), false);

        return controls;

        /**
         * @param {!Event} event
         * @this {WebInspector.ListWidget}
         */
        function onEditClicked(event)
        {
            event.consume();
            var index = this._elements.indexOf(element);
            var insertionPoint = this._elements[index + 1] || null;
            this._startEditing(item, element, insertionPoint);
        }

        /**
         * @param {!Event} event
         * @this {WebInspector.ListWidget}
         */
        function onRemoveClicked(event)
        {
            event.consume();
            var index = this._elements.indexOf(element);
            this._delegate.removeItemRequested(this._items[index], index);
        }
    },

    wasShown: function()
    {
        WebInspector.VBox.prototype.wasShown.call(this);
        this._stopEditing();
    },

    _updatePlaceholder: function()
    {
        if (!this._emptyPlaceholder)
            return;

        if (!this._elements.length && !this._editor)
            this._list.appendChild(this._emptyPlaceholder);
        else
            this._emptyPlaceholder.remove();
    },

    /**
     * @param {*} item
     * @param {?Element} element
     * @param {?Element} insertionPoint
     */
    _startEditing: function(item, element, insertionPoint)
    {
        if (element && this._editElement === element)
            return;

        this._stopEditing();

        this._list.classList.add("list-editing");
        this._editItem = item;
        this._editElement = element;
        if (element)
            element.classList.add("hidden");

        var index = element ? this._elements.indexOf(element) : -1;
        this._editor = this._delegate.beginEdit(item);
        this._updatePlaceholder();
        this._list.insertBefore(this._editor.element, insertionPoint);
        this._editor.beginEdit(item, index, element ? WebInspector.UIString("Save") : WebInspector.UIString("Add"), this._commitEditing.bind(this), this._stopEditing.bind(this));
    },

    _commitEditing: function()
    {
        var editItem = this._editItem;
        var isNew = !this._editElement;
        var editor = /** @type {!WebInspector.ListWidget.Editor} */ (this._editor);
        this._stopEditing();
        this._delegate.commitEdit(editItem, editor, isNew);
    },

    _stopEditing: function()
    {
        this._list.classList.remove("list-editing");
        if (this._editElement)
            this._editElement.classList.remove("hidden");
        if (this._editor && this._editor.element.parentElement)
            this._editor.element.remove();

        this._editor = null;
        this._editItem = null;
        this._editElement = null;
        this._updatePlaceholder();
    },

    __proto__: WebInspector.VBox.prototype
}

/**
 * @constructor
 */
WebInspector.ListWidget.Editor = function()
{
    this.element = createElementWithClass("div", "editor-container");
    this.element.addEventListener("keydown", onKeyDown.bind(null, isEscKey, this._cancelClicked.bind(this)), false);
    this.element.addEventListener("keydown", onKeyDown.bind(null, isEnterKey, this._commitClicked.bind(this)), false);

    this._contentElement = this.element.createChild("div", "editor-content");

    var buttonsRow = this.element.createChild("div", "editor-buttons");
    this._commitButton = createTextButton("", this._commitClicked.bind(this));
    buttonsRow.appendChild(this._commitButton);
    this._cancelButton = createTextButton(WebInspector.UIString("Cancel"), this._cancelClicked.bind(this));
    this._cancelButton.addEventListener("keydown", onKeyDown.bind(null, isEnterKey, this._cancelClicked.bind(this)), false);
    buttonsRow.appendChild(this._cancelButton);

    /**
     * @param {function(!Event):boolean} predicate
     * @param {function()} callback
     * @param {!Event} event
     */
    function onKeyDown(predicate, callback, event)
    {
        if (predicate(event)) {
            event.consume(true);
            callback();
        }
    }

    /** @type {!Array<!HTMLInputElement|!HTMLSelectElement>} */
    this._controls = [];
    /** @type {!Map<string, !HTMLInputElement|!HTMLSelectElement>} */
    this._controlByName = new Map();
    /** @type {!Array<function(*, number, (!HTMLInputElement|!HTMLSelectElement)):boolean>} */
    this._validators = [];

    /** @type {?function()} */
    this._commit = null;
    /** @type {?function()} */
    this._cancel = null;
    /** @type {*|null} */
    this._item = null;
    /** @type {number} */
    this._index = -1;
}

WebInspector.ListWidget.Editor.prototype = {
    /**
     * @return {!Element}
     */
    contentElement: function()
    {
        return this._contentElement;
    },

    /**
     * @param {string} name
     * @param {string} type
     * @param {string} title
     * @param {function(*, number, (!HTMLInputElement|!HTMLSelectElement)):boolean} validator
     * @return {!HTMLInputElement}
     */
    createInput: function(name, type, title, validator)
    {
        var input = /** @type {!HTMLInputElement} */ (createElement("input"));
        input.type = type;
        input.placeholder = title;
        input.addEventListener("input", this._validateControls.bind(this, false), false);
        input.addEventListener("blur", this._validateControls.bind(this, false), false);
        this._controlByName.set(name, input);
        this._controls.push(input);
        this._validators.push(validator);
        return input;
    },

    /**
     * @param {string} name
     * @param {!Array<string>} options
     * @param {function(*, number, (!HTMLInputElement|!HTMLSelectElement)):boolean} validator
     * @return {!HTMLSelectElement}
     */
    createSelect: function(name, options, validator)
    {
        var select = /** @type {!HTMLSelectElement} */ (createElementWithClass("select", "chrome-select"));
        for (var index = 0; index < options.length; ++index) {
            var option = select.createChild("option");
            option.value = options[index];
            option.textContent = options[index];
        }
        select.addEventListener("input", this._validateControls.bind(this, false), false);
        select.addEventListener("blur", this._validateControls.bind(this, false), false);
        this._controlByName.set(name, select);
        this._controls.push(select);
        this._validators.push(validator);
        return select;
    },

    /**
     * @param {string} name
     * @return {!HTMLInputElement|!HTMLSelectElement}
     */
    control: function(name)
    {
        return /** @type {!HTMLInputElement|!HTMLSelectElement} */ (this._controlByName.get(name));
    },

    /**
     * @param {boolean} forceValid
     */
    _validateControls: function(forceValid)
    {
        var allValid = true;
        for (var index = 0; index < this._controls.length; ++index) {
            var input = this._controls[index];
            var valid = this._validators[index].call(null, this._item, this._index, input);
            input.classList.toggle("error-input", !valid && !forceValid);
            allValid &= valid;
        }
        this._commitButton.disabled = !allValid;
    },

    /**
     * @param {*} item
     * @param {number} index
     * @param {string} commitButtonTitle
     * @param {function()} commit
     * @param {function()} cancel
     */
    beginEdit: function(item, index, commitButtonTitle, commit, cancel)
    {
        this._commit = commit;
        this._cancel = cancel;
        this._item = item;
        this._index = index;

        this._commitButton.textContent = commitButtonTitle;
        this.element.scrollIntoViewIfNeeded(false);
        if (this._controls.length)
            this._controls[0].focus();
        this._validateControls(true);
    },

    _commitClicked: function()
    {
        if (this._commitButton.disabled)
            return;

        var commit = this._commit;
        this._commit = null;
        this._cancel = null;
        this._item = null;
        this._index = -1;
        commit();
    },

    _cancelClicked: function()
    {
        var cancel = this._cancel;
        this._commit = null;
        this._cancel = null;
        this._item = null;
        this._index = -1;
        cancel();
    }
}
;/* Panel.js */
/*
 * Copyright (C) 2007, 2008 Apple Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @extends {WebInspector.VBox}
 * @constructor
 */
WebInspector.Panel = function(name)
{
    WebInspector.VBox.call(this);

    this.element.classList.add("panel");
    this.element.classList.add(name);
    this._panelName = name;

    this._shortcuts = /** !Object.<number, function(Event=):boolean> */ ({});
}

// Should by in sync with style declarations.
WebInspector.Panel.counterRightMargin = 25;

WebInspector.Panel.prototype = {
    get name()
    {
        return this._panelName;
    },

    reset: function()
    {
    },

    /**
     * @return {?WebInspector.SearchableView}
     */
    searchableView: function()
    {
        return null;
    },

    /**
     * @override
     * @return {!Array.<!Element>}
     */
    elementsToRestoreScrollPositionsFor: function()
    {
        return [];
    },

    /**
     * @param {!KeyboardEvent} event
     */
    handleShortcut: function(event)
    {
        var shortcutKey = WebInspector.KeyboardShortcut.makeKeyFromEvent(event);
        var handler = this._shortcuts[shortcutKey];
        if (handler && handler(event))
            event.handled = true;
    },

    /**
     * @param {!Array.<!WebInspector.KeyboardShortcut.Descriptor>} keys
     * @param {function(!Event=):boolean} handler
     */
    registerShortcuts: function(keys, handler)
    {
        for (var i = 0; i < keys.length; ++i)
            this._shortcuts[keys[i].key] = handler;
    },

    /**
     * @param {!WebInspector.Infobar} infobar
     */
    showInfobar: function(infobar)
    {
        infobar.setCloseCallback(this._onInfobarClosed.bind(this, infobar));
        if (this.element.firstChild)
            this.element.insertBefore(infobar.element, this.element.firstChild);
        else
            this.element.appendChild(infobar.element);
        infobar.setParentView(this);
        this.doResize();
    },

    /**
     * @param {!WebInspector.Infobar} infobar
     */
    _onInfobarClosed: function(infobar)
    {
        infobar.element.remove();
        this.doResize();
    },

    __proto__: WebInspector.VBox.prototype
}

/**
 * @extends {WebInspector.Panel}
 * @param {string} name
 * @param {number=} defaultWidth
 * @constructor
 */
WebInspector.PanelWithSidebar = function(name, defaultWidth)
{
    WebInspector.Panel.call(this, name);

    this._panelSplitWidget = new WebInspector.SplitWidget(true, false, this._panelName + "PanelSplitViewState", defaultWidth || 200);
    this._panelSplitWidget.show(this.element);

    this._mainWidget = new WebInspector.VBox();
    this._panelSplitWidget.setMainWidget(this._mainWidget);

    this._sidebarWidget = new WebInspector.VBox();
    this._sidebarWidget.setMinimumSize(100, 25);
    this._panelSplitWidget.setSidebarWidget(this._sidebarWidget);

    this._sidebarWidget.element.classList.add("sidebar");
}

WebInspector.PanelWithSidebar.prototype = {
    /**
     * @return {!Element}
     */
    panelSidebarElement: function()
    {
        return this._sidebarWidget.element;
    },

    /**
     * @return {!Element}
     */
    mainElement: function()
    {
        return this._mainWidget.element;
    },

    /**
     * @return {!WebInspector.SplitWidget}
     */
    splitWidget: function()
    {
        return this._panelSplitWidget;
    },

    __proto__: WebInspector.Panel.prototype
}

/**
 * @interface
 */
WebInspector.PanelDescriptor = function()
{
}

WebInspector.PanelDescriptor.prototype = {
    /**
     * @return {string}
     */
    name: function() {},

    /**
     * @return {string}
     */
    title: function() {},

    /**
     * @return {!Promise.<!WebInspector.Panel>}
     */
    panel: function() {}
}

/**
 * @interface
 */
WebInspector.PanelFactory = function()
{
}

WebInspector.PanelFactory.prototype = {
    /**
     * @return {!WebInspector.Panel}
     */
    createPanel: function() { }
}

/**
 * @constructor
 * @param {!Runtime.Extension} extension
 * @implements {WebInspector.PanelDescriptor}
 */
WebInspector.RuntimeExtensionPanelDescriptor = function(extension)
{
    this._name = extension.descriptor()["name"];
    this._title = WebInspector.UIString(extension.descriptor()["title"]);
    this._extension = extension;
}

WebInspector.RuntimeExtensionPanelDescriptor.prototype = {
    /**
     * @override
     * @return {string}
     */
    name: function()
    {
        return this._name;
    },

    /**
     * @override
     * @return {string}
     */
    title: function()
    {
        return this._title;
    },

    /**
     * @override
     * @return {!Promise.<!WebInspector.Panel>}
     */
    panel: function()
    {
        return this._extension.instancePromise().then(createPanel);

        /**
         * @param {!Object} panelFactory
         * @return {!WebInspector.Panel}
         */
        function createPanel(panelFactory)
        {
            return /** @type {!WebInspector.PanelFactory} */ (panelFactory).createPanel();
        }
    }
}
;/* Popover.js */
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Widget}
 * @param {!WebInspector.PopoverHelper=} popoverHelper
 */
WebInspector.Popover = function(popoverHelper)
{
    WebInspector.Widget.call(this);
    this.markAsRoot();
    this.element.className = WebInspector.Popover._classNamePrefix; // Override
    this._containerElement = createElementWithClass("div", "fill popover-container");

    this._popupArrowElement = this.element.createChild("div", "arrow");
    this._contentDiv = this.element.createChild("div", "content");

    this._popoverHelper = popoverHelper;
    this._hideBound = this.hide.bind(this);
}

WebInspector.Popover._classNamePrefix = "popover";

WebInspector.Popover.prototype = {
    /**
     * @param {!Element} element
     * @param {!Element|!AnchorBox} anchor
     * @param {?number=} preferredWidth
     * @param {?number=} preferredHeight
     * @param {?WebInspector.Popover.Orientation=} arrowDirection
     */
    showForAnchor: function(element, anchor, preferredWidth, preferredHeight, arrowDirection)
    {
        this._innerShow(null, element, anchor, preferredWidth, preferredHeight, arrowDirection);
    },

    /**
     * @param {!WebInspector.Widget} view
     * @param {!Element|!AnchorBox} anchor
     * @param {?number=} preferredWidth
     * @param {?number=} preferredHeight
     */
    showView: function(view, anchor, preferredWidth, preferredHeight)
    {
        this._innerShow(view, view.element, anchor, preferredWidth, preferredHeight);
    },

    /**
     * @param {?WebInspector.Widget} view
     * @param {!Element} contentElement
     * @param {!Element|!AnchorBox} anchor
     * @param {?number=} preferredWidth
     * @param {?number=} preferredHeight
     * @param {?WebInspector.Popover.Orientation=} arrowDirection
     */
    _innerShow: function(view, contentElement, anchor, preferredWidth, preferredHeight, arrowDirection)
    {
        if (this._disposed)
            return;
        this._contentElement = contentElement;

        // This should not happen, but we hide previous popup to be on the safe side.
        if (WebInspector.Popover._popover)
            WebInspector.Popover._popover.hide();
        WebInspector.Popover._popover = this;

        var document = anchor instanceof Element ? anchor.ownerDocument : contentElement.ownerDocument;
        var window = document.defaultView;

        // Temporarily attach in order to measure preferred dimensions.
        var preferredSize = view ? view.measurePreferredSize() : WebInspector.measurePreferredSize(this._contentElement);
        this._preferredWidth = preferredWidth || preferredSize.width;
        this._preferredHeight = preferredHeight || preferredSize.height;

        window.addEventListener("resize", this._hideBound, false);
        document.body.appendChild(this._containerElement);
        WebInspector.Widget.prototype.show.call(this, this._containerElement);

        if (view)
            view.show(this._contentDiv);
        else
            this._contentDiv.appendChild(this._contentElement);

        this.positionElement(anchor, this._preferredWidth, this._preferredHeight, arrowDirection);

        if (this._popoverHelper) {
            this._contentDiv.addEventListener("mousemove", this._popoverHelper._killHidePopoverTimer.bind(this._popoverHelper), true);
            this.element.addEventListener("mouseout", this._popoverHelper._popoverMouseOut.bind(this._popoverHelper), true);
        }
    },

    hide: function()
    {
        this._containerElement.ownerDocument.defaultView.removeEventListener("resize", this._hideBound, false);
        this.detach();
        this._containerElement.remove();
        delete WebInspector.Popover._popover;
    },

    get disposed()
    {
        return this._disposed;
    },

    dispose: function()
    {
        if (this.isShowing())
            this.hide();
        this._disposed = true;
    },

    /**
     * @param {boolean} canShrink
     */
    setCanShrink: function(canShrink)
    {
        this._hasFixedHeight = !canShrink;
        this._contentDiv.classList.toggle("fixed-height", this._hasFixedHeight);
    },

    /**
     * @param {boolean} noMargins
     */
    setNoMargins: function(noMargins)
    {
        this._hasNoMargins = noMargins;
        this._contentDiv.classList.toggle("no-margin", this._hasNoMargins);
    },

    /**
     * @param {!Element|!AnchorBox} anchorElement
     * @param {number=} preferredWidth
     * @param {number=} preferredHeight
     * @param {?WebInspector.Popover.Orientation=} arrowDirection
     */
    positionElement: function(anchorElement, preferredWidth, preferredHeight, arrowDirection)
    {
        const borderWidth = this._hasNoMargins ? 0 : 8;
        const scrollerWidth = this._hasFixedHeight ? 0 : 14;
        const arrowHeight = this._hasNoMargins ? 8 : 15;
        const arrowOffset = 10;
        const borderRadius = 4;
        const arrowRadius = 6;
        preferredWidth = preferredWidth || this._preferredWidth;
        preferredHeight = preferredHeight || this._preferredHeight;

        // Skinny tooltips are not pretty, their arrow location is not nice.
        preferredWidth = Math.max(preferredWidth, 50);
        // Position relative to main DevTools element.
        const container = WebInspector.Dialog.modalHostView().element;
        const totalWidth = container.offsetWidth;
        const totalHeight = container.offsetHeight;

        var anchorBox = anchorElement instanceof AnchorBox ? anchorElement : anchorElement.boxInWindow(window);
        anchorBox = anchorBox.relativeToElement(container);
        var newElementPosition = { x: 0, y: 0, width: preferredWidth + scrollerWidth, height: preferredHeight };

        var verticalAlignment;
        var roomAbove = anchorBox.y;
        var roomBelow = totalHeight - anchorBox.y - anchorBox.height;

        if ((roomAbove > roomBelow) || (arrowDirection === WebInspector.Popover.Orientation.Bottom)) {
            // Positioning above the anchor.
            if ((anchorBox.y > newElementPosition.height + arrowHeight + borderRadius) || (arrowDirection === WebInspector.Popover.Orientation.Bottom))
                newElementPosition.y = anchorBox.y - newElementPosition.height - arrowHeight;
            else {
                newElementPosition.y = borderRadius;
                newElementPosition.height = anchorBox.y - borderRadius * 2 - arrowHeight;
                if (this._hasFixedHeight && newElementPosition.height < preferredHeight) {
                    newElementPosition.y = borderRadius;
                    newElementPosition.height = preferredHeight;
                }
            }
            verticalAlignment = WebInspector.Popover.Orientation.Bottom;
        } else {
            // Positioning below the anchor.
            newElementPosition.y = anchorBox.y + anchorBox.height + arrowHeight;
            if ((newElementPosition.y + newElementPosition.height + borderRadius >= totalHeight) && (arrowDirection !== WebInspector.Popover.Orientation.Top)) {
                newElementPosition.height = totalHeight - borderRadius - newElementPosition.y;
                if (this._hasFixedHeight && newElementPosition.height < preferredHeight) {
                    newElementPosition.y = totalHeight - preferredHeight - borderRadius;
                    newElementPosition.height = preferredHeight;
                }
            }
            // Align arrow.
            verticalAlignment = WebInspector.Popover.Orientation.Top;
        }

        var horizontalAlignment;
        this._popupArrowElement.removeAttribute("style");
        if (anchorBox.x + newElementPosition.width < totalWidth) {
            newElementPosition.x = Math.max(borderRadius, anchorBox.x - borderRadius - arrowOffset);
            horizontalAlignment = "left";
            this._popupArrowElement.style.left = arrowOffset + "px";
        } else if (newElementPosition.width + borderRadius * 2 < totalWidth) {
            newElementPosition.x = totalWidth - newElementPosition.width - borderRadius - 2 * borderWidth;
            horizontalAlignment = "right";
            // Position arrow accurately.
            var arrowRightPosition = Math.max(0, totalWidth - anchorBox.x - anchorBox.width - borderRadius - arrowOffset);
            arrowRightPosition += anchorBox.width / 2;
            arrowRightPosition = Math.min(arrowRightPosition, newElementPosition.width - borderRadius - arrowOffset);
            this._popupArrowElement.style.right = arrowRightPosition + "px";
        } else {
            newElementPosition.x = borderRadius;
            newElementPosition.width = totalWidth - borderRadius * 2;
            newElementPosition.height += scrollerWidth;
            horizontalAlignment = "left";
            if (verticalAlignment === WebInspector.Popover.Orientation.Bottom)
                newElementPosition.y -= scrollerWidth;
            // Position arrow accurately.
            this._popupArrowElement.style.left = Math.max(0, anchorBox.x - newElementPosition.x - borderRadius - arrowRadius + anchorBox.width / 2) + "px";
        }

        this.element.className = WebInspector.Popover._classNamePrefix + " " + verticalAlignment + "-" + horizontalAlignment + "-arrow";
        this.element.positionAt(newElementPosition.x, newElementPosition.y - borderWidth, container);
        this.element.style.width = newElementPosition.width + borderWidth * 2 + "px";
        this.element.style.height = newElementPosition.height + borderWidth * 2 + "px";
    },

    __proto__: WebInspector.Widget.prototype
}

/**
 * @constructor
 * @param {!Element} panelElement
 * @param {function(!Element, !Event):(!Element|!AnchorBox|undefined)} getAnchor
 * @param {function(!Element, !WebInspector.Popover):undefined} showPopover
 * @param {function()=} onHide
 * @param {boolean=} disableOnClick
 */
WebInspector.PopoverHelper = function(panelElement, getAnchor, showPopover, onHide, disableOnClick)
{
    this._getAnchor = getAnchor;
    this._showPopover = showPopover;
    this._onHide = onHide;
    this._disableOnClick = !!disableOnClick;
    panelElement.addEventListener("mousedown", this._mouseDown.bind(this), false);
    panelElement.addEventListener("mousemove", this._mouseMove.bind(this), false);
    panelElement.addEventListener("mouseout", this._mouseOut.bind(this), false);
    this.setTimeout(1000, 500);
}

WebInspector.PopoverHelper.prototype = {
    /**
     * @param {number} timeout
     * @param {number=} hideTimeout
     */
    setTimeout: function(timeout, hideTimeout)
    {
        this._timeout = timeout;
        if (typeof hideTimeout === "number")
            this._hideTimeout = hideTimeout;
        else
            this._hideTimeout = timeout / 2;
    },

    /**
     * @param {!MouseEvent} event
     * @return {boolean}
     */
    _eventInHoverElement: function(event)
    {
        if (!this._hoverElement)
            return false;
        var box = this._hoverElement instanceof AnchorBox ? this._hoverElement : this._hoverElement.boxInWindow();
        return (box.x <= event.clientX && event.clientX <= box.x + box.width &&
            box.y <= event.clientY && event.clientY <= box.y + box.height);
    },

    _mouseDown: function(event)
    {
        if (this._disableOnClick || !this._eventInHoverElement(event))
            this.hidePopover();
        else {
            this._killHidePopoverTimer();
            this._handleMouseAction(event, true);
        }
    },

    _mouseMove: function(event)
    {
        // Pretend that nothing has happened.
        if (this._eventInHoverElement(event))
            return;

        this._startHidePopoverTimer();
        this._handleMouseAction(event, false);
    },

    _popoverMouseOut: function(event)
    {
        if (!this.isPopoverVisible())
            return;
        if (event.relatedTarget && !event.relatedTarget.isSelfOrDescendant(this._popover._contentDiv))
            this._startHidePopoverTimer();
    },

    _mouseOut: function(event)
    {
        if (!this.isPopoverVisible())
            return;
        if (!this._eventInHoverElement(event))
            this._startHidePopoverTimer();
    },

    _startHidePopoverTimer: function()
    {
        // User has 500ms (this._hideTimeout) to reach the popup.
        if (!this._popover || this._hidePopoverTimer)
            return;

        /**
         * @this {WebInspector.PopoverHelper}
         */
        function doHide()
        {
            this._hidePopover();
            delete this._hidePopoverTimer;
        }
        this._hidePopoverTimer = setTimeout(doHide.bind(this), this._hideTimeout);
    },

    _handleMouseAction: function(event, isMouseDown)
    {
        this._resetHoverTimer();
        if (event.which && this._disableOnClick)
            return;
        this._hoverElement = this._getAnchor(event.target, event);
        if (!this._hoverElement)
            return;
        const toolTipDelay = isMouseDown ? 0 : (this._popup ? this._timeout * 0.6 : this._timeout);
        this._hoverTimer = setTimeout(this._mouseHover.bind(this, this._hoverElement), toolTipDelay);
    },

    _resetHoverTimer: function()
    {
        if (this._hoverTimer) {
            clearTimeout(this._hoverTimer);
            delete this._hoverTimer;
        }
    },

    /**
     * @return {boolean}
     */
    isPopoverVisible: function()
    {
        return !!this._popover;
    },

    hidePopover: function()
    {
        this._resetHoverTimer();
        this._hidePopover();
    },

    _hidePopover: function()
    {
        if (!this._popover)
            return;

        if (this._onHide)
            this._onHide();

        this._popover.dispose();
        delete this._popover;
        this._hoverElement = null;
    },

    _mouseHover: function(element)
    {
        delete this._hoverTimer;
        this._hoverElement = element;
        this._hidePopover();
        this._popover = new WebInspector.Popover(this);
        this._showPopover(element, this._popover);
    },

    _killHidePopoverTimer: function()
    {
        if (this._hidePopoverTimer) {
            clearTimeout(this._hidePopoverTimer);
            delete this._hidePopoverTimer;

            // We know that we reached the popup, but we might have moved over other elements.
            // Discard pending command.
            this._resetHoverTimer();
        }
    }
}

/** @enum {string} */
WebInspector.Popover.Orientation = {
    Top: "top",
    Bottom: "bottom"
}
;/* ProgressIndicator.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @implements {WebInspector.Progress}
 */
WebInspector.ProgressIndicator = function()
{
    this.element = createElementWithClass("div", "progress-indicator");
    this._shadowRoot = WebInspector.createShadowRootWithCoreStyles(this.element, "ui/progressIndicator.css");
    this._contentElement = this._shadowRoot.createChild("div", "progress-indicator-shadow-container");

    this._labelElement = this._contentElement.createChild("div", "title");
    this._progressElement = this._contentElement.createChild("progress");
    this._progressElement.value = 0;
    this._stopButton = this._contentElement.createChild("button", "progress-indicator-shadow-stop-button");
    this._stopButton.addEventListener("click", this.cancel.bind(this));

    this._isCanceled = false;
    this._worked = 0;
}

WebInspector.ProgressIndicator.prototype = {
    /**
     * @param {!Element} parent
     */
    show: function(parent)
    {
        parent.appendChild(this.element);
    },

    /**
     * @override
     */
    done: function()
    {
        if (this._isDone)
            return;
        this._isDone = true;
        this.element.remove();
    },

    cancel: function()
    {
        this._isCanceled = true;
    },

    /**
     * @override
     * @return {boolean}
     */
    isCanceled: function()
    {
        return this._isCanceled;
    },

    /**
     * @override
     * @param {string} title
     */
    setTitle: function(title)
    {
        this._labelElement.textContent = title;
    },

    /**
     * @override
     * @param {number} totalWork
     */
    setTotalWork: function(totalWork)
    {
        this._progressElement.max = totalWork;
    },

    /**
     * @override
     * @param {number} worked
     * @param {string=} title
     */
    setWorked: function(worked, title)
    {
        this._worked = worked;
        this._progressElement.value = worked;
        if (title)
            this.setTitle(title);
    },

    /**
     * @override
     * @param {number=} worked
     */
    worked: function(worked)
    {
        this.setWorked(this._worked + (worked || 1));
    }
}
;/* ResizerWidget.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.Object}
 */
WebInspector.ResizerWidget = function()
{
    WebInspector.Object.call(this);

    this._isEnabled = true;
    this._elements = [];
    this._installDragOnMouseDownBound = this._installDragOnMouseDown.bind(this);
    this._cursor = "nwse-resize";
};

WebInspector.ResizerWidget.Events = {
    ResizeStart: "ResizeStart",
    ResizeUpdate: "ResizeUpdate",
    ResizeEnd: "ResizeEnd"
};

WebInspector.ResizerWidget.prototype = {
    /**
     * @return {boolean}
     */
    isEnabled: function()
    {
        return this._isEnabled;
    },

    /**
     * @param {boolean} enabled
     */
    setEnabled: function(enabled)
    {
        this._isEnabled = enabled;
        this.updateElementCursors();
    },

    /**
     * @return {!Array.<!Element>}
     */
    elements: function()
    {
        return this._elements.slice();
    },

    /**
     * @param {!Element} element
     */
    addElement: function(element)
    {
        if (this._elements.indexOf(element) !== -1)
            return;

        this._elements.push(element);
        element.addEventListener("mousedown", this._installDragOnMouseDownBound, false);
        this._updateElementCursor(element);
    },

    /**
     * @param {!Element} element
     */
    removeElement: function(element)
    {
        if (this._elements.indexOf(element) === -1)
            return;

        this._elements.remove(element);
        element.removeEventListener("mousedown", this._installDragOnMouseDownBound, false);
        element.style.removeProperty("cursor");
    },

    updateElementCursors: function()
    {
        this._elements.forEach(this._updateElementCursor.bind(this));
    },

    /**
     * @param {!Element} element
     */
    _updateElementCursor: function(element)
    {
        if (this._isEnabled)
            element.style.setProperty("cursor", this.cursor());
        else
            element.style.removeProperty("cursor");
    },

    /**
     * @return {string}
     */
    cursor: function()
    {
        return this._cursor;
    },

    /**
     * @param {string} cursor
     */
    setCursor: function(cursor)
    {
        this._cursor = cursor;
        this.updateElementCursors();
    },

    /**
     * @param {!Event} event
     */
    _installDragOnMouseDown: function(event)
    {
        // Only handle drags of the nodes specified.
        if (this._elements.indexOf(event.target) === -1)
            return false;
        WebInspector.elementDragStart(/** @type {!Element} */(event.target), this._dragStart.bind(this), this._drag.bind(this), this._dragEnd.bind(this), this.cursor(), event);
    },

    /**
     * @param {!MouseEvent} event
     * @return {boolean}
     */
    _dragStart: function(event)
    {
        if (!this._isEnabled)
            return false;
        this._startX = event.pageX;
        this._startY = event.pageY;
        this.sendDragStart(this._startX, this._startY);
        return true;
    },

    /**
     * @param {number} x
     * @param {number} y
     */
    sendDragStart: function(x, y)
    {
        this.dispatchEventToListeners(WebInspector.ResizerWidget.Events.ResizeStart, { startX: x, currentX: x, startY: y, currentY: y });
    },

    /**
     * @param {!MouseEvent} event
     * @return {boolean}
     */
    _drag: function(event)
    {
        if (!this._isEnabled) {
            this._dragEnd(event);
            return true;  // Cancel drag.
        }

        this.sendDragMove(this._startX, event.pageX, this._startY, event.pageY, event.shiftKey);
        event.preventDefault();
        return false;  // Continue drag.
    },

    /**
     * @param {number} startX
     * @param {number} currentX
     * @param {number} startY
     * @param {number} currentY
     * @param {boolean} shiftKey
     */
    sendDragMove: function(startX, currentX, startY, currentY, shiftKey)
    {
        this.dispatchEventToListeners(WebInspector.ResizerWidget.Events.ResizeUpdate, { startX: startX, currentX: currentX, startY: startY, currentY: currentY, shiftKey: shiftKey });
    },

    /**
     * @param {!MouseEvent} event
     */
    _dragEnd: function(event)
    {
        this.dispatchEventToListeners(WebInspector.ResizerWidget.Events.ResizeEnd);
        delete this._startX;
        delete this._startY;
    },

    __proto__: WebInspector.Object.prototype
};

/**
 * @constructor
 * @extends {WebInspector.ResizerWidget}
 */
WebInspector.SimpleResizerWidget = function()
{
    WebInspector.ResizerWidget.call(this);
    this._isVertical = true;
};

WebInspector.SimpleResizerWidget.prototype = {
    /**
     * @return {boolean}
     */
    isVertical: function()
    {
        return this._isVertical;
    },

    /**
     * Vertical widget resizes height (along y-axis).
     * @param {boolean} vertical
     */
    setVertical: function(vertical)
    {
        this._isVertical = vertical;
        this.updateElementCursors();
    },

    /**
     * @override
     * @return {string}
     */
    cursor: function()
    {
        return this._isVertical ? "ns-resize" : "ew-resize";
    },

    /**
     * @override
     * @param {number} x
     * @param {number} y
     */
    sendDragStart: function(x, y)
    {
        var position = this._isVertical ? y : x;
        this.dispatchEventToListeners(WebInspector.ResizerWidget.Events.ResizeStart, { startPosition: position, currentPosition: position });
    },

    /**
     * @override
     * @param {number} startX
     * @param {number} currentX
     * @param {number} startY
     * @param {number} currentY
     * @param {boolean} shiftKey
     */
    sendDragMove: function(startX, currentX, startY, currentY, shiftKey)
    {
        if (this._isVertical)
            this.dispatchEventToListeners(WebInspector.ResizerWidget.Events.ResizeUpdate, { startPosition: startY, currentPosition: currentY, shiftKey: shiftKey });
        else
            this.dispatchEventToListeners(WebInspector.ResizerWidget.Events.ResizeUpdate, { startPosition: startX, currentPosition: currentX, shiftKey: shiftKey });
    },

    __proto__: WebInspector.ResizerWidget.prototype
};
;/* RootView.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.VBox}
 */
WebInspector.RootView = function()
{
    WebInspector.VBox.call(this);
    this.markAsRoot();
    this.element.classList.add("root-view");
    this.element.setAttribute("spellcheck", false);
}

WebInspector.RootView.prototype = {
    /**
     * @param {!Document} document
     */
    attachToDocument: function(document)
    {
        document.defaultView.addEventListener("resize", this.doResize.bind(this), false);
        this._window = document.defaultView;
        this.doResize();
        this.show(document.body);
    },

    doResize: function()
    {
        if (this._window) {
            var size = this.constraints().minimum;
            var zoom = WebInspector.zoomManager.zoomFactor();
            var right = Math.min(0, this._window.innerWidth - size.width / zoom);
            this.element.style.marginRight = right + "px";
            var bottom = Math.min(0, this._window.innerHeight - size.height / zoom);
            this.element.style.marginBottom = bottom + "px";
        }
        WebInspector.VBox.prototype.doResize.call(this);
    },

    __proto__: WebInspector.VBox.prototype
}
;/* SearchableView.js */
/*
 * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.
 * Copyright (C) 2007 Matt Lilek (pewtermoose@gmail.com).
 * Copyright (C) 2009 Joseph Pecoraro
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.VBox}
 * @param {!WebInspector.Searchable} searchable
 * @param {string=} settingName
 */
WebInspector.SearchableView = function(searchable, settingName)
{
    WebInspector.VBox.call(this, true);
    this.registerRequiredCSS("ui/searchableView.css");
    this.element[WebInspector.SearchableView._symbol] = this;

    this._searchProvider = searchable;
    this._setting = settingName ? WebInspector.settings.createSetting(settingName, {}) : null;

    this.contentElement.createChild("content");
    this._footerElementContainer = this.contentElement.createChild("div", "search-bar hidden");
    this._footerElementContainer.style.order = 100;

    var toolbar = new WebInspector.Toolbar("search-toolbar", this._footerElementContainer);

    if (this._searchProvider.supportsCaseSensitiveSearch()) {
        this._caseSensitiveButton = new WebInspector.ToolbarToggle(WebInspector.UIString("Case sensitive"), "");
        this._caseSensitiveButton.setText("Aa");
        this._caseSensitiveButton.addEventListener("click", this._toggleCaseSensitiveSearch, this);
        toolbar.appendToolbarItem(this._caseSensitiveButton);
    }

    if (this._searchProvider.supportsRegexSearch()) {
        this._regexButton = new WebInspector.ToolbarToggle(WebInspector.UIString("Regex"), "");
        this._regexButton.setText(".*");
        this._regexButton.addEventListener("click", this._toggleRegexSearch, this);
        toolbar.appendToolbarItem(this._regexButton);
    }

    this._footerElement = this._footerElementContainer.createChild("table", "toolbar-search");
    this._footerElement.cellSpacing = 0;

    this._firstRowElement = this._footerElement.createChild("tr");
    this._secondRowElement = this._footerElement.createChild("tr", "hidden");

    // Column 1
    var searchControlElementColumn = this._firstRowElement.createChild("td");
    this._searchControlElement = searchControlElementColumn.createChild("span", "toolbar-search-control");

    this._searchInputElement = WebInspector.HistoryInput.create();
    this._searchInputElement.classList.add("search-replace");
    this._searchControlElement.appendChild(this._searchInputElement);

    this._searchInputElement.id = "search-input-field";
    this._searchInputElement.placeholder = WebInspector.UIString("Find");

    this._matchesElement = this._searchControlElement.createChild("label", "search-results-matches");
    this._matchesElement.setAttribute("for", "search-input-field");

    this._searchNavigationElement = this._searchControlElement.createChild("div", "toolbar-search-navigation-controls");

    this._searchNavigationPrevElement = this._searchNavigationElement.createChild("div", "toolbar-search-navigation toolbar-search-navigation-prev");
    this._searchNavigationPrevElement.addEventListener("click", this._onPrevButtonSearch.bind(this), false);
    this._searchNavigationPrevElement.title = WebInspector.UIString("Search Previous");

    this._searchNavigationNextElement = this._searchNavigationElement.createChild("div", "toolbar-search-navigation toolbar-search-navigation-next");
    this._searchNavigationNextElement.addEventListener("click", this._onNextButtonSearch.bind(this), false);
    this._searchNavigationNextElement.title = WebInspector.UIString("Search Next");

    this._searchInputElement.addEventListener("mousedown", this._onSearchFieldManualFocus.bind(this), false); // when the search field is manually selected
    this._searchInputElement.addEventListener("keydown", this._onSearchKeyDown.bind(this), true);
    this._searchInputElement.addEventListener("input", this._onInput.bind(this), false);

    this._replaceInputElement = this._secondRowElement.createChild("td").createChild("input", "search-replace toolbar-replace-control");
    this._replaceInputElement.addEventListener("keydown", this._onReplaceKeyDown.bind(this), true);
    this._replaceInputElement.placeholder = WebInspector.UIString("Replace");

    // Column 2
    this._findButtonElement = this._firstRowElement.createChild("td").createChild("button", "search-action-button hidden");
    this._findButtonElement.textContent = WebInspector.UIString("Find");
    this._findButtonElement.tabIndex = -1;
    this._findButtonElement.addEventListener("click", this._onFindClick.bind(this), false);

    this._replaceButtonElement = this._secondRowElement.createChild("td").createChild("button", "search-action-button");
    this._replaceButtonElement.textContent = WebInspector.UIString("Replace");
    this._replaceButtonElement.disabled = true;
    this._replaceButtonElement.tabIndex = -1;
    this._replaceButtonElement.addEventListener("click", this._replace.bind(this), false);

    // Column 3
    this._prevButtonElement = this._firstRowElement.createChild("td").createChild("button", "search-action-button hidden");
    this._prevButtonElement.textContent = WebInspector.UIString("Previous");
    this._prevButtonElement.tabIndex = -1;
    this._prevButtonElement.addEventListener("click", this._onPreviousClick.bind(this), false);

    this._replaceAllButtonElement = this._secondRowElement.createChild("td").createChild("button", "search-action-button");
    this._replaceAllButtonElement.textContent = WebInspector.UIString("Replace All");
    this._replaceAllButtonElement.addEventListener("click", this._replaceAll.bind(this), false);

    // Column 4
    this._replaceElement = this._firstRowElement.createChild("td").createChild("span");

    this._replaceLabelElement = createCheckboxLabel(WebInspector.UIString("Replace"));
    this._replaceCheckboxElement = this._replaceLabelElement.checkboxElement;
    this._uniqueId = ++WebInspector.SearchableView._lastUniqueId;
    var replaceCheckboxId = "search-replace-trigger" + this._uniqueId;
    this._replaceCheckboxElement.id = replaceCheckboxId;
    this._replaceCheckboxElement.addEventListener("change", this._updateSecondRowVisibility.bind(this), false);

    this._replaceElement.appendChild(this._replaceLabelElement);

    // Column 5
    var cancelButtonElement = this._firstRowElement.createChild("td").createChild("button", "search-action-button");
    cancelButtonElement.textContent = WebInspector.UIString("Cancel");
    cancelButtonElement.tabIndex = -1;
    cancelButtonElement.addEventListener("click", this.closeSearch.bind(this), false);
    this._minimalSearchQuerySize = 3;

    this._loadSetting();
}

WebInspector.SearchableView._lastUniqueId = 0;

WebInspector.SearchableView._symbol = Symbol("searchableView");

/**
 * @param {?Element} element
 * @return {?WebInspector.SearchableView}
 */
WebInspector.SearchableView.fromElement = function(element)
{
    var view = null;
    while (element && !view) {
        view = element[WebInspector.SearchableView._symbol];
        element = element.parentElementOrShadowHost();
    }
    return view;
}

WebInspector.SearchableView.prototype = {
    _toggleCaseSensitiveSearch: function()
    {
        this._caseSensitiveButton.setToggled(!this._caseSensitiveButton.toggled());
        this._saveSetting();
        this._performSearch(false, true);
    },

    _toggleRegexSearch: function()
    {
        this._regexButton.setToggled(!this._regexButton.toggled());
        this._saveSetting();
        this._performSearch(false, true);
    },

    _saveSetting: function()
    {
        if (!this._setting)
            return;
        var settingValue = this._setting.get() || {};
        settingValue.caseSensitive = this._caseSensitiveButton.toggled();
        settingValue.isRegex = this._regexButton.toggled();
        this._setting.set(settingValue);
    },

    _loadSetting: function()
    {
        var settingValue = this._setting ? (this._setting.get() || {}) : {};
        if (this._searchProvider.supportsCaseSensitiveSearch())
            this._caseSensitiveButton.setToggled(!!settingValue.caseSensitive);
        if (this._searchProvider.supportsRegexSearch())
            this._regexButton.setToggled(!!settingValue.isRegex);
    },

    /**
     * @override
     * @return {!Element}
     */
    defaultFocusedElement: function()
    {
        var children = this.children();
        for (var i = 0; i < children.length; ++i) {
            var element = children[i].defaultFocusedElement();
            if (element)
                return element;
        }
        return WebInspector.Widget.prototype.defaultFocusedElement.call(this);
    },

    /**
     * @param {number} minimalSearchQuerySize
     */
    setMinimalSearchQuerySize: function(minimalSearchQuerySize)
    {
        this._minimalSearchQuerySize = minimalSearchQuerySize;
    },

    /**
     * @param {string} placeholder
     */
    setPlaceholder: function(placeholder)
    {
        this._searchInputElement.placeholder = placeholder;
    },

    /**
     * @param {boolean} replaceable
     */
    setReplaceable: function(replaceable)
    {
        this._replaceable = replaceable;
    },

    /**
     * @param {number} matches
     */
    updateSearchMatchesCount: function(matches)
    {
        this._searchProvider.currentSearchMatches = matches;
        this._updateSearchMatchesCountAndCurrentMatchIndex(this._searchProvider.currentQuery ? matches : 0, -1);
    },

    /**
     * @param {number} currentMatchIndex
     */
    updateCurrentMatchIndex: function(currentMatchIndex)
    {
        this._updateSearchMatchesCountAndCurrentMatchIndex(this._searchProvider.currentSearchMatches, currentMatchIndex);
    },

    /**
     * @return {boolean}
     */
    isSearchVisible: function()
    {
        return this._searchIsVisible;
    },

    closeSearch: function()
    {
        this.cancelSearch();
        if (WebInspector.currentFocusElement() && WebInspector.currentFocusElement().isDescendant(this._footerElementContainer))
            this.focus();
    },

    _toggleSearchBar: function(toggled)
    {
        this._footerElementContainer.classList.toggle("hidden", !toggled);
        this.doResize();
    },

    cancelSearch: function()
    {
        if (!this._searchIsVisible)
            return;
        this.resetSearch();
        delete this._searchIsVisible;
        this._toggleSearchBar(false);
    },

    resetSearch: function()
    {
        this._clearSearch();
        this._updateReplaceVisibility();
        this._matchesElement.textContent = "";
    },

    refreshSearch: function()
    {
        if (!this._searchIsVisible)
            return;
        this.resetSearch();
        this._performSearch(false, false);
    },

    /**
     * @return {boolean}
     */
    handleFindNextShortcut: function()
    {
        if (!this._searchIsVisible)
            return false;
        this._searchProvider.jumpToNextSearchResult();
        return true;
    },

    /**
     * @return {boolean}
     */
    handleFindPreviousShortcut: function()
    {
        if (!this._searchIsVisible)
            return false;
        this._searchProvider.jumpToPreviousSearchResult();
        return true;
    },

    /**
     * @return {boolean}
     */
    handleFindShortcut: function()
    {
        this.showSearchField();
        return true;
    },

    /**
     * @return {boolean}
     */
    handleCancelSearchShortcut: function()
    {
        if (!this._searchIsVisible)
            return false;
        this.closeSearch();
        return true;
    },

    /**
     * @param {boolean} enabled
     */
    _updateSearchNavigationButtonState: function(enabled)
    {
        this._replaceButtonElement.disabled = !enabled;
        if (enabled) {
            this._searchNavigationPrevElement.classList.add("enabled");
            this._searchNavigationNextElement.classList.add("enabled");
        } else {
            this._searchNavigationPrevElement.classList.remove("enabled");
            this._searchNavigationNextElement.classList.remove("enabled");
        }
    },

    /**
     * @param {number} matches
     * @param {number} currentMatchIndex
     */
    _updateSearchMatchesCountAndCurrentMatchIndex: function(matches, currentMatchIndex)
    {
        if (!this._currentQuery)
            this._matchesElement.textContent = "";
        else if (matches === 0 || currentMatchIndex >= 0)
            this._matchesElement.textContent = WebInspector.UIString("%d of %d", currentMatchIndex + 1, matches);
        else if (matches === 1)
            this._matchesElement.textContent = WebInspector.UIString("1 match");
        else
            this._matchesElement.textContent = WebInspector.UIString("%d matches", matches);
        this._updateSearchNavigationButtonState(matches > 0);
    },

    showSearchField: function()
    {
        if (this._searchIsVisible)
            this.cancelSearch();

        var queryCandidate;
        if (WebInspector.currentFocusElement() !== this._searchInputElement) {
            var selection = this._searchInputElement.getComponentSelection();
            if (selection.rangeCount)
                queryCandidate = selection.toString().replace(/\r?\n.*/, "");
        }

        this._toggleSearchBar(true);
        this._updateReplaceVisibility();
        if (queryCandidate)
            this._searchInputElement.value = queryCandidate;
        this._performSearch(false, false);
        this._searchInputElement.focus();
        this._searchInputElement.select();
        this._searchIsVisible = true;
    },

    _updateReplaceVisibility: function()
    {
        this._replaceElement.classList.toggle("hidden", !this._replaceable);
        if (!this._replaceable) {
            this._replaceCheckboxElement.checked = false;
            this._updateSecondRowVisibility();
        }
    },

    /**
     * @param {!Event} event
     */
    _onSearchFieldManualFocus: function(event)
    {
        WebInspector.setCurrentFocusElement(/** @type {?Node} */ (event.target));
    },

    /**
     * @param {!Event} event
     */
    _onSearchKeyDown: function(event)
    {
        if (!isEnterKey(event))
            return;

        if (!this._currentQuery)
            this._performSearch(true, true, event.shiftKey);
        else
            this._jumpToNextSearchResult(event.shiftKey);
    },

    /**
     * @param {!Event} event
     */
    _onReplaceKeyDown: function(event)
    {
        if (isEnterKey(event))
            this._replace();
    },

    /**
     * @param {boolean=} isBackwardSearch
     */
    _jumpToNextSearchResult: function(isBackwardSearch)
    {
        if (!this._currentQuery || !this._searchNavigationPrevElement.classList.contains("enabled"))
            return;

        if (isBackwardSearch)
            this._searchProvider.jumpToPreviousSearchResult();
        else
            this._searchProvider.jumpToNextSearchResult();
    },

    _onNextButtonSearch: function(event)
    {
        if (!this._searchNavigationNextElement.classList.contains("enabled"))
            return;
        this._jumpToNextSearchResult();
        this._searchInputElement.focus();
    },

    _onPrevButtonSearch: function(event)
    {
        if (!this._searchNavigationPrevElement.classList.contains("enabled"))
            return;
        this._jumpToNextSearchResult(true);
        this._searchInputElement.focus();
    },

    _onFindClick: function(event)
    {
        if (!this._currentQuery)
            this._performSearch(true, true);
        else
            this._jumpToNextSearchResult();
        this._searchInputElement.focus();
    },

    _onPreviousClick: function(event)
    {
        if (!this._currentQuery)
            this._performSearch(true, true, true);
        else
            this._jumpToNextSearchResult(true);
        this._searchInputElement.focus();
    },

    _clearSearch: function()
    {
        delete this._currentQuery;
        if (!!this._searchProvider.currentQuery) {
            delete this._searchProvider.currentQuery;
            this._searchProvider.searchCanceled();
        }
        this._updateSearchMatchesCountAndCurrentMatchIndex(0, -1);
    },

    /**
     * @param {boolean} forceSearch
     * @param {boolean} shouldJump
     * @param {boolean=} jumpBackwards
     */
    _performSearch: function(forceSearch, shouldJump, jumpBackwards)
    {
        var query = this._searchInputElement.value;
        if (!query || (!forceSearch && query.length < this._minimalSearchQuerySize && !this._currentQuery)) {
            this._clearSearch();
            return;
        }

        this._currentQuery = query;
        this._searchProvider.currentQuery = query;

        var searchConfig = this._currentSearchConfig();
        this._searchProvider.performSearch(searchConfig, shouldJump, jumpBackwards);
    },

    /**
     * @return {!WebInspector.SearchableView.SearchConfig}
     */
    _currentSearchConfig: function()
    {
        var query = this._searchInputElement.value;
        var caseSensitive = this._caseSensitiveButton ? this._caseSensitiveButton.toggled() : false;
        var isRegex = this._regexButton ? this._regexButton.toggled() : false;
        return new WebInspector.SearchableView.SearchConfig(query, caseSensitive, isRegex);
     },

    _updateSecondRowVisibility: function()
    {
        var secondRowVisible = this._replaceCheckboxElement.checked;
        this._footerElementContainer.classList.toggle("replaceable", secondRowVisible);
        this._footerElement.classList.toggle("toolbar-search-replace", secondRowVisible);
        this._secondRowElement.classList.toggle("hidden", !secondRowVisible);
        this._prevButtonElement.classList.toggle("hidden", !secondRowVisible);
        this._findButtonElement.classList.toggle("hidden", !secondRowVisible);
        this._replaceCheckboxElement.tabIndex = secondRowVisible ? -1 : 0;

        if (secondRowVisible)
            this._replaceInputElement.focus();
        else
            this._searchInputElement.focus();
        this.doResize();
    },

    _replace: function()
    {
        var searchConfig = this._currentSearchConfig();
        /** @type {!WebInspector.Replaceable} */ (this._searchProvider).replaceSelectionWith(searchConfig, this._replaceInputElement.value);
        delete this._currentQuery;
        this._performSearch(true, true);
    },

    _replaceAll: function()
    {
        var searchConfig = this._currentSearchConfig();
        /** @type {!WebInspector.Replaceable} */ (this._searchProvider).replaceAllWith(searchConfig, this._replaceInputElement.value);
    },

    /**
     * @param {!Event} event
     */
    _onInput: function(event)
    {
        if (this._valueChangedTimeoutId)
            clearTimeout(this._valueChangedTimeoutId);
        var timeout = this._searchInputElement.value.length < 3 ? 200 : 0;
        this._valueChangedTimeoutId = setTimeout(this._onValueChanged.bind(this), timeout);
    },

    _onValueChanged: function()
    {
        delete this._valueChangedTimeoutId;
        this._performSearch(false, true);
    },

    __proto__: WebInspector.VBox.prototype
}

/**
 * @interface
 */
WebInspector.Searchable = function()
{
}

WebInspector.Searchable.prototype = {
    searchCanceled: function() { },

    /**
     * @param {!WebInspector.SearchableView.SearchConfig} searchConfig
     * @param {boolean} shouldJump
     * @param {boolean=} jumpBackwards
     */
    performSearch: function(searchConfig, shouldJump, jumpBackwards) { },

    jumpToNextSearchResult: function() { },

    jumpToPreviousSearchResult: function() { },

    /**
     * @return {boolean}
     */
    supportsCaseSensitiveSearch: function() { },

    /**
     * @return {boolean}
     */
    supportsRegexSearch: function() { }
}

/**
 * @interface
 */
WebInspector.Replaceable = function()
{
}

WebInspector.Replaceable.prototype = {
    /**
     * @param {!WebInspector.SearchableView.SearchConfig} searchConfig
     * @param {string} replacement
     */
    replaceSelectionWith: function(searchConfig, replacement) { },

    /**
     * @param {!WebInspector.SearchableView.SearchConfig} searchConfig
     * @param {string} replacement
     */
    replaceAllWith: function(searchConfig, replacement) { }
}

/**
 * @constructor
 * @param {string} query
 * @param {boolean} caseSensitive
 * @param {boolean} isRegex
 */
WebInspector.SearchableView.SearchConfig = function(query, caseSensitive, isRegex)
{
    this.query = query;
    this.caseSensitive = caseSensitive;
    this.isRegex = isRegex;
}

WebInspector.SearchableView.SearchConfig.prototype = {
    /**
     * @param {boolean=} global
     * @return {!RegExp}
     */
    toSearchRegex: function(global)
    {
        var modifiers = this.caseSensitive ? "" : "i";
        if (global)
            modifiers += "g";
        var query = this.isRegex ? "/" + this.query + "/" : this.query;

        var regex;

        // First try creating regex if user knows the / / hint.
        try {
            if (/^\/.+\/$/.test(query)) {
                regex = new RegExp(query.substring(1, query.length - 1), modifiers);
                regex.__fromRegExpQuery = true;
            }
        } catch (e) {
            // Silent catch.
        }

        // Otherwise just do a plain text search.
        if (!regex)
            regex = createPlainTextSearchRegex(query, modifiers);

        return regex;
    }
}
;/* Section.js */
/*
 * Copyright (C) 2007 Apple Inc.  All rights reserved.
 * Copyright (C) 2009 Google Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {string|!Node} title
 * @param {string=} subtitle
 */
WebInspector.Section = function(title, subtitle)
{
    this.element = createElementWithClass("div", "section");
    this.element._section = this;
    this.registerRequiredCSS("ui/section.css");

    this.headerElement = createElementWithClass("div", "header monospace");

    this.titleElement = createElementWithClass("div", "title");

    this.subtitleElement = createElementWithClass("div", "subtitle");

    this.headerElement.appendChild(this.subtitleElement);
    this.headerElement.appendChild(this.titleElement);

    this.headerElement.addEventListener("click", this.handleClick.bind(this), false);
    this.element.appendChild(this.headerElement);

    this.title = title;
    if (subtitle) {
        this._subtitle = subtitle;
        this.subtitleElement.textContent = subtitle;
    }
    this._expanded = false;
}

WebInspector.Section.prototype = {
    get title()
    {
        return this._title;
    },

    set title(x)
    {
        if (this._title === x)
            return;
        this._title = x;

        if (x instanceof Node) {
            this.titleElement.removeChildren();
            this.titleElement.appendChild(x);
        } else
          this.titleElement.textContent = x;
    },

    get subtitle()
    {
        return this._subtitle;
    },

    get expanded()
    {
        return this._expanded;
    },

    repopulate: function()
    {
        this._populated = false;
        if (this._expanded) {
            this.onpopulate();
            this._populated = true;
        }
    },

    /**
     * @protected
     */
    onpopulate: function()
    {
        // Overridden by subclasses.
    },

    expand: function()
    {
        if (this._expanded)
            return;
        this._expanded = true;
        this.element.classList.add("expanded");

        if (!this._populated) {
            this.onpopulate();
            this._populated = true;
        }
    },

    collapse: function()
    {
        if (!this._expanded)
            return;
        this._expanded = false;
        this.element.classList.remove("expanded");
    },

    /**
     * @param {string} cssFile
     */
    registerRequiredCSS: function(cssFile)
    {
        WebInspector.appendStyle(this.element, cssFile);
    },

    /**
     * @param {!Event} event
     * @protected
     */
    handleClick: function(event)
    {
        if (this._doNotExpandOnTitleClick)
            return;

        if (this._expanded)
            this.collapse();
        else
            this.expand();
        event.consume();
    },

    doNotExpandOnTitleClick: function()
    {
        this._doNotExpandOnTitleClick = true;
    }
}

/**
 * @constructor
 * @extends {WebInspector.Section}
 * @param {string|!Node} title
 * @param {string=} subtitle
 */
WebInspector.PropertiesSection = function(title, subtitle)
{
    WebInspector.Section.call(this, title, subtitle);
    this.registerRequiredCSS("ui/propertiesSection.css");

    this.propertiesTreeOutline = new TreeOutline(true);
    this.propertiesElement = this.propertiesTreeOutline.element;
    this.propertiesElement.classList.add("properties", "properties-tree", "monospace");
    this.propertiesTreeOutline.setFocusable(false);
    this.propertiesTreeOutline.section = this;

    this.element.appendChild(this.propertiesElement);
}

WebInspector.PropertiesSection.prototype = {
    __proto__: WebInspector.Section.prototype
}
;/* SettingsUI.js */
/*
 * Copyright (C) 2014 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

WebInspector.SettingsUI = {}

/**
 * @param {string} name
 * @param {!WebInspector.Setting} setting
 * @param {boolean=} omitParagraphElement
 * @param {string=} tooltip
 * @return {!Element}
 */
WebInspector.SettingsUI.createSettingCheckbox = function(name, setting, omitParagraphElement, tooltip)
{
    var label = createCheckboxLabel(name);
    if (tooltip)
        label.title = tooltip;

    var input = label.checkboxElement;
    input.name = name;
    WebInspector.SettingsUI.bindCheckbox(input, setting);

    if (omitParagraphElement)
        return label;

    var p = createElement("p");
    p.appendChild(label);
    return p;
}

/**
 * @param {!Element} input
 * @param {!WebInspector.Setting} setting
 */
WebInspector.SettingsUI.bindCheckbox = function(input, setting)
{
    function settingChanged()
    {
        if (input.checked !== setting.get())
            input.checked = setting.get();
    }
    setting.addChangeListener(settingChanged);
    settingChanged();

    function inputChanged()
    {
        if (setting.get() !== input.checked)
            setting.set(input.checked);
    }
    input.addEventListener("change", inputChanged, false);
}

/**
 * @param {string} name
 * @param {!Element} element
 * @return {!Element}
 */
WebInspector.SettingsUI.createCustomSetting = function(name, element)
{
    var p = createElement("p");
    var fieldsetElement = p.createChild("fieldset");
    fieldsetElement.createChild("label").textContent = name;
    fieldsetElement.appendChild(element);
    return p;
}

/**
 * @param {!WebInspector.Setting} setting
 * @return {!Element}
 */
WebInspector.SettingsUI.createSettingFieldset = function(setting)
{
    var fieldset = createElement("fieldset");
    fieldset.disabled = !setting.get();
    setting.addChangeListener(settingChanged);
    return fieldset;

    function settingChanged()
    {
        fieldset.disabled = !setting.get();
    }
}

/**
 * @interface
 */
WebInspector.SettingUI = function()
{
}

WebInspector.SettingUI.prototype = {
    /**
     * @return {?Element}
     */
    settingElement: function() { }
}
;/* SidebarTreeElement.js */
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {TreeElement}
 * @param {string} title
 */
WebInspector.SidebarSectionTreeElement = function(title)
{
    TreeElement.call(this, title.escapeHTML(), true);
    this.expand();
}

WebInspector.SidebarSectionTreeElement.prototype = {
    selectable: false,

    collapse: function()
    {
        // Should not collapse as it is not selectable.
    },

    get smallChildren()
    {
        return this._smallChildren;
    },

    set smallChildren(x)
    {
        if (this._smallChildren === x)
            return;

        this._smallChildren = x;

        this._childrenListNode.classList.toggle("small", this._smallChildren);
    },

    onattach: function()
    {
        this.listItemElement.classList.add("sidebar-tree-section");
    },

    __proto__: TreeElement.prototype
}

/**
 * @constructor
 * @extends {TreeElement}
 * @param {string} className
 * @param {string} title
 * @param {string=} subtitle
 * @param {boolean=} expandable
 */
WebInspector.SidebarTreeElement = function(className, title, subtitle, expandable)
{
    TreeElement.call(this, "", expandable);

    if (expandable)
        this.disclosureButton = createElementWithClass("button", "disclosure-button");

    this.iconElement = createElementWithClass("div", "icon");
    this.statusElement = createElementWithClass("div", "status");
    this._titlesElement = createElementWithClass("div", "titles");

    this.titleContainer = this._titlesElement.createChild("span", "title-container");
    this.titleElement = this.titleContainer.createChild("span", "title");

    this.subtitleElement = this._titlesElement.createChild("span", "subtitle");

    this.className = className;
    this.mainTitle = title;
    this.subtitle = subtitle;
}

WebInspector.SidebarTreeElement.prototype = {
    get small()
    {
        return this._small;
    },

    set small(x)
    {
        this._small = x;
        if (this.listItemElement)
            this.listItemElement.classList.toggle("small", this._small);
    },

    get mainTitle()
    {
        return this._mainTitle;
    },

    set mainTitle(x)
    {
        this._mainTitle = x;
        this.refreshTitles();
    },

    get subtitle()
    {
        return this._subtitle;
    },

    set subtitle(x)
    {
        this._subtitle = x;
        this.refreshTitles();
    },

    set wait(x)
    {
        this.listItemElement.classList.toggle("wait", x);
    },

    refreshTitles: function()
    {
        var mainTitle = this.mainTitle;
        if (this.titleElement.textContent !== mainTitle)
            this.titleElement.textContent = mainTitle;

        var subtitle = this.subtitle;
        if (subtitle) {
            if (this.subtitleElement.textContent !== subtitle)
                this.subtitleElement.textContent = subtitle;
            this._titlesElement.classList.remove("no-subtitle");
        } else {
            this.subtitleElement.textContent = "";
            this._titlesElement.classList.add("no-subtitle");
        }
    },

    /**
     * @override
     * @return {boolean}
     */
    isEventWithinDisclosureTriangle: function(event)
    {
        return event.target === this.disclosureButton;
    },

    onattach: function()
    {
        this.listItemElement.classList.add("sidebar-tree-item");

        if (this.className)
            this.listItemElement.classList.add(this.className);

        if (this.small)
            this.listItemElement.classList.add("small");

        if (this.isExpandable() && this.disclosureButton)
            this.listItemElement.appendChild(this.disclosureButton);

        this.listItemElement.appendChildren(this.iconElement, this.statusElement, this._titlesElement);
    },

    __proto__: TreeElement.prototype
}
;/* SoftContextMenu.js */
/*
 * Copyright (C) 2011 Google Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {!Array.<!InspectorFrontendHostAPI.ContextMenuDescriptor>} items
 * @param {function(string)} itemSelectedCallback
 * @param {!WebInspector.SoftContextMenu=} parentMenu
 */
WebInspector.SoftContextMenu = function(items, itemSelectedCallback, parentMenu)
{
    this._items = items;
    this._itemSelectedCallback = itemSelectedCallback;
    this._parentMenu = parentMenu;
}

WebInspector.SoftContextMenu.prototype = {
    /**
     * @param {!Document} document
     * @param {number} x
     * @param {number} y
     */
    show: function(document, x, y)
    {
        if (!this._items.length)
            return;

        this._document = document;
        this._x = x;
        this._y = y;
        this._time = new Date().getTime();

        // Create context menu.
        this.element = createElementWithClass("div", "soft-context-menu");
        var root = WebInspector.createShadowRootWithCoreStyles(this.element, "ui/softContextMenu.css");
        this._contextMenuElement = root.createChild("div");
        this.element.style.top = y + "px";
        var subMenuOverlap = 3;
        this.element.style.left = (this._parentMenu ? x - subMenuOverlap : x) + "px";

        this._contextMenuElement.tabIndex = 0;
        this._contextMenuElement.addEventListener("mouseup", consumeEvent, false);
        this._contextMenuElement.addEventListener("keydown", this._menuKeyDown.bind(this), false);

        for (var i = 0; i < this._items.length; ++i)
            this._contextMenuElement.appendChild(this._createMenuItem(this._items[i]));

        // Install glass pane capturing events.
        if (!this._parentMenu) {
            this._glassPaneElement = createElementWithClass("div", "soft-context-menu-glass-pane fill");
            this._glassPaneElement.tabIndex = 0;
            this._glassPaneElement.addEventListener("mouseup", this._glassPaneMouseUp.bind(this), false);
            this._glassPaneElement.appendChild(this.element);
            document.body.appendChild(this._glassPaneElement);
            this._discardMenuOnResizeListener = this._discardMenu.bind(this, true);
            document.defaultView.addEventListener("resize", this._discardMenuOnResizeListener, false);
        } else {
            this._parentMenu._parentGlassPaneElement().appendChild(this.element);
        }

        // Re-position menu in case it does not fit.
        if (document.body.offsetWidth < this.element.offsetLeft + this.element.offsetWidth) {
            this.element.style.left = Math.max(WebInspector.Dialog.modalHostView().element.totalOffsetLeft(), this._parentMenu
                ? this._parentMenu.element.offsetLeft - this.element.offsetWidth + subMenuOverlap
                : document.body.offsetWidth - this.element.offsetWidth) + "px";
        }

        // Move submenus upwards if it does not fit.
        if (this._parentMenu && document.body.offsetHeight < this.element.offsetTop + this.element.offsetHeight) {
            y = Math.max(WebInspector.Dialog.modalHostView().element.totalOffsetTop(), document.body.offsetHeight - this.element.offsetHeight);
            this.element.style.top = y + "px";
        }

        var maxHeight = WebInspector.Dialog.modalHostView().element.offsetHeight;
        maxHeight -= y - WebInspector.Dialog.modalHostView().element.totalOffsetTop();
        this.element.style.maxHeight = maxHeight + "px";

        this._focus();
    },

    discard: function()
    {
        this._discardMenu(true);
    },

    _parentGlassPaneElement: function()
    {
        if (this._glassPaneElement)
            return this._glassPaneElement;
        if (this._parentMenu)
            return this._parentMenu._parentGlassPaneElement();
        return null;
    },

    _createMenuItem: function(item)
    {
        if (item.type === "separator")
            return this._createSeparator();

        if (item.type === "subMenu")
            return this._createSubMenu(item);

        var menuItemElement = createElementWithClass("div", "soft-context-menu-item");
        var checkMarkElement = menuItemElement.createChild("div", "checkmark");
        if (!item.checked)
            checkMarkElement.style.opacity = "0";

        if (item.element) {
            var wrapper = menuItemElement.createChild("div", "soft-context-menu-custom-item");
            wrapper.appendChild(item.element);
            menuItemElement._isCustom = true;
            return menuItemElement;
        }

        if (!item.enabled)
            menuItemElement.classList.add("soft-context-menu-disabled");
        menuItemElement.createTextChild(item.label);
        menuItemElement.createChild("span", "soft-context-menu-shortcut").textContent = item.shortcut;

        menuItemElement.addEventListener("mousedown", this._menuItemMouseDown.bind(this), false);
        menuItemElement.addEventListener("mouseup", this._menuItemMouseUp.bind(this), false);

        // Manually manage hover highlight since :hover does not work in case of click-and-hold menu invocation.
        menuItemElement.addEventListener("mouseover", this._menuItemMouseOver.bind(this), false);
        menuItemElement.addEventListener("mouseleave", this._menuItemMouseLeave.bind(this), false);

        menuItemElement._actionId = item.id;
        return menuItemElement;
    },

    _createSubMenu: function(item)
    {
        var menuItemElement = createElementWithClass("div", "soft-context-menu-item");
        menuItemElement._subItems = item.subItems;

        // Occupy the same space on the left in all items.
        var checkMarkElement = menuItemElement.createChild("span", "soft-context-menu-item-checkmark checkmark");
        checkMarkElement.textContent = "\u2713 "; // Checkmark Unicode symbol
        checkMarkElement.style.opacity = "0";

        menuItemElement.createTextChild(item.label);

        var subMenuArrowElement = menuItemElement.createChild("span", "soft-context-menu-item-submenu-arrow");
        subMenuArrowElement.textContent = "\u25B6"; // BLACK RIGHT-POINTING TRIANGLE

        menuItemElement.addEventListener("mousedown", this._menuItemMouseDown.bind(this), false);
        menuItemElement.addEventListener("mouseup", this._menuItemMouseUp.bind(this), false);

        // Manually manage hover highlight since :hover does not work in case of click-and-hold menu invocation.
        menuItemElement.addEventListener("mouseover", this._menuItemMouseOver.bind(this), false);
        menuItemElement.addEventListener("mouseleave", this._menuItemMouseLeave.bind(this), false);

        return menuItemElement;
    },

    _createSeparator: function()
    {
        var separatorElement = createElementWithClass("div", "soft-context-menu-separator");
        separatorElement._isSeparator = true;
        separatorElement.createChild("div", "separator-line");
        return separatorElement;
    },

    _menuItemMouseDown: function(event)
    {
        // Do not let separator's mouse down hit menu's handler - we need to receive mouse up!
        event.consume(true);
    },

    _menuItemMouseUp: function(event)
    {
        this._triggerAction(event.target, event);
        event.consume();
    },

    _focus: function()
    {
        this._contextMenuElement.focus();
    },

    _triggerAction: function(menuItemElement, event)
    {
        if (!menuItemElement._subItems) {
            this._discardMenu(true, event);
            if (typeof menuItemElement._actionId !== "undefined") {
                this._itemSelectedCallback(menuItemElement._actionId);
                delete menuItemElement._actionId;
            }
            return;
        }

        this._showSubMenu(menuItemElement);
        event.consume();
    },

    _showSubMenu: function(menuItemElement)
    {
        if (menuItemElement._subMenuTimer) {
            clearTimeout(menuItemElement._subMenuTimer);
            delete menuItemElement._subMenuTimer;
        }
        if (this._subMenu)
            return;

        this._subMenu = new WebInspector.SoftContextMenu(menuItemElement._subItems, this._itemSelectedCallback, this);
        var topPadding = 4;
        this._subMenu.show(this._document, menuItemElement.totalOffsetLeft() + menuItemElement.offsetWidth, menuItemElement.totalOffsetTop() - 1 - topPadding);
    },

    _hideSubMenu: function()
    {
        if (!this._subMenu)
            return;
        this._subMenu._discardSubMenus();
        this._focus();
    },

    _menuItemMouseOver: function(event)
    {
        this._highlightMenuItem(event.target, true);
    },

    _menuItemMouseLeave: function(event)
    {
        if (!this._subMenu || !event.relatedTarget) {
            this._highlightMenuItem(null, true);
            return;
        }

        var relatedTarget = event.relatedTarget;
        if (relatedTarget.classList.contains("soft-context-menu-glass-pane"))
            this._highlightMenuItem(null, true);
    },

    /**
     * @param {?Element} menuItemElement
     * @param {boolean} scheduleSubMenu
     */
    _highlightMenuItem: function(menuItemElement, scheduleSubMenu)
    {
        if (this._highlightedMenuItemElement ===  menuItemElement)
            return;

        this._hideSubMenu();
        if (this._highlightedMenuItemElement) {
            this._highlightedMenuItemElement.classList.remove("soft-context-menu-item-mouse-over");
            if (this._highlightedMenuItemElement._subItems && this._highlightedMenuItemElement._subMenuTimer) {
                clearTimeout(this._highlightedMenuItemElement._subMenuTimer);
                delete this._highlightedMenuItemElement._subMenuTimer;
            }
        }
        this._highlightedMenuItemElement = menuItemElement;
        if (this._highlightedMenuItemElement) {
            this._highlightedMenuItemElement.classList.add("soft-context-menu-item-mouse-over");
            this._contextMenuElement.focus();
            if (scheduleSubMenu && this._highlightedMenuItemElement._subItems && !this._highlightedMenuItemElement._subMenuTimer)
                this._highlightedMenuItemElement._subMenuTimer = setTimeout(this._showSubMenu.bind(this, this._highlightedMenuItemElement), 150);
        }
    },

    _highlightPrevious: function()
    {
        var menuItemElement = this._highlightedMenuItemElement ? this._highlightedMenuItemElement.previousSibling : this._contextMenuElement.lastChild;
        while (menuItemElement && (menuItemElement._isSeparator || menuItemElement._isCustom))
            menuItemElement = menuItemElement.previousSibling;
        if (menuItemElement)
            this._highlightMenuItem(menuItemElement, false);
    },

    _highlightNext: function()
    {
        var menuItemElement = this._highlightedMenuItemElement ? this._highlightedMenuItemElement.nextSibling : this._contextMenuElement.firstChild;
        while (menuItemElement && (menuItemElement._isSeparator || menuItemElement._isCustom))
            menuItemElement = menuItemElement.nextSibling;
        if (menuItemElement)
            this._highlightMenuItem(menuItemElement, false);
    },

    _menuKeyDown: function(event)
    {
        switch (event.keyIdentifier) {
        case "Up":
            this._highlightPrevious(); break;
        case "Down":
            this._highlightNext(); break;
        case "Left":
            if (this._parentMenu) {
                this._highlightMenuItem(null, false);
                this._parentMenu._hideSubMenu();
            }
            break;
        case "Right":
            if (!this._highlightedMenuItemElement)
                break;
            if (this._highlightedMenuItemElement._subItems) {
                this._showSubMenu(this._highlightedMenuItemElement);
                this._subMenu._focus();
                this._subMenu._highlightNext();
            }
            break;
        case "U+001B": // Escape
            this._discardMenu(false, event); break;
        case "Enter":
            if (!isEnterKey(event))
                break;
            // Fall through
        case "U+0020": // Space
            if (this._highlightedMenuItemElement)
                this._triggerAction(this._highlightedMenuItemElement, event);
            if (this._highlightedMenuItemElement._subItems) {
                this._subMenu._focus();
                this._subMenu._highlightNext();
            }
            break;
        }
        event.consume(true);
    },

    _glassPaneMouseUp: function(event)
    {
        // Return if this is simple 'click', since dispatched on glass pane, can't use 'click' event.
        if (new Date().getTime() - this._time < 300)
            return;
        if (event.target === this.element)
            return;
        this._discardMenu(true, event);
        event.consume();
    },

    /**
     * @param {boolean} closeParentMenus
     * @param {!Event=} event
     */
    _discardMenu: function(closeParentMenus, event)
    {
        if (this._subMenu && !closeParentMenus)
            return;
        if (this._glassPaneElement) {
            var glassPane = this._glassPaneElement;
            delete this._glassPaneElement;
            // This can re-enter discardMenu due to blur.
            this._document.body.removeChild(glassPane);
            if (this._parentMenu) {
                delete this._parentMenu._subMenu;
                if (closeParentMenus)
                    this._parentMenu._discardMenu(closeParentMenus, event);
                else
                    this._parentMenu._focus();
            }

            if (event)
                event.consume(true);
        } else if (this._parentMenu && this._contextMenuElement.parentElementOrShadowHost()) {
            this._discardSubMenus();
            if (closeParentMenus)
                this._parentMenu._discardMenu(closeParentMenus, event);
            else
                this._parentMenu._focus();
            if (event)
                event.consume(true);
        }
        if (this._discardMenuOnResizeListener) {
            this._document.defaultView.removeEventListener("resize", this._discardMenuOnResizeListener, false);
            delete this._discardMenuOnResizeListener;
        }
    },

    _discardSubMenus: function()
    {
        if (this._subMenu)
            this._subMenu._discardSubMenus();
        this.element.remove();
        if (this._parentMenu)
            delete this._parentMenu._subMenu;
    }
}
;/* SplitWidget.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. AND ITS CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE INC.
 * OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Widget}
 * @param {boolean} isVertical
 * @param {boolean} secondIsSidebar
 * @param {string=} settingName
 * @param {number=} defaultSidebarWidth
 * @param {number=} defaultSidebarHeight
 * @param {boolean=} constraintsInDip
 */
WebInspector.SplitWidget = function(isVertical, secondIsSidebar, settingName, defaultSidebarWidth, defaultSidebarHeight, constraintsInDip)
{
    WebInspector.Widget.call(this, true);
    this.element.classList.add("split-widget");
    this.registerRequiredCSS("ui/splitWidget.css");

    this.contentElement.classList.add("shadow-split-widget");
    this._mainElement = this.contentElement.createChild("div", "shadow-split-widget-contents shadow-split-widget-main vbox");
    this._mainElement.createChild("content").select = ".insertion-point-main";
    this._sidebarElement = this.contentElement.createChild("div", "shadow-split-widget-contents shadow-split-widget-sidebar vbox");
    this._sidebarElement.createChild("content").select = ".insertion-point-sidebar";
    this._resizerElement = this.contentElement.createChild("div", "shadow-split-widget-resizer");

    this._resizerWidget = new WebInspector.SimpleResizerWidget();
    this._resizerWidget.setEnabled(true);
    this._resizerWidget.addEventListener(WebInspector.ResizerWidget.Events.ResizeStart, this._onResizeStart, this);
    this._resizerWidget.addEventListener(WebInspector.ResizerWidget.Events.ResizeUpdate, this._onResizeUpdate, this);
    this._resizerWidget.addEventListener(WebInspector.ResizerWidget.Events.ResizeEnd, this._onResizeEnd, this);

    this._defaultSidebarWidth = defaultSidebarWidth || 200;
    this._defaultSidebarHeight = defaultSidebarHeight || this._defaultSidebarWidth;
    this._constraintsInDip = !!constraintsInDip;
    this._setting = settingName ? WebInspector.settings.createSetting(settingName, {}) : null;

    this.setSecondIsSidebar(secondIsSidebar);

    this._innerSetVertical(isVertical);
    this._showMode = WebInspector.SplitWidget.ShowMode.Both;

    // Should be called after isVertical has the right value.
    this.installResizer(this._resizerElement);
}

/** @typedef {{showMode: string, size: number}} */
WebInspector.SplitWidget.SettingForOrientation;

WebInspector.SplitWidget.ShowMode = {
    Both: "Both",
    OnlyMain: "OnlyMain",
    OnlySidebar: "OnlySidebar"
}

WebInspector.SplitWidget.Events = {
    SidebarSizeChanged: "SidebarSizeChanged",
    ShowModeChanged: "ShowModeChanged"
}

WebInspector.SplitWidget.MinPadding = 20;

WebInspector.SplitWidget.prototype = {
    /**
     * @return {boolean}
     */
    isVertical: function()
    {
        return this._isVertical;
    },

    /**
     * @param {boolean} isVertical
     */
    setVertical: function(isVertical)
    {
        if (this._isVertical === isVertical)
            return;

        this._innerSetVertical(isVertical);

        if (this.isShowing())
            this._updateLayout();
    },

    /**
     * @param {boolean} isVertical
     */
    _innerSetVertical: function(isVertical)
    {
        this.contentElement.classList.toggle("vbox", !isVertical);
        this.contentElement.classList.toggle("hbox", isVertical);
        this._isVertical = isVertical;

        delete this._resizerElementSize;
        this._sidebarSizeDIP = -1;
        this._restoreSidebarSizeFromSettings();
        if (this._shouldSaveShowMode)
            this._restoreAndApplyShowModeFromSettings();
        this._updateShowHideSidebarButton();
        // FIXME: reverse SplitWidget.isVertical meaning.
        this._resizerWidget.setVertical(!isVertical);
        this.invalidateConstraints();
    },

    /**
     * @param {boolean=} animate
     */
    _updateLayout: function(animate)
    {
        delete this._totalSizeCSS; // Lazy update.
        delete this._totalSizeOtherDimensionCSS;

        // Remove properties that might affect total size calculation.
        this._mainElement.style.removeProperty("width");
        this._mainElement.style.removeProperty("height");
        this._sidebarElement.style.removeProperty("width");
        this._sidebarElement.style.removeProperty("height");

        this._innerSetSidebarSizeDIP(this._preferredSidebarSizeDIP(), !!animate);
    },

    /**
     * @param {!WebInspector.Widget} widget
     */
    setMainWidget: function(widget)
    {
        if (this._mainWidget)
            this._mainWidget.detach();
        this._mainWidget = widget;
        if (widget) {
            widget.element.classList.add("insertion-point-main");
            widget.element.classList.remove("insertion-point-sidebar");
            if (this._showMode === WebInspector.SplitWidget.ShowMode.OnlyMain || this._showMode === WebInspector.SplitWidget.ShowMode.Both)
                widget.show(this.element);
        }
    },

    /**
     * @param {!WebInspector.Widget} widget
     */
    setSidebarWidget: function(widget)
    {
        if (this._sidebarWidget)
            this._sidebarWidget.detach();
        this._sidebarWidget = widget;
        if (widget) {
            widget.element.classList.add("insertion-point-sidebar");
            widget.element.classList.remove("insertion-point-main");
            if (this._showMode === WebInspector.SplitWidget.ShowMode.OnlySidebar || this._showMode === WebInspector.SplitWidget.ShowMode.Both)
                widget.show(this.element);
        }
    },

    /**
     * @return {?WebInspector.Widget}
     */
    mainWidget: function()
    {
        return this._mainWidget;
    },

    /**
     * @return {?WebInspector.Widget}
     */
    sidebarWidget: function()
    {
        return this._sidebarWidget;
    },

    /**
     * @override
     * @param {!WebInspector.Widget} widget
     */
    childWasDetached: function(widget)
    {
        if (this._detaching)
            return;
        if (this._mainWidget === widget)
            delete this._mainWidget;
        if (this._sidebarWidget === widget)
            delete this._sidebarWidget;
    },

    /**
     * @return {boolean}
     */
    isSidebarSecond: function()
    {
        return this._secondIsSidebar;
    },

    enableShowModeSaving: function()
    {
        this._shouldSaveShowMode = true;
        this._restoreAndApplyShowModeFromSettings();
    },

    /**
     * @return {string}
     */
    showMode: function()
    {
        return this._showMode;
    },

    /**
     * @param {boolean} secondIsSidebar
     */
    setSecondIsSidebar: function(secondIsSidebar)
    {
        this.contentElement.classList.toggle("shadow-split-widget-first-is-sidebar", !secondIsSidebar);
        this._secondIsSidebar = secondIsSidebar;
    },

    /**
     * @return {?string}
     */
    sidebarSide: function()
    {
        if (this._showMode !== WebInspector.SplitWidget.ShowMode.Both)
            return null;
        return this._isVertical ?
            (this._secondIsSidebar ? "right" : "left") :
            (this._secondIsSidebar ? "bottom" : "top");
    },

    /**
     * @return {!Element}
     */
    resizerElement: function()
    {
        return this._resizerElement;
    },

    /**
     * @param {boolean=} animate
     */
    hideMain: function(animate)
    {
        this._showOnly(this._sidebarWidget, this._mainWidget, this._sidebarElement, this._mainElement, animate);
        this._updateShowMode(WebInspector.SplitWidget.ShowMode.OnlySidebar);
    },

    /**
     * @param {boolean=} animate
     */
    hideSidebar: function(animate)
    {
        this._showOnly(this._mainWidget, this._sidebarWidget, this._mainElement, this._sidebarElement, animate);
        this._updateShowMode(WebInspector.SplitWidget.ShowMode.OnlyMain);
    },

    /**
     * @param {boolean} minimized
     */
    setSidebarMinimized: function(minimized)
    {
        this._sidebarMinimized = minimized;
        this.invalidateConstraints();
    },

    /**
     * @param {!WebInspector.Widget} sideToShow
     * @param {!WebInspector.Widget} sideToHide
     * @param {!Element} shadowToShow
     * @param {!Element} shadowToHide
     * @param {boolean=} animate
     */
    _showOnly: function(sideToShow, sideToHide, shadowToShow, shadowToHide, animate)
    {
        this._cancelAnimation();

        /**
         * @this {WebInspector.SplitWidget}
         */
        function callback()
        {
            if (sideToShow) {
                // Make sure main is first in the children list.
                if (sideToShow === this._mainWidget)
                    this._mainWidget.show(this.element, this._sidebarWidget ? this._sidebarWidget.element : null);
                else
                    this._sidebarWidget.show(this.element);
            }
            if (sideToHide) {
                this._detaching = true;
                sideToHide.detach();
                delete this._detaching;
            }

            this._resizerElement.classList.add("hidden");
            shadowToShow.classList.remove("hidden");
            shadowToShow.classList.add("maximized");
            shadowToHide.classList.add("hidden");
            shadowToHide.classList.remove("maximized");
            this._removeAllLayoutProperties();
            this.doResize();
        }

        if (animate)
            this._animate(true, callback.bind(this));
        else
            callback.call(this);

        this._sidebarSizeDIP = -1;
        this.setResizable(false);
    },

    _removeAllLayoutProperties: function()
    {
        this._sidebarElement.style.removeProperty("flexBasis");

        this._mainElement.style.removeProperty("width");
        this._mainElement.style.removeProperty("height");
        this._sidebarElement.style.removeProperty("width");
        this._sidebarElement.style.removeProperty("height");

        this._resizerElement.style.removeProperty("left");
        this._resizerElement.style.removeProperty("right");
        this._resizerElement.style.removeProperty("top");
        this._resizerElement.style.removeProperty("bottom");

        this._resizerElement.style.removeProperty("margin-left");
        this._resizerElement.style.removeProperty("margin-right");
        this._resizerElement.style.removeProperty("margin-top");
        this._resizerElement.style.removeProperty("margin-bottom");
    },

    /**
     * @param {boolean=} animate
     */
    showBoth: function(animate)
    {
        if (this._showMode === WebInspector.SplitWidget.ShowMode.Both)
            animate = false;

        this._cancelAnimation();
        this._mainElement.classList.remove("maximized", "hidden");
        this._sidebarElement.classList.remove("maximized", "hidden");
        this._resizerElement.classList.remove("hidden");
        this.setResizable(true);

        // Make sure main is the first in the children list.
        if (this._sidebarWidget)
            this._sidebarWidget.show(this.element);
        if (this._mainWidget)
            this._mainWidget.show(this.element, this._sidebarWidget ? this._sidebarWidget.element : null);
        // Order widgets in DOM properly.
        this.setSecondIsSidebar(this._secondIsSidebar);

        this._sidebarSizeDIP = -1;
        this._updateShowMode(WebInspector.SplitWidget.ShowMode.Both);
        this._updateLayout(animate);
    },

    /**
     * @param {boolean} resizable
     */
    setResizable: function(resizable)
    {
        this._resizerWidget.setEnabled(resizable);
    },

    /**
     * @return {boolean}
     */
    isResizable: function()
    {
        return this._resizerWidget.isEnabled();
    },

    /**
     * @param {number} size
     */
    setSidebarSize: function(size)
    {
        var sizeDIP = WebInspector.zoomManager.cssToDIP(size);
        this._savedSidebarSizeDIP = sizeDIP;
        this._saveSetting();
        this._innerSetSidebarSizeDIP(sizeDIP, false, true);
    },

    /**
     * @return {number}
     */
    sidebarSize: function()
    {
        var sizeDIP = Math.max(0, this._sidebarSizeDIP);
        return WebInspector.zoomManager.dipToCSS(sizeDIP);
    },

    /**
     * Returns total size in DIP.
     * @return {number}
     */
    _totalSizeDIP: function()
    {
        if (!this._totalSizeCSS) {
            this._totalSizeCSS = this._isVertical ? this.contentElement.offsetWidth : this.contentElement.offsetHeight;
            this._totalSizeOtherDimensionCSS = this._isVertical ? this.contentElement.offsetHeight : this.contentElement.offsetWidth;
        }
        return WebInspector.zoomManager.cssToDIP(this._totalSizeCSS);
    },

    /**
     * @param {string} showMode
     */
    _updateShowMode: function(showMode)
    {
        this._showMode = showMode;
        this._saveShowModeToSettings();
        this._updateShowHideSidebarButton();
        this.dispatchEventToListeners(WebInspector.SplitWidget.Events.ShowModeChanged, showMode);
        this.invalidateConstraints();
    },

    /**
     * @param {number} sizeDIP
     * @param {boolean} animate
     * @param {boolean=} userAction
     */
    _innerSetSidebarSizeDIP: function(sizeDIP, animate, userAction)
    {
        if (this._showMode !== WebInspector.SplitWidget.ShowMode.Both || !this.isShowing())
            return;

        sizeDIP = this._applyConstraints(sizeDIP, userAction);
        if (this._sidebarSizeDIP === sizeDIP)
            return;

        if (!this._resizerElementSize)
            this._resizerElementSize = this._isVertical ? this._resizerElement.offsetWidth : this._resizerElement.offsetHeight;

        // Invalidate layout below.

        this._removeAllLayoutProperties();

        // this._totalSizeDIP is available below since we successfully applied constraints.
        var sidebarSizeValue = WebInspector.zoomManager.dipToCSS(sizeDIP) + "px";
        var mainSizeValue = (this._totalSizeCSS - WebInspector.zoomManager.dipToCSS(sizeDIP)) + "px";
        this._sidebarElement.style.flexBasis = sidebarSizeValue;

        // Make both sides relayout boundaries.
        if (this._isVertical) {
            this._sidebarElement.style.width = sidebarSizeValue;
            this._mainElement.style.width = mainSizeValue;
            this._sidebarElement.style.height = this._totalSizeOtherDimensionCSS + "px";
            this._mainElement.style.height = this._totalSizeOtherDimensionCSS + "px";
        } else {
            this._sidebarElement.style.height = sidebarSizeValue;
            this._mainElement.style.height = mainSizeValue;
            this._sidebarElement.style.width = this._totalSizeOtherDimensionCSS + "px";
            this._mainElement.style.width = this._totalSizeOtherDimensionCSS + "px";
        }

        // Position resizer.
        if (this._isVertical) {
            if (this._secondIsSidebar) {
                this._resizerElement.style.right = sidebarSizeValue;
                this._resizerElement.style.marginRight = -this._resizerElementSize / 2 + "px";
            } else {
                this._resizerElement.style.left = sidebarSizeValue;
                this._resizerElement.style.marginLeft = -this._resizerElementSize / 2 + "px";
            }
        } else {
            if (this._secondIsSidebar) {
                this._resizerElement.style.bottom = sidebarSizeValue;
                this._resizerElement.style.marginBottom = -this._resizerElementSize / 2 + "px";
            } else {
                this._resizerElement.style.top = sidebarSizeValue;
                this._resizerElement.style.marginTop = -this._resizerElementSize / 2 + "px";
            }
        }

        this._sidebarSizeDIP = sizeDIP;

        // Force layout.

        if (animate) {
            this._animate(false);
        } else {
            // No need to recalculate this._sidebarSizeDIP and this._totalSizeDIP again.
            this.doResize();
            this.dispatchEventToListeners(WebInspector.SplitWidget.Events.SidebarSizeChanged, this.sidebarSize());
        }
    },

    /**
     * @param {boolean} reverse
     * @param {function()=} callback
     */
    _animate: function(reverse, callback)
    {
        var animationTime = 50;
        this._animationCallback = callback;

        var animatedMarginPropertyName;
        if (this._isVertical)
            animatedMarginPropertyName = this._secondIsSidebar ? "margin-right" : "margin-left";
        else
            animatedMarginPropertyName = this._secondIsSidebar ? "margin-bottom" : "margin-top";

        var marginFrom = reverse ? "0" : "-" + WebInspector.zoomManager.dipToCSS(this._sidebarSizeDIP) + "px";
        var marginTo = reverse ? "-" + WebInspector.zoomManager.dipToCSS(this._sidebarSizeDIP) + "px" : "0";

        // This order of things is important.
        // 1. Resize main element early and force layout.
        this.contentElement.style.setProperty(animatedMarginPropertyName, marginFrom);
        if (!reverse) {
            suppressUnused(this._mainElement.offsetWidth);
            suppressUnused(this._sidebarElement.offsetWidth);
        }

        // 2. Issue onresize to the sidebar element, its size won't change.
        if (!reverse)
            this._sidebarWidget.doResize();

        // 3. Configure and run animation
        this.contentElement.style.setProperty("transition", animatedMarginPropertyName + " " + animationTime + "ms linear");

        var boundAnimationFrame;
        var startTime;
        /**
         * @this {WebInspector.SplitWidget}
         */
        function animationFrame()
        {
            delete this._animationFrameHandle;

            if (!startTime) {
                // Kick animation on first frame.
                this.contentElement.style.setProperty(animatedMarginPropertyName, marginTo);
                startTime = window.performance.now();
            } else if (window.performance.now() < startTime + animationTime) {
                // Process regular animation frame.
                if (this._mainWidget)
                    this._mainWidget.doResize();
            } else {
                // Complete animation.
                this._cancelAnimation();
                if (this._mainWidget)
                    this._mainWidget.doResize();
                this.dispatchEventToListeners(WebInspector.SplitWidget.Events.SidebarSizeChanged, this.sidebarSize());
                return;
            }
            this._animationFrameHandle = this.contentElement.window().requestAnimationFrame(boundAnimationFrame);
        }
        boundAnimationFrame = animationFrame.bind(this);
        this._animationFrameHandle = this.contentElement.window().requestAnimationFrame(boundAnimationFrame);
    },

    _cancelAnimation: function()
    {
        this.contentElement.style.removeProperty("margin-top");
        this.contentElement.style.removeProperty("margin-right");
        this.contentElement.style.removeProperty("margin-bottom");
        this.contentElement.style.removeProperty("margin-left");
        this.contentElement.style.removeProperty("transition");

        if (this._animationFrameHandle) {
            this.contentElement.window().cancelAnimationFrame(this._animationFrameHandle);
            delete this._animationFrameHandle;
        }
        if (this._animationCallback) {
            this._animationCallback();
            delete this._animationCallback;
        }
    },

    /**
     * @param {number} sidebarSize
     * @param {boolean=} userAction
     * @return {number}
     */
    _applyConstraints: function(sidebarSize, userAction)
    {
        var totalSize = this._totalSizeDIP();
        var zoomFactor = this._constraintsInDip ? 1 : WebInspector.zoomManager.zoomFactor();

        var constraints = this._sidebarWidget ? this._sidebarWidget.constraints() : new Constraints();
        var minSidebarSize = this.isVertical() ? constraints.minimum.width : constraints.minimum.height;
        if (!minSidebarSize)
            minSidebarSize = WebInspector.SplitWidget.MinPadding;
        minSidebarSize *= zoomFactor;
        if (this._sidebarMinimized)
            sidebarSize = minSidebarSize;

        var preferredSidebarSize = this.isVertical() ? constraints.preferred.width : constraints.preferred.height;
        if (!preferredSidebarSize)
            preferredSidebarSize = WebInspector.SplitWidget.MinPadding;
        preferredSidebarSize *= zoomFactor;
        // Allow sidebar to be less than preferred by explicit user action.
        if (sidebarSize < preferredSidebarSize)
            preferredSidebarSize = Math.max(sidebarSize, minSidebarSize);
        preferredSidebarSize += zoomFactor; // 1 css pixel for splitter border.

        constraints = this._mainWidget ? this._mainWidget.constraints() : new Constraints();
        var minMainSize = this.isVertical() ? constraints.minimum.width : constraints.minimum.height;
        if (!minMainSize)
            minMainSize = WebInspector.SplitWidget.MinPadding;
        minMainSize *= zoomFactor;

        var preferredMainSize = this.isVertical() ? constraints.preferred.width : constraints.preferred.height;
        if (!preferredMainSize)
            preferredMainSize = WebInspector.SplitWidget.MinPadding;
        preferredMainSize *= zoomFactor;
        var savedMainSize = this.isVertical() ? this._savedVerticalMainSize : this._savedHorizontalMainSize;
        if (typeof savedMainSize !== "undefined")
            preferredMainSize = Math.min(preferredMainSize, savedMainSize * zoomFactor);
        if (userAction)
            preferredMainSize = minMainSize;

        // Enough space for preferred.
        var totalPreferred = preferredMainSize + preferredSidebarSize;
        if (totalPreferred <= totalSize)
            return Number.constrain(sidebarSize, preferredSidebarSize, totalSize - preferredMainSize);

        // Enough space for minimum.
        if (minMainSize + minSidebarSize <= totalSize) {
            var delta = totalPreferred - totalSize;
            var sidebarDelta = delta * preferredSidebarSize / totalPreferred;
            sidebarSize = preferredSidebarSize - sidebarDelta;
            return Number.constrain(sidebarSize, minSidebarSize, totalSize - minMainSize);
        }

        // Not enough space even for minimum sizes.
        return Math.max(0, totalSize - minMainSize);
    },

    wasShown: function()
    {
        this._forceUpdateLayout();
        WebInspector.zoomManager.addEventListener(WebInspector.ZoomManager.Events.ZoomChanged, this._onZoomChanged, this);
    },

    willHide: function()
    {
        WebInspector.zoomManager.removeEventListener(WebInspector.ZoomManager.Events.ZoomChanged, this._onZoomChanged, this);
    },

    onResize: function()
    {
        this._updateLayout();
    },

    onLayout: function()
    {
        this._updateLayout();
    },

    /**
     * @override
     * @return {!Constraints}
     */
    calculateConstraints: function()
    {
        if (this._showMode === WebInspector.SplitWidget.ShowMode.OnlyMain)
            return this._mainWidget ? this._mainWidget.constraints() : new Constraints();
        if (this._showMode === WebInspector.SplitWidget.ShowMode.OnlySidebar)
            return this._sidebarWidget ? this._sidebarWidget.constraints() : new Constraints();

        var mainConstraints = this._mainWidget ? this._mainWidget.constraints() : new Constraints();
        var sidebarConstraints = this._sidebarWidget ? this._sidebarWidget.constraints() : new Constraints();
        var min = WebInspector.SplitWidget.MinPadding;
        if (this._isVertical) {
            mainConstraints = mainConstraints.widthToMax(min).addWidth(1); // 1 for splitter
            sidebarConstraints = sidebarConstraints.widthToMax(min);
            return mainConstraints.addWidth(sidebarConstraints).heightToMax(sidebarConstraints);
        } else {
            mainConstraints = mainConstraints.heightToMax(min).addHeight(1); // 1 for splitter
            sidebarConstraints = sidebarConstraints.heightToMax(min);
            return mainConstraints.widthToMax(sidebarConstraints).addHeight(sidebarConstraints);
        }
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onResizeStart: function(event)
    {
        this._resizeStartSizeDIP = this._sidebarSizeDIP;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onResizeUpdate: function(event)
    {
        var offset = event.data.currentPosition - event.data.startPosition;
        var offsetDIP = WebInspector.zoomManager.cssToDIP(offset);
        var newSizeDIP = this._secondIsSidebar ? this._resizeStartSizeDIP - offsetDIP : this._resizeStartSizeDIP + offsetDIP;
        var constrainedSizeDIP = this._applyConstraints(newSizeDIP, true);
        this._savedSidebarSizeDIP = constrainedSizeDIP;
        this._saveSetting();
        this._innerSetSidebarSizeDIP(constrainedSizeDIP, false, true);
        if (this.isVertical())
            this._savedVerticalMainSize = this._totalSizeDIP() - this._sidebarSizeDIP;
        else
            this._savedHorizontalMainSize = this._totalSizeDIP() - this._sidebarSizeDIP;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onResizeEnd: function(event)
    {
        delete this._resizeStartSizeDIP;
    },

    hideDefaultResizer: function()
    {
        this.uninstallResizer(this._resizerElement);
    },

    /**
     * @param {!Element} resizerElement
     */
    installResizer: function(resizerElement)
    {
        this._resizerWidget.addElement(resizerElement);
    },

    /**
     * @param {!Element} resizerElement
     */
    uninstallResizer: function(resizerElement)
    {
        this._resizerWidget.removeElement(resizerElement);
    },

    /**
     * @return {boolean}
     */
    hasCustomResizer: function()
    {
        var elements = this._resizerWidget.elements();
        return elements.length > 1 || (elements.length == 1 && elements[0] !== this._resizerElement);
    },

    /**
     * @param {!Element} resizer
     * @param {boolean} on
     */
    toggleResizer: function(resizer, on)
    {
        if (on)
            this.installResizer(resizer);
        else
            this.uninstallResizer(resizer);
    },

    /**
     * @return {?WebInspector.SplitWidget.SettingForOrientation}
     */
    _settingForOrientation: function()
    {
        var state = this._setting ? this._setting.get() : {};
        return this._isVertical ? state.vertical : state.horizontal;
    },

    /**
     * @return {number}
     */
    _preferredSidebarSizeDIP: function()
    {
        var size = this._savedSidebarSizeDIP;
        if (!size) {
            size = this._isVertical ? this._defaultSidebarWidth : this._defaultSidebarHeight;
            // If we have default value in percents, calculate it on first use.
            if (0 < size && size < 1)
                size *= this._totalSizeDIP();
        }
        return size;
    },

    _restoreSidebarSizeFromSettings: function()
    {
        var settingForOrientation = this._settingForOrientation();
        this._savedSidebarSizeDIP = settingForOrientation ? settingForOrientation.size : 0;
    },

    _restoreAndApplyShowModeFromSettings: function()
    {
        var orientationState = this._settingForOrientation();
        this._savedShowMode = orientationState && orientationState.showMode ? orientationState.showMode : this._showMode;
        this._showMode = this._savedShowMode;

        switch (this._savedShowMode) {
        case WebInspector.SplitWidget.ShowMode.Both:
            this.showBoth();
            break;
        case WebInspector.SplitWidget.ShowMode.OnlyMain:
            this.hideSidebar();
            break;
        case WebInspector.SplitWidget.ShowMode.OnlySidebar:
            this.hideMain();
            break;
        }
    },

    _saveShowModeToSettings: function()
    {
        this._savedShowMode = this._showMode;
        this._saveSetting();
    },

    _saveSetting: function()
    {
        if (!this._setting)
            return;
        var state = this._setting.get();
        var orientationState = (this._isVertical ? state.vertical : state.horizontal) || {};

        orientationState.size = this._savedSidebarSizeDIP;
        if (this._shouldSaveShowMode)
            orientationState.showMode = this._savedShowMode;

        if (this._isVertical)
            state.vertical = orientationState;
        else
            state.horizontal = orientationState;
        this._setting.set(state);
    },

    _forceUpdateLayout: function()
    {
        // Force layout even if sidebar size does not change.
        this._sidebarSizeDIP = -1;
        this._updateLayout();
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onZoomChanged: function(event)
    {
        this._forceUpdateLayout();
    },

    /**
     * @param {string} title
     * @param {string=} className
     * @return {!Element}
     */
    displayShowHideSidebarButton: function(title, className)
    {
        console.assert(this.isVertical(), "Buttons for split widget with horizontal split are not supported yet.");

        this._showHideSidebarButtonTitle = WebInspector.UIString(title);
        this._showHideSidebarButton = this._mainElement.createChild("button", "sidebar-show-hide-button " + (className || ""));
        this._showHideSidebarButton.addEventListener("click", buttonClicked.bind(this), false);
        this._updateShowHideSidebarButton();

        /**
         * @param {!Event} event
         * @this {WebInspector.SplitWidget}
         */
        function buttonClicked(event)
        {
            if (this._showMode !== WebInspector.SplitWidget.ShowMode.Both)
                this.showBoth(true);
            else
                this.hideSidebar(true);
        }

        return this._showHideSidebarButton;
    },

    _updateShowHideSidebarButton: function()
    {
        if (!this._showHideSidebarButton)
            return;
        var sidebarHidden = this._showMode === WebInspector.SplitWidget.ShowMode.OnlyMain;
        this._showHideSidebarButton.classList.toggle("toggled-show", sidebarHidden);
        this._showHideSidebarButton.classList.toggle("toggled-hide", !sidebarHidden);
        this._showHideSidebarButton.classList.toggle("top-sidebar-show-hide-button", !this.isVertical() && !this.isSidebarSecond());
        this._showHideSidebarButton.classList.toggle("right-sidebar-show-hide-button", this.isVertical() && this.isSidebarSecond());
        this._showHideSidebarButton.classList.toggle("bottom-sidebar-show-hide-button", !this.isVertical() && this.isSidebarSecond());
        this._showHideSidebarButton.classList.toggle("left-sidebar-show-hide-button", this.isVertical() && !this.isSidebarSecond());
        this._showHideSidebarButton.title = sidebarHidden ? WebInspector.UIString("Show %s", this._showHideSidebarButtonTitle) : WebInspector.UIString("Hide %s", this._showHideSidebarButtonTitle);
    },

    __proto__: WebInspector.Widget.prototype
}
;/* StackView.js */
/*
 * Copyright (C) 2014 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. AND ITS CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE INC.
 * OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.VBox}
 * @param {boolean} isVertical
 */
WebInspector.StackView = function(isVertical)
{
    WebInspector.VBox.call(this);
    this._isVertical = isVertical;
    this._currentSplitWidget = null;
}

WebInspector.StackView.prototype = {
    /**
     * @param {!WebInspector.Widget} view
     * @param {string=} sidebarSizeSettingName
     * @param {number=} defaultSidebarWidth
     * @param {number=} defaultSidebarHeight
     * @return {?WebInspector.SplitWidget}
     */
    appendView: function(view, sidebarSizeSettingName, defaultSidebarWidth, defaultSidebarHeight)
    {
        var splitWidget = new WebInspector.SplitWidget(this._isVertical, true, sidebarSizeSettingName, defaultSidebarWidth, defaultSidebarHeight);
        splitWidget.setMainWidget(view);
        splitWidget.hideSidebar();

        if (!this._currentSplitWidget) {
            splitWidget.show(this.element);
        } else {
            this._currentSplitWidget.setSidebarWidget(splitWidget);
            this._currentSplitWidget.showBoth();
        }

        var lastSplitWidget = this._currentSplitWidget;
        this._currentSplitWidget = splitWidget;
        return lastSplitWidget;
    },

    detachChildWidgets: function()
    {
        WebInspector.Widget.prototype.detachChildWidgets.call(this);
        this._currentSplitWidget = null;
    },

    __proto__: WebInspector.VBox.prototype
}
;/* Toolbar.js */
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {string} className
 * @param {!Element=} parentElement
 */
WebInspector.Toolbar = function(className, parentElement)
{
    /** @type {!Array.<!WebInspector.ToolbarItem>} */
    this._items = [];
    this._reverse = false;
    this.element = parentElement ? parentElement.createChild("div") : createElement("div");
    this.element.className = className;
    this.element.classList.add("toolbar");
    this._shadowRoot = WebInspector.createShadowRootWithCoreStyles(this.element, "ui/toolbar.css");
    this._contentElement = this._shadowRoot.createChild("div", "toolbar-shadow");
    this._insertionPoint = this._contentElement.createChild("content");
}

WebInspector.Toolbar.prototype = {
    /**
     * @param {boolean=} reverse
     */
    makeWrappable: function(reverse)
    {
        this._contentElement.classList.add("wrappable");
        this._reverse = !!reverse;
        if (reverse)
            this._contentElement.classList.add("wrappable-reverse");
    },

    makeVertical: function()
    {
        this._contentElement.classList.add("vertical");
    },

    makeBlueOnHover: function()
    {
        this._contentElement.classList.add("toolbar-blue-on-hover");
    },

    makeToggledGray: function()
    {
        this._contentElement.classList.add("toolbar-toggled-gray");
    },

    /**
     * @param {boolean} enabled
     */
    setEnabled: function(enabled)
    {
        for (var item of this._items)
            item.setEnabled(enabled);
    },

    /**
     * @param {!WebInspector.ToolbarItem} item
     */
    appendToolbarItem: function(item)
    {
        this._items.push(item);
        item._toolbar = this;
        if (this._reverse)
            this._contentElement.insertBefore(item.element, this._insertionPoint.nextSibling);
        else
            this._contentElement.insertBefore(item.element, this._insertionPoint);
        this._hideSeparatorDupes();
    },

    appendSeparator: function()
    {
        this.appendToolbarItem(new WebInspector.ToolbarSeparator());
    },

    /**
     * @param {string} text
     */
    appendText: function(text)
    {
        this.appendToolbarItem(new WebInspector.ToolbarText(text));
    },

    removeToolbarItems: function()
    {
        for (var item of this._items)
            delete item._toolbar;
        this._items = [];
        this._contentElement.removeChildren();
        this._insertionPoint = this._contentElement.createChild("content");
    },

    /**
     * @param {string} color
     */
    setColor: function(color)
    {
        var style = createElement("style");
        style.textContent = ".toolbar-glyph { background-color: " + color + " !important }";
        this._shadowRoot.appendChild(style);
    },

    /**
     * @param {string} color
     */
    setToggledColor: function(color)
    {
        var style = createElement("style");
        style.textContent = ".toolbar-button.toolbar-state-on .toolbar-glyph { background-color: " + color + " !important }";
        this._shadowRoot.appendChild(style);
    },

    _hideSeparatorDupes: function()
    {
        if (!this._items.length)
            return;
        // Don't hide first and last separators if they were added explicitly.
        var previousIsSeparator = false;
        var lastSeparator;
        var nonSeparatorVisible = false;
        for (var i = 0; i < this._items.length; ++i) {
            if (this._items[i] instanceof WebInspector.ToolbarSeparator) {
                this._items[i].setVisible(!previousIsSeparator);
                previousIsSeparator = true;
                lastSeparator = this._items[i];
                continue;
            }
            if (this._items[i].visible()) {
                previousIsSeparator = false;
                lastSeparator = null;
                nonSeparatorVisible = true;
            }
        }
        if (lastSeparator && lastSeparator !== this._items.peekLast())
            lastSeparator.setVisible(false);

        this.element.classList.toggle("hidden", lastSeparator && lastSeparator.visible() && !nonSeparatorVisible);
    }
}

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @param {!Element} element
 */
WebInspector.ToolbarItem = function(element)
{
    this.element = element;
    this.element.classList.add("toolbar-item");
    this._visible = true;
    this._enabled = true;
    this.element.addEventListener("mouseenter", this._mouseEnter.bind(this), false);
    this.element.addEventListener("mouseleave", this._mouseLeave.bind(this), false);
}

WebInspector.ToolbarItem.prototype = {
    /**
     * @param {string} title
     */
    setTitle: function(title)
    {
        if (this._title === title)
            return;
        this._title = title;
        WebInspector.Tooltip.install(this.element, title);
    },

    _mouseEnter: function()
    {
        this.element.classList.add("hover");
    },

    _mouseLeave: function()
    {
        this.element.classList.remove("hover");
    },

    /**
     * @param {boolean} value
     */
    setEnabled: function(value)
    {
        if (this._enabled === value)
            return;
        this._enabled = value;
        this._applyEnabledState();
    },

    _applyEnabledState: function()
    {
        this.element.disabled = !this._enabled;
    },

    /**
     * @return {boolean} x
     */
    visible: function()
    {
        return this._visible;
    },

    /**
     * @param {boolean} x
     */
    setVisible: function(x)
    {
        if (this._visible === x)
            return;
        this.element.classList.toggle("hidden", !x);
        this._visible = x;
        if (this._toolbar && !(this instanceof WebInspector.ToolbarSeparator))
            this._toolbar._hideSeparatorDupes();
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @constructor
 * @extends {WebInspector.ToolbarItem}
 * @param {string=} text
 */
WebInspector.ToolbarText = function(text)
{
    WebInspector.ToolbarItem.call(this, createElementWithClass("div", "toolbar-text"));
    this.element.classList.add("toolbar-text");
    this.setText(text || "");
}

WebInspector.ToolbarText.prototype = {
     /**
     * @param {string} text
     */
    setText: function(text)
    {
        this.element.textContent = text;
    },

    __proto__: WebInspector.ToolbarItem.prototype
}

/**
 * @constructor
 * @extends {WebInspector.ToolbarItem}
 * @param {string} title
 * @param {string=} glyph
 * @param {string=} text
 */
WebInspector.ToolbarButton = function(title, glyph, text)
{
    WebInspector.ToolbarItem.call(this, createElementWithClass("button", "toolbar-button"));
    this.element.addEventListener("click", this._clicked.bind(this), false);
    this.element.addEventListener("mousedown", this._mouseDown.bind(this), false);
    this.element.addEventListener("mouseup", this._mouseUp.bind(this), false);

    this._glyphElement = this.element.createChild("div", "toolbar-glyph hidden");
    this._textElement = this.element.createChild("div", "toolbar-text hidden");

    this.setTitle(title);
    if (glyph)
        this.setGlyph(glyph);
    this.setText(text || "");
    this._state = "";
    this._title = "";
}

WebInspector.ToolbarButton.prototype = {
    /**
     * @param {string} text
     */
    setText: function(text)
    {
        if (this._text === text)
            return;
        this._textElement.textContent = text;
        this._textElement.classList.toggle("hidden", !text);
        this._text = text;
    },

    /**
     * @param {string} glyph
     */
    setGlyph: function(glyph)
    {
        if (this._glyph === glyph)
            return;
        if (this._glyph)
            this._glyphElement.classList.remove(this._glyph);
        if (glyph)
            this._glyphElement.classList.add(glyph);
        this._glyphElement.classList.toggle("hidden", !glyph);
        this.element.classList.toggle("toolbar-has-glyph", !!glyph);
        this._glyph = glyph;
    },

    /**
     * @param {string} iconURL
     */
    setBackgroundImage: function(iconURL)
    {
        this.element.style.backgroundImage = "url(" + iconURL + ")";
    },

    /**
     * @return {string}
     */
    state: function()
    {
        return this._state;
    },

    /**
     * @param {string} state
     */
    setState: function(state)
    {
        if (this._state === state)
            return;
        this.element.classList.remove("toolbar-state-" + this._state);
        this.element.classList.add("toolbar-state-" + state);
        this._state = state;
    },

    /**
     * @param {number=} width
     */
    turnIntoSelect: function(width)
    {
        this.element.classList.add("toolbar-has-dropdown");
        this.element.createChild("div", "toolbar-dropdown-arrow");
        if (width)
            this.element.style.width = width + "px";
    },

    /**
     * @param {!Event} event
     */
    _clicked: function(event)
    {
        var defaultPrevented = this.dispatchEventToListeners("click", event);
        event.consume(defaultPrevented);
    },

    /**
     * @param {!Event} event
     */
    _mouseDown: function(event)
    {
        this.dispatchEventToListeners("mousedown", event);
    },

    /**
     * @param {!Event} event
     */
    _mouseUp: function(event)
    {
        this.dispatchEventToListeners("mouseup", event);
    },

    __proto__: WebInspector.ToolbarItem.prototype
}

/**
 * @constructor
 * @extends {WebInspector.ToolbarItem}
 * @param {string=} placeholder
 * @param {number=} growFactor
 */
WebInspector.ToolbarInput = function(placeholder, growFactor)
{
    WebInspector.ToolbarItem.call(this, createElementWithClass("input", "toolbar-item"));
    this.element.addEventListener("input", this._onChangeCallback.bind(this), false);
    if (growFactor)
        this.element.style.flexGrow = growFactor;
    if (placeholder)
        this.element.setAttribute("placeholder", placeholder);
    this._value = "";
}

WebInspector.ToolbarInput.Event = {
    TextChanged: "TextChanged"
};

WebInspector.ToolbarInput.prototype = {
    /**
     * @param {string} value
     */
    setValue: function(value)
    {
        this._value = value;
        this.element.value = value;
    },

    /**
     * @return {string}
     */
    value: function()
    {
        return this.element.value;
    },

    _onChangeCallback: function()
    {
        this.dispatchEventToListeners(WebInspector.ToolbarInput.Event.TextChanged, this.element.value);
    },

    __proto__: WebInspector.ToolbarItem.prototype
}

/**
 * @constructor
 * @extends {WebInspector.ToolbarButton}
 * @param {string} title
 * @param {string=} glyph
 * @param {string=} text
 */
WebInspector.ToolbarToggle = function(title, glyph, text)
{
    WebInspector.ToolbarButton.call(this, title, glyph, text);
    this._toggled = false;
    this.setState("off");
}

WebInspector.ToolbarToggle.prototype = {
    /**
     * @return {boolean}
     */
    toggled: function()
    {
        return this._toggled;
    },

    /**
     * @param {boolean} toggled
     */
    setToggled: function(toggled)
    {
        if (this._toggled === toggled)
            return;
        this._toggled = toggled;
        this.setState(toggled ? "on" : "off");
    },

    __proto__: WebInspector.ToolbarButton.prototype
}

/**
 * @param {!WebInspector.Action} action
 * @param {!Array<!WebInspector.ToolbarButton>=} toggledOptions
 * @param {!Array<!WebInspector.ToolbarButton>=} untoggledOptions
 * @return {!WebInspector.ToolbarItem}
 */
WebInspector.Toolbar.createActionButton = function(action, toggledOptions, untoggledOptions)
{
    var button = new WebInspector.ToolbarButton(action.title(), action.icon());
    button.addEventListener("click", action.execute, action);
    action.addEventListener(WebInspector.Action.Events.Enabled, enabledChanged);
    action.addEventListener(WebInspector.Action.Events.StateChanged, stateChanged);
    action.addEventListener(WebInspector.Action.Events.TitleChanged, titleChanged);
    /** @type {?WebInspector.LongClickController} */
    var longClickController = null;
    /** @type {?Array<!WebInspector.ToolbarButton>} */
    var longClickButtons = null;
    /** @type {?Element} */
    var longClickGlyph = null;
    titleChanged();
    stateChanged();
    return button;

    function titleChanged()
    {
        WebInspector.Tooltip.install(button.element, action.title(), action.id());
    }

    /**
     * @param {!WebInspector.Event} event
     */
    function enabledChanged(event)
    {
        button.setEnabled(/** @type {boolean} */ (event.data));
    }

    function stateChanged()
    {
        button.setState(action.state());
        updateOptions();
    }

    function updateOptions()
    {
        if (action.statesCount() !== 2)
            return;

        var buttons = action.toggled() ? (toggledOptions || null) : (untoggledOptions || null);

        if (buttons && buttons.length) {
            if (!longClickController) {
                longClickController = new WebInspector.LongClickController(button.element, showOptions);
                longClickGlyph = button.element.createChild("div", "long-click-glyph toolbar-button-theme");
                longClickButtons = buttons;
            }
        } else {
            if (longClickController) {
                longClickController.dispose();
                longClickController = null;
                longClickGlyph.remove();
                longClickGlyph = null;
                longClickButtons = null;
            }
        }
    }

    function showOptions()
    {
        var buttons = longClickButtons.slice();
        var mainButtonClone = new WebInspector.ToolbarButton(action.title(), action.icon());
        mainButtonClone.addEventListener("click", clicked);

        /**
         * @param {!WebInspector.Event} event
         */
        function clicked(event)
        {
            button._clicked(/** @type {!Event} */ (event.data));
        }

        mainButtonClone.setState(action.state());
        buttons.push(mainButtonClone);

        var document = button.element.ownerDocument;
        document.documentElement.addEventListener("mouseup", mouseUp, false);

        var optionsGlassPane = new WebInspector.GlassPane(document);
        var optionsBar = new WebInspector.Toolbar("fill", optionsGlassPane.element);
        optionsBar._contentElement.classList.add("floating");
        const buttonHeight = 26;

        var hostButtonPosition = button.element.totalOffset();

        var topNotBottom = hostButtonPosition.top + buttonHeight * buttons.length < document.documentElement.offsetHeight;

        if (topNotBottom)
            buttons = buttons.reverse();

        optionsBar.element.style.height = (buttonHeight * buttons.length) + "px";
        if (topNotBottom)
            optionsBar.element.style.top = (hostButtonPosition.top + 1) + "px";
        else
            optionsBar.element.style.top = (hostButtonPosition.top - (buttonHeight * (buttons.length - 1))) + "px";
        optionsBar.element.style.left = (hostButtonPosition.left + 1) + "px";

        for (var i = 0; i < buttons.length; ++i) {
            buttons[i].element.addEventListener("mousemove", mouseOver, false);
            buttons[i].element.addEventListener("mouseout", mouseOut, false);
            optionsBar.appendToolbarItem(buttons[i]);
        }
        var hostButtonIndex = topNotBottom ? 0 : buttons.length - 1;
        buttons[hostButtonIndex].element.classList.add("emulate-active");

        function mouseOver(e)
        {
            if (e.which !== 1)
                return;
            var buttonElement = e.target.enclosingNodeOrSelfWithClass("toolbar-item");
            buttonElement.classList.add("emulate-active");
        }

        function mouseOut(e)
        {
            if (e.which !== 1)
                return;
            var buttonElement = e.target.enclosingNodeOrSelfWithClass("toolbar-item");
            buttonElement.classList.remove("emulate-active");
        }

        function mouseUp(e)
        {
            if (e.which !== 1)
                return;
            optionsGlassPane.dispose();
            document.documentElement.removeEventListener("mouseup", mouseUp, false);

            for (var i = 0; i < buttons.length; ++i) {
                if (buttons[i].element.classList.contains("emulate-active")) {
                    buttons[i].element.classList.remove("emulate-active");
                    buttons[i]._clicked(e);
                    break;
                }
            }
        }
    }
}

/**
 * @constructor
 * @extends {WebInspector.ToolbarButton}
 * @param {function(!WebInspector.ContextMenu)} contextMenuHandler
 * @param {boolean=} useSoftMenu
 */
WebInspector.ToolbarMenuButton = function(contextMenuHandler, useSoftMenu)
{
    WebInspector.ToolbarButton.call(this, "", "menu-toolbar-item");
    this._contextMenuHandler = contextMenuHandler;
    this._useSoftMenu = !!useSoftMenu;
}

WebInspector.ToolbarMenuButton.prototype = {
    /**
     * @override
     * @param {!Event} event
     */
    _mouseDown: function(event)
    {
        if (event.buttons !== 1) {
            WebInspector.ToolbarButton.prototype._mouseDown.call(this, event);
            return;
        }

        var contextMenu = new WebInspector.ContextMenu(event,
            this._useSoftMenu,
            this.element.totalOffsetLeft(),
            this.element.totalOffsetTop() + this.element.offsetHeight);
        this._contextMenuHandler(contextMenu);
        contextMenu.show();
    },

    /**
     * @override
     * @param {!Event} event
     */
    _clicked: function(event)
    {
    },

    __proto__: WebInspector.ToolbarButton.prototype
}

/**
 * @constructor
 * @extends {WebInspector.ToolbarToggle}
 * @param {!WebInspector.Setting} setting
 * @param {string} glyph
 * @param {string} title
 * @param {string=} toggledTitle
 */
WebInspector.ToolbarSettingToggle = function(setting, glyph, title, toggledTitle)
{
    WebInspector.ToolbarToggle.call(this, title, glyph);
    this._defaultTitle = title;
    this._toggledTitle = toggledTitle || title;
    this._setting = setting;
    this._settingChanged();
    this._setting.addChangeListener(this._settingChanged, this);
}

WebInspector.ToolbarSettingToggle.prototype = {
    _settingChanged: function()
    {
        var toggled = this._setting.get();
        this.setToggled(toggled);
        this.setTitle(toggled ? this._toggledTitle : this._defaultTitle);
    },

    /**
     * @override
     * @param {!Event} event
     */
    _clicked: function(event)
    {
        this._setting.set(!this.toggled());
        WebInspector.ToolbarToggle.prototype._clicked.call(this, event);
    },

    __proto__: WebInspector.ToolbarToggle.prototype
}

/**
 * @constructor
 * @extends {WebInspector.ToolbarItem}
 */
WebInspector.ToolbarSeparator = function()
{
    WebInspector.ToolbarItem.call(this, createElementWithClass("div", "toolbar-divider"));
}

WebInspector.ToolbarSeparator.prototype = {
    __proto__: WebInspector.ToolbarItem.prototype
}

/**
 * @interface
 */
WebInspector.ToolbarItem.Provider = function()
{
}

WebInspector.ToolbarItem.Provider.prototype = {
    /**
     * @return {?WebInspector.ToolbarItem}
     */
    item: function() {}
}

/**
 * @constructor
 * @extends {WebInspector.ToolbarItem}
 * @param {?function(!Event)} changeHandler
 * @param {string=} className
 */
WebInspector.ToolbarComboBox = function(changeHandler, className)
{
    WebInspector.ToolbarItem.call(this, createElementWithClass("span", "toolbar-select-container"));

    this._selectElement = this.element.createChild("select", "toolbar-item");
    this.element.createChild("div", "toolbar-dropdown-arrow");
    if (changeHandler)
        this._selectElement.addEventListener("change", changeHandler, false);
    if (className)
        this._selectElement.classList.add(className);
}

WebInspector.ToolbarComboBox.prototype = {
    /**
     * @return {!HTMLSelectElement}
     */
    selectElement: function()
    {
        return /** @type {!HTMLSelectElement} */ (this._selectElement);
    },

    /**
     * @return {number}
     */
    size: function()
    {
        return this._selectElement.childElementCount;
    },

    /**
     * @return {!Array.<!Element>}
     */
    options: function()
    {
        return Array.prototype.slice.call(this._selectElement.children, 0);
    },

    /**
     * @param {!Element} option
     */
    addOption: function(option)
    {
        this._selectElement.appendChild(option);
    },

    /**
     * @param {string} label
     * @param {string=} title
     * @param {string=} value
     * @return {!Element}
     */
    createOption: function(label, title, value)
    {
        var option = this._selectElement.createChild("option");
        option.text = label;
        if (title)
            option.title = title;
        if (typeof value !== "undefined")
            option.value = value;
        return option;
    },

    /**
     * @override
     */
    _applyEnabledState: function()
    {
        this._selectElement.disabled = !this._enabled;
    },

    /**
     * @param {!Element} option
     */
    removeOption: function(option)
    {
        this._selectElement.removeChild(option);
    },

    removeOptions: function()
    {
        this._selectElement.removeChildren();
    },

    /**
     * @return {?Element}
     */
    selectedOption: function()
    {
        if (this._selectElement.selectedIndex >= 0)
            return this._selectElement[this._selectElement.selectedIndex];
        return null;
    },

    /**
     * @param {!Element} option
     */
    select: function(option)
    {
        this._selectElement.selectedIndex = Array.prototype.indexOf.call(/** @type {?} */ (this._selectElement), option);
    },

    /**
     * @param {number} index
     */
    setSelectedIndex: function(index)
    {
        this._selectElement.selectedIndex = index;
    },

    /**
     * @return {number}
     */
    selectedIndex: function()
    {
        return this._selectElement.selectedIndex;
    },

    /**
     * @param {number} width
     */
    setMaxWidth: function(width)
    {
        this._selectElement.style.maxWidth = width + "px";
    },

    __proto__: WebInspector.ToolbarItem.prototype
}

/**
 * @constructor
 * @extends {WebInspector.ToolbarItem}
 * @param {string} text
 * @param {string=} title
 * @param {!WebInspector.Setting=} setting
 */
WebInspector.ToolbarCheckbox = function(text, title, setting)
{
    WebInspector.ToolbarItem.call(this, createCheckboxLabel(text));
    this.element.classList.add("checkbox");
    this.inputElement = this.element.checkboxElement;
    if (title)
        this.element.title = title;
    if (setting)
        WebInspector.SettingsUI.bindCheckbox(this.inputElement, setting);
}

WebInspector.ToolbarCheckbox.prototype = {
    /**
     * @return {boolean}
     */
    checked: function()
    {
        return this.inputElement.checked;
    },

    __proto__: WebInspector.ToolbarItem.prototype
}

/**
 * @constructor
 * @extends {WebInspector.Toolbar}
 * @param {string} location
 * @param {!Element=} parentElement
 */
WebInspector.ExtensibleToolbar = function(location, parentElement)
{
    WebInspector.Toolbar.call(this, "", parentElement);
    this._loadItems(location);
}

WebInspector.ExtensibleToolbar.prototype = {
    /**
     * @param {string} location
     */
    _loadItems: function(location)
    {
        var extensions = self.runtime.extensions(WebInspector.ToolbarItem.Provider);
        var promises = [];
        for (var i = 0; i < extensions.length; ++i) {
            if (extensions[i].descriptor()["location"] === location)
                promises.push(resolveItem(extensions[i]));
        }
        this._promise = Promise.all(promises).then(appendItemsInOrder.bind(this));

        /**
         * @param {!Runtime.Extension} extension
         * @return {!Promise.<?WebInspector.ToolbarItem>}
         */
        function resolveItem(extension)
        {
            var descriptor = extension.descriptor();
            if (descriptor["separator"])
                return Promise.resolve(/** @type {?WebInspector.ToolbarItem} */(new WebInspector.ToolbarSeparator()));
            if (descriptor["actionId"])
                return Promise.resolve(/** @type {?WebInspector.ToolbarItem} */(WebInspector.Toolbar.createActionButton(WebInspector.actionRegistry.action(descriptor["actionId"]))));
            return extension.instancePromise().then(fetchItemFromProvider);

            /**
             * @param {!Object} provider
             */
            function fetchItemFromProvider(provider)
            {
                return /** @type {!WebInspector.ToolbarItem.Provider} */ (provider).item();
            }
        }

        /**
         * @param {!Array.<?WebInspector.ToolbarItem>} items
         * @this {WebInspector.ExtensibleToolbar}
         */
        function appendItemsInOrder(items)
        {
            for (var i = 0; i < items.length; ++i) {
                var item = items[i];
                if (item)
                    this.appendToolbarItem(item);
            }
        }
    },

    /**
     * @return {!Promise}
     */
    onLoad: function()
    {
        return this._promise;
    },

    __proto__: WebInspector.Toolbar.prototype
};/* Tooltip.js */
// Copyright (c) 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {!Document} doc
 */
WebInspector.Tooltip = function(doc)
{
    this.element = doc.body.createChild("div");
    this._shadowRoot = WebInspector.createShadowRootWithCoreStyles(this.element, "ui/tooltip.css");

    this._tooltipElement = this._shadowRoot.createChild("div", "tooltip");
    doc.addEventListener("mousemove", this._mouseMove.bind(this), true);
    doc.addEventListener("mousedown", this._hide.bind(this, true), true);
    doc.addEventListener("mouseleave", this._hide.bind(this, false), true);
    doc.addEventListener("keydown", this._hide.bind(this, true), true);
    WebInspector.zoomManager.addEventListener(WebInspector.ZoomManager.Events.ZoomChanged, this._reset, this);
    doc.defaultView.addEventListener("resize", this._reset.bind(this), false);
}

WebInspector.Tooltip.Timing = {
    // Max time between tooltips showing that no opening delay is required.
    "InstantThreshold": 300,
    // Wait time before opening a tooltip.
    "OpeningDelay": 600
}

WebInspector.Tooltip.prototype = {
    /**
     * @param {!Event} event
     */
    _mouseMove: function(event)
    {
        var path = event.path;
        if (!path || event.buttons !== 0)
            return;

        if (this._anchorElement && path.indexOf(this._anchorElement) === -1)
            this._hide(false);

        for (var element of path) {
            if (element === this._anchorElement) {
                return;
            } else if (element[WebInspector.Tooltip._symbol]) {
                this._show(element, event);
                return;
            }
        }
    },

    /**
     * @param {!Element} anchorElement
     * @param {!Event} event
     */
    _show: function(anchorElement, event)
    {
        var tooltip = anchorElement[WebInspector.Tooltip._symbol];
        this._anchorElement = anchorElement;
        this._tooltipElement.removeChildren();

        // Check if native tooltips should be used.
        for (var element of WebInspector.Tooltip._nativeOverrideContainer) {
            if (this._anchorElement.isSelfOrDescendant(element)) {
                Object.defineProperty(this._anchorElement, "title", WebInspector.Tooltip._nativeTitle);
                this._anchorElement.title = tooltip.content;
                return;
            }
        }

        if (typeof tooltip.content === "string")
            this._tooltipElement.textContent = tooltip.content;
        else
            this._tooltipElement.appendChild(tooltip.content);

        if (tooltip.actionId) {
            var shortcuts = WebInspector.shortcutRegistry.shortcutDescriptorsForAction(tooltip.actionId);
            for (var shortcut of shortcuts) {
                var shortcutElement = this._tooltipElement.createChild("div", "tooltip-shortcut");
                shortcutElement.textContent = shortcut.name;
            }
        }

        this._tooltipElement.classList.add("shown");
        // Reposition to ensure text doesn't overflow unnecessarily.
        this._tooltipElement.positionAt(0, 0);

        // Show tooltip instantly if a tooltip was shown recently.
        var now = Date.now();
        var instant = (this._tooltipLastClosed && now - this._tooltipLastClosed < WebInspector.Tooltip.Timing.InstantThreshold);
        this._tooltipElement.classList.toggle("instant", instant);
        this._tooltipLastOpened = instant ? now : now + WebInspector.Tooltip.Timing.OpeningDelay;

        // Get container element.
        var container = WebInspector.Dialog.modalHostView().element;
        if (!anchorElement.isDescendant(container))
            container = this.element.parentElement;

        // Posititon tooltip based on the anchor element.
        var containerOffset = container.offsetRelativeToWindow(this.element.window());
        var containerOffsetWidth = container.offsetWidth;
        var containerOffsetHeight = container.offsetHeight;
        var anchorBox = this._anchorElement.boxInWindow(this.element.window());
        const anchorOffset = 2;
        const pageMargin = 2;
        var cursorOffset = 10;
        this._tooltipElement.style.maxWidth = (containerOffsetWidth - pageMargin * 2) + "px";
        this._tooltipElement.style.maxHeight = "";
        var tooltipWidth = this._tooltipElement.offsetWidth;
        var tooltipHeight = this._tooltipElement.offsetHeight;
        var anchorTooltipAtElement = this._anchorElement.nodeName === "BUTTON" || this._anchorElement.nodeName === "LABEL";
        var tooltipX = anchorTooltipAtElement ? anchorBox.x : event.x + cursorOffset;
        tooltipX = Number.constrain(tooltipX,
            containerOffset.x + pageMargin,
            containerOffset.x + containerOffsetWidth - tooltipWidth - pageMargin);
        var tooltipY;
        if (!anchorTooltipAtElement) {
            tooltipY = event.y + cursorOffset + tooltipHeight < containerOffset.y + containerOffsetHeight ? event.y + cursorOffset : event.y - tooltipHeight;
        } else {
            var onBottom = anchorBox.y + anchorOffset + anchorBox.height + tooltipHeight < containerOffset.y + containerOffsetHeight;
            tooltipY = onBottom ? anchorBox.y + anchorBox.height + anchorOffset : anchorBox.y - tooltipHeight - anchorOffset;
        }
        this._tooltipElement.positionAt(tooltipX, tooltipY);
    },

    /**
     * @param {boolean} removeInstant
     */
    _hide: function(removeInstant)
    {
        delete this._anchorElement;
        this._tooltipElement.classList.remove("shown");
        if (Date.now() > this._tooltipLastOpened)
            this._tooltipLastClosed = Date.now();
        if (removeInstant)
            delete this._tooltipLastClosed;
    },

    _reset: function()
    {
        this._hide(true);
        this._tooltipElement.positionAt(0, 0);
        this._tooltipElement.style.maxWidth = "0";
        this._tooltipElement.style.maxHeight = "0";
    }
}

WebInspector.Tooltip._symbol = Symbol("Tooltip");

/**
 * @param {!Document} doc
 */
WebInspector.Tooltip.installHandler = function(doc)
{
    new WebInspector.Tooltip(doc);
}

/**
 * @param {!Element} element
 * @param {!Element|string} tooltipContent
 * @param {string=} actionId
 * @param {!Object=} options
 */
WebInspector.Tooltip.install = function(element, tooltipContent, actionId, options)
{
    if (typeof tooltipContent === "string" && tooltipContent === "") {
        delete element[WebInspector.Tooltip._symbol];
        return;
    }
    element[WebInspector.Tooltip._symbol] = { content: tooltipContent, actionId: actionId, options: options || {} };
}

/**
 * @param {!Element} element
 */
WebInspector.Tooltip.addNativeOverrideContainer = function(element)
{
    WebInspector.Tooltip._nativeOverrideContainer.push(element);
}

/** @type {!Array.<!Element>} */
WebInspector.Tooltip._nativeOverrideContainer = [];
WebInspector.Tooltip._nativeTitle = /** @type {!ObjectPropertyDescriptor} */(Object.getOwnPropertyDescriptor(HTMLElement.prototype, "title"));

Object.defineProperty(HTMLElement.prototype, "title", {
    /**
     * @return {!Element|string}
     * @this {!Element}
     */
    get: function()
    {
        var tooltip = this[WebInspector.Tooltip._symbol];
        return tooltip ? tooltip.content : "";
    },

    /**
     * @param {!Element|string} x
     * @this {!Element}
     */
    set: function(x)
    {
        WebInspector.Tooltip.install(this, x);
    }
});
;/* SuggestBox.js */
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @interface
 */
WebInspector.SuggestBoxDelegate = function()
{
}

WebInspector.SuggestBoxDelegate.prototype = {
    /**
     * @param {string} suggestion
     * @param {boolean=} isIntermediateSuggestion
     */
    applySuggestion: function(suggestion, isIntermediateSuggestion) { },

    /**
     * acceptSuggestion will be always called after call to applySuggestion with isIntermediateSuggestion being equal to false.
     */
    acceptSuggestion: function() { },
}

/**
 * @constructor
 * @param {!WebInspector.SuggestBoxDelegate} suggestBoxDelegate
 * @param {number=} maxItemsHeight
 */
WebInspector.SuggestBox = function(suggestBoxDelegate, maxItemsHeight)
{
    this._suggestBoxDelegate = suggestBoxDelegate;
    this._length = 0;
    this._selectedIndex = -1;
    this._selectedElement = null;
    this._maxItemsHeight = maxItemsHeight;
    this._maybeHideBound = this._maybeHide.bind(this);
    this._container = createElementWithClass("div", "suggest-box-container");
    this._element = this._container.createChild("div", "suggest-box");
    this._element.addEventListener("mousedown", this._onBoxMouseDown.bind(this), true);
    this._detailsPopup = this._container.createChild("div", "suggest-box details-popup monospace");
    this._detailsPopup.classList.add("hidden");
    this._asyncDetailsCallback = null;
    this._asyncDetailsPromises = /** @type {!Map<number, !Promise>} */ ({});
}

/**
 * @typedef Array.<{title: string, className: (string|undefined)}>
 */
WebInspector.SuggestBox.Suggestions;

WebInspector.SuggestBox.prototype = {
    /**
     * @return {boolean}
     */
    visible: function()
    {
        return !!this._container.parentElement;
    },

    /**
     * @param {!AnchorBox} anchorBox
     */
    setPosition: function(anchorBox)
    {
        this._updateBoxPosition(anchorBox);
    },

    /**
     * @param {!AnchorBox} anchorBox
     */
    _updateBoxPosition: function(anchorBox)
    {
        console.assert(this._overlay);
        if (this._lastAnchorBox && this._lastAnchorBox.equals(anchorBox))
            return;
        this._lastAnchorBox = anchorBox;

        // Position relative to main DevTools element.
        var container = WebInspector.Dialog.modalHostView().element;
        anchorBox = anchorBox.relativeToElement(container);
        var totalHeight = container.offsetHeight;
        var aboveHeight = anchorBox.y;
        var underHeight = totalHeight - anchorBox.y - anchorBox.height;

        this._overlay.setLeftOffset(anchorBox.x);

        var under = underHeight >= aboveHeight;
        if (under)
            this._overlay.setVerticalOffset(anchorBox.y + anchorBox.height, true);
        else
            this._overlay.setVerticalOffset(totalHeight - anchorBox.y, false);

        /** const */ var rowHeight = 17;
        /** const */ var spacer = 6;
        var maxHeight = this._maxItemsHeight ? this._maxItemsHeight * rowHeight : Math.max(underHeight, aboveHeight) - spacer;
        this._element.style.maxHeight = maxHeight + "px";
    },

    /**
     * @param {!Event} event
     */
    _onBoxMouseDown: function(event)
    {
        if (this._hideTimeoutId) {
            window.clearTimeout(this._hideTimeoutId);
            delete this._hideTimeoutId;
        }
        event.preventDefault();
    },

    _maybeHide: function()
    {
        if (!this._hideTimeoutId)
            this._hideTimeoutId = window.setTimeout(this.hide.bind(this), 0);
    },

    /**
     * // FIXME: make SuggestBox work for multiple documents.
     * @suppressGlobalPropertiesCheck
     */
    _show: function()
    {
        if (this.visible())
            return;
        this._bodyElement = document.body;
        this._bodyElement.addEventListener("mousedown", this._maybeHideBound, true);
        this._overlay = new WebInspector.SuggestBox.Overlay();
        this._overlay.setContentElement(this._container);
    },

    hide: function()
    {
        if (!this.visible())
            return;

        this._bodyElement.removeEventListener("mousedown", this._maybeHideBound, true);
        delete this._bodyElement;
        this._container.remove();
        this._overlay.dispose();
        delete this._overlay;
        delete this._selectedElement;
        this._selectedIndex = -1;
        delete this._lastAnchorBox;
    },

    removeFromElement: function()
    {
        this.hide();
    },

    /**
     * @param {boolean=} isIntermediateSuggestion
     */
    _applySuggestion: function(isIntermediateSuggestion)
    {
        if (!this.visible() || !this._selectedElement)
            return false;

        var suggestion = this._selectedElement.__fullValue;
        if (!suggestion)
            return false;

        this._suggestBoxDelegate.applySuggestion(suggestion, isIntermediateSuggestion);
        return true;
    },

    /**
     * @return {boolean}
     */
    acceptSuggestion: function()
    {
        var result = this._applySuggestion();
        this.hide();
        if (!result)
            return false;

        this._suggestBoxDelegate.acceptSuggestion();

        return true;
    },

    /**
     * @param {number} shift
     * @param {boolean=} isCircular
     * @return {boolean} is changed
     */
    _selectClosest: function(shift, isCircular)
    {
        if (!this._length)
            return false;

        if (this._selectedIndex === -1 && shift < 0)
            shift += 1;

        var index = this._selectedIndex + shift;

        if (isCircular)
            index = (this._length + index) % this._length;
        else
            index = Number.constrain(index, 0, this._length - 1);

        this._selectItem(index, true);
        this._applySuggestion(true);
        return true;
    },

    /**
     * @param {!Event} event
     */
    _onItemMouseDown: function(event)
    {
        this._selectedElement = event.currentTarget;
        this.acceptSuggestion();
        event.consume(true);
    },

    /**
     * @param {string} prefix
     * @param {string} text
     * @param {string|undefined} className
     * @param {number} index
     */
    _createItemElement: function(prefix, text, className, index)
    {
        var element = createElementWithClass("div", "suggest-box-content-item source-code " + (className || ""));
        element.tabIndex = -1;
        if (prefix && prefix.length && !text.indexOf(prefix)) {
            element.createChild("span", "prefix").textContent = prefix;
            element.createChild("span", "suffix").textContent = text.substring(prefix.length).trimEnd(50);
        } else {
            element.createChild("span", "suffix").textContent = text.trimEnd(50);
        }
        element.__fullValue = text;
        element.createChild("span", "spacer");
        element.addEventListener("mousedown", this._onItemMouseDown.bind(this), false);
        return element;
    },

    /**
     * @param {!WebInspector.SuggestBox.Suggestions} items
     * @param {string} userEnteredText
     * @param {function(number): !Promise<{detail:string, description:string}>=} asyncDetails
     */
    _updateItems: function(items, userEnteredText, asyncDetails)
    {
        this._length = items.length;
        this._asyncDetailsPromises = {};
        this._asyncDetailsCallback = asyncDetails;
        this._element.removeChildren();
        delete this._selectedElement;

        for (var i = 0; i < items.length; ++i) {
            var item = items[i];
            var currentItemElement = this._createItemElement(userEnteredText, item.title, item.className, i);
            this._element.appendChild(currentItemElement);
        }
    },

    /**
     * @param {number} index
     * @return {!Promise<({detail: string, description: string}|undefined)>}
     */
    _asyncDetails: function(index)
    {
        if (!this._asyncDetailsCallback)
            return Promise.resolve();
        if (!this._asyncDetailsPromises[index])
            this._asyncDetailsPromises[index] = this._asyncDetailsCallback(index);
        return this._asyncDetailsPromises[index];
    },

    /**
     * @param {{detail: string, description: string}=} details
     */
    _showDetailsPopup: function(details)
    {
        this._detailsPopup.removeChildren();
        if (!details)
            return;
        this._detailsPopup.createChild("section", "detail").createTextChild(details.detail);
        this._detailsPopup.createChild("section", "description").createTextChild(details.description);
        this._detailsPopup.classList.remove("hidden");
    },

    /**
     * @param {number} index
     * @param {boolean} scrollIntoView
     */
    _selectItem: function(index, scrollIntoView)
    {
        if (this._selectedElement)
            this._selectedElement.classList.remove("selected");

        this._selectedIndex = index;
        if (index < 0)
            return;

        this._selectedElement = this._element.children[index];
        this._selectedElement.classList.add("selected");
        this._detailsPopup.classList.add("hidden");
        var elem = this._selectedElement;
        this._asyncDetails(index).then(showDetails.bind(this), function(){});

        if (scrollIntoView)
            this._selectedElement.scrollIntoViewIfNeeded(false);

        /**
         * @param {{detail: string, description: string}=} details
         * @this {WebInspector.SuggestBox}
         */
        function showDetails(details)
        {
            if (elem === this._selectedElement)
                this._showDetailsPopup(details);
        }
    },

    /**
     * @param {!WebInspector.SuggestBox.Suggestions} completions
     * @param {boolean} canShowForSingleItem
     * @param {string} userEnteredText
     */
    _canShowBox: function(completions, canShowForSingleItem, userEnteredText)
    {
        if (!completions || !completions.length)
            return false;

        if (completions.length > 1)
            return true;

        // Do not show a single suggestion if it is the same as user-entered prefix, even if allowed to show single-item suggest boxes.
        return canShowForSingleItem && completions[0].title !== userEnteredText;
    },

    _ensureRowCountPerViewport: function()
    {
        if (this._rowCountPerViewport)
            return;
        if (!this._element.firstChild)
            return;

        this._rowCountPerViewport = Math.floor(this._element.offsetHeight / this._element.firstChild.offsetHeight);
    },

    /**
     * @param {!AnchorBox} anchorBox
     * @param {!WebInspector.SuggestBox.Suggestions} completions
     * @param {number} selectedIndex
     * @param {boolean} canShowForSingleItem
     * @param {string} userEnteredText
     * @param {function(number): !Promise<{detail:string, description:string}>=} asyncDetails
     */
    updateSuggestions: function(anchorBox, completions, selectedIndex, canShowForSingleItem, userEnteredText, asyncDetails)
    {
        if (this._canShowBox(completions, canShowForSingleItem, userEnteredText)) {
            this._updateItems(completions, userEnteredText, asyncDetails);
            this._show();
            this._updateBoxPosition(anchorBox);
            this._selectItem(selectedIndex, selectedIndex > 0);
            delete this._rowCountPerViewport;
        } else
            this.hide();
    },

    /**
     * @param {!KeyboardEvent} event
     * @return {boolean}
     */
    keyPressed: function(event)
    {
        switch (event.keyIdentifier) {
        case "Up":
            return this.upKeyPressed();
        case "Down":
            return this.downKeyPressed();
        case "PageUp":
            return this.pageUpKeyPressed();
        case "PageDown":
            return this.pageDownKeyPressed();
        case "Enter":
            return this.enterKeyPressed();
        }
        return false;
    },

    /**
     * @return {boolean}
     */
    upKeyPressed: function()
    {
        return this._selectClosest(-1, true);
    },

    /**
     * @return {boolean}
     */
    downKeyPressed: function()
    {
        return this._selectClosest(1, true);
    },

    /**
     * @return {boolean}
     */
    pageUpKeyPressed: function()
    {
        this._ensureRowCountPerViewport();
        return this._selectClosest(-this._rowCountPerViewport, false);
    },

    /**
     * @return {boolean}
     */
    pageDownKeyPressed: function()
    {
        this._ensureRowCountPerViewport();
        return this._selectClosest(this._rowCountPerViewport, false);
    },

    /**
     * @return {boolean}
     */
    enterKeyPressed: function()
    {
        var hasSelectedItem = !!this._selectedElement;
        this.acceptSuggestion();

        // Report the event as non-handled if there is no selected item,
        // to commit the input or handle it otherwise.
        return hasSelectedItem;
    }
}

/**
 * @constructor
 * // FIXME: make SuggestBox work for multiple documents.
 * @suppressGlobalPropertiesCheck
 */
WebInspector.SuggestBox.Overlay = function()
{
    this.element = createElementWithClass("div", "suggest-box-overlay");
    var root = WebInspector.createShadowRootWithCoreStyles(this.element, "ui/suggestBox.css");
    this._leftSpacerElement = root.createChild("div", "suggest-box-left-spacer");
    this._horizontalElement = root.createChild("div", "suggest-box-horizontal");
    this._topSpacerElement = this._horizontalElement.createChild("div", "suggest-box-top-spacer");
    this._bottomSpacerElement = this._horizontalElement.createChild("div", "suggest-box-bottom-spacer");
    this._resize();
    document.body.appendChild(this.element);
}

WebInspector.SuggestBox.Overlay.prototype = {
    /**
     * @param {number} offset
     */
    setLeftOffset: function(offset)
    {
        this._leftSpacerElement.style.flexBasis = offset + "px";
    },

    /**
     * @param {number} offset
     * @param {boolean} isTopOffset
     */
    setVerticalOffset: function(offset, isTopOffset)
    {
        this.element.classList.toggle("under-anchor", isTopOffset);

        if (isTopOffset) {
            this._bottomSpacerElement.style.flexBasis = "auto";
            this._topSpacerElement.style.flexBasis = offset + "px";
        } else {
            this._bottomSpacerElement.style.flexBasis = offset + "px";
            this._topSpacerElement.style.flexBasis = "auto";
        }
    },

    /**
     * @param {!Element} element
     */
    setContentElement: function(element)
    {
        this._horizontalElement.insertBefore(element, this._bottomSpacerElement);
    },

    _resize: function()
    {
        var container = WebInspector.Dialog.modalHostView().element;
        var containerBox = container.boxInWindow(container.ownerDocument.defaultView);

        this.element.style.left = containerBox.x + "px";
        this.element.style.top = containerBox.y + "px";
        this.element.style.height = containerBox.height + "px";
        this.element.style.width = containerBox.width + "px";
    },

    dispose: function()
    {
        this.element.remove();
    }
}
;/* TabbedPane.js */
/*
 * Copyright (C) 2010 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @extends {WebInspector.VBox}
 * @constructor
 */
WebInspector.TabbedPane = function()
{
    WebInspector.VBox.call(this, true);
    this.registerRequiredCSS("ui/tabbedPane.css");
    this.element.classList.add("tabbed-pane");
    this.contentElement.classList.add("tabbed-pane-shadow");
    this.contentElement.tabIndex = -1;
    this._headerElement = this.contentElement.createChild("div", "tabbed-pane-header");
    this._headerElement.createChild("content").select = ".tabbed-pane-header-before";
    this._headerContentsElement = this._headerElement.createChild("div", "tabbed-pane-header-contents");
    this._tabSlider = createElementWithClass("div", "tabbed-pane-tab-slider");
    this._headerElement.createChild("content").select = ".tabbed-pane-header-after";
    this._tabsElement = this._headerContentsElement.createChild("div", "tabbed-pane-header-tabs");
    this._contentElement = this.contentElement.createChild("div", "tabbed-pane-content");
    this._contentElement.createChild("content");
    /** @type {!Array.<!WebInspector.TabbedPaneTab>} */
    this._tabs = [];
    /** @type {!Array.<!WebInspector.TabbedPaneTab>} */
    this._tabsHistory = [];
    /** @type {!Object.<string, !WebInspector.TabbedPaneTab>} */
    this._tabsById = {};
    this._currentTabLocked = false;

    this._dropDownButton = this._createDropDownButton();
    WebInspector.zoomManager.addEventListener(WebInspector.ZoomManager.Events.ZoomChanged, this._zoomChanged, this);
}

WebInspector.TabbedPane.EventTypes = {
    TabSelected: "TabSelected",
    TabClosed: "TabClosed",
    TabOrderChanged: "TabOrderChanged"
}

WebInspector.TabbedPane.prototype = {
    /**
     * @param {boolean} locked
     */
    setCurrentTabLocked: function(locked)
    {
        this._currentTabLocked = locked;
        this._headerElement.classList.toggle("locked", this._currentTabLocked);
    },

    /**
     * @return {?WebInspector.Widget}
     */
    get visibleView()
    {
        return this._currentTab ? this._currentTab.view : null;
    },

    /**
     * @return {!Array.<!WebInspector.Widget>}
     */
    tabViews: function()
    {
        /**
         * @param {!WebInspector.TabbedPaneTab} tab
         * @return {!WebInspector.Widget}
         */
        function tabToView(tab)
        {
            return tab.view;
        }
        return this._tabs.map(tabToView);
    },

    /**
     * @return {?string}
     */
    get selectedTabId()
    {
        return this._currentTab ? this._currentTab.id : null;
    },

    /**
     * @param {boolean} shrinkableTabs
     */
    setShrinkableTabs: function(shrinkableTabs)
    {
        this._shrinkableTabs = shrinkableTabs;
    },

    /**
     * @param {boolean} verticalTabLayout
     */
    setVerticalTabLayout: function(verticalTabLayout)
    {
        this._verticalTabLayout = verticalTabLayout;
        this.contentElement.classList.add("vertical-tab-layout");
        this.invalidateConstraints();
    },

    /**
     * @param {boolean} closeableTabs
     */
    setCloseableTabs: function(closeableTabs)
    {
        this._closeableTabs = closeableTabs;
    },

    /**
     * @override
     * @return {!Element}
     */
    defaultFocusedElement: function()
    {
        return this.visibleView ? this.visibleView.defaultFocusedElement() : this.contentElement;
    },

    focus: function()
    {
        if (this.visibleView)
            this.visibleView.focus();
        else
            this.contentElement.focus();
    },

    /**
     * @return {!Element}
     */
    headerElement: function()
    {
        return this._headerElement;
    },

    /**
     * @param {string} id
     * @return {boolean}
     */
    isTabCloseable: function(id)
    {
        var tab = this._tabsById[id];
        return tab ? tab.isCloseable() : false;
    },

    /**
     * @param {!WebInspector.TabbedPaneTabDelegate} delegate
     */
    setTabDelegate: function(delegate)
    {
        var tabs = this._tabs.slice();
        for (var i = 0; i < tabs.length; ++i)
            tabs[i].setDelegate(delegate);
        this._delegate = delegate;
    },

    /**
     * @param {string} id
     * @param {string} tabTitle
     * @param {!WebInspector.Widget} view
     * @param {string=} tabTooltip
     * @param {boolean=} userGesture
     * @param {boolean=} isCloseable
     * @param {number=} index
     */
    appendTab: function(id, tabTitle, view, tabTooltip, userGesture, isCloseable, index)
    {
        isCloseable = typeof isCloseable === "boolean" ? isCloseable : this._closeableTabs;
        var tab = new WebInspector.TabbedPaneTab(this, id, tabTitle, isCloseable, view, tabTooltip);
        tab.setDelegate(this._delegate);
        this._tabsById[id] = tab;
        if (index !== undefined)
            this._tabs.splice(index, 0, tab);
        else
            this._tabs.push(tab);
        this._tabsHistory.push(tab);
        if (this._tabsHistory[0] === tab && this.isShowing())
            this.selectTab(tab.id, userGesture);
        this._updateTabElements();
    },

    /**
     * @param {string} id
     * @param {boolean=} userGesture
     */
    closeTab: function(id, userGesture)
    {
        this.closeTabs([id], userGesture);
    },

    /**
     * @param {!Array.<string>} ids
     * @param {boolean=} userGesture
     */
    closeTabs: function(ids, userGesture)
    {
        var focused = this.hasFocus();
        for (var i = 0; i < ids.length; ++i)
            this._innerCloseTab(ids[i], userGesture);
        this._updateTabElements();
        if (this._tabsHistory.length)
            this.selectTab(this._tabsHistory[0].id, false);
        if (focused)
            this.focus();
    },

    /**
     * @param {string} id
     * @param {boolean=} userGesture
     */
    _innerCloseTab: function(id, userGesture)
    {
        if (!this._tabsById[id])
            return;
        if (userGesture && !this._tabsById[id]._closeable)
            return;
        if (this._currentTab && this._currentTab.id === id)
            this._hideCurrentTab();

        var tab = this._tabsById[id];
        delete this._tabsById[id];

        this._tabsHistory.splice(this._tabsHistory.indexOf(tab), 1);
        this._tabs.splice(this._tabs.indexOf(tab), 1);
        if (tab._shown)
            this._hideTabElement(tab);

        var eventData = { tabId: id, view: tab.view, isUserGesture: userGesture };
        this.dispatchEventToListeners(WebInspector.TabbedPane.EventTypes.TabClosed, eventData);
        return true;
    },

    /**
     * @param {string} tabId
     * @return {boolean}
     */
    hasTab: function(tabId)
    {
        return !!this._tabsById[tabId];
    },

    /**
     * @return {!Array.<string>}
     */
    allTabs: function()
    {
        return this._tabs.map(function (tab) { return tab.id; });
    },

    /**
     * @param {string} id
     * @return {!Array.<string>}
     */
    otherTabs: function(id)
    {
        var result = [];
        for (var i = 0; i < this._tabs.length; ++i) {
            if (this._tabs[i].id !== id)
                result.push(this._tabs[i].id);
        }
        return result;
    },

    /**
     * @param {string} id
     * @return {!Array.<string>}
     */
    _tabsToTheRight: function(id)
    {
        var index = -1;
        for (var i = 0; i < this._tabs.length; ++i) {
            if (this._tabs[i].id === id) {
                index = i;
                break;
            }
        }
        if (index === -1)
            return [];
        return this._tabs.slice(index + 1).map(function (tab) { return tab.id; });
    },

    /**
     * @param {string} id
     * @param {boolean=} userGesture
     * @return {boolean}
     */
    selectTab: function(id, userGesture)
    {
        if (this._currentTabLocked)
            return false;
        var focused = this.hasFocus();
        var tab = this._tabsById[id];
        if (!tab)
            return false;
        if (this._currentTab && this._currentTab.id === id)
            return true;

        this._hideCurrentTab();
        this._showTab(tab);
        this._currentTab = tab;

        this._tabsHistory.splice(this._tabsHistory.indexOf(tab), 1);
        this._tabsHistory.splice(0, 0, tab);

        this._updateTabElements();
        if (focused)
            this.focus();

        var eventData = { tabId: id, view: tab.view, isUserGesture: userGesture };
        this.dispatchEventToListeners(WebInspector.TabbedPane.EventTypes.TabSelected, eventData);
        return true;
    },

    /**
     * @param {number} tabsCount
     * @return {!Array.<string>}
     */
    lastOpenedTabIds: function(tabsCount)
    {
        function tabToTabId(tab) {
            return tab.id;
        }

        return this._tabsHistory.slice(0, tabsCount).map(tabToTabId);
    },

    /**
     * @param {string} id
     * @param {string} iconType
     * @param {string=} iconTooltip
     */
    setTabIcon: function(id, iconType, iconTooltip)
    {
        var tab = this._tabsById[id];
        if (tab._setIconType(iconType, iconTooltip))
            this._updateTabElements();
    },

    /**
     * @param {string} id
     * @param {string} className
     * @param {boolean=} force
     */
    toggleTabClass: function(id, className, force)
    {
        var tab = this._tabsById[id];
        if (tab._toggleClass(className, force))
            this._updateTabElements();
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _zoomChanged: function(event)
    {
        for (var i = 0; i < this._tabs.length; ++i)
            delete this._tabs[i]._measuredWidth;
        if (this.isShowing())
            this._updateTabElements();
    },

    /**
     * @param {string} id
     * @param {string} tabTitle
     */
    changeTabTitle: function(id, tabTitle)
    {
        var tab = this._tabsById[id];
        if (tab.title === tabTitle)
            return;
        tab.title = tabTitle;
        this._updateTabElements();
    },

    /**
     * @param {string} id
     * @param {!WebInspector.Widget} view
     */
    changeTabView: function(id, view)
    {
        var tab = this._tabsById[id];
        if (this._currentTab && this._currentTab.id === tab.id) {
            if (tab.view !== view)
                this._hideTab(tab);
            tab.view = view;
            this._showTab(tab);
        } else
            tab.view = view;
    },

    onResize: function()
    {
        this._updateTabElements();
    },

    headerResized: function()
    {
        this._updateTabElements();
    },

    wasShown: function()
    {
        var effectiveTab = this._currentTab || this._tabsHistory[0];
        if (effectiveTab)
            this.selectTab(effectiveTab.id);
    },

    /**
     * @param {boolean} enable
     */
    setTabSlider: function(enable)
    {
        this._sliderEnabled = enable;
        this._tabSlider.classList.toggle("enabled", enable);
    },

    /**
     * @override
     * @return {!Constraints}
     */
    calculateConstraints: function()
    {
        var constraints = WebInspector.VBox.prototype.calculateConstraints.call(this);
        var minContentConstraints = new Constraints(new Size(0, 0), new Size(50, 50));
        constraints = constraints.widthToMax(minContentConstraints).heightToMax(minContentConstraints);
        if (this._verticalTabLayout)
            constraints = constraints.addWidth(new Constraints(new Size(120, 0)));
        else
            constraints = constraints.addHeight(new Constraints(new Size(0, 30)));
        return constraints;
    },

    _updateTabElements: function()
    {
        WebInspector.invokeOnceAfterBatchUpdate(this, this._innerUpdateTabElements);
    },

    /**
     * @param {string} text
     */
    setPlaceholderText: function(text)
    {
        this._noTabsMessage = text;
    },

    _innerUpdateTabElements: function()
    {
        if (!this.isShowing())
            return;

        if (!this._tabs.length) {
            this._contentElement.classList.add("has-no-tabs");
            if (this._noTabsMessage && !this._noTabsMessageElement) {
                this._noTabsMessageElement = this._contentElement.createChild("div", "tabbed-pane-placeholder fill");
                this._noTabsMessageElement.textContent = this._noTabsMessage;
            }
        } else {
            this._contentElement.classList.remove("has-no-tabs");
            if (this._noTabsMessageElement) {
                this._noTabsMessageElement.remove();
                delete this._noTabsMessageElement;
            }
        }

        this._measureDropDownButton();
        this._updateWidths();
        this._updateTabsDropDown();
        this._updateTabSlider();
    },

    /**
     * @param {number} index
     * @param {!WebInspector.TabbedPaneTab} tab
     */
    _showTabElement: function(index, tab)
    {
        if (index >= this._tabsElement.children.length)
            this._tabsElement.appendChild(tab.tabElement);
        else
            this._tabsElement.insertBefore(tab.tabElement, this._tabsElement.children[index]);
        tab._shown = true;
    },

    /**
     * @param {!WebInspector.TabbedPaneTab} tab
     */
    _hideTabElement: function(tab)
    {
        this._tabsElement.removeChild(tab.tabElement);
        tab._shown = false;
    },

    _createDropDownButton: function()
    {
        var dropDownContainer = createElementWithClass("div", "tabbed-pane-header-tabs-drop-down-container");
        dropDownContainer.createChild("div", "glyph");
        this._dropDownMenu = new WebInspector.DropDownMenu(dropDownContainer);
        this._dropDownMenu.addEventListener(WebInspector.DropDownMenu.Events.ItemSelected, this._dropDownMenuItemSelected, this);

        return dropDownContainer;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _dropDownMenuItemSelected: function(event)
    {
        var tabId = /** @type {string} */ (event.data);
        this._lastSelectedOverflowTab = this._tabsById[tabId];
        this.selectTab(tabId, true);
    },

    _totalWidth: function()
    {
        return this._headerContentsElement.getBoundingClientRect().width;
    },

    /**
     * @return {number}
     */
    _numberOfTabsShown: function()
    {
        var numTabsShown = 0;
        for (var tab of this._tabs) {
            if (tab._shown)
                numTabsShown++;
        }
        return numTabsShown;
    },

    disableOverflowMenu: function()
    {
        this._overflowDisabled = true;
    },

    _updateTabsDropDown: function()
    {
        var tabsToShowIndexes = this._tabsToShowIndexes(this._tabs, this._tabsHistory, this._totalWidth(), this._measuredDropDownButtonWidth || 0);
        if (this._lastSelectedOverflowTab && this._numberOfTabsShown() !== tabsToShowIndexes.length) {
            delete this._lastSelectedOverflowTab;
            this._updateTabsDropDown();
            return;
        }

        for (var i = 0; i < this._tabs.length; ++i) {
            if (this._tabs[i]._shown && tabsToShowIndexes.indexOf(i) === -1)
                this._hideTabElement(this._tabs[i]);
        }
        for (var i = 0; i < tabsToShowIndexes.length; ++i) {
            var tab = this._tabs[tabsToShowIndexes[i]];
            if (!tab._shown)
                this._showTabElement(i, tab);
        }

        if (!this._overflowDisabled)
            this._populateDropDownFromIndex();
    },

    _populateDropDownFromIndex: function()
    {
        if (this._dropDownButton.parentElement)
            this._headerContentsElement.removeChild(this._dropDownButton);

        this._dropDownMenu.clear();

        var tabsToShow = [];
        for (var i = 0; i < this._tabs.length; ++i) {
            if (!this._tabs[i]._shown)
                tabsToShow.push(this._tabs[i]);
        }

        var selectedId = null;
        for (var i = 0; i < tabsToShow.length; ++i) {
            var tab = tabsToShow[i];
            this._dropDownMenu.addItem(tab.id, tab.title);
            if (this._tabsHistory[0] === tab)
                selectedId = tab.id;
        }
        if (tabsToShow.length) {
            this._headerContentsElement.appendChild(this._dropDownButton);
            this._dropDownMenu.selectItem(selectedId);
        }
    },

    _measureDropDownButton: function()
    {
        if (this._overflowDisabled || this._measuredDropDownButtonWidth)
            return;
        this._dropDownButton.classList.add("measuring");
        this._headerContentsElement.appendChild(this._dropDownButton);
        this._measuredDropDownButtonWidth = this._dropDownButton.getBoundingClientRect().width;
        this._headerContentsElement.removeChild(this._dropDownButton);
        this._dropDownButton.classList.remove("measuring");
    },

    _updateWidths: function()
    {
        var measuredWidths = this._measureWidths();
        var maxWidth = this._shrinkableTabs ? this._calculateMaxWidth(measuredWidths.slice(), this._totalWidth()) : Number.MAX_VALUE;

        var i = 0;
        for (var tabId in this._tabs) {
            var tab = this._tabs[tabId];
            tab.setWidth(this._verticalTabLayout ? -1 : Math.min(maxWidth, measuredWidths[i++]));
        }
    },

    _measureWidths: function()
    {
        // Add all elements to measure into this._tabsElement
        this._tabsElement.style.setProperty("width", "2000px");
        var measuringTabElements = [];
        for (var tabId in this._tabs) {
            var tab = this._tabs[tabId];
            if (typeof tab._measuredWidth === "number")
                continue;
            var measuringTabElement = tab._createTabElement(true);
            measuringTabElement.__tab = tab;
            measuringTabElements.push(measuringTabElement);
            this._tabsElement.appendChild(measuringTabElement);
        }

        // Perform measurement
        for (var i = 0; i < measuringTabElements.length; ++i) {
            var width = measuringTabElements[i].getBoundingClientRect().width;
            measuringTabElements[i].__tab._measuredWidth = Math.ceil(width);
        }

        // Nuke elements from the UI
        for (var i = 0; i < measuringTabElements.length; ++i)
            measuringTabElements[i].remove();

        // Combine the results.
        var measuredWidths = [];
        for (var tabId in this._tabs)
            measuredWidths.push(this._tabs[tabId]._measuredWidth);
        this._tabsElement.style.removeProperty("width");

        return measuredWidths;
    },

    /**
     * @param {!Array.<number>} measuredWidths
     * @param {number} totalWidth
     */
    _calculateMaxWidth: function(measuredWidths, totalWidth)
    {
        if (!measuredWidths.length)
            return 0;

        measuredWidths.sort(function(x, y) { return x - y; });

        var totalMeasuredWidth = 0;
        for (var i = 0; i < measuredWidths.length; ++i)
            totalMeasuredWidth += measuredWidths[i];

        if (totalWidth >= totalMeasuredWidth)
            return measuredWidths[measuredWidths.length - 1];

        var totalExtraWidth = 0;
        for (var i = measuredWidths.length - 1; i > 0; --i) {
            var extraWidth = measuredWidths[i] - measuredWidths[i - 1];
            totalExtraWidth += (measuredWidths.length - i) * extraWidth;

            if (totalWidth + totalExtraWidth >= totalMeasuredWidth)
                return measuredWidths[i - 1] + (totalWidth + totalExtraWidth - totalMeasuredWidth) / (measuredWidths.length - i);
        }

        return totalWidth / measuredWidths.length;
    },

    /**
     * @param {!Array.<!WebInspector.TabbedPaneTab>} tabsOrdered
     * @param {!Array.<!WebInspector.TabbedPaneTab>} tabsHistory
     * @param {number} totalWidth
     * @param {number} measuredDropDownButtonWidth
     * @return {!Array.<number>}
     */
    _tabsToShowIndexes: function(tabsOrdered, tabsHistory, totalWidth, measuredDropDownButtonWidth)
    {
        var tabsToShowIndexes = [];

        var totalTabsWidth = 0;
        var tabCount = tabsOrdered.length;
        var tabsToLookAt = tabsOrdered.slice(0);
        if (this._currentTab !== undefined)
            tabsToLookAt.unshift(tabsToLookAt.splice(tabsToLookAt.indexOf(this._currentTab), 1)[0]);
        if (this._lastSelectedOverflowTab !== undefined)
            tabsToLookAt.unshift(tabsToLookAt.splice(tabsToLookAt.indexOf(this._lastSelectedOverflowTab), 1)[0]);
        for (var i = 0; i < tabCount; ++i) {
            var tab = this._automaticReorder ? tabsHistory[i] : tabsToLookAt[i];
            totalTabsWidth += tab.width();
            var minimalRequiredWidth = totalTabsWidth;
            if (i !== tabCount - 1)
                minimalRequiredWidth += measuredDropDownButtonWidth;
            if (!this._verticalTabLayout && minimalRequiredWidth > totalWidth)
                break;
            tabsToShowIndexes.push(tabsOrdered.indexOf(tab));
        }

        tabsToShowIndexes.sort(function(x, y) { return x - y; });

        return tabsToShowIndexes;
    },

    _hideCurrentTab: function()
    {
        if (!this._currentTab)
            return;

        this._hideTab(this._currentTab);
        delete this._currentTab;
    },

    /**
     * @param {!WebInspector.TabbedPaneTab} tab
     */
    _showTab: function(tab)
    {
        tab.tabElement.classList.add("selected");
        tab.view.show(this.element);
        this._updateTabSlider();
    },

    _updateTabSlider: function()
    {
        if (!this._currentTab || !this._sliderEnabled)
            return;
        var left = 0;
        for (var i = 0; i < this._tabs.length && this._currentTab !== this._tabs[i] && this._tabs[i]._shown; i++)
            left += this._tabs[i]._measuredWidth;
        var sliderWidth = this._currentTab._shown ? this._currentTab._measuredWidth : this._dropDownButton.offsetWidth;
        var scaleFactor = window.devicePixelRatio >= 1.5 ? " scaleY(0.75)" : "";
        this._tabSlider.style.transform = "translateX(" + left + "px)" + scaleFactor;
        this._tabSlider.style.width = sliderWidth + "px";

        if (this._tabSlider.parentElement !== this._headerContentsElement)
            this._headerContentsElement.appendChild(this._tabSlider);
    },

    /**
     * @param {!WebInspector.TabbedPaneTab} tab
     */
    _hideTab: function(tab)
    {
        tab.tabElement.classList.remove("selected");
        tab.view.detach();
    },

    /**
     * @override
     * @return {!Array.<!Element>}
     */
    elementsToRestoreScrollPositionsFor: function()
    {
        return [ this._contentElement ];
    },

    /**
     * @param {!WebInspector.TabbedPaneTab} tab
     * @param {number} index
     */
    _insertBefore: function(tab, index)
    {
        this._tabsElement.insertBefore(tab._tabElement || null, this._tabsElement.childNodes[index]);
        var oldIndex = this._tabs.indexOf(tab);
        this._tabs.splice(oldIndex, 1);
        if (oldIndex < index)
            --index;
        this._tabs.splice(index, 0, tab);
        this.dispatchEventToListeners(WebInspector.TabbedPane.EventTypes.TabOrderChanged, this._tabs);
    },

    /**
     * @param {!Element} element
     */
    insertBeforeTabStrip: function(element)
    {
        element.classList.add("tabbed-pane-header-before");
        this.element.appendChild(element);
    },

    /**
     * @param {!Element} element
     */
    appendAfterTabStrip: function(element)
    {
        element.classList.add("tabbed-pane-header-after");
        this.element.appendChild(element);
    },

    renderWithNoHeaderBackground: function()
    {
        this._headerElement.classList.add("tabbed-pane-no-header-background");
    },

    /**
     * @param {boolean} allow
     * @param {boolean=} automatic
     */
    setAllowTabReorder: function(allow, automatic)
    {
        this._allowTabReorder = allow;
        this._automaticReorder = automatic;
    },

    __proto__: WebInspector.VBox.prototype
}

/**
 * @constructor
 * @param {!WebInspector.TabbedPane} tabbedPane
 * @param {string} id
 * @param {string} title
 * @param {boolean} closeable
 * @param {!WebInspector.Widget} view
 * @param {string=} tooltip
 */
WebInspector.TabbedPaneTab = function(tabbedPane, id, title, closeable, view, tooltip)
{
    this._closeable = closeable;
    this._tabbedPane = tabbedPane;
    this._id = id;
    this._title = title;
    this._tooltip = tooltip;
    this._view = view;
    this._shown = false;
    /** @type {number} */ this._measuredWidth;
    /** @type {!Element|undefined} */ this._tabElement;
}

WebInspector.TabbedPaneTab.prototype = {
    /**
     * @return {string}
     */
    get id()
    {
        return this._id;
    },

    /**
     * @return {string}
     */
    get title()
    {
        return this._title;
    },

    set title(title)
    {
        if (title === this._title)
            return;
        this._title = title;
        if (this._titleElement)
            this._titleElement.textContent = title;
        delete this._measuredWidth;
    },

    /**
     * @return {boolean}
     */
    isCloseable: function()
    {
        return this._closeable;
    },

    /**
     * @param {string} iconType
     * @param {string=} iconTooltip
     * @return {boolean}
     */
    _setIconType: function(iconType, iconTooltip)
    {
        if (iconType === this._iconType && iconTooltip === this._iconTooltip)
            return false;
        this._iconType = iconType;
        this._iconTooltip = iconTooltip;
        if (this._tabElement)
            this._createIconElement(this._tabElement, this._titleElement);
        delete this._measuredWidth;
        return true;
    },

    /**
     * @param {string} className
     * @param {boolean=} force
     * @return {boolean}
     */
    _toggleClass: function(className, force)
    {
        var element = this.tabElement;
        var hasClass = element.classList.contains(className);
        if (hasClass === force)
            return false;
        element.classList.toggle(className, force);
        delete this._measuredWidth;
        return true;
    },

    /**
     * @return {!WebInspector.Widget}
     */
    get view()
    {
        return this._view;
    },

    set view(view)
    {
        this._view = view;
    },

    /**
     * @return {string|undefined}
     */
    get tooltip()
    {
        return this._tooltip;
    },

    set tooltip(tooltip)
    {
        this._tooltip = tooltip;
        if (this._titleElement)
            this._titleElement.title = tooltip || "";
    },

    /**
     * @return {!Element}
     */
    get tabElement()
    {
        if (!this._tabElement)
            this._tabElement = this._createTabElement(false);

        return this._tabElement;
    },

    /**
     * @return {number}
     */
    width: function()
    {
        return this._width;
    },

    /**
     * @param {number} width
     */
    setWidth: function(width)
    {
        this.tabElement.style.width = width === -1 ? "" : (width + "px");
        this._width = width;
    },

    /**
     * @param {!WebInspector.TabbedPaneTabDelegate} delegate
     */
    setDelegate: function(delegate)
    {
        this._delegate = delegate;
    },

    /**
     * @param {!Element} tabElement
     * @param {!Element} titleElement
     */
    _createIconElement: function(tabElement, titleElement)
    {
        if (tabElement.__iconElement)
            tabElement.__iconElement.remove();
        if (!this._iconType)
            return;

        var iconElement = createElementWithClass("label", "tabbed-pane-header-tab-icon", "dt-icon-label");
        iconElement.type = this._iconType;
        if (this._iconTooltip)
            iconElement.title = this._iconTooltip;
        tabElement.insertBefore(iconElement, titleElement);
        tabElement.__iconElement = iconElement;
    },

    /**
     * @param {boolean} measuring
     * @return {!Element}
     */
    _createTabElement: function(measuring)
    {
        var tabElement = createElementWithClass("div", "tabbed-pane-header-tab");
        tabElement.id = "tab-" + this._id;
        tabElement.tabIndex = -1;
        tabElement.selectTabForTest = this._tabbedPane.selectTab.bind(this._tabbedPane, this.id, true);

        var titleElement = tabElement.createChild("span", "tabbed-pane-header-tab-title");
        titleElement.textContent = this.title;
        titleElement.title = this.tooltip || "";
        this._createIconElement(tabElement, titleElement);
        if (!measuring)
            this._titleElement = titleElement;

        if (this._closeable)
            tabElement.createChild("div", "tabbed-pane-close-button", "dt-close-button").gray = true;

        if (measuring) {
            tabElement.classList.add("measuring");
        } else {
            tabElement.addEventListener("click", this._tabClicked.bind(this), false);
            tabElement.addEventListener("mousedown", this._tabMouseDown.bind(this), false);
            tabElement.addEventListener("mouseup", this._tabMouseUp.bind(this), false);

            tabElement.addEventListener("contextmenu", this._tabContextMenu.bind(this), false);
            if (this._tabbedPane._allowTabReorder)
                WebInspector.installDragHandle(tabElement, this._startTabDragging.bind(this), this._tabDragging.bind(this), this._endTabDragging.bind(this), "-webkit-grabbing", "pointer", 200);
        }

        // 暂时隐藏profiles tab;
        if (this._id == "profiles") {
            tabElement.classList.add("toolkit-hide");
        }

        return tabElement;
    },

    /**
     * @param {!Event} event
     */
    _tabClicked: function(event)
    {
        var middleButton = event.button === 1;
        var shouldClose = this._closeable && (middleButton || event.target.classList.contains("tabbed-pane-close-button"));
        if (!shouldClose) {
            this._tabbedPane.focus();
            return;
        }
        this._closeTabs([this.id]);
        event.consume(true);
    },

    /**
     * @param {!Event} event
     */
    _tabMouseDown: function(event)
    {
        if (event.target.classList.contains("tabbed-pane-close-button") || event.button === 1)
            return;
        this._tabbedPane.selectTab(this.id, true);
    },

    /**
     * @param {!Event} event
     */
    _tabMouseUp: function(event)
    {
        // This is needed to prevent middle-click pasting on linux when tabs are clicked.
        if (event.button === 1)
            event.consume(true);
    },

    /**
     * @param {!Array.<string>} ids
     */
    _closeTabs: function(ids)
    {
        if (this._delegate) {
            this._delegate.closeTabs(this._tabbedPane, ids);
            return;
        }
        this._tabbedPane.closeTabs(ids, true);
    },

    _tabContextMenu: function(event)
    {
        /**
         * @this {WebInspector.TabbedPaneTab}
         */
        function close()
        {
            this._closeTabs([this.id]);
        }

        /**
         * @this {WebInspector.TabbedPaneTab}
         */
        function closeOthers()
        {
            this._closeTabs(this._tabbedPane.otherTabs(this.id));
        }

        /**
         * @this {WebInspector.TabbedPaneTab}
         */
        function closeAll()
        {
            this._closeTabs(this._tabbedPane.allTabs());
        }

        /**
         * @this {WebInspector.TabbedPaneTab}
         */
        function closeToTheRight()
        {
            this._closeTabs(this._tabbedPane._tabsToTheRight(this.id));
        }

        var contextMenu = new WebInspector.ContextMenu(event);
        if (this._closeable) {
            contextMenu.appendItem(WebInspector.UIString.capitalize("Close"), close.bind(this));
            contextMenu.appendItem(WebInspector.UIString.capitalize("Close ^others"), closeOthers.bind(this));
            contextMenu.appendItem(WebInspector.UIString.capitalize("Close ^tabs to the ^right"), closeToTheRight.bind(this));
            contextMenu.appendItem(WebInspector.UIString.capitalize("Close ^all"), closeAll.bind(this));
        }
        if (this._delegate)
            this._delegate.onContextMenu(this.id, contextMenu);
        contextMenu.show();
    },

    /**
     * @param {!Event} event
     * @return {boolean}
     */
    _startTabDragging: function(event)
    {
        if (event.target.classList.contains("tabbed-pane-close-button"))
            return false;
        this._dragStartX = event.pageX;
        this._tabElement.classList.add("dragging");
        this._tabbedPane._tabSlider.remove();
        return true;
    },

    /**
     * @param {!Event} event
     */
    _tabDragging: function(event)
    {
        var tabElements = this._tabbedPane._tabsElement.childNodes;
        for (var i = 0; i < tabElements.length; ++i) {
            var tabElement = tabElements[i];
            if (tabElement === this._tabElement)
                continue;

            var intersects = tabElement.offsetLeft + tabElement.clientWidth > this._tabElement.offsetLeft &&
                this._tabElement.offsetLeft + this._tabElement.clientWidth > tabElement.offsetLeft;
            if (!intersects)
                continue;

            if (Math.abs(event.pageX - this._dragStartX) < tabElement.clientWidth / 2 + 5)
                break;

            if (event.pageX - this._dragStartX > 0) {
                tabElement = tabElement.nextSibling;
                ++i;
            }

            var oldOffsetLeft = this._tabElement.offsetLeft;
            this._tabbedPane._insertBefore(this, i);
            this._dragStartX += this._tabElement.offsetLeft - oldOffsetLeft;
            break;
        }

        if (!this._tabElement.previousSibling && event.pageX - this._dragStartX < 0) {
            this._tabElement.style.setProperty("left", "0px");
            return;
        }
        if (!this._tabElement.nextSibling && event.pageX - this._dragStartX > 0) {
            this._tabElement.style.setProperty("left", "0px");
            return;
        }

        this._tabElement.style.setProperty("left", (event.pageX - this._dragStartX) + "px");
    },

    /**
     * @param {!Event} event
     */
    _endTabDragging: function(event)
    {
        this._tabElement.classList.remove("dragging");
        this._tabElement.style.removeProperty("left");
        delete this._dragStartX;
        this._tabbedPane._updateTabSlider();
    }
}

/**
 * @interface
 */
WebInspector.TabbedPaneTabDelegate = function()
{
}

WebInspector.TabbedPaneTabDelegate.prototype = {
    /**
     * @param {!WebInspector.TabbedPane} tabbedPane
     * @param {!Array.<string>} ids
     */
    closeTabs: function(tabbedPane, ids) { },

    /**
     * @param {string} tabId
     * @param {!WebInspector.ContextMenu} contextMenu
     */
    onContextMenu: function(tabId, contextMenu) { }
}

/**
 * @constructor
 * @param {!WebInspector.TabbedPane} tabbedPane
 * @param {string} extensionPoint
 * @param {function(string, !WebInspector.Widget)=} viewCallback
 */
WebInspector.ExtensibleTabbedPaneController = function(tabbedPane, extensionPoint, viewCallback)
{
    this._tabbedPane = tabbedPane;
    this._extensionPoint = extensionPoint;
    this._viewCallback = viewCallback;
    /** @type {!Object.<string, !Promise.<?WebInspector.Widget>>} */
    this._promiseForId = {};

    this._tabbedPane.addEventListener(WebInspector.TabbedPane.EventTypes.TabSelected, this._tabSelected, this);
    this._tabbedPane.addEventListener(WebInspector.TabbedPane.EventTypes.TabClosed, this._tabClosed, this);
    /** @type {!Map.<string, !WebInspector.Widget>} */
    this._views = new Map();
    this._closeableTabSetting = WebInspector.settings.createSetting(extensionPoint + "-closeableTabs", {});
    this._initialize();
}

WebInspector.ExtensibleTabbedPaneController.prototype = {
    _initialize: function()
    {
        /** @type {!Map.<string, !Runtime.Extension>} */
        this._extensions = new Map();
        var extensions = self.runtime.extensions(this._extensionPoint);

        for (var i = 0; i < extensions.length; ++i) {
            var id = extensions[i].descriptor()["name"];
            this._extensions.set(id, extensions[i]);
            if (this._isPermanentTab(id))
                this._appendTab(extensions[i]);
        }

        for (var i = 0; i < extensions.length; i++) {
            var id = extensions[i].descriptor()["name"];
            if (this._isCloseableTab(id) && this._closeableTabSetting.get()[id])
                this._appendTab(extensions[i]);
        }
    },

    /**
     * @param {string} id
     * @return {boolean}
     */
    _isPermanentTab: function(id)
    {
        return this._extensions.get(id).descriptor()["persistence"] === "permanent" || !this._extensions.get(id).descriptor()["persistence"];
    },

    /**
     * @param {string} id
     * @return {boolean}
     */
    _isCloseableTab: function(id)
    {
        return this._extensions.get(id).descriptor()["persistence"] === "closeable";
    },

    enableMoreTabsButton: function()
    {
        var toolbar = new WebInspector.Toolbar("drawer-toolbar");
        toolbar.appendToolbarItem(new WebInspector.ToolbarMenuButton(this._appendTabsToMenu.bind(this)));
        this._tabbedPane.insertBeforeTabStrip(toolbar.element);
        this._tabbedPane.disableOverflowMenu();
    },

    /**
     * @param {!WebInspector.ContextMenu} contextMenu
     */
    _appendTabsToMenu: function(contextMenu)
    {
        for (var id of this._extensions.keysArray().filter(this._isPermanentTab.bind(this))) {
            var title = WebInspector.UIString(this._extensions.get(id).title(WebInspector.platform()));
            contextMenu.appendItem(title, this.showTab.bind(this, id));
        }
        for (var id of this._extensions.keysArray().filter(this._isCloseableTab.bind(this))) {
            var title = WebInspector.UIString(this._extensions.get(id).title(WebInspector.platform()));
            contextMenu.appendItem(title, this.showTab.bind(this, id));
        }
    },

    /**
     * @param {!Runtime.Extension} extension
     */
    _appendTab: function(extension)
    {
        var descriptor = extension.descriptor();
        var id = descriptor["name"];
        var title = WebInspector.UIString(extension.title(WebInspector.platform()));
        var closeable = descriptor["persistence"] === "closeable" || descriptor["persistence"] === "temporary";
        this._tabbedPane.appendTab(id, title, this._views.get(id) || new WebInspector.Widget(), undefined, false, closeable);
    },

    /**
     * @param {string} id
     * @return {!Promise.<?WebInspector.Widget>}
     */
    showTab: function(id)
    {
        /**
         * @param {?WebInspector.Widget} view
         * @return {?WebInspector.Widget} view
         * @this {WebInspector.ExtensibleTabbedPaneController}
         */
        function viewLoaded(view)
        {
            if (this._pendingView === id)
                this._tabbedPane.selectTab(id);
            delete this._pendingView;
            return view;
        }

        console.assert(this._extensions.get(id));
        if (!this._tabbedPane.hasTab(id))
            this._appendTab(/** @type {!Runtime.Extension} */(this._extensions.get(id)));
        this._tabbedPane.selectTab(id);

        var descriptor = this._extensions.get(id).descriptor();
        if (descriptor["persistence"] === "closeable") {
            var tabs = this._closeableTabSetting.get();
            if (!tabs[id]) {
                tabs[id] = true;
                this._closeableTabSetting.set(tabs);
            }
        }

        this._pendingView = id;
        return this.viewForId(id).then(viewLoaded.bind(this));
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _tabSelected: function(event)
    {
        var tabId = /** @type {string} */ (event.data.tabId);
        this.viewForId(tabId);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _tabClosed: function(event)
    {
        var tabs = this._closeableTabSetting.get();
        if (tabs[event.data.tabId]) {
            delete tabs[event.data.tabId];
            this._closeableTabSetting.set(tabs);
        }
    },

    /**
     * @return {!Array.<string>}
     */
    viewIds: function()
    {
        return this._extensions.keysArray();
    },

    /**
     * @param {string} id
     * @return {!Promise.<?WebInspector.Widget>}
     */
    viewForId: function(id)
    {
        if (this._views.has(id))
            return Promise.resolve(/** @type {?WebInspector.Widget} */ (this._views.get(id)));
        if (!this._extensions.has(id))
            return Promise.resolve(/** @type {?WebInspector.Widget} */ (null));
        if (this._promiseForId[id])
            return this._promiseForId[id];

        var promise = this._extensions.get(id).instancePromise();
        this._promiseForId[id] = /** @type {!Promise.<?WebInspector.Widget>} */ (promise);
        return promise.then(cacheView.bind(this));

        /**
         * @param {!Object} object
         * @this {WebInspector.ExtensibleTabbedPaneController}
         */
        function cacheView(object)
        {
            var view = /** @type {!WebInspector.Widget} */ (object);
            delete this._promiseForId[id];
            this._views.set(id, view);
            if (this._viewCallback && view)
                this._viewCallback(id, view);
            var shouldFocus = this._tabbedPane.visibleView.element.isSelfOrAncestor(WebInspector.currentFocusElement());
            this._tabbedPane.changeTabView(id, view);
            if (shouldFocus)
                view.focus();
            return view;
        }
    }
}
;/* SidebarPane.js */
/*
 * Copyright (C) 2007 Apple Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Widget}
 * @param {string} title
 */
WebInspector.SidebarPane = function(title)
{
    WebInspector.Widget.call(this);
    this.setMinimumSize(25, 0);
    this.element.className = "sidebar-pane"; // Override

    this._title = title;
    this._expandCallback = null;
    this._paneVisible = true;
}

WebInspector.SidebarPane.prototype = {
    /**
     * @return {!WebInspector.Toolbar}
     */
    toolbar: function()
    {
        if (!this._toolbar) {
            this._toolbar = new WebInspector.Toolbar("");
            this._toolbar.element.addEventListener("click", consumeEvent);
            this.element.insertBefore(this._toolbar.element, this.element.firstChild);
        }
        return this._toolbar;
    },

    /**
     * @return {string}
     */
    title: function()
    {
        return this._title;
    },

    expand: function()
    {
        this.onContentReady();
    },

    onContentReady: function()
    {
        if (this._expandCallback)
            this._expandCallback();
        else
            this._expandPending = true;
    },

    /**
     * @param {function(boolean)} setVisibleCallback
     * @param {function()} expandCallback
     */
    _attached: function(setVisibleCallback, expandCallback)
    {
        this._setVisibleCallback = setVisibleCallback;
        this._setVisibleCallback(this._paneVisible);

        this._expandCallback = expandCallback;
        if (this._expandPending) {
            delete this._expandPending;
            this._expandCallback();
        }
    },

    /**
     * @param {boolean} visible
     */
    setVisible: function(visible)
    {
        this._paneVisible = visible;
        if (this._setVisibleCallback)
            this._setVisibleCallback(visible)
    },

    __proto__: WebInspector.Widget.prototype
}

/**
 * @constructor
 * @param {!Element} container
 * @param {!WebInspector.SidebarPane} pane
 */
WebInspector.SidebarPaneTitle = function(container, pane)
{
    this._pane = pane;

    this.element = container.createChild("div", "sidebar-pane-title");
    this.element.textContent = pane.title();
    this.element.tabIndex = 0;
    this.element.addEventListener("click", this._toggleExpanded.bind(this), false);
    this.element.addEventListener("keydown", this._onTitleKeyDown.bind(this), false);
}

WebInspector.SidebarPaneTitle.prototype = {
    _expand: function()
    {
        this.element.classList.add("expanded");
        this._pane.show(this.element.parentElement, /** @type {?Element} */ (this.element.nextSibling));
    },

    _collapse: function()
    {
        this.element.classList.remove("expanded");
        if (this._pane.element.parentNode == this.element.parentNode)
            this._pane.detach();
    },

    _toggleExpanded: function()
    {
        if (this.element.classList.contains("expanded"))
            this._collapse();
        else
            this._pane.expand();
    },

    /**
     * @param {!Event} event
     */
    _onTitleKeyDown: function(event)
    {
        if (isEnterKey(event) || event.keyCode === WebInspector.KeyboardShortcut.Keys.Space.code)
            this._toggleExpanded();
    }
}

/**
 * @constructor
 * @extends {WebInspector.Widget}
 */
WebInspector.SidebarPaneStack = function()
{
    WebInspector.Widget.call(this);
    this.setMinimumSize(25, 0);
    this.element.className = "sidebar-pane-stack"; // Override
    /** @type {!Map.<!WebInspector.SidebarPane, !WebInspector.SidebarPaneTitle>} */
    this._titleByPane = new Map();
}

WebInspector.SidebarPaneStack.prototype = {
    /**
     * @param {!WebInspector.SidebarPane} pane
     */
    addPane: function(pane)
    {
        var paneTitle = new WebInspector.SidebarPaneTitle(this.element, pane);
        this._titleByPane.set(pane, paneTitle);
        if (pane._toolbar)
            paneTitle.element.appendChild(pane._toolbar.element);
        pane._attached(this._setPaneVisible.bind(this, pane), paneTitle._expand.bind(paneTitle));
    },

    /**
     * @param {!WebInspector.SidebarPane} pane
     * @param {boolean} visible
     */
    _setPaneVisible: function(pane, visible)
    {
        var title = this._titleByPane.get(pane);
        if (!title)
            return;

        title.element.classList.toggle("hidden", !visible);
        pane.element.classList.toggle("sidebar-pane-hidden", !visible);
    },

    __proto__: WebInspector.Widget.prototype
}

/**
 * @constructor
 * @extends {WebInspector.TabbedPane}
 */
WebInspector.SidebarTabbedPane = function()
{
    WebInspector.TabbedPane.call(this);
    this.element.classList.add("sidebar-tabbed-pane");
}

WebInspector.SidebarTabbedPane.prototype = {
    /**
     * @param {!WebInspector.SidebarPane} pane
     */
    addPane: function(pane)
    {
        var title = pane.title();
        this.appendTab(title, title, pane);
        if (pane._toolbar)
            pane.element.insertBefore(pane._toolbar.element, pane.element.firstChild);
        pane._attached(this._setPaneVisible.bind(this, pane), this.selectTab.bind(this, title));
    },

    /**
     * @param {!WebInspector.SidebarPane} pane
     * @param {boolean} visible
     */
    _setPaneVisible: function(pane, visible)
    {
        var title = pane._title;
        if (visible) {
            if (!this.hasTab(title))
                this.appendTab(title, title, pane);
        } else {
            if (this.hasTab(title))
                this.closeTab(title);
        }
    },

    __proto__: WebInspector.TabbedPane.prototype
}
;/* TextPrompt.js */
/*
 * Copyright (C) 2008 Apple Inc.  All rights reserved.
 * Copyright (C) 2011 Google Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @implements {WebInspector.SuggestBoxDelegate}
 * @param {function(!Element, string, number, !Range, boolean, function(!Array.<string>, number=))} completions
 * @param {string=} stopCharacters
 */
WebInspector.TextPrompt = function(completions, stopCharacters)
{
    /**
     * @type {!Element|undefined}
     */
    this._proxyElement;
    this._proxyElementDisplay = "inline-block";
    this._loadCompletions = completions;
    this._completionStopCharacters = stopCharacters || " =:[({;,!+-*/&|^<>.";
    this._autocompletionTimeout = WebInspector.TextPrompt.DefaultAutocompletionTimeout;
}

WebInspector.TextPrompt.DefaultAutocompletionTimeout = 250;

WebInspector.TextPrompt.Events = {
    ItemApplied: "text-prompt-item-applied",
    ItemAccepted: "text-prompt-item-accepted"
};

WebInspector.TextPrompt.prototype = {
    /**
     * @param {number} timeout
     */
    setAutocompletionTimeout: function(timeout)
    {
        this._autocompletionTimeout = timeout;
    },

    /**
     * @param {boolean} suggestBoxEnabled
     */
    setSuggestBoxEnabled: function(suggestBoxEnabled)
    {
        this._suggestBoxEnabled = suggestBoxEnabled;
    },

    renderAsBlock: function()
    {
        this._proxyElementDisplay = "block";
    },

    /**
     * Clients should never attach any event listeners to the |element|. Instead,
     * they should use the result of this method to attach listeners for bubbling events.
     *
     * @param {!Element} element
     * @return {!Element}
     */
    attach: function(element)
    {
        return this._attachInternal(element);
    },

    /**
     * Clients should never attach any event listeners to the |element|. Instead,
     * they should use the result of this method to attach listeners for bubbling events
     * or the |blurListener| parameter to register a "blur" event listener on the |element|
     * (since the "blur" event does not bubble.)
     *
     * @param {!Element} element
     * @param {function(!Event)} blurListener
     * @return {!Element}
     */
    attachAndStartEditing: function(element, blurListener)
    {
        var proxyElement = this._attachInternal(element);
        this._startEditing(blurListener);
        return proxyElement;
    },

    /**
     * @param {!Element} element
     * @return {!Element}
     */
    _attachInternal: function(element)
    {
        if (this._proxyElement)
            throw "Cannot attach an attached TextPrompt";
        this._element = element;

        this._boundOnKeyDown = this.onKeyDown.bind(this);
        this._boundOnInput = this.onInput.bind(this);
        this._boundOnMouseWheel = this.onMouseWheel.bind(this);
        this._boundSelectStart = this._selectStart.bind(this);
        this._boundRemoveSuggestionAids = this._removeSuggestionAids.bind(this);
        this._proxyElement = element.ownerDocument.createElement("span");
        var shadowRoot = WebInspector.createShadowRootWithCoreStyles(this._proxyElement, "ui/textPrompt.css");
        this._contentElement = shadowRoot.createChild("div");
        this._contentElement.createChild("content");
        this._proxyElement.style.display = this._proxyElementDisplay;
        element.parentElement.insertBefore(this._proxyElement, element);
        this._proxyElement.appendChild(element);
        this._element.classList.add("text-prompt");
        this._element.addEventListener("keydown", this._boundOnKeyDown, false);
        this._element.addEventListener("input", this._boundOnInput, false);
        this._element.addEventListener("mousewheel", this._boundOnMouseWheel, false);
        this._element.addEventListener("selectstart", this._boundSelectStart, false);
        this._element.addEventListener("blur", this._boundRemoveSuggestionAids, false);
        this._element.ownerDocument.defaultView.addEventListener("resize", this._boundRemoveSuggestionAids, false);

        if (this._suggestBoxEnabled)
            this._suggestBox = new WebInspector.SuggestBox(this);

        return this._proxyElement;
    },

    detach: function()
    {
        this._removeFromElement();
        this._proxyElement.parentElement.insertBefore(this._element, this._proxyElement);
        this._proxyElement.remove();
        delete this._proxyElement;
        this._element.classList.remove("text-prompt");
        WebInspector.restoreFocusFromElement(this._element);
    },

    /**
     * @return {string}
     */
    text: function()
    {
        return this._element.textContent;
    },

    /**
     * @return {string}
     */
    userEnteredText: function()
    {
        var text = this.text();
        if (this.autoCompleteElement) {
            var addition = this.autoCompleteElement.textContent;
            text = text.substring(0, text.length - addition.length);
        }
        return text;
    },

    /**
     * @param {string} x
     */
    setText: function(x)
    {
        this._removeSuggestionAids();
        if (!x) {
            // Append a break element instead of setting textContent to make sure the selection is inside the prompt.
            this._element.removeChildren();
            this._element.createChild("br");
        } else {
            this._element.textContent = x;
        }

        this.moveCaretToEndOfPrompt();
        this._element.scrollIntoView();
    },

    _removeFromElement: function()
    {
        this.clearAutoComplete(true);
        this._element.removeEventListener("keydown", this._boundOnKeyDown, false);
        this._element.removeEventListener("input", this._boundOnInput, false);
        this._element.removeEventListener("selectstart", this._boundSelectStart, false);
        this._element.removeEventListener("blur", this._boundRemoveSuggestionAids, false);
        this._element.ownerDocument.defaultView.removeEventListener("resize", this._boundRemoveSuggestionAids, false);
        if (this._isEditing)
            this._stopEditing();
        if (this._suggestBox)
            this._suggestBox.removeFromElement();
    },

    /**
     * @param {function(!Event)=} blurListener
     */
    _startEditing: function(blurListener)
    {
        this._isEditing = true;
        this._contentElement.classList.add("text-prompt-editing");
        if (blurListener) {
            this._blurListener = blurListener;
            this._element.addEventListener("blur", this._blurListener, false);
        }
        this._oldTabIndex = this._element.tabIndex;
        if (this._element.tabIndex < 0)
            this._element.tabIndex = 0;
        WebInspector.setCurrentFocusElement(this._element);
        if (!this.text())
            this._updateAutoComplete();
    },

    _stopEditing: function()
    {
        this._element.tabIndex = this._oldTabIndex;
        if (this._blurListener)
            this._element.removeEventListener("blur", this._blurListener, false);
        this._contentElement.classList.remove("text-prompt-editing");
        delete this._isEditing;
    },

    _removeSuggestionAids: function()
    {
        this.clearAutoComplete();
        this.hideSuggestBox();
    },

    _selectStart: function()
    {
        if (this._selectionTimeout)
            clearTimeout(this._selectionTimeout);

        this._removeSuggestionAids();

        /**
         * @this {WebInspector.TextPrompt}
         */
        function moveBackIfOutside()
        {
            delete this._selectionTimeout;
            if (!this.isCaretInsidePrompt() && this._element.isComponentSelectionCollapsed()) {
                this.moveCaretToEndOfPrompt();
                this.autoCompleteSoon();
            }
        }

        this._selectionTimeout = setTimeout(moveBackIfOutside.bind(this), 100);
    },

    /**
     * @param {boolean=} force
     */
    _updateAutoComplete: function(force)
    {
        this.clearAutoComplete();
        this.autoCompleteSoon(force);
    },

    /**
     * @param {!Event} event
     */
    onMouseWheel: function(event)
    {
        // Subclasses can implement.
    },

    /**
     * @param {!Event} event
     */
    onKeyDown: function(event)
    {
        if (isEnterKey(event))
            return;

        var handled = false;
        delete this._needUpdateAutocomplete;

        switch (event.keyIdentifier) {
        case "U+0009": // Tab
            handled = this.tabKeyPressed(event);
            break;
        case "Left":
        case "Home":
            this._removeSuggestionAids();
            break;
        case "Right":
        case "End":
            if (this.isCaretAtEndOfPrompt())
                handled = this.acceptAutoComplete();
            else
                this._removeSuggestionAids();
            break;
        case "U+001B": // Esc
            if (this.isSuggestBoxVisible()) {
                this._removeSuggestionAids();
                handled = true;
            }
            break;
        case "U+0020": // Space
            if (event.ctrlKey && !event.metaKey && !event.altKey && !event.shiftKey) {
                this._updateAutoComplete(true);
                handled = true;
            }
            break;
        case "Alt":
        case "Meta":
        case "Shift":
        case "Control":
            break;
        }

        if (!handled && this.isSuggestBoxVisible())
            handled = this._suggestBox.keyPressed(event);

        if (!handled)
            this._needUpdateAutocomplete = true;

        if (handled)
            event.consume(true);
    },

    /**
     * @param {!Event} event
     */
    onInput: function(event)
    {
        if (this._needUpdateAutocomplete)
            this._updateAutoComplete();
    },

    /**
     * @return {boolean}
     */
    acceptAutoComplete: function()
    {
        var result = false;
        if (this.isSuggestBoxVisible())
            result = this._suggestBox.acceptSuggestion();
        if (!result)
            result = this._acceptSuggestionInternal();

        return result;
    },

    /**
     * @param {boolean=} includeTimeout
     */
    clearAutoComplete: function(includeTimeout)
    {
        if (includeTimeout && this._completeTimeout) {
            clearTimeout(this._completeTimeout);
            delete this._completeTimeout;
        }
        delete this._waitingForCompletions;

        if (!this.autoCompleteElement)
            return;

        this.autoCompleteElement.remove();
        delete this.autoCompleteElement;
        delete this._userEnteredRange;
        delete this._userEnteredText;
    },

    /**
     * @param {boolean=} force
     */
    autoCompleteSoon: function(force)
    {
        var immediately = this.isSuggestBoxVisible() || force;
        if (!this._completeTimeout)
            this._completeTimeout = setTimeout(this.complete.bind(this, force), immediately ? 0 : this._autocompletionTimeout);
    },

    /**
     * @param {boolean=} force
     * @param {boolean=} reverse
     */
    complete: function(force, reverse)
    {
        this.clearAutoComplete(true);
        var selection = this._element.getComponentSelection();
        if (!selection.rangeCount)
            return;

        var selectionRange = selection.getRangeAt(0);
        var shouldExit;

        if (!force && !this.isCaretAtEndOfPrompt() && !this.isSuggestBoxVisible())
            shouldExit = true;
        else if (!selection.isCollapsed)
            shouldExit = true;
        else if (!force) {
            // BUG72018: Do not show suggest box if caret is followed by a non-stop character.
            var wordSuffixRange = selectionRange.startContainer.rangeOfWord(selectionRange.endOffset, this._completionStopCharacters, this._element, "forward");
            if (wordSuffixRange.toString().length)
                shouldExit = true;
        }
        if (shouldExit) {
            this.hideSuggestBox();
            return;
        }

        var wordPrefixRange = selectionRange.startContainer.rangeOfWord(selectionRange.startOffset, this._completionStopCharacters, this._element, "backward");
        this._waitingForCompletions = true;
        this._loadCompletions(/** @type {!Element} */ (this._proxyElement), this.text(), selectionRange.startOffset, wordPrefixRange, force || false, this._completionsReady.bind(this, selection, wordPrefixRange, !!reverse, !!force));
    },

    disableDefaultSuggestionForEmptyInput: function()
    {
        this._disableDefaultSuggestionForEmptyInput = true;
    },

    /**
     * @param {!Selection} selection
     * @param {!Range} textRange
     */
    _boxForAnchorAtStart: function(selection, textRange)
    {
        var rangeCopy = selection.getRangeAt(0).cloneRange();
        var anchorElement = createElement("span");
        anchorElement.textContent = "\u200B";
        textRange.insertNode(anchorElement);
        var box = anchorElement.boxInWindow(window);
        anchorElement.remove();
        selection.removeAllRanges();
        selection.addRange(rangeCopy);
        return box;
    },

    /**
     * @param {!Array.<string>} completions
     * @param {number} wordPrefixLength
     */
    _buildCommonPrefix: function(completions, wordPrefixLength)
    {
        var commonPrefix = completions[0];
        for (var i = 0; i < completions.length; ++i) {
            var completion = completions[i];
            var lastIndex = Math.min(commonPrefix.length, completion.length);
            for (var j = wordPrefixLength; j < lastIndex; ++j) {
                if (commonPrefix[j] !== completion[j]) {
                    commonPrefix = commonPrefix.substr(0, j);
                    break;
                }
            }
        }
        return commonPrefix;
    },

    /**
     * @return {?Range}
     * @suppressGlobalPropertiesCheck
     */
    _createRange: function()
    {
        return document.createRange();
    },

    /**
     * @param {string} prefix
     * @return {!WebInspector.SuggestBox.Suggestions}
     */
    additionalCompletions: function(prefix)
    {
        return [];
    },

    /**
     * @param {!Selection} selection
     * @param {!Range} originalWordPrefixRange
     * @param {boolean} reverse
     * @param {boolean} force
     * @param {!Array.<string>} completions
     * @param {number=} selectedIndex
     */
    _completionsReady: function(selection, originalWordPrefixRange, reverse, force, completions, selectedIndex)
    {
        var prefix = originalWordPrefixRange.toString();

        // Filter out dupes.
        var store = new Set();
        completions = completions.filter(item => !store.has(item) && !!store.add(item));
        var annotatedCompletions = completions.map(item => ({title: item}));

        if (prefix || force) {
            if (prefix)
                annotatedCompletions = annotatedCompletions.concat(this.additionalCompletions(prefix));
            else
                annotatedCompletions = this.additionalCompletions(prefix).concat(annotatedCompletions);
        }

        if (!this._waitingForCompletions || !annotatedCompletions.length) {
            this.hideSuggestBox();
            return;
        }

        delete this._waitingForCompletions;

        var selectionRange = selection.getRangeAt(0);

        var fullWordRange = this._createRange();
        fullWordRange.setStart(originalWordPrefixRange.startContainer, originalWordPrefixRange.startOffset);
        fullWordRange.setEnd(selectionRange.endContainer, selectionRange.endOffset);

        if (prefix + selectionRange.toString() !== fullWordRange.toString())
            return;

        selectedIndex = (this._disableDefaultSuggestionForEmptyInput && !this.text()) ? -1 : (selectedIndex || 0);

        this._userEnteredRange = fullWordRange;
        this._userEnteredText = fullWordRange.toString();

        if (this._suggestBox)
            this._suggestBox.updateSuggestions(this._boxForAnchorAtStart(selection, fullWordRange), annotatedCompletions, selectedIndex, !this.isCaretAtEndOfPrompt(), this._userEnteredText);

        if (selectedIndex === -1)
            return;

        var wordPrefixLength = originalWordPrefixRange.toString().length;
        this._commonPrefix = this._buildCommonPrefix(completions, wordPrefixLength);

        if (this.isCaretAtEndOfPrompt()) {
            var completionText = annotatedCompletions[selectedIndex].title;
            var prefixText = this._userEnteredRange.toString();
            var suffixText = completionText.substring(wordPrefixLength);
            this._userEnteredRange.deleteContents();
            this._element.normalize();
            var finalSelectionRange = this._createRange();

            var prefixTextNode = createTextNode(prefixText);
            fullWordRange.insertNode(prefixTextNode);

            this.autoCompleteElement = createElementWithClass("span", "auto-complete-text");
            this.autoCompleteElement.textContent = suffixText;

            prefixTextNode.parentNode.insertBefore(this.autoCompleteElement, prefixTextNode.nextSibling);

            finalSelectionRange.setStart(prefixTextNode, wordPrefixLength);
            finalSelectionRange.setEnd(prefixTextNode, wordPrefixLength);
            selection.removeAllRanges();
            selection.addRange(finalSelectionRange);
            this.dispatchEventToListeners(WebInspector.TextPrompt.Events.ItemApplied);
        }
    },

    _completeCommonPrefix: function()
    {
        if (!this.autoCompleteElement || !this._commonPrefix || !this._userEnteredText || !this._commonPrefix.startsWith(this._userEnteredText))
            return;

        if (!this.isSuggestBoxVisible()) {
            this.acceptAutoComplete();
            return;
        }

        this.autoCompleteElement.textContent = this._commonPrefix.substring(this._userEnteredText.length);
        this._acceptSuggestionInternal(true);
    },

    /**
     * @override
     * @param {string} completionText
     * @param {boolean=} isIntermediateSuggestion
     */
    applySuggestion: function(completionText, isIntermediateSuggestion)
    {
        this._applySuggestion(completionText, isIntermediateSuggestion);
    },

    /**
     * @param {string} completionText
     * @param {boolean=} isIntermediateSuggestion
     */
    _applySuggestion: function(completionText, isIntermediateSuggestion)
    {
        var wordPrefixLength = this._userEnteredText ? this._userEnteredText.length : 0;

        this._userEnteredRange.deleteContents();
        this._element.normalize();
        var finalSelectionRange = this._createRange();
        var completionTextNode = createTextNode(completionText);
        this._userEnteredRange.insertNode(completionTextNode);
        if (this.autoCompleteElement) {
            this.autoCompleteElement.remove();
            delete this.autoCompleteElement;
        }

        if (isIntermediateSuggestion)
            finalSelectionRange.setStart(completionTextNode, wordPrefixLength);
        else
            finalSelectionRange.setStart(completionTextNode, completionText.length);

        finalSelectionRange.setEnd(completionTextNode, completionText.length);

        var selection = this._element.getComponentSelection();
        selection.removeAllRanges();
        selection.addRange(finalSelectionRange);
        if (isIntermediateSuggestion)
            this.dispatchEventToListeners(WebInspector.TextPrompt.Events.ItemApplied, { itemText: completionText });
    },

    /**
     * @override
     */
    acceptSuggestion: function()
    {
        this._acceptSuggestionInternal();
    },

    /**
     * @param {boolean=} prefixAccepted
     * @return {boolean}
     */
    _acceptSuggestionInternal: function(prefixAccepted)
    {
        if (!this.autoCompleteElement || !this.autoCompleteElement.parentNode)
            return false;

        var text = this.autoCompleteElement.textContent;
        var textNode = createTextNode(text);
        this.autoCompleteElement.parentNode.replaceChild(textNode, this.autoCompleteElement);
        delete this.autoCompleteElement;

        var finalSelectionRange = this._createRange();
        finalSelectionRange.setStart(textNode, text.length);
        finalSelectionRange.setEnd(textNode, text.length);

        var selection = this._element.getComponentSelection();
        selection.removeAllRanges();
        selection.addRange(finalSelectionRange);

        if (!prefixAccepted) {
            this.hideSuggestBox();
            this.dispatchEventToListeners(WebInspector.TextPrompt.Events.ItemAccepted);
        } else
            this.autoCompleteSoon(true);

        return true;
    },

    hideSuggestBox: function()
    {
        if (this.isSuggestBoxVisible())
            this._suggestBox.hide();
    },

    /**
     * @return {boolean}
     */
    isSuggestBoxVisible: function()
    {
        return this._suggestBox && this._suggestBox.visible();
    },

    /**
     * @return {boolean}
     */
    isCaretInsidePrompt: function()
    {
        return this._element.isInsertionCaretInside();
    },

    /**
     * @return {boolean}
     */
    isCaretAtEndOfPrompt: function()
    {
        var selection = this._element.getComponentSelection();
        if (!selection.rangeCount || !selection.isCollapsed)
            return false;

        var selectionRange = selection.getRangeAt(0);
        var node = selectionRange.startContainer;
        if (!node.isSelfOrDescendant(this._element))
            return false;

        if (node.nodeType === Node.TEXT_NODE && selectionRange.startOffset < node.nodeValue.length)
            return false;

        var foundNextText = false;
        while (node) {
            if (node.nodeType === Node.TEXT_NODE && node.nodeValue.length) {
                if (foundNextText && (!this.autoCompleteElement || !this.autoCompleteElement.isAncestor(node)))
                    return false;
                foundNextText = true;
            }

            node = node.traverseNextNode(this._element);
        }

        return true;
    },

    /**
     * @return {boolean}
     */
    isCaretOnFirstLine: function()
    {
        var selection = this._element.getComponentSelection();
        var focusNode = selection.focusNode;
        if (!focusNode || focusNode.nodeType !== Node.TEXT_NODE || focusNode.parentNode !== this._element)
            return true;

        if (focusNode.textContent.substring(0, selection.focusOffset).indexOf("\n") !== -1)
            return false;
        focusNode = focusNode.previousSibling;

        while (focusNode) {
            if (focusNode.nodeType !== Node.TEXT_NODE)
                return true;
            if (focusNode.textContent.indexOf("\n") !== -1)
                return false;
            focusNode = focusNode.previousSibling;
        }

        return true;
    },

    /**
     * @return {boolean}
     */
    isCaretOnLastLine: function()
    {
        var selection = this._element.getComponentSelection();
        var focusNode = selection.focusNode;
        if (!focusNode || focusNode.nodeType !== Node.TEXT_NODE || focusNode.parentNode !== this._element)
            return true;

        if (focusNode.textContent.substring(selection.focusOffset).indexOf("\n") !== -1)
            return false;
        focusNode = focusNode.nextSibling;

        while (focusNode) {
            if (focusNode.nodeType !== Node.TEXT_NODE)
                return true;
            if (focusNode.textContent.indexOf("\n") !== -1)
                return false;
            focusNode = focusNode.nextSibling;
        }

        return true;
    },

    moveCaretToEndOfPrompt: function()
    {
        var selection = this._element.getComponentSelection();
        var selectionRange = this._createRange();

        var container = this._element;
        while (container.childNodes.length)
            container = container.lastChild;
        var offset = container.nodeType === Node.TEXT_NODE ? container.textContent.length : 0;
        selectionRange.setStart(container, offset);
        selectionRange.setEnd(container, offset);

        selection.removeAllRanges();
        selection.addRange(selectionRange);
    },

    /**
     * @param {!Event} event
     * @return {boolean}
     */
    tabKeyPressed: function(event)
    {
        this.acceptAutoComplete();

        // Consume the key.
        return true;
    },

    /**
     * @return {?Element}
     */
    proxyElementForTests: function()
    {
        return this._proxyElement || null;
    },

    __proto__: WebInspector.Object.prototype
}


/**
 * @constructor
 * @extends {WebInspector.TextPrompt}
 * @param {function(!Element, string, number, !Range, boolean, function(!Array.<string>, number=))} completions
 * @param {string=} stopCharacters
 */
WebInspector.TextPromptWithHistory = function(completions, stopCharacters)
{
    WebInspector.TextPrompt.call(this, completions, stopCharacters);

    /**
     * @type {!Array.<string>}
     */
    this._data = [];

    /**
     * 1-based entry in the history stack.
     * @type {number}
     */
    this._historyOffset = 1;

    this._addCompletionsFromHistory = true;
}

WebInspector.TextPromptWithHistory.prototype = {
    /**
     * @return {!Array.<string>}
     */
    historyData: function()
    {
        // FIXME: do we need to copy this?
        return this._data;
    },

    /**
     * @override
     * @param {string} prefix
     * @return {!WebInspector.SuggestBox.Suggestions}
     */
    additionalCompletions: function(prefix)
    {
        if (!this._addCompletionsFromHistory || !this.isCaretAtEndOfPrompt())
            return [];
        var result = [];
        var text = this.text();
        var set = new Set();
        for (var i = this._data.length - 1; i >= 0 && result.length < 50; --i) {
            var item = this._data[i];
            if (!item.startsWith(text))
                continue;
            if (set.has(item))
                continue;
            set.add(item);
            result.push({title: item.substring(text.length - prefix.length), className: "additional"});
        }
        return result;
    },

    /**
     * @param {!Array.<string>} data
     */
    setHistoryData: function(data)
    {
        this._data = [].concat(data);
        this._historyOffset = 1;
    },

    /**
     * @param {boolean} value
     */
    setAddCompletionsFromHistory: function(value)
    {
        this._addCompletionsFromHistory = value;
    },

    /**
     * Pushes a committed text into the history.
     * @param {string} text
     */
    pushHistoryItem: function(text)
    {
        if (this._uncommittedIsTop) {
            this._data.pop();
            delete this._uncommittedIsTop;
        }

        this._historyOffset = 1;
        if (text === this._currentHistoryItem())
            return;
        this._data.push(text);
    },

    /**
     * Pushes the current (uncommitted) text into the history.
     */
    _pushCurrentText: function()
    {
        if (this._uncommittedIsTop)
            this._data.pop(); // Throw away obsolete uncommitted text.
        this._uncommittedIsTop = true;
        this.clearAutoComplete(true);
        this._data.push(this.text());
    },

    /**
     * @return {string|undefined}
     */
    _previous: function()
    {
        if (this._historyOffset > this._data.length)
            return undefined;
        if (this._historyOffset === 1)
            this._pushCurrentText();
        ++this._historyOffset;
        return this._currentHistoryItem();
    },

    /**
     * @return {string|undefined}
     */
    _next: function()
    {
        if (this._historyOffset === 1)
            return undefined;
        --this._historyOffset;
        return this._currentHistoryItem();
    },

    /**
     * @return {string|undefined}
     */
    _currentHistoryItem: function()
    {
        return this._data[this._data.length - this._historyOffset];
    },

    /**
     * @override
     */
    onKeyDown: function(event)
    {
        var newText;
        var isPrevious;

        switch (event.keyIdentifier) {
        case "Up":
            if (!this.isCaretOnFirstLine() || this.isSuggestBoxVisible())
                break;
            newText = this._previous();
            isPrevious = true;
            break;
        case "Down":
            if (!this.isCaretOnLastLine() || this.isSuggestBoxVisible())
                break;
            newText = this._next();
            break;
        case "U+0050": // Ctrl+P = Previous
            if (WebInspector.isMac() && event.ctrlKey && !event.metaKey && !event.altKey && !event.shiftKey) {
                newText = this._previous();
                isPrevious = true;
            }
            break;
        case "U+004E": // Ctrl+N = Next
            if (WebInspector.isMac() && event.ctrlKey && !event.metaKey && !event.altKey && !event.shiftKey)
                newText = this._next();
            break;
        }

        if (newText !== undefined) {
            event.consume(true);
            this.setText(newText);

            if (isPrevious) {
                var firstNewlineIndex = this.text().indexOf("\n");
                if (firstNewlineIndex === -1)
                    this.moveCaretToEndOfPrompt();
                else {
                    var selection = this._element.getComponentSelection();
                    var selectionRange = this._createRange();

                    selectionRange.setStart(this._element.firstChild, firstNewlineIndex);
                    selectionRange.setEnd(this._element.firstChild, firstNewlineIndex);

                    selection.removeAllRanges();
                    selection.addRange(selectionRange);
                }
            }

            return;
        }

        WebInspector.TextPrompt.prototype.onKeyDown.apply(this, arguments);
    },

    __proto__: WebInspector.TextPrompt.prototype
}

;/* UIUtils.js */
/*
 * Copyright (C) 2011 Google Inc.  All rights reserved.
 * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.
 * Copyright (C) 2007 Matt Lilek (pewtermoose@gmail.com).
 * Copyright (C) 2009 Joseph Pecoraro
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

WebInspector.highlightedSearchResultClassName = "highlighted-search-result";

/**
 * @param {!Element} element
 * @param {?function(!MouseEvent): boolean} elementDragStart
 * @param {function(!MouseEvent)} elementDrag
 * @param {?function(!MouseEvent)} elementDragEnd
 * @param {string} cursor
 * @param {?string=} hoverCursor
 * @param {number=} startDelay
 */
WebInspector.installDragHandle = function(element, elementDragStart, elementDrag, elementDragEnd, cursor, hoverCursor, startDelay)
{
    /**
     * @param {!Event} event
     */
    function onMouseDown(event)
    {
        var dragStart = WebInspector.elementDragStart.bind(WebInspector, element, elementDragStart, elementDrag, elementDragEnd, cursor, event);
        if (!startDelay)
            dragStart();
        startTimer = setTimeout(dragStart, startDelay || 0);
    }

    function onMouseUp()
    {
        if (startTimer)
            clearInterval(startTimer);
        startTimer = null;
    }

    var startTimer;
    element.addEventListener("mousedown", onMouseDown, false);
    if (startDelay)
        element.addEventListener("mouseup", onMouseUp, false);
    if (hoverCursor !== null)
        element.style.cursor = hoverCursor || cursor;
}

/**
 * @param {!Element} targetElement
 * @param {?function(!MouseEvent):boolean} elementDragStart
 * @param {function(!MouseEvent)} elementDrag
 * @param {?function(!MouseEvent)} elementDragEnd
 * @param {string} cursor
 * @param {!Event} event
 */
WebInspector.elementDragStart = function(targetElement, elementDragStart, elementDrag, elementDragEnd, cursor, event)
{
    // Only drag upon left button. Right will likely cause a context menu. So will ctrl-click on mac.
    if (event.button || (WebInspector.isMac() && event.ctrlKey))
        return;

    if (WebInspector._elementDraggingEventListener)
        return;

    if (elementDragStart && !elementDragStart(/** @type {!MouseEvent} */ (event)))
        return;

    if (WebInspector._elementDraggingGlassPane) {
        WebInspector._elementDraggingGlassPane.dispose();
        delete WebInspector._elementDraggingGlassPane;
    }

    var targetDocument = event.target.ownerDocument;

    WebInspector._elementDraggingEventListener = elementDrag;
    WebInspector._elementEndDraggingEventListener = elementDragEnd;
    WebInspector._mouseOutWhileDraggingTargetDocument = targetDocument;
    WebInspector._dragEventsTargetDocument = targetDocument;
    WebInspector._dragEventsTargetDocumentTop = targetDocument.defaultView.top.document;

    targetDocument.addEventListener("mousemove", WebInspector._elementDragMove, true);
    targetDocument.addEventListener("mouseup", WebInspector._elementDragEnd, true);
    targetDocument.addEventListener("mouseout", WebInspector._mouseOutWhileDragging, true);
    if (targetDocument !== WebInspector._dragEventsTargetDocumentTop)
        WebInspector._dragEventsTargetDocumentTop.addEventListener("mouseup", WebInspector._elementDragEnd, true);

    if (typeof cursor === "string") {
        WebInspector._restoreCursorAfterDrag = restoreCursor.bind(null, targetElement.style.cursor);
        targetElement.style.cursor = cursor;
        targetDocument.body.style.cursor = cursor;
    }
    function restoreCursor(oldCursor)
    {
        targetDocument.body.style.removeProperty("cursor");
        targetElement.style.cursor = oldCursor;
        WebInspector._restoreCursorAfterDrag = null;
    }
    event.preventDefault();
}

WebInspector._mouseOutWhileDragging = function()
{
    var document = WebInspector._mouseOutWhileDraggingTargetDocument;
    WebInspector._unregisterMouseOutWhileDragging();
    WebInspector._elementDraggingGlassPane = new WebInspector.GlassPane(document);
}

WebInspector._unregisterMouseOutWhileDragging = function()
{
    if (!WebInspector._mouseOutWhileDraggingTargetDocument)
        return;
    WebInspector._mouseOutWhileDraggingTargetDocument.removeEventListener("mouseout", WebInspector._mouseOutWhileDragging, true);
    delete WebInspector._mouseOutWhileDraggingTargetDocument;
}

WebInspector._unregisterDragEvents = function()
{
    if (!WebInspector._dragEventsTargetDocument)
        return;
    WebInspector._dragEventsTargetDocument.removeEventListener("mousemove", WebInspector._elementDragMove, true);
    WebInspector._dragEventsTargetDocument.removeEventListener("mouseup", WebInspector._elementDragEnd, true);
    if (WebInspector._dragEventsTargetDocument !== WebInspector._dragEventsTargetDocumentTop)
        WebInspector._dragEventsTargetDocumentTop.removeEventListener("mouseup", WebInspector._elementDragEnd, true);
    delete WebInspector._dragEventsTargetDocument;
    delete WebInspector._dragEventsTargetDocumentTop;
}

/**
 * @param {!Event} event
 */
WebInspector._elementDragMove = function(event)
{
    if (event.buttons !== 1) {
        WebInspector._elementDragEnd(event);
        return;
    }

    if (WebInspector._elementDraggingEventListener(/** @type {!MouseEvent} */ (event)))
        WebInspector._cancelDragEvents(event);
}

/**
 * @param {!Event} event
 */
WebInspector._cancelDragEvents = function(event)
{
    WebInspector._unregisterDragEvents();
    WebInspector._unregisterMouseOutWhileDragging();

    if (WebInspector._restoreCursorAfterDrag)
        WebInspector._restoreCursorAfterDrag();

    if (WebInspector._elementDraggingGlassPane)
        WebInspector._elementDraggingGlassPane.dispose();

    delete WebInspector._elementDraggingGlassPane;
    delete WebInspector._elementDraggingEventListener;
    delete WebInspector._elementEndDraggingEventListener;
}

/**
 * @param {!Event} event
 */
WebInspector._elementDragEnd = function(event)
{
    var elementDragEnd = WebInspector._elementEndDraggingEventListener;

    WebInspector._cancelDragEvents(/** @type {!MouseEvent} */ (event));

    event.preventDefault();
    if (elementDragEnd)
        elementDragEnd(/** @type {!MouseEvent} */ (event));
}

/**
 * @constructor
 * @param {!Document} document
 * @param {boolean=} dimmed
 */
WebInspector.GlassPane = function(document, dimmed)
{
    this.element = createElement("div");
    var background = dimmed ? "rgba(255, 255, 255, 0.5)" : "transparent";
    this._zIndex = WebInspector._glassPane ? WebInspector._glassPane._zIndex + 1000 : 3000; // Deliberately starts with 3000 to hide other z-indexed elements below.
    this.element.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;background-color:" + background + ";z-index:" + this._zIndex + ";overflow:hidden;";
    document.body.appendChild(this.element);
    WebInspector._glassPane = this;
}

WebInspector.GlassPane.prototype = {
    dispose: function()
    {
        delete WebInspector._glassPane;
        if (WebInspector.GlassPane.DefaultFocusedViewStack.length)
            WebInspector.GlassPane.DefaultFocusedViewStack.peekLast().focus();
        this.element.remove();
    }
}

/** @type {!WebInspector.GlassPane|undefined} */
WebInspector._glassPane;

/**
 * @type {!Array.<!WebInspector.Widget|!WebInspector.Dialog>}
 */
WebInspector.GlassPane.DefaultFocusedViewStack = [];

/**
 * @param {?Node=} node
 * @return {boolean}
 */
WebInspector.isBeingEdited = function(node)
{
    if (!node || node.nodeType !== Node.ELEMENT_NODE)
        return false;
    var element = /** {!Element} */ (node);
    if (element.classList.contains("text-prompt") || element.nodeName === "INPUT" || element.nodeName === "TEXTAREA")
        return true;

    if (!WebInspector.__editingCount)
        return false;

    while (element) {
        if (element.__editing)
            return true;
        element = element.parentElementOrShadowHost();
    }
    return false;
}

/**
 * @return {boolean}
 */
WebInspector.isEditing = function()
{
    if (WebInspector.__editingCount)
        return true;

    var element = WebInspector.currentFocusElement();
    if (!element)
        return false;
    return element.classList.contains("text-prompt") || element.nodeName === "INPUT" || element.nodeName === "TEXTAREA";
}

/**
 * @param {!Element} element
 * @param {boolean} value
 * @return {boolean}
 */
WebInspector.markBeingEdited = function(element, value)
{
    if (value) {
        if (element.__editing)
            return false;
        element.classList.add("being-edited");
        element.__editing = true;
        WebInspector.__editingCount = (WebInspector.__editingCount || 0) + 1;
    } else {
        if (!element.__editing)
            return false;
        element.classList.remove("being-edited");
        delete element.__editing;
        --WebInspector.__editingCount;
    }
    return true;
}

WebInspector.CSSNumberRegex = /^(-?(?:\d+(?:\.\d+)?|\.\d+))$/;

WebInspector.StyleValueDelimiters = " \xA0\t\n\"':;,/()";


/**
 * @param {!Event} event
 * @return {?string}
 */
WebInspector._valueModificationDirection = function(event)
{
    var direction = null;
    if (event.type === "mousewheel") {
        if (event.wheelDeltaY > 0)
            direction = "Up";
        else if (event.wheelDeltaY < 0)
            direction = "Down";
    } else {
        if (event.keyIdentifier === "Up" || event.keyIdentifier === "PageUp")
            direction = "Up";
        else if (event.keyIdentifier === "Down" || event.keyIdentifier === "PageDown")
            direction = "Down";
    }
    return direction;
}

/**
 * @param {string} hexString
 * @param {!Event} event
 */
WebInspector._modifiedHexValue = function(hexString, event)
{
    var direction = WebInspector._valueModificationDirection(event);
    if (!direction)
        return hexString;

    var number = parseInt(hexString, 16);
    if (isNaN(number) || !isFinite(number))
        return hexString;

    var maxValue = Math.pow(16, hexString.length) - 1;
    var arrowKeyOrMouseWheelEvent = (event.keyIdentifier === "Up" || event.keyIdentifier === "Down" || event.type === "mousewheel");
    var delta;

    if (arrowKeyOrMouseWheelEvent)
        delta = (direction === "Up") ? 1 : -1;
    else
        delta = (event.keyIdentifier === "PageUp") ? 16 : -16;

    if (event.shiftKey)
        delta *= 16;

    var result = number + delta;
    if (result < 0)
        result = 0; // Color hex values are never negative, so clamp to 0.
    else if (result > maxValue)
        return hexString;

    // Ensure the result length is the same as the original hex value.
    var resultString = result.toString(16).toUpperCase();
    for (var i = 0, lengthDelta = hexString.length - resultString.length; i < lengthDelta; ++i)
        resultString = "0" + resultString;
    return resultString;
}

/**
 * @param {number} number
 * @param {!Event} event
 */
WebInspector._modifiedFloatNumber = function(number, event)
{
    var direction = WebInspector._valueModificationDirection(event);
    if (!direction)
        return number;

    var arrowKeyOrMouseWheelEvent = (event.keyIdentifier === "Up" || event.keyIdentifier === "Down" || event.type === "mousewheel");

    // Jump by 10 when shift is down or jump by 0.1 when Alt/Option is down.
    // Also jump by 10 for page up and down, or by 100 if shift is held with a page key.
    var changeAmount = 1;
    if (event.shiftKey && !arrowKeyOrMouseWheelEvent)
        changeAmount = 100;
    else if (event.shiftKey || !arrowKeyOrMouseWheelEvent)
        changeAmount = 10;
    else if (event.altKey)
        changeAmount = 0.1;

    if (direction === "Down")
        changeAmount *= -1;

    // Make the new number and constrain it to a precision of 6, this matches numbers the engine returns.
    // Use the Number constructor to forget the fixed precision, so 1.100000 will print as 1.1.
    var result = Number((number + changeAmount).toFixed(6));
    if (!String(result).match(WebInspector.CSSNumberRegex))
        return null;

    return result;
}

/**
 * @param {string} wordString
 * @param {!Event} event
 * @param {function(string, number, string):string=} customNumberHandler
 * @return {?string}
 */
WebInspector.createReplacementString = function(wordString, event, customNumberHandler)
{
    var replacementString;
    var prefix, suffix, number;

    var matches;
    matches = /(.*#)([\da-fA-F]+)(.*)/.exec(wordString);
    if (matches && matches.length) {
        prefix = matches[1];
        suffix = matches[3];
        number = WebInspector._modifiedHexValue(matches[2], event);

        replacementString = customNumberHandler ? customNumberHandler(prefix, number, suffix) : prefix + number + suffix;
    } else {
        matches = /(.*?)(-?(?:\d+(?:\.\d+)?|\.\d+))(.*)/.exec(wordString);
        if (matches && matches.length) {
            prefix = matches[1];
            suffix = matches[3];
            number = WebInspector._modifiedFloatNumber(parseFloat(matches[2]), event);

            // Need to check for null explicitly.
            if (number === null)
                return null;

            replacementString = customNumberHandler ? customNumberHandler(prefix, number, suffix) : prefix + number + suffix;
        }
    }
    return replacementString || null;
}

/**
 * @param {!Event} event
 * @param {!Element} element
 * @param {function(string,string)=} finishHandler
 * @param {function(string)=} suggestionHandler
 * @param {function(string, number, string):string=} customNumberHandler
 * @return {boolean}
 */
WebInspector.handleElementValueModifications = function(event, element, finishHandler, suggestionHandler, customNumberHandler)
{
    /**
     * @return {?Range}
     * @suppressGlobalPropertiesCheck
     */
    function createRange()
    {
        return document.createRange();
    }

    var arrowKeyOrMouseWheelEvent = (event.keyIdentifier === "Up" || event.keyIdentifier === "Down" || event.type === "mousewheel");
    var pageKeyPressed = (event.keyIdentifier === "PageUp" || event.keyIdentifier === "PageDown");
    if (!arrowKeyOrMouseWheelEvent && !pageKeyPressed)
        return false;

    var selection = element.getComponentSelection();
    if (!selection.rangeCount)
        return false;

    var selectionRange = selection.getRangeAt(0);
    if (!selectionRange.commonAncestorContainer.isSelfOrDescendant(element))
        return false;

    var originalValue = element.textContent;
    var wordRange = selectionRange.startContainer.rangeOfWord(selectionRange.startOffset, WebInspector.StyleValueDelimiters, element);
    var wordString = wordRange.toString();

    if (suggestionHandler && suggestionHandler(wordString))
        return false;

    var replacementString = WebInspector.createReplacementString(wordString, event, customNumberHandler);

    if (replacementString) {
        var replacementTextNode = createTextNode(replacementString);

        wordRange.deleteContents();
        wordRange.insertNode(replacementTextNode);

        var finalSelectionRange = createRange();
        finalSelectionRange.setStart(replacementTextNode, 0);
        finalSelectionRange.setEnd(replacementTextNode, replacementString.length);

        selection.removeAllRanges();
        selection.addRange(finalSelectionRange);

        event.handled = true;
        event.preventDefault();

        if (finishHandler)
            finishHandler(originalValue, replacementString);

        return true;
    }
    return false;
}

/**
 * @param {number} ms
 * @param {number=} precision
 * @return {string}
 */
Number.preciseMillisToString = function(ms, precision)
{
    precision = precision || 0;
    var format = "%." + precision + "f\u2009ms";
    return WebInspector.UIString(format, ms);
}

/** @type {!WebInspector.UIStringFormat} */
WebInspector._subMillisFormat = new WebInspector.UIStringFormat("%.2f\u2009ms");

/** @type {!WebInspector.UIStringFormat} */
WebInspector._millisFormat = new WebInspector.UIStringFormat("%.0f\u2009ms");

/** @type {!WebInspector.UIStringFormat} */
WebInspector._secondsFormat = new WebInspector.UIStringFormat("%.2f\u2009s");

/** @type {!WebInspector.UIStringFormat} */
WebInspector._minutesFormat = new WebInspector.UIStringFormat("%.1f\u2009min");

/** @type {!WebInspector.UIStringFormat} */
WebInspector._hoursFormat = new WebInspector.UIStringFormat("%.1f\u2009hrs");

/** @type {!WebInspector.UIStringFormat} */
WebInspector._daysFormat = new WebInspector.UIStringFormat("%.1f\u2009days");

/**
 * @param {number} ms
 * @param {boolean=} higherResolution
 * @return {string}
 */
Number.millisToString = function(ms, higherResolution)
{
    if (!isFinite(ms))
        return "-";

    if (ms === 0)
        return "0";

    if (higherResolution && ms < 1000)
        return WebInspector._subMillisFormat.format(ms);
    else if (ms < 1000)
        return WebInspector._millisFormat.format(ms);

    var seconds = ms / 1000;
    if (seconds < 60)
        return WebInspector._secondsFormat.format(seconds);

    var minutes = seconds / 60;
    if (minutes < 60)
        return WebInspector._minutesFormat.format(minutes);

    var hours = minutes / 60;
    if (hours < 24)
        return WebInspector._hoursFormat.format(hours);

    var days = hours / 24;
    return WebInspector._daysFormat.format(days);
}

/**
 * @param {number} seconds
 * @param {boolean=} higherResolution
 * @return {string}
 */
Number.secondsToString = function(seconds, higherResolution)
{
    if (!isFinite(seconds))
        return "-";
    return Number.millisToString(seconds * 1000, higherResolution);
}

/**
 * @param {number} bytes
 * @return {string}
 */
Number.bytesToString = function(bytes)
{
    if (bytes < 1024)
        return WebInspector.UIString("%.0f\u2009B", bytes);

    var kilobytes = bytes / 1024;
    if (kilobytes < 100)
        return WebInspector.UIString("%.1f\u2009KB", kilobytes);
    if (kilobytes < 1024)
        return WebInspector.UIString("%.0f\u2009KB", kilobytes);

    var megabytes = kilobytes / 1024;
    if (megabytes < 100)
        return WebInspector.UIString("%.1f\u2009MB", megabytes);
    else
        return WebInspector.UIString("%.0f\u2009MB", megabytes);
}

/**
 * @param {number} num
 * @return {string}
 */
Number.withThousandsSeparator = function(num)
{
    var str = num + "";
    var re = /(\d+)(\d{3})/;
    while (str.match(re))
        str = str.replace(re, "$1\u2009$2"); // \u2009 is a thin space.
    return str;
}

/**
 * @param {string} format
 * @param {?ArrayLike} substitutions
 * @return {!Element}
 */
WebInspector.formatLocalized = function(format, substitutions)
{
    var formatters = {
        s: substitution => substitution
    };
    /**
     * @param {!Element} a
     * @param {string|!Element} b
     * @return {!Element}
     */
    function append(a, b)
    {
        a.appendChild(typeof b === "string" ? createTextNode(b) : b);
        return a;
    }
    return String.format(WebInspector.UIString(format), substitutions, formatters, createElement("span"), append).formattedResult;
}

/**
 * @return {string}
 */
WebInspector.openLinkExternallyLabel = function()
{
    return WebInspector.UIString.capitalize("Open ^link in ^new ^tab");
}

/**
 * @return {string}
 */
WebInspector.copyLinkAddressLabel = function()
{
    return WebInspector.UIString.capitalize("Copy ^link ^address");
}

/**
 * @return {string}
 */
WebInspector.anotherProfilerActiveLabel = function()
{
    return WebInspector.UIString("Another profiler is already active");
}

/**
 * @param {string|undefined} description
 * @return {string}
 */
WebInspector.asyncStackTraceLabel = function(description)
{
    if (description)
        return description + " " + WebInspector.UIString("(async)");
    return WebInspector.UIString("Async Call");
}

/**
 * @return {string}
 */
WebInspector.manageBlackboxingSettingsTabLabel = function()
{
    return WebInspector.UIString("Blackboxing");
}

/**
 * @param {!Element} element
 */
WebInspector.installComponentRootStyles = function(element)
{
    WebInspector.appendStyle(element, "ui/inspectorCommon.css");
    WebInspector.themeSupport.injectHighlightStyleSheets(element);
    element.classList.add("platform-" + WebInspector.platform());
}

/**
 * @param {!Element} element
 * @param {string=} cssFile
 * @return {!DocumentFragment}
 */
WebInspector.createShadowRootWithCoreStyles = function(element, cssFile)
{
    var shadowRoot = element.createShadowRoot();
    WebInspector.appendStyle(shadowRoot, "ui/inspectorCommon.css");
    WebInspector.themeSupport.injectHighlightStyleSheets(shadowRoot);
    if (cssFile)
        WebInspector.appendStyle(shadowRoot, cssFile);
    shadowRoot.addEventListener("focus", WebInspector._focusChanged.bind(WebInspector), true);
    return shadowRoot;
}

/**
 * @param {!Document} document
 * @param {!Event} event
 */
WebInspector._windowFocused = function(document, event)
{
    if (event.target.document.nodeType === Node.DOCUMENT_NODE)
        document.body.classList.remove("inactive");
}

/**
 * @param {!Document} document
 * @param {!Event} event
 */
WebInspector._windowBlurred = function(document, event)
{
    if (event.target.document.nodeType === Node.DOCUMENT_NODE)
        document.body.classList.add("inactive");
}

/**
 * @return {!Element}
 */
WebInspector.previousFocusElement = function()
{
    return WebInspector._previousFocusElement;
}

/**
 * @return {!Element}
 */
WebInspector.currentFocusElement = function()
{
    return WebInspector._currentFocusElement;
}

/**
 * @param {!Event} event
 */
WebInspector._focusChanged = function(event)
{
    var node = event.deepActiveElement();
    WebInspector.setCurrentFocusElement(node);
}

/**
 * @param {!Document} document
 * @param {!Event} event
 */
WebInspector._documentBlurred = function(document, event)
{
    // We want to know when currentFocusElement loses focus to nowhere.
    // This is the case when event.relatedTarget is null (no element is being focused)
    // and document.activeElement is reset to default (this is not a window blur).
    if (!event.relatedTarget && document.activeElement === document.body)
      WebInspector.setCurrentFocusElement(null);
}

WebInspector._textInputTypes = ["text", "search", "tel", "url", "email", "password"].keySet();
WebInspector._isTextEditingElement = function(element)
{
    if (element instanceof HTMLInputElement)
        return element.type in WebInspector._textInputTypes;

    if (element instanceof HTMLTextAreaElement)
        return true;

    return false;
}

/**
 * @param {?Node} x
 */
WebInspector.setCurrentFocusElement = function(x)
{
    if (WebInspector._glassPane && x && !WebInspector._glassPane.element.isAncestor(x))
        return;
    if (WebInspector._currentFocusElement !== x)
        WebInspector._previousFocusElement = WebInspector._currentFocusElement;
    WebInspector._currentFocusElement = x;

    if (x) {
        x.focus();

        // Make a caret selection inside the new element if there isn't a range selection and there isn't already a caret selection inside.
        // This is needed (at least) to remove caret from console when focus is moved to some element in the panel.
        // The code below should not be applied to text fields and text areas, hence _isTextEditingElement check.
        var selection = x.getComponentSelection();
        if (!WebInspector._isTextEditingElement(x) && selection.isCollapsed && !x.isInsertionCaretInside()) {
            var selectionRange = x.ownerDocument.createRange();
            selectionRange.setStart(x, 0);
            selectionRange.setEnd(x, 0);

            selection.removeAllRanges();
            selection.addRange(selectionRange);
        }
    } else if (WebInspector._previousFocusElement)
        WebInspector._previousFocusElement.blur();
}

WebInspector.restoreFocusFromElement = function(element)
{
    if (element && element.isSelfOrAncestor(WebInspector.currentFocusElement()))
        WebInspector.setCurrentFocusElement(WebInspector.previousFocusElement());
}

/**
 * @param {!Element} element
 * @param {number} offset
 * @param {number} length
 * @param {!Array.<!Object>=} domChanges
 * @return {?Element}
 */
WebInspector.highlightSearchResult = function(element, offset, length, domChanges)
{
    var result = WebInspector.highlightSearchResults(element, [new WebInspector.SourceRange(offset, length)], domChanges);
    return result.length ? result[0] : null;
}

/**
 * @param {!Element} element
 * @param {!Array.<!WebInspector.SourceRange>} resultRanges
 * @param {!Array.<!Object>=} changes
 * @return {!Array.<!Element>}
 */
WebInspector.highlightSearchResults = function(element, resultRanges, changes)
{
    return WebInspector.highlightRangesWithStyleClass(element, resultRanges, WebInspector.highlightedSearchResultClassName, changes);
}

/**
 * @param {!Element} element
 * @param {string} className
 */
WebInspector.runCSSAnimationOnce = function(element, className)
{
    function animationEndCallback()
    {
        element.classList.remove(className);
        element.removeEventListener("webkitAnimationEnd", animationEndCallback, false);
    }

    if (element.classList.contains(className))
        element.classList.remove(className);

    element.addEventListener("webkitAnimationEnd", animationEndCallback, false);
    element.classList.add(className);
}

/**
 * @param {!Element} element
 * @param {!Array.<!WebInspector.SourceRange>} resultRanges
 * @param {string} styleClass
 * @param {!Array.<!Object>=} changes
 * @return {!Array.<!Element>}
 */
WebInspector.highlightRangesWithStyleClass = function(element, resultRanges, styleClass, changes)
{
    changes = changes || [];
    var highlightNodes = [];
    var textNodes = element.childTextNodes();
    var lineText = textNodes.map(function (node) { return node.textContent; }).join("");
    var ownerDocument = element.ownerDocument;

    if (textNodes.length === 0)
        return highlightNodes;

    var nodeRanges = [];
    var rangeEndOffset = 0;
    for (var i = 0; i < textNodes.length; ++i) {
        var range = {};
        range.offset = rangeEndOffset;
        range.length = textNodes[i].textContent.length;
        rangeEndOffset = range.offset + range.length;
        nodeRanges.push(range);
    }

    var startIndex = 0;
    for (var i = 0; i < resultRanges.length; ++i) {
        var startOffset = resultRanges[i].offset;
        var endOffset = startOffset + resultRanges[i].length;

        while (startIndex < textNodes.length && nodeRanges[startIndex].offset + nodeRanges[startIndex].length <= startOffset)
            startIndex++;
        var endIndex = startIndex;
        while (endIndex < textNodes.length && nodeRanges[endIndex].offset + nodeRanges[endIndex].length < endOffset)
            endIndex++;
        if (endIndex === textNodes.length)
            break;

        var highlightNode = ownerDocument.createElement("span");
        highlightNode.className = styleClass;
        highlightNode.textContent = lineText.substring(startOffset, endOffset);

        var lastTextNode = textNodes[endIndex];
        var lastText = lastTextNode.textContent;
        lastTextNode.textContent = lastText.substring(endOffset - nodeRanges[endIndex].offset);
        changes.push({ node: lastTextNode, type: "changed", oldText: lastText, newText: lastTextNode.textContent });

        if (startIndex === endIndex) {
            lastTextNode.parentElement.insertBefore(highlightNode, lastTextNode);
            changes.push({ node: highlightNode, type: "added", nextSibling: lastTextNode, parent: lastTextNode.parentElement });
            highlightNodes.push(highlightNode);

            var prefixNode = ownerDocument.createTextNode(lastText.substring(0, startOffset - nodeRanges[startIndex].offset));
            lastTextNode.parentElement.insertBefore(prefixNode, highlightNode);
            changes.push({ node: prefixNode, type: "added", nextSibling: highlightNode, parent: lastTextNode.parentElement });
        } else {
            var firstTextNode = textNodes[startIndex];
            var firstText = firstTextNode.textContent;
            var anchorElement = firstTextNode.nextSibling;

            firstTextNode.parentElement.insertBefore(highlightNode, anchorElement);
            changes.push({ node: highlightNode, type: "added", nextSibling: anchorElement, parent: firstTextNode.parentElement });
            highlightNodes.push(highlightNode);

            firstTextNode.textContent = firstText.substring(0, startOffset - nodeRanges[startIndex].offset);
            changes.push({ node: firstTextNode, type: "changed", oldText: firstText, newText: firstTextNode.textContent });

            for (var j = startIndex + 1; j < endIndex; j++) {
                var textNode = textNodes[j];
                var text = textNode.textContent;
                textNode.textContent = "";
                changes.push({ node: textNode, type: "changed", oldText: text, newText: textNode.textContent });
            }
        }
        startIndex = endIndex;
        nodeRanges[startIndex].offset = endOffset;
        nodeRanges[startIndex].length = lastTextNode.textContent.length;

    }
    return highlightNodes;
}

WebInspector.applyDomChanges = function(domChanges)
{
    for (var i = 0, size = domChanges.length; i < size; ++i) {
        var entry = domChanges[i];
        switch (entry.type) {
        case "added":
            entry.parent.insertBefore(entry.node, entry.nextSibling);
            break;
        case "changed":
            entry.node.textContent = entry.newText;
            break;
        }
    }
}

WebInspector.revertDomChanges = function(domChanges)
{
    for (var i = domChanges.length - 1; i >= 0; --i) {
        var entry = domChanges[i];
        switch (entry.type) {
        case "added":
            entry.node.remove();
            break;
        case "changed":
            entry.node.textContent = entry.oldText;
            break;
        }
    }
}

/**
 * @param {!Element} element
 * @param {?Element=} containerElement
 * @return {!Size}
 */
WebInspector.measurePreferredSize = function(element, containerElement)
{
    containerElement = containerElement || element.ownerDocument.body;
    containerElement.appendChild(element);
    element.positionAt(0, 0);
    var result = new Size(element.offsetWidth, element.offsetHeight);
    element.positionAt(undefined, undefined);
    element.remove();
    return result;
}

/**
 * @constructor
 * @param {boolean} autoInvoke
 */
WebInspector.InvokeOnceHandlers = function(autoInvoke)
{
    this._handlers = null;
    this._autoInvoke = autoInvoke;
}

WebInspector.InvokeOnceHandlers.prototype = {
    /**
     * @param {!Object} object
     * @param {function()} method
     */
    add: function(object, method)
    {
        if (!this._handlers) {
            this._handlers = new Map();
            if (this._autoInvoke)
                this.scheduleInvoke();
        }
        var methods = this._handlers.get(object);
        if (!methods) {
            methods = new Set();
            this._handlers.set(object, methods);
        }
        methods.add(method);
    },

    /**
     * @suppressGlobalPropertiesCheck
     */
    scheduleInvoke: function()
    {
        if (this._handlers)
            requestAnimationFrame(this._invoke.bind(this));
    },

    _invoke: function()
    {
        var handlers = this._handlers;
        this._handlers = null;
        var keys = handlers.keysArray();
        for (var i = 0; i < keys.length; ++i) {
            var object = keys[i];
            var methods = handlers.get(object).valuesArray();
            for (var j = 0; j < methods.length; ++j)
                methods[j].call(object);
        }
    }
}

WebInspector._coalescingLevel = 0;
WebInspector._postUpdateHandlers = null;

WebInspector.startBatchUpdate = function()
{
    if (!WebInspector._coalescingLevel++)
        WebInspector._postUpdateHandlers = new WebInspector.InvokeOnceHandlers(false);
}

WebInspector.endBatchUpdate = function()
{
    if (--WebInspector._coalescingLevel)
        return;
    WebInspector._postUpdateHandlers.scheduleInvoke();
    WebInspector._postUpdateHandlers = null;
}

/**
 * @param {!Object} object
 * @param {function()} method
 */
WebInspector.invokeOnceAfterBatchUpdate = function(object, method)
{
    if (!WebInspector._postUpdateHandlers)
        WebInspector._postUpdateHandlers = new WebInspector.InvokeOnceHandlers(true);
    WebInspector._postUpdateHandlers.add(object, method);
}

/**
 * @param {!Window} window
 * @param {!Function} func
 * @param {!Array.<{from:number, to:number}>} params
 * @param {number} frames
 * @param {function()=} animationComplete
 * @return {function()}
 */
WebInspector.animateFunction = function(window, func, params, frames, animationComplete)
{
    var values = new Array(params.length);
    var deltas = new Array(params.length);
    for (var i = 0; i < params.length; ++i) {
        values[i] = params[i].from;
        deltas[i] = (params[i].to - params[i].from) / frames;
    }

    var raf = window.requestAnimationFrame(animationStep);

    var framesLeft = frames;

    function animationStep()
    {
        if (--framesLeft < 0) {
            if (animationComplete)
                animationComplete();
            return;
        }
        for (var i = 0; i < params.length; ++i) {
            if (params[i].to > params[i].from)
                values[i] = Number.constrain(values[i] + deltas[i], params[i].from, params[i].to);
            else
                values[i] = Number.constrain(values[i] + deltas[i], params[i].to, params[i].from);
        }
        func.apply(null, values);
        raf = window.requestAnimationFrame(animationStep);
    }

    function cancelAnimation()
    {
        window.cancelAnimationFrame(raf);
    }

    return cancelAnimation;
}

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @param {!Element} element
 * @param {function(!Event)} callback
 */
WebInspector.LongClickController = function(element, callback)
{
    this._element = element;
    this._callback = callback;
    this._enable();
}

WebInspector.LongClickController.prototype = {
    reset: function()
    {
        if (this._longClickInterval) {
            clearInterval(this._longClickInterval);
            delete this._longClickInterval;
        }
    },

    _enable: function()
    {
        if (this._longClickData)
            return;
        var boundMouseDown = mouseDown.bind(this);
        var boundMouseUp = mouseUp.bind(this);
        var boundReset = this.reset.bind(this);

        this._element.addEventListener("mousedown", boundMouseDown, false);
        this._element.addEventListener("mouseout", boundReset, false);
        this._element.addEventListener("mouseup", boundMouseUp, false);
        this._element.addEventListener("click", boundReset, true);

        this._longClickData = { mouseUp: boundMouseUp, mouseDown: boundMouseDown, reset: boundReset };

        /**
         * @param {!Event} e
         * @this {WebInspector.LongClickController}
         */
        function mouseDown(e)
        {
            if (e.which !== 1)
                return;
            var callback = this._callback;
            this._longClickInterval = setTimeout(callback.bind(null, e), 200);
        }

        /**
         * @param {!Event} e
         * @this {WebInspector.LongClickController}
         */
        function mouseUp(e)
        {
            if (e.which !== 1)
                return;
            this.reset();
        }
    },

    dispose: function()
    {
        if (!this._longClickData)
            return;
        this._element.removeEventListener("mousedown", this._longClickData.mouseDown, false);
        this._element.removeEventListener("mouseout", this._longClickData.reset, false);
        this._element.removeEventListener("mouseup", this._longClickData.mouseUp, false);
        this._element.addEventListener("click", this._longClickData.reset, true);
        delete this._longClickData;
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @param {!Document} document
 * @param {!WebInspector.Setting} themeSetting
 */
WebInspector.initializeUIUtils = function(document, themeSetting)
{
    document.defaultView.addEventListener("focus", WebInspector._windowFocused.bind(WebInspector, document), false);
    document.defaultView.addEventListener("blur", WebInspector._windowBlurred.bind(WebInspector, document), false);
    document.addEventListener("focus", WebInspector._focusChanged.bind(WebInspector), true);
    document.addEventListener("blur", WebInspector._documentBlurred.bind(WebInspector, document), true);

    if (!WebInspector.themeSupport)
        WebInspector.themeSupport = new WebInspector.ThemeSupport(themeSetting);
    WebInspector.themeSupport.applyTheme(document);

    var body = /** @type {!Element} */ (document.body);
    WebInspector.appendStyle(body, "ui/inspectorStyle.css");
    WebInspector.appendStyle(body, "ui/popover.css");
    WebInspector.appendStyle(body, "ui/sidebarPane.css");

}

/**
 * @param {string} name
 * @return {string}
 */
WebInspector.beautifyFunctionName = function(name)
{
    return name || WebInspector.UIString("(anonymous function)");
}

/**
 * @param {string} localName
 * @param {string} typeExtension
 * @param {!Object} prototype
 * @return {function()}
 * @suppressGlobalPropertiesCheck
 * @template T
 */
function registerCustomElement(localName, typeExtension, prototype)
{
    return document.registerElement(typeExtension, {
        prototype: Object.create(prototype),
        extends: localName
    });
}

/**
 * @param {string} text
 * @param {function(!Event)=} clickHandler
 * @param {string=} className
 * @param {string=} title
 * @return {!Element}
 */
function createTextButton(text, clickHandler, className, title)
{
    var element = createElementWithClass("button", className || "", "text-button");
    element.textContent = text;
    if (clickHandler)
        element.addEventListener("click", clickHandler, false);
    if (title)
        element.title = title;
    return element;
}

/**
 * @param {string} name
 * @param {string} title
 * @param {boolean=} checked
 * @return {!Element}
 */
function createRadioLabel(name, title, checked)
{
    var element = createElement("label", "dt-radio");
    element.radioElement.name = name;
    element.radioElement.checked = !!checked;
    element.createTextChild(title);
    return element;
}

/**
 * @param {string=} title
 * @param {boolean=} checked
 * @return {!Element}
 */
function createCheckboxLabel(title, checked)
{
    var element = createElement("label", "dt-checkbox");
    element.checkboxElement.checked = !!checked;
    if (title !== undefined) {
        element.textElement = element.createChild("div", "dt-checkbox-text");
        element.textElement.textContent = title;
    }
    return element;
}

/**
 * @param {!Node} node
 * @param {string} cssFile
 * @suppressGlobalPropertiesCheck
 */
WebInspector.appendStyle = function(node, cssFile)
{
    var content = Runtime.cachedResources[cssFile] || "";
    if (!content)
        console.error(cssFile + " not preloaded. Check module.json");
    var styleElement = createElement("style");
    styleElement.type = "text/css";
    styleElement.textContent = content;
    node.appendChild(styleElement);

    var themeStyleSheet = WebInspector.themeSupport.themeStyleSheet(cssFile, content);
    if (themeStyleSheet) {
        styleElement = createElement("style");
        styleElement.type = "text/css";
        styleElement.textContent = themeStyleSheet + "\n" + Runtime.resolveSourceURL(cssFile + ".theme");
        node.appendChild(styleElement);
    }
}

;(function() {
    registerCustomElement("button", "text-button", {
        /**
         * @this {Element}
         */
        createdCallback: function()
        {
            this.type = "button";
            var root = WebInspector.createShadowRootWithCoreStyles(this, "ui/textButton.css");
            root.createChild("content");
        },

        __proto__: HTMLButtonElement.prototype
    });

    registerCustomElement("label", "dt-radio", {
        /**
         * @this {Element}
         */
        createdCallback: function()
        {
            this.radioElement = this.createChild("input", "dt-radio-button");
            this.radioElement.type = "radio";
            var root = WebInspector.createShadowRootWithCoreStyles(this, "ui/radioButton.css");
            root.createChild("content").select = ".dt-radio-button";
            root.createChild("content");
            this.addEventListener("click", radioClickHandler, false);
        },

        __proto__: HTMLLabelElement.prototype
    });

    /**
     * @param {!Event} event
     * @suppressReceiverCheck
     * @this {Element}
     */
    function radioClickHandler(event)
    {
        if (this.radioElement.checked || this.radioElement.disabled)
            return;
        this.radioElement.checked = true;
        this.radioElement.dispatchEvent(new Event("change"));
    }

    registerCustomElement("label", "dt-checkbox", {
        /**
         * @this {Element}
         */
        createdCallback: function()
        {
            this._root = WebInspector.createShadowRootWithCoreStyles(this, "ui/checkboxTextLabel.css");
            var checkboxElement = createElementWithClass("input", "dt-checkbox-button");
            checkboxElement.type = "checkbox";
            this._root.appendChild(checkboxElement);
            this.checkboxElement = checkboxElement;

            this.addEventListener("click", toggleCheckbox.bind(this));

            /**
             * @param {!Event} event
             * @this {Node}
             */
            function toggleCheckbox(event)
            {
                if (event.target !== checkboxElement && event.target !== this) {
                    event.consume();
                    checkboxElement.click();
                }
            }

            this._root.createChild("content");
        },

        /**
         * @param {string} color
         * @this {Element}
         */
        set backgroundColor(color)
        {
            this.checkboxElement.classList.add("dt-checkbox-themed");
            this.checkboxElement.style.backgroundColor = color;
        },

        /**
         * @param {string} color
         * @this {Element}
         */
        set checkColor(color)
        {
            this.checkboxElement.classList.add("dt-checkbox-themed");
            var stylesheet = createElement("style");
            stylesheet.textContent = "input.dt-checkbox-themed:checked:after { background-color: " + color + "}";
            this._root.appendChild(stylesheet);
        },

        /**
         * @param {string} color
         * @this {Element}
         */
        set borderColor(color)
        {
            this.checkboxElement.classList.add("dt-checkbox-themed");
            this.checkboxElement.style.borderColor = color;
        },

        __proto__: HTMLLabelElement.prototype
    });

    registerCustomElement("label", "dt-icon-label", {
        /**
         * @this {Element}
         */
        createdCallback: function()
        {
            var root = WebInspector.createShadowRootWithCoreStyles(this, "ui/smallIcon.css");
            this._iconElement = root.createChild("div");
            root.createChild("content");
        },

        /**
         * @param {string} type
         * @this {Element}
         */
        set type(type)
        {
            this._iconElement.className = type;
        },

        __proto__: HTMLLabelElement.prototype
    });

    registerCustomElement("div", "dt-close-button", {
        /**
         * @this {Element}
         */
        createdCallback: function()
        {
            var root = WebInspector.createShadowRootWithCoreStyles(this, "ui/closeButton.css");
            this._buttonElement = root.createChild("div", "close-button");
        },

        /**
         * @param {boolean} gray
         * @this {Element}
         */
        set gray(gray)
        {
            this._buttonElement.className = gray ? "close-button-gray" : "close-button";
        },

        __proto__: HTMLDivElement.prototype
    });
})();

/**
 * @param {!Element} input
 * @param {function(string)} apply
 * @param {function(string):boolean} validate
 * @param {boolean} numeric
 * @return {function(string)}
 */
WebInspector.bindInput = function(input, apply, validate, numeric)
{
    input.addEventListener("change", onChange, false);
    input.addEventListener("input", onInput, false);
    input.addEventListener("keydown", onKeyDown, false);
    input.addEventListener("focus", input.select.bind(input), false);

    function onInput()
    {
        input.classList.toggle("error-input", !validate(input.value));
    }

    function onChange()
    {
        var valid = validate(input.value);
        input.classList.toggle("error-input", !valid);
        if (valid)
            apply(input.value);
    }

    /**
     * @param {!Event} event
     */
    function onKeyDown(event)
    {
        if (isEnterKey(event)) {
            if (validate(input.value))
                apply(input.value);
            return;
        }

        if (!numeric)
            return;

        var increment = event.keyIdentifier === "Up" ? 1 : event.keyIdentifier === "Down" ? -1 : 0;
        if (!increment)
            return;
        if (event.shiftKey)
            increment *= 10;

        var value = input.value;
        if (!validate(value) || !value)
            return;

        value = (value ? Number(value) : 0) + increment;
        var stringValue = value ? String(value) : "";
        if (!validate(stringValue) || !value)
            return;

        input.value = stringValue;
        apply(input.value);
        event.preventDefault();
    }

    /**
     * @param {string} value
     */
    function setValue(value)
    {
        if (value === input.value)
            return;
        var valid = validate(value);
        input.classList.toggle("error-input", !valid);
        input.value = value;
        input.setSelectionRange(value.length, value.length);
    }

    return setValue;
}

/**
 * @constructor
 */
WebInspector.StringFormatter = function()
{
    this._processors = [];
    this._regexes = [];
}

WebInspector.StringFormatter.prototype = {
    /**
     * @param {!RegExp} regex
     * @param {function(string):!Node} handler
     */
    addProcessor: function(regex, handler)
    {
        this._regexes.push(regex);
        this._processors.push(handler);
    },

    /**
     * @param {string} text
     * @return {!Node}
     */
    formatText: function(text)
    {
        return this._runProcessor(0, text);
    },

    /**
     * @param {number} processorIndex
     * @param {string} text
     * @return {!Node}
     */
    _runProcessor: function(processorIndex, text)
    {
        if (processorIndex >= this._processors.length)
            return createTextNode(text);

        var container = createDocumentFragment();
        var regex = this._regexes[processorIndex];
        var processor = this._processors[processorIndex];

        // Due to the nature of regex, |items| array has matched elements on its even indexes.
        var items = text.replace(regex, "\0$1\0").split("\0");
        for (var i = 0; i < items.length; ++i) {
            var processedNode = i % 2 ? processor(items[i]) : this._runProcessor(processorIndex + 1, items[i]);
            container.appendChild(processedNode);
        }

        return container;
    }
}

/**
 * @constructor
 * @param {!WebInspector.Setting} setting
 */
WebInspector.ThemeSupport = function(setting)
{
    this._themeName = setting.get() || "default";
    this._themableProperties = new Set([
        "color", "box-shadow", "text-shadow", "outline-color",
        "background-image", "background-color",
        "border-left-color", "border-right-color", "border-top-color", "border-bottom-color",
        "-webkit-border-image"]);
    /** @type {!Map<string, string>} */
    this._cachedThemePatches = new Map();
    this._setting = setting;
}

WebInspector.ThemeSupport.prototype = {
    /**
     * @return {boolean}
     */
    hasTheme: function()
    {
        return this._themeName !== "default";
    },

    /**
     * @param {!Element} element
     */
    injectHighlightStyleSheets: function(element)
    {
        this._injectingStyleSheet = true;
        WebInspector.appendStyle(element, "ui/inspectorSyntaxHighlight.css");
        if (this._themeName === "dark")
            WebInspector.appendStyle(element, "ui/inspectorSyntaxHighlightDark.css");
        this._injectingStyleSheet = false;
    },

    /**
     * @param {!Document} document
     */
    applyTheme: function(document)
    {
        if (!this.hasTheme())
            return;

        if (this._themeName === "dark")
            document.body.classList.add("-theme-with-dark-background");

        var styleSheets = document.styleSheets;
        var result = [];
        for (var i = 0; i < styleSheets.length; ++i)
            result.push(this._patchForTheme(styleSheets[i].href, styleSheets[i]));
        result.push("/*# sourceURL=inspector.css.theme */");

        var styleElement = createElement("style");
        styleElement.type = "text/css";
        styleElement.textContent = result.join("\n");
        document.head.appendChild(styleElement);
    },

    /**
     * @param {string} id
     * @param {string} text
     * @return {string}
     * @suppressGlobalPropertiesCheck
     */
    themeStyleSheet: function(id, text)
    {
        if (!this.hasTheme() || this._injectingStyleSheet)
            return "";

        var patch = this._cachedThemePatches.get(id);
        if (!patch) {
            var styleElement = createElement("style");
            styleElement.type = "text/css";
            styleElement.textContent = text;
            document.body.appendChild(styleElement);
            patch = this._patchForTheme(id, styleElement.sheet);
            document.body.removeChild(styleElement);
        }
        return patch;
    },

    /**
     * @param {string} id
     * @param {!CSSStyleSheet} styleSheet
     * @return {string}
     */
    _patchForTheme: function(id, styleSheet)
    {
        var cached = this._cachedThemePatches.get(id);
        if (cached)
            return cached;

        try {
            var rules = styleSheet.cssRules;
            var result = [];
            for (var j = 0; j < rules.length; ++j) {
                if (rules[j] instanceof CSSImportRule) {
                    result.push(this._patchForTheme(rules[j].styleSheet.href, rules[j].styleSheet));
                    continue;
                }
                var output = [];
                var style = rules[j].style;
                var selectorText = rules[j].selectorText;
                for (var i = 0; style && i < style.length; ++i)
                    this._patchProperty(selectorText, style, style[i], output);
                if (output.length)
                    result.push(rules[j].selectorText + "{" + output.join("") + "}");
            }

            var fullText = result.join("\n");
            this._cachedThemePatches.set(id, fullText);
            return fullText;
        } catch(e) {
           this._setting.set("default");
           return "";
        }
    },

    /**
     * @param {string} selectorText
     * @param {!CSSStyleDeclaration} style
     * @param {string} name
     * @param {!Array<string>} output
     *
     * Theming API is primarily targeted at making dark theme look good.
     * - If rule has ".-theme-preserve" in selector, it won't be affected.
     * - If rule has ".selection" or "selected" or "-theme-selection-color" in selector, its hue is rotated 180deg in dark themes.
     * - One can create specializations for dark themes via body.-theme-with-dark-background selector in host context.
     */
    _patchProperty: function(selectorText, style, name, output)
    {
        if (!this._themableProperties.has(name))
            return;

        var value = style.getPropertyValue(name);
        if (!value || value === "none" || value === "inherit" || value === "initial" || value === "transparent")
            return;
        if (name === "background-image" && value.indexOf("gradient") === -1)
            return;

        var isSelection = selectorText.indexOf(".-theme-selection-color") !== -1;
        if (selectorText.indexOf("-theme-") !== -1 && !isSelection)
            return;

        if (name === "-webkit-border-image") {
            output.push("-webkit-filter: invert(100%)");
            return;
        }

        isSelection = isSelection || selectorText.indexOf("selected") !== -1 || selectorText.indexOf(".selection") !== -1;
        var isBackground = name.indexOf("background") === 0 || name.indexOf("border") === 0;
        var isForeground = name.indexOf("background") === -1;

        var colorRegex = /((?:rgb|hsl)a?\([^)]+\)|#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3}|\b\w+\b(?!-))/g;
        output.push(name);
        output.push(":");
        var items = value.replace(colorRegex, "\0$1\0").split("\0");
        for (var i = 0; i < items.length; ++i)
            output.push(this._patchColor(items[i], isSelection, isBackground, isForeground));
        if (style.getPropertyPriority(name))
            output.push(" !important");
        output.push(";");
    },

    /**
     * @param {string} text
     * @param {boolean} isSelection
     * @param {boolean} isBackground
     * @param {boolean} isForeground
     * @return {string}
     */
    _patchColor: function(text, isSelection, isBackground, isForeground)
    {
        var color = WebInspector.Color.parse(text);
        if (!color)
            return text;

        var hsla = color.hsla();
        this._patchHSLA(hsla, isSelection, isBackground, isForeground);
        var rgba = [];
        WebInspector.Color.hsl2rgb(hsla, rgba);
        var outColor = new WebInspector.Color(rgba, color.format());
        var outText = outColor.asString(null);
        if (!outText)
            outText = outColor.asString(outColor.hasAlpha() ? WebInspector.Color.Format.RGBA : WebInspector.Color.Format.RGB);
        return outText || text;
    },

    /**
     * @param {!Array<number>} hsla
     * @param {boolean} isSelection
     * @param {boolean} isBackground
     * @param {boolean} isForeground
     */
    _patchHSLA: function(hsla, isSelection, isBackground, isForeground)
    {
        var hue = hsla[0];
        var sat = hsla[1];
        var lit = hsla[2];
        var alpha = hsla[3]

        switch (this._themeName) {
        case "dark":
            if (isSelection)
                hue = (hue + 0.5) % 1;
            var minCap = isBackground ? 0.14 : 0;
            var maxCap = isForeground ? 0.9 : 1;
            lit = 1 - lit;
            if (lit < minCap * 2)
                lit = minCap + lit / 2;
            else if (lit > 2 * maxCap - 1)
                lit = maxCap - 1 / 2 + lit / 2;

            break;
        }
        hsla[0] = Number.constrain(hue, 0, 1);
        hsla[1] = Number.constrain(sat, 0, 1);
        hsla[2] = Number.constrain(lit, 0, 1);
        hsla[3] = Number.constrain(alpha, 0, 1);
    }
}

/**
 * @param {?NetworkAgent.ResourcePriority} priority
 * @return {string}
 */
WebInspector.uiLabelForPriority = function(priority)
{
    var labelMap = WebInspector.uiLabelForPriority._priorityToUILabel;
    if (!labelMap) {
        labelMap = new Map([
            [NetworkAgent.ResourcePriority.VeryLow, WebInspector.UIString("Lowest")],
            [NetworkAgent.ResourcePriority.Low, WebInspector.UIString("Low")],
            [NetworkAgent.ResourcePriority.Medium, WebInspector.UIString("Medium")],
            [NetworkAgent.ResourcePriority.High, WebInspector.UIString("High")],
            [NetworkAgent.ResourcePriority.VeryHigh, WebInspector.UIString("Highest")]
        ]);
        WebInspector.uiLabelForPriority._priorityToUILabel = labelMap;
    }
    return labelMap.get(priority) || WebInspector.UIString("Unknown");
}

/** @type {!WebInspector.ThemeSupport} */
WebInspector.themeSupport;
;/* ViewportControl.js */
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {!WebInspector.ViewportControl.Provider} provider
 */
WebInspector.ViewportControl = function(provider)
{
    this.element = createElement("div");
    this.element.style.overflow = "auto";
    this._topGapElement = this.element.createChild("div");
    this._topGapElement.style.height = "0px";
    this._topGapElement.style.color = "transparent";
    this._contentElement = this.element.createChild("div");
    this._bottomGapElement = this.element.createChild("div");
    this._bottomGapElement.style.height = "0px";
    this._bottomGapElement.style.color = "transparent";

    // Text content needed for range intersection checks in _updateSelectionModel.
    // Use Unicode ZERO WIDTH NO-BREAK SPACE, which avoids contributing any height to the element's layout overflow.
    this._topGapElement.textContent = "\uFEFF";
    this._bottomGapElement.textContent = "\uFEFF";

    this._provider = provider;
    this.element.addEventListener("scroll", this._onScroll.bind(this), false);
    this.element.addEventListener("copy", this._onCopy.bind(this), false);
    this.element.addEventListener("dragstart", this._onDragStart.bind(this), false);

    this._firstVisibleIndex = 0;
    this._lastVisibleIndex = -1;
    this._renderedItems = [];
    this._anchorSelection = null;
    this._headSelection = null;
    this._stickToBottom = false;
    this._scrolledToBottom = true;
    this._itemCount = 0;
}

/**
 * @interface
 */
WebInspector.ViewportControl.Provider = function()
{
}

WebInspector.ViewportControl.Provider.prototype = {
    /**
     * @param {number} index
     * @return {number}
     */
    fastHeight: function(index) { return 0; },

    /**
     * @return {number}
     */
    itemCount: function() { return 0; },

    /**
     * @return {number}
     */
    minimumRowHeight: function() { return 0; },

    /**
     * @param {number} index
     * @return {?WebInspector.ViewportElement}
     */
    itemElement: function(index) { return null; }
}

/**
 * @interface
 */
WebInspector.ViewportElement = function() { }
WebInspector.ViewportElement.prototype = {
    willHide: function() { },

    wasShown: function() { },

    /**
     * @return {!Element}
     */
    element: function() { },
}

/**
 * @constructor
 * @implements {WebInspector.ViewportElement}
 * @param {!Element} element
 */
WebInspector.StaticViewportElement = function(element)
{
    this._element = element;
}

WebInspector.StaticViewportElement.prototype = {
    /**
     * @override
     */
    willHide: function() { },

    /**
     * @override
     */
    wasShown: function() { },

    /**
     * @override
     * @return {!Element}
     */
    element: function()
    {
        return this._element;
    },
}

WebInspector.ViewportControl.prototype = {
    /**
     * @return {boolean}
     */
    scrolledToBottom: function()
    {
        return this._scrolledToBottom;
    },

    /**
     * @param {boolean} value
     */
    setStickToBottom: function(value)
    {
        this._stickToBottom = value;
    },

    /**
     * @param {!Event} event
     */
    _onCopy: function(event)
    {
        var text = this._selectedText();
        if (!text)
            return;
        event.preventDefault();
        event.clipboardData.setData("text/plain", text);
    },

    /**
     * @param {!Event} event
     */
    _onDragStart: function(event)
    {
        var text = this._selectedText();
        if (!text)
            return false;
        event.dataTransfer.clearData();
        event.dataTransfer.setData("text/plain", text);
        event.dataTransfer.effectAllowed = "copy";
        return true;
    },

    /**
     * @return {!Element}
     */
    contentElement: function()
    {
        return this._contentElement;
    },

    invalidate: function()
    {
        delete this._cumulativeHeights;
        delete this._cachedProviderElements;
        this._itemCount = this._provider.itemCount();
        this._innerRefresh(false);
    },

    /**
     * @param {number} index
     * @return {?WebInspector.ViewportElement}
     */
    _providerElement: function(index)
    {
        if (!this._cachedProviderElements)
            this._cachedProviderElements = new Array(this._itemCount);
        var element = this._cachedProviderElements[index];
        if (!element) {
            element = this._provider.itemElement(index);
            this._cachedProviderElements[index] = element;
        }
        return element;
    },

    _rebuildCumulativeHeightsIfNeeded: function()
    {
        if (this._cumulativeHeights)
            return;
        if (!this._itemCount)
            return;
        var firstVisibleIndex = this._firstVisibleIndex;
        var lastVisibleIndex = this._lastVisibleIndex;
        var height = 0;
        this._cumulativeHeights = new Int32Array(this._itemCount);
        for (var i = 0; i < this._itemCount; ++i) {
            if (firstVisibleIndex <= i && i <= lastVisibleIndex)
                height += this._renderedItems[i - firstVisibleIndex].element().offsetHeight;
            else
                height += this._provider.fastHeight(i);
            this._cumulativeHeights[i] = height;
        }
    },

    /**
     * @param {number} index
     * @return {number}
     */
    _cachedItemHeight: function(index)
    {
        return index === 0 ? this._cumulativeHeights[0] : this._cumulativeHeights[index] - this._cumulativeHeights[index - 1];
    },

    /**
     * @param {?Selection} selection
     * @suppressGlobalPropertiesCheck
     */
    _isSelectionBackwards: function(selection)
    {
        if (!selection || !selection.rangeCount)
            return false;
        var range = document.createRange();
        range.setStart(selection.anchorNode, selection.anchorOffset);
        range.setEnd(selection.focusNode, selection.focusOffset);
        return range.collapsed;
    },

    /**
     * @param {number} itemIndex
     * @param {!Node} node
     * @param {number} offset
     * @return {!{item: number, node: !Node, offset: number}}
     */
    _createSelectionModel: function(itemIndex, node, offset)
    {
        return {
            item: itemIndex,
            node: node,
            offset: offset
        };
    },

    /**
     * @param {?Selection} selection
     */
    _updateSelectionModel: function(selection)
    {
        if (!selection || !selection.rangeCount || selection.isCollapsed) {
            this._headSelection = null;
            this._anchorSelection = null;
            return false;
        }

        var firstSelected = Number.MAX_VALUE;
        var lastSelected = -1;

        var range = selection.getRangeAt(0);
        var hasVisibleSelection = false;
        for (var i = 0; i < this._renderedItems.length; ++i) {
            if (range.intersectsNode(this._renderedItems[i].element())) {
                var index = i + this._firstVisibleIndex;
                firstSelected = Math.min(firstSelected, index);
                lastSelected = Math.max(lastSelected, index);
                hasVisibleSelection = true;
            }
        }
        if (hasVisibleSelection) {
            firstSelected = this._createSelectionModel(firstSelected, /** @type {!Node} */(range.startContainer), range.startOffset);
            lastSelected = this._createSelectionModel(lastSelected, /** @type {!Node} */(range.endContainer), range.endOffset);
        }
        var topOverlap = range.intersectsNode(this._topGapElement) && this._topGapElement._active;
        var bottomOverlap = range.intersectsNode(this._bottomGapElement) && this._bottomGapElement._active;
        if (!topOverlap && !bottomOverlap && !hasVisibleSelection) {
            this._headSelection = null;
            this._anchorSelection = null;
            return false;
        }

        if (!this._anchorSelection || !this._headSelection) {
            this._anchorSelection = this._createSelectionModel(0, this.element, 0);
            this._headSelection = this._createSelectionModel(this._itemCount - 1, this.element, this.element.children.length);
            this._selectionIsBackward = false;
        }

        var isBackward = this._isSelectionBackwards(selection);
        var startSelection = this._selectionIsBackward ? this._headSelection : this._anchorSelection;
        var endSelection = this._selectionIsBackward ? this._anchorSelection : this._headSelection;
        if (topOverlap && bottomOverlap && hasVisibleSelection) {
            firstSelected = firstSelected.item < startSelection.item ? firstSelected : startSelection;
            lastSelected = lastSelected.item > endSelection.item ? lastSelected : endSelection;
        } else if (!hasVisibleSelection) {
            firstSelected = startSelection;
            lastSelected = endSelection;
        } else if (topOverlap)
            firstSelected = isBackward ? this._headSelection : this._anchorSelection;
        else if (bottomOverlap)
            lastSelected = isBackward ? this._anchorSelection : this._headSelection;

        if (isBackward) {
            this._anchorSelection = lastSelected;
            this._headSelection = firstSelected;
        } else {
            this._anchorSelection = firstSelected;
            this._headSelection = lastSelected;
        }
        this._selectionIsBackward = isBackward;
        return true;
    },

    /**
     * @param {?Selection} selection
     */
    _restoreSelection: function(selection)
    {
        var anchorElement = null;
        var anchorOffset;
        if (this._firstVisibleIndex <= this._anchorSelection.item && this._anchorSelection.item <= this._lastVisibleIndex) {
            anchorElement = this._anchorSelection.node;
            anchorOffset = this._anchorSelection.offset;
        } else {
            if (this._anchorSelection.item < this._firstVisibleIndex)
                anchorElement = this._topGapElement;
            else if (this._anchorSelection.item > this._lastVisibleIndex)
                anchorElement = this._bottomGapElement;
            anchorOffset = this._selectionIsBackward ? 1 : 0;
        }

        var headElement = null;
        var headOffset;
        if (this._firstVisibleIndex <= this._headSelection.item && this._headSelection.item <= this._lastVisibleIndex) {
            headElement = this._headSelection.node;
            headOffset = this._headSelection.offset;
        } else {
            if (this._headSelection.item < this._firstVisibleIndex)
                headElement = this._topGapElement;
            else if (this._headSelection.item > this._lastVisibleIndex)
                headElement = this._bottomGapElement;
            headOffset = this._selectionIsBackward ? 0 : 1;
        }

        selection.setBaseAndExtent(anchorElement, anchorOffset, headElement, headOffset);
    },

    refresh: function()
    {
        this._innerRefresh(false);
    },

    /**
     * @param {boolean} isUserGesture
     */
    _innerRefresh: function(isUserGesture)
    {
        if (!this._visibleHeight())
            return;  // Do nothing for invisible controls.

        if (!this._itemCount) {
            for (var i = 0; i < this._renderedItems.length; ++i)
                this._renderedItems[i].willHide();
            this._renderedItems = [];
            this._contentElement.removeChildren();
            this._topGapElement.style.height = "0px";
            this._bottomGapElement.style.height = "0px";
            this._firstVisibleIndex = -1;
            this._lastVisibleIndex = -1;
            return;
        }

        var selection = this.element.getComponentSelection();
        var shouldRestoreSelection = this._updateSelectionModel(selection);

        var visibleFrom = this.element.scrollTop;
        var visibleHeight = this._visibleHeight();
        this._scrolledToBottom = this.element.isScrolledToBottom();
        var isInvalidating = !this._cumulativeHeights;

        for (var i = 0; i < this._renderedItems.length; ++i) {
            // Tolerate 1-pixel error due to double-to-integer rounding errors.
            if (this._cumulativeHeights && Math.abs(this._cachedItemHeight(this._firstVisibleIndex + i) - this._renderedItems[i].element().offsetHeight) > 1)
                delete this._cumulativeHeights;
        }
        this._rebuildCumulativeHeightsIfNeeded();
        var oldFirstVisibleIndex = this._firstVisibleIndex;
        var oldLastVisibleIndex = this._lastVisibleIndex;

        var shouldStickToBottom = !isUserGesture && this._stickToBottom && this._scrolledToBottom;

        if (shouldStickToBottom) {
            this._lastVisibleIndex = this._itemCount - 1;
            this._firstVisibleIndex = Math.max(this._itemCount - Math.ceil(visibleHeight / this._provider.minimumRowHeight()), 0);
        } else {
            this._firstVisibleIndex = Math.max(Array.prototype.lowerBound.call(this._cumulativeHeights, visibleFrom + 1), 0);
            // Proactively render more rows in case some of them will be collapsed without triggering refresh. @see crbug.com/390169
            this._lastVisibleIndex = this._firstVisibleIndex + Math.ceil(visibleHeight / this._provider.minimumRowHeight()) - 1;
            this._lastVisibleIndex = Math.min(this._lastVisibleIndex, this._itemCount - 1);
        }
        var topGapHeight = this._cumulativeHeights[this._firstVisibleIndex - 1] || 0;
        var bottomGapHeight = this._cumulativeHeights[this._cumulativeHeights.length - 1] - this._cumulativeHeights[this._lastVisibleIndex];

        /**
         * @this {WebInspector.ViewportControl}
         */
        function prepare()
        {
            this._topGapElement.style.height = topGapHeight + "px";
            this._bottomGapElement.style.height = bottomGapHeight + "px";
            this._topGapElement._active = !!topGapHeight;
            this._bottomGapElement._active = !!bottomGapHeight;
            this._contentElement.style.setProperty("height", "10000000px");
        }

        if (isInvalidating)
            this._fullViewportUpdate(prepare.bind(this));
        else
            this._partialViewportUpdate(oldFirstVisibleIndex, oldLastVisibleIndex, prepare.bind(this));
        this._contentElement.style.removeProperty("height");
        // Should be the last call in the method as it might force layout.
        if (shouldRestoreSelection)
            this._restoreSelection(selection);
        if (shouldStickToBottom)
            this.element.scrollTop = 10000000;
    },

    /**
     * @param {function()} prepare
     */
    _fullViewportUpdate: function(prepare)
    {
        for (var i = 0; i < this._renderedItems.length; ++i)
            this._renderedItems[i].willHide();
        prepare();
        this._renderedItems = [];
        this._contentElement.removeChildren();
        for (var i = this._firstVisibleIndex; i <= this._lastVisibleIndex; ++i) {
            var viewportElement = this._providerElement(i);
            this._contentElement.appendChild(viewportElement.element());
            this._renderedItems.push(viewportElement);
        }
        for (var i = 0; i < this._renderedItems.length; ++i)
            this._renderedItems[i].wasShown();
    },

    /**
     * @param {number} oldFirstVisibleIndex
     * @param {number} oldLastVisibleIndex
     * @param {function()} prepare
     */
    _partialViewportUpdate: function(oldFirstVisibleIndex, oldLastVisibleIndex, prepare)
    {
        var willBeHidden = [];
        for (var i = 0; i < this._renderedItems.length; ++i) {
            var index = oldFirstVisibleIndex + i;
            if (index < this._firstVisibleIndex || this._lastVisibleIndex < index)
                willBeHidden.push(this._renderedItems[i]);
        }
        for (var i = 0; i < willBeHidden.length; ++i)
            willBeHidden[i].willHide();
        prepare();
        for (var i = 0; i < willBeHidden.length; ++i)
            willBeHidden[i].element().remove();

        this._renderedItems = [];
        var anchor = this._contentElement.firstChild;
        var wasShown = [];
        for (var i = this._firstVisibleIndex; i <= this._lastVisibleIndex; ++i) {
            var viewportElement = this._providerElement(i);
            var element = viewportElement.element();
            if (element !== anchor) {
                this._contentElement.insertBefore(element, anchor);
                wasShown.push(viewportElement);
            } else {
                anchor = anchor.nextSibling;
            }
            this._renderedItems.push(viewportElement);
        }
        for (var i = 0; i < wasShown.length; ++i)
            wasShown[i].wasShown();
    },

    /**
     * @return {?string}
     */
    _selectedText: function()
    {
        this._updateSelectionModel(this.element.getComponentSelection());
        if (!this._headSelection || !this._anchorSelection)
            return null;

        var startSelection = null;
        var endSelection = null;
        if (this._selectionIsBackward) {
            startSelection = this._headSelection;
            endSelection = this._anchorSelection;
        } else {
            startSelection = this._anchorSelection;
            endSelection = this._headSelection;
        }

        var textLines = [];
        for (var i = startSelection.item; i <= endSelection.item; ++i)
            textLines.push(this._providerElement(i).element().deepTextContent());

        var endSelectionElement = this._providerElement(endSelection.item).element();
        if (endSelection.node && endSelection.node.isSelfOrDescendant(endSelectionElement)) {
            var itemTextOffset = this._textOffsetInNode(endSelectionElement, endSelection.node, endSelection.offset);
            textLines[textLines.length - 1] = textLines.peekLast().substring(0, itemTextOffset);
        }

        var startSelectionElement = this._providerElement(startSelection.item).element();
        if (startSelection.node && startSelection.node.isSelfOrDescendant(startSelectionElement)) {
            var itemTextOffset = this._textOffsetInNode(startSelectionElement, startSelection.node, startSelection.offset);
            textLines[0] = textLines[0].substring(itemTextOffset);
        }

        return textLines.join("\n");
    },

    /**
     * @param {!Element} itemElement
     * @param {!Node} container
     * @param {number} offset
     * @return {number}
     */
    _textOffsetInNode: function(itemElement, container, offset)
    {
        var chars = 0;
        var node = itemElement;
        while ((node = node.traverseNextTextNode()) && node !== container)
            chars += node.textContent.length;
        return chars + offset;
    },

    /**
     * @param {!Event} event
     */
    _onScroll: function(event)
    {
        this._innerRefresh(event.isTrusted);
    },

    /**
     * @return {number}
     */
    firstVisibleIndex: function()
    {
        return this._firstVisibleIndex;
    },

    /**
     * @return {number}
     */
    lastVisibleIndex: function()
    {
        return this._lastVisibleIndex;
    },

    /**
     * @return {?Element}
     */
    renderedElementAt: function(index)
    {
        if (index < this._firstVisibleIndex)
            return null;
        if (index > this._lastVisibleIndex)
            return null;
        return this._renderedItems[index - this._firstVisibleIndex].element();
    },

    /**
     * @param {number} index
     * @param {boolean=} makeLast
     */
    scrollItemIntoView: function(index, makeLast)
    {
        if (index > this._firstVisibleIndex && index < this._lastVisibleIndex)
            return;
        if (makeLast)
            this.forceScrollItemToBeLast(index);
        else if (index <= this._firstVisibleIndex)
            this.forceScrollItemToBeFirst(index);
        else if (index >= this._lastVisibleIndex)
            this.forceScrollItemToBeLast(index);
    },

    /**
     * @param {number} index
     */
    forceScrollItemToBeFirst: function(index)
    {
        this._rebuildCumulativeHeightsIfNeeded();
        this.element.scrollTop = index > 0 ? this._cumulativeHeights[index - 1] : 0;
        this._innerRefresh(false);
    },

    /**
     * @param {number} index
     */
    forceScrollItemToBeLast: function(index)
    {
        this._rebuildCumulativeHeightsIfNeeded();
        this.element.scrollTop = this._cumulativeHeights[index] - this._visibleHeight();
        this._innerRefresh(false);
    },

    /**
     * @return {number}
     */
    _visibleHeight: function()
    {
        // Use offsetHeight instead of clientHeight to avoid being affected by horizontal scroll.
        return this.element.offsetHeight;
    }
}
;/* ZoomManager.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @param {!Window} window
 * @param {!InspectorFrontendHostAPI} frontendHost
 */
WebInspector.ZoomManager = function(window, frontendHost)
{
    this._frontendHost = frontendHost;
    this._zoomFactor = this._frontendHost.zoomFactor();
    window.addEventListener("resize", this._onWindowResize.bind(this), true);
};

WebInspector.ZoomManager.Events = {
    ZoomChanged: "ZoomChanged"
};

WebInspector.ZoomManager.prototype = {
    /**
     * @return {number}
     */
    zoomFactor: function()
    {
        return this._zoomFactor;
    },

    /**
     * @param {number} value
     * @return {number}
     */
    cssToDIP: function(value)
    {
        return value * this._zoomFactor;
    },

    /**
     * @param {number} valueDIP
     * @return {number}
     */
    dipToCSS: function(valueDIP)
    {
        return valueDIP / this._zoomFactor;
    },

    _onWindowResize: function()
    {
        var oldZoomFactor = this._zoomFactor;
        this._zoomFactor = this._frontendHost.zoomFactor();
        if (oldZoomFactor !== this._zoomFactor)
            this.dispatchEventToListeners(WebInspector.ZoomManager.Events.ZoomChanged, {from: oldZoomFactor, to: this._zoomFactor});
    },

    __proto__: WebInspector.Object.prototype
};

/**
 * @type {!WebInspector.ZoomManager}
 */
WebInspector.zoomManager;
;/* ThrottledWidget.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.Widget}
 */
WebInspector.ThrottledWidget = function()
{
    WebInspector.Widget.call(this);
    this._updateThrottler = new WebInspector.Throttler(100);
    this._updateWhenVisible = false;
}

WebInspector.ThrottledWidget.prototype = {
    /**
     * @protected
     * @return {!Promise.<?>}
     */
    doUpdate: function()
    {
        return Promise.resolve();
    },

    update: function()
    {
        this._updateWhenVisible = !this.isShowing();
        if (this._updateWhenVisible)
            return;
        this._updateThrottler.schedule(innerUpdate.bind(this));

        /**
         * @this {WebInspector.ThrottledWidget}
         * @return {!Promise.<?>}
         */
        function innerUpdate()
        {
            if (this.isShowing()) {
                return this.doUpdate();
            } else {
                this._updateWhenVisible = true;
                return Promise.resolve();
            }
        }
    },

    /**
     * @override
     */
    wasShown: function()
    {
        WebInspector.Widget.prototype.wasShown.call(this);
        if (this._updateWhenVisible)
            this.update();
    },

    __proto__: WebInspector.Widget.prototype
}
;
/* Module sdk */
/* InspectorBackend.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 */
function InspectorBackendClass()
{
    this._agentPrototypes = {};
    this._dispatcherPrototypes = {};
    this._initialized = false;
    this._initProtocolAgentsConstructor();
}

InspectorBackendClass._DevToolsErrorCode = -32000;
InspectorBackendClass.DevToolsStubErrorCode = -32015;

/**
 * @param {string} error
 * @param {!Object} messageObject
 */
InspectorBackendClass.reportProtocolError = function(error, messageObject)
{
    console.error(error + ": " + JSON.stringify(messageObject));
}

InspectorBackendClass.prototype = {
    /**
     * @return {boolean}
     */
    isInitialized: function()
    {
        return this._initialized;
    },

    _initProtocolAgentsConstructor: function()
    {
        window.Protocol = {};

        /**
         * @constructor
         * @param {!Object.<string, !Object>} agentsMap
         */
        window.Protocol.Agents = function(agentsMap) {
            this._agentsMap = agentsMap;
        };
    },

    /**
     * @param {string} domain
     */
    _addAgentGetterMethodToProtocolAgentsPrototype: function(domain)
    {
        var upperCaseLength = 0;
        while (upperCaseLength < domain.length && domain[upperCaseLength].toLowerCase() !== domain[upperCaseLength])
            ++upperCaseLength;

        var methodName = domain.substr(0, upperCaseLength).toLowerCase() + domain.slice(upperCaseLength) + "Agent";

        /**
         * @this {Protocol.Agents}
         */
        function agentGetter()
        {
            return this._agentsMap[domain];
        }

        window.Protocol.Agents.prototype[methodName] = agentGetter;

        /**
         * @this {Protocol.Agents}
         */
        function registerDispatcher(dispatcher)
        {
            this.registerDispatcher(domain, dispatcher)
        }

        window.Protocol.Agents.prototype["register" + domain + "Dispatcher"] = registerDispatcher;
    },

    /**
     * @param {string} domain
     * @return {!InspectorBackendClass.AgentPrototype}
     */
    _agentPrototype: function(domain)
    {
        if (!this._agentPrototypes[domain]) {
            this._agentPrototypes[domain] = new InspectorBackendClass.AgentPrototype(domain);
            this._addAgentGetterMethodToProtocolAgentsPrototype(domain);
        }

        return this._agentPrototypes[domain];
    },

    /**
     * @param {string} domain
     * @return {!InspectorBackendClass.DispatcherPrototype}
     */
    _dispatcherPrototype: function(domain)
    {
        if (!this._dispatcherPrototypes[domain])
            this._dispatcherPrototypes[domain] = new InspectorBackendClass.DispatcherPrototype();
        return this._dispatcherPrototypes[domain];
    },

    /**
     * @param {string} method
     * @param {!Array.<!Object>} signature
     * @param {!Array.<string>} replyArgs
     * @param {boolean} hasErrorData
     */
    registerCommand: function(method, signature, replyArgs, hasErrorData)
    {
        var domainAndMethod = method.split(".");
        this._agentPrototype(domainAndMethod[0]).registerCommand(domainAndMethod[1], signature, replyArgs, hasErrorData);
        this._initialized = true;
    },

    /**
     * @param {string} type
     * @param {!Object} values
     */
    registerEnum: function(type, values)
    {
        var domainAndMethod = type.split(".");
        var agentName = domainAndMethod[0] + "Agent";
        if (!window[agentName])
            window[agentName] = {};

        window[agentName][domainAndMethod[1]] = values;
        this._initialized = true;
    },

    /**
     * @param {string} eventName
     * @param {!Object} params
     */
    registerEvent: function(eventName, params)
    {
        var domain = eventName.split(".")[0];
        this._dispatcherPrototype(domain).registerEvent(eventName, params);
        this._initialized = true;
    },

    /**
     * @param {function(T)} clientCallback
     * @param {string} errorPrefix
     * @param {function(new:T,S)=} constructor
     * @param {T=} defaultValue
     * @return {function(?string, S)}
     * @template T,S
     */
    wrapClientCallback: function(clientCallback, errorPrefix, constructor, defaultValue)
    {
        /**
         * @param {?string} error
         * @param {S} value
         * @template S
         */
        function callbackWrapper(error, value)
        {
            if (error) {
                console.error(errorPrefix + error);
                clientCallback(defaultValue);
                return;
            }
            if (constructor)
                clientCallback(new constructor(value));
            else
                clientCallback(value);
        }
        return callbackWrapper;
    }
}

/**
 *  @constructor
 *  @extends {WebInspector.Object}
 */
InspectorBackendClass.Connection = function()
{
    this._lastMessageId = 1;
    this._pendingResponsesCount = 0;
    this._agents = {};
    this._dispatchers = {};
    this._callbacks = {};
    this._initialize(InspectorBackend._agentPrototypes, InspectorBackend._dispatcherPrototypes);
    this._isConnected = true;
}

InspectorBackendClass.Connection.Events = {
    Disconnected: "Disconnected",
}

InspectorBackendClass.Connection.prototype = {
    /**
     * @param {!Object.<string, !InspectorBackendClass.AgentPrototype>} agentPrototypes
     * @param {!Object.<string, !InspectorBackendClass.DispatcherPrototype>} dispatcherPrototypes
     */
    _initialize: function(agentPrototypes, dispatcherPrototypes)
    {
        for (var domain in agentPrototypes) {
            this._agents[domain] = Object.create(agentPrototypes[domain]);
            this._agents[domain].setConnection(this);
        }

        for (var domain in dispatcherPrototypes)
            this._dispatchers[domain] = Object.create(dispatcherPrototypes[domain]);
    },

    /**
     * @return {number}
     */
    nextMessageId: function()
    {
        return this._lastMessageId++;
    },

    /**
     * @param {string} domain
     * @return {!InspectorBackendClass.AgentPrototype}
     */
    agent: function(domain)
    {
        return this._agents[domain];
    },

    /**
     * @return {!Object.<string, !Object>}
     */
    agentsMap: function()
    {
        return this._agents;
    },

    /**
     * @param {string} domain
     * @param {string} method
     * @param {?Object} params
     * @param {?function(*)} callback
     */
    _wrapCallbackAndSendMessageObject: function(domain, method, params, callback)
    {
        if (!this._isConnected && callback) {
            this._dispatchConnectionErrorResponse(domain, method, callback);
            return;
        }

        var messageObject = {};
        var messageId = this.nextMessageId();
        messageObject.id = messageId;
        messageObject.method = method;
        if (params)
            messageObject.params = params;

        var wrappedCallback = this._wrap(callback, domain, method);

        if (InspectorBackendClass.Options.dumpInspectorProtocolMessages)
            this._dumpProtocolMessage("frontend: " + JSON.stringify(messageObject));

        this.sendMessage(messageObject);
        ++this._pendingResponsesCount;
        this._callbacks[messageId] = wrappedCallback;
    },

    /**
     * @param {?function(*)} callback
     * @param {string} method
     * @param {string} domain
     * @return {function(*)}
     */
    _wrap: function(callback, domain, method)
    {
        if (!callback)
            callback = function() {};

        callback.methodName = method;
        callback.domain = domain;
        if (InspectorBackendClass.Options.dumpInspectorTimeStats)
            callback.sendRequestTime = Date.now();

        return callback;
    },

    /**
     * @param {!Object} messageObject
     */
    sendMessage: function(messageObject)
    {
        throw "Not implemented";
    },

    /**
     * @param {!Object|string} message
     */
    dispatch: function(message)
    {
        if (InspectorBackendClass.Options.dumpInspectorProtocolMessages)
            this._dumpProtocolMessage("backend: " + ((typeof message === "string") ? message : JSON.stringify(message)));

        var messageObject = /** @type {!Object} */ ((typeof message === "string") ? JSON.parse(message) : message);

        if ("id" in messageObject) { // just a response for some request
            var callback = this._callbacks[messageObject.id];
            if (!callback) {
                InspectorBackendClass.reportProtocolError("Protocol Error: the message with wrong id", messageObject);
                return;
            }

            var processingStartTime;
            if (InspectorBackendClass.Options.dumpInspectorTimeStats)
                processingStartTime = Date.now();

            this.agent(callback.domain).dispatchResponse(messageObject, callback.methodName, callback);
            --this._pendingResponsesCount;
            delete this._callbacks[messageObject.id];

            if (InspectorBackendClass.Options.dumpInspectorTimeStats)
                console.log("time-stats: " + callback.methodName + " = " + (processingStartTime - callback.sendRequestTime) + " + " + (Date.now() - processingStartTime));

            if (this._scripts && !this._pendingResponsesCount)
                this.runAfterPendingDispatches();
            return;
        } else {
            var method = messageObject.method.split(".");
            var domainName = method[0];
            if (!(domainName in this._dispatchers)) {
                InspectorBackendClass.reportProtocolError("Protocol Error: the message " + messageObject.method + " is for non-existing domain '" + domainName + "'", messageObject);
                return;
            }

            this._dispatchers[domainName].dispatch(method[1], messageObject);
        }

    },

    /**
     * @param {string} domain
     * @param {!Object} dispatcher
     */
    registerDispatcher: function(domain, dispatcher)
    {
        if (!this._dispatchers[domain])
            return;

        this._dispatchers[domain].setDomainDispatcher(dispatcher);
    },

    /**
     * @param {function()=} script
     */
    runAfterPendingDispatches: function(script)
    {
        if (!this._scripts)
            this._scripts = [];

        if (script)
            this._scripts.push(script);

        // Execute all promises.
        setTimeout(function() {
            if (!this._pendingResponsesCount)
                this._executeAfterPendingDispatches();
            else
                this.runAfterPendingDispatches();
        }.bind(this), 0);
    },

    _executeAfterPendingDispatches: function()
    {
        if (!this._pendingResponsesCount) {
            var scripts = this._scripts;
            this._scripts = [];
            for (var id = 0; id < scripts.length; ++id)
                scripts[id].call(this);
        }
    },

    _dumpProtocolMessage: function(message)
    {
        console.log(message);
    },

    /**
     * @protected
     * @param {string} reason
     */
    connectionClosed: function(reason)
    {
        this._isConnected = false;
        this._runPendingCallbacks();
        this.dispatchEventToListeners(InspectorBackendClass.Connection.Events.Disconnected, {reason: reason});
    },

    _runPendingCallbacks: function()
    {
        var keys = Object.keys(this._callbacks).map(function(num) { return parseInt(num, 10); });
        for (var i = 0; i < keys.length; ++i) {
            var callback = this._callbacks[keys[i]];
            this._dispatchConnectionErrorResponse(callback.domain, callback.methodName, callback);
        }
        this._callbacks = {};
    },

    /**
     * @param {string} domain
     * @param {string} methodName
     * @param {function(*)} callback
     */
    _dispatchConnectionErrorResponse: function(domain, methodName, callback)
    {
        var error = { message: "Connection is closed, can't dispatch pending " + methodName, code:  InspectorBackendClass._DevToolsErrorCode, data: null};
        var messageObject = {error: error};
        setTimeout(InspectorBackendClass.AgentPrototype.prototype.dispatchResponse.bind(this.agent(domain), messageObject, methodName, callback), 0);
    },

    /**
     * @return {boolean}
     */
    isClosed: function()
    {
        return !this._isConnected;
    },

    /**
     * @param {!Array.<string>} domains
     */
    suppressErrorsForDomains: function(domains)
    {
        domains.forEach(function(domain) { this._agents[domain].suppressErrorLogging(); }, this);
    },

    __proto__: WebInspector.Object.prototype

}

/**
 * @constructor
 * @param {string} domain
 */
InspectorBackendClass.AgentPrototype = function(domain)
{
    this._replyArgs = {};
    this._hasErrorData = {};
    this._domain = domain;
    this._suppressErrorLogging = false;
}

InspectorBackendClass.AgentPrototype.prototype = {
    /**
     * @param {!InspectorBackendClass.Connection} connection
     */
    setConnection: function(connection)
    {
        this._connection = connection;
    },

    /**
     * @param {string} methodName
     * @param {!Array.<!Object>} signature
     * @param {!Array.<string>} replyArgs
     * @param {boolean} hasErrorData
     */
    registerCommand: function(methodName, signature, replyArgs, hasErrorData)
    {
        var domainAndMethod = this._domain + "." + methodName;

        /**
         * @param {...*} vararg
         * @this {InspectorBackendClass.AgentPrototype}
         * @return {!Promise.<*>}
         */
        function sendMessagePromise(vararg)
        {
            var params = Array.prototype.slice.call(arguments);
            return InspectorBackendClass.AgentPrototype.prototype._sendMessageToBackendPromise.call(this, domainAndMethod, signature, params);
        }

        this[methodName] = sendMessagePromise;

        /**
         * @param {...*} vararg
         * @this {InspectorBackendClass.AgentPrototype}
         */
        function invoke(vararg)
        {
            var params = [domainAndMethod].concat(Array.prototype.slice.call(arguments));
            InspectorBackendClass.AgentPrototype.prototype._invoke.apply(this, params);
        }

        this["invoke_" + methodName] = invoke;

        this._replyArgs[domainAndMethod] = replyArgs;
        if (hasErrorData)
            this._hasErrorData[domainAndMethod] = true;
    },

    /**
     * @param {string} method
     * @param {!Array.<!Object>} signature
     * @param {!Array.<*>} args
     * @param {boolean} allowExtraUndefinedArg
     * @param {function(string)} errorCallback
     * @return {?Object}
     */
    _prepareParameters: function(method, signature, args, allowExtraUndefinedArg, errorCallback)
    {
        var params = {};
        var hasParams = false;
        for (var i = 0; i < signature.length; ++i) {
            var param = signature[i];
            var paramName = param["name"];
            var typeName = param["type"];
            var optionalFlag = param["optional"];

            if (!args.length && !optionalFlag) {
                errorCallback("Protocol Error: Invalid number of arguments for method '" + method + "' call. It must have the following arguments '" + JSON.stringify(signature) + "'.");
                return null;
            }

            var value = args.shift();
            if (optionalFlag && typeof value === "undefined")
                continue;

            if (typeof value !== typeName) {
                errorCallback("Protocol Error: Invalid type of argument '" + paramName + "' for method '" + method + "' call. It must be '" + typeName + "' but it is '" + typeof value + "'.");
                return null;
            }

            params[paramName] = value;
            hasParams = true;
        }

        if (args.length === 1 && (!allowExtraUndefinedArg || (typeof args[0] !== "undefined"))) {
            errorCallback("Protocol Error: Optional callback argument for method '" + method + "' call must be a function but its type is '" + typeof args[0] + "'.");
            return null;
        }

        if (args.length > 1) {
            errorCallback("Protocol Error: Extra " + args.length + " arguments in a call to method '" + method + "'.");
            return null;
        }

        return hasParams ? params : null
    },

    /**
     * @param {string} method
     * @param {!Array.<!Object>} signature
     * @param {!Array.<*>} args
     * @return {!Promise.<*>}
     */
    _sendMessageToBackendPromise: function(method, signature, args)
    {
        var errorMessage;
        /**
         * @param {string} message
         */
        function onError(message)
        {
            console.error(message);
            errorMessage = message;
        }
        var userCallback = (args.length && typeof args.peekLast() === "function") ? args.pop() : null;
        var params = this._prepareParameters(method, signature, args, !userCallback, onError);
        if (errorMessage)
            return Promise.reject(new Error(errorMessage));
        else
            return new Promise(promiseAction.bind(this));

        /**
         * @param {function(?)} resolve
         * @param {function(!Error)} reject
         * @this {InspectorBackendClass.AgentPrototype}
         */
        function promiseAction(resolve, reject)
        {
            /**
             * @param {...*} vararg
             */
            function callback(vararg)
            {
                var result = userCallback ? userCallback.apply(null, arguments) : undefined;
                resolve(result);
            }
            this._connection._wrapCallbackAndSendMessageObject(this._domain, method, params, callback);
        }
    },

    /**
     * @param {string} method
     * @param {?Object} args
     * @param {?function(*)} callback
     */
    _invoke: function(method, args, callback)
    {
        this._connection._wrapCallbackAndSendMessageObject(this._domain, method, args, callback);
    },

    /**
     * @param {!Object} messageObject
     * @param {string} methodName
     * @param {function(*)|function(?Protocol.Error, ?Object)} callback
     */
    dispatchResponse: function(messageObject, methodName, callback)
    {
        if (messageObject.error && messageObject.error.code !== InspectorBackendClass._DevToolsErrorCode && messageObject.error.code !== InspectorBackendClass.DevToolsStubErrorCode && !InspectorBackendClass.Options.suppressRequestErrors && !this._suppressErrorLogging) {
            var id = InspectorBackendClass.Options.dumpInspectorProtocolMessages ? " with id = " + messageObject.id : "";
            console.error("Request " + methodName + id + " failed. " + JSON.stringify(messageObject.error));
        }

        var argumentsArray = [];
        argumentsArray[0] = messageObject.error ? messageObject.error.message: null;

        if (this._hasErrorData[methodName])
            argumentsArray[1] = messageObject.error ? messageObject.error.data : null;

        if (messageObject.result) {
            var paramNames = this._replyArgs[methodName] || [];
            for (var i = 0; i < paramNames.length; ++i)
                argumentsArray.push(messageObject.result[paramNames[i]]);
        }

        callback.apply(null, argumentsArray);
    },

    suppressErrorLogging: function()
    {
        this._suppressErrorLogging = true;
    }
}

/**
 * @constructor
 */
InspectorBackendClass.DispatcherPrototype = function()
{
    this._eventArgs = {};
    this._dispatcher = null;
}

InspectorBackendClass.DispatcherPrototype.prototype = {

    /**
     * @param {string} eventName
     * @param {!Object} params
     */
    registerEvent: function(eventName, params)
    {
        this._eventArgs[eventName] = params;
    },

    /**
     * @param {!Object} dispatcher
     */
    setDomainDispatcher: function(dispatcher)
    {
        this._dispatcher = dispatcher;
    },

    /**
     * @param {string} functionName
     * @param {!Object} messageObject
     */
    dispatch: function(functionName, messageObject)
    {
        if (!this._dispatcher)
            return;

        if (!(functionName in this._dispatcher)) {
            InspectorBackendClass.reportProtocolError("Protocol Error: Attempted to dispatch an unimplemented method '" + messageObject.method + "'", messageObject);
            return;
        }

        if (!this._eventArgs[messageObject.method]) {
            InspectorBackendClass.reportProtocolError("Protocol Error: Attempted to dispatch an unspecified method '" + messageObject.method + "'", messageObject);
            return;
        }

        var params = [];
        if (messageObject.params) {
            var paramNames = this._eventArgs[messageObject.method];
            for (var i = 0; i < paramNames.length; ++i)
                params.push(messageObject.params[paramNames[i]]);
        }

        var processingStartTime;
        if (InspectorBackendClass.Options.dumpInspectorTimeStats)
            processingStartTime = Date.now();

        this._dispatcher[functionName].apply(this._dispatcher, params);

        if (InspectorBackendClass.Options.dumpInspectorTimeStats)
            console.log("time-stats: " + messageObject.method + " = " + (Date.now() - processingStartTime));
    }
}

InspectorBackendClass.Options = {
    dumpInspectorTimeStats: false,
    dumpInspectorProtocolMessages: false,
    suppressRequestErrors: false
}

InspectorBackend = new InspectorBackendClass();
;/* ../InspectorBackendCommands.js */
// File is generated by src/devtools/scripts/CodeGeneratorFrontend.py

// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


// Inspector.
InspectorBackend.registerEvent("Inspector.evaluateForTestInFrontend", ["testCallId", "script"]);
InspectorBackend.registerEvent("Inspector.inspect", ["object", "hints"]);
InspectorBackend.registerEvent("Inspector.detached", ["reason"]);
InspectorBackend.registerEvent("Inspector.targetCrashed", []);
InspectorBackend.registerCommand("Inspector.enable", [], [], false);
InspectorBackend.registerCommand("Inspector.disable", [], [], false);

// Memory.
InspectorBackend.registerEnum("Memory.PressureLevel", {Moderate: "moderate", Critical: "critical"});
InspectorBackend.registerCommand("Memory.getDOMCounters", [], ["documents", "nodes", "jsEventListeners"], false);
InspectorBackend.registerCommand("Memory.setPressureNotificationsSuppressed", [{"name": "suppressed", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("Memory.simulatePressureNotification", [{"name": "level", "type": "string", "optional": false}], [], false);

// Page.
InspectorBackend.registerEnum("Page.ResourceType", {Document: "Document", Stylesheet: "Stylesheet", Image: "Image", Media: "Media", Font: "Font", Script: "Script", TextTrack: "TextTrack", XHR: "XHR", Fetch: "Fetch", EventSource: "EventSource", WebSocket: "WebSocket", Manifest: "Manifest", Other: "Other"});
InspectorBackend.registerEnum("Page.DialogType", {Alert: "alert", Confirm: "confirm", Prompt: "prompt", Beforeunload: "beforeunload"});
InspectorBackend.registerEvent("Page.domContentEventFired", ["timestamp"]);
InspectorBackend.registerEvent("Page.loadEventFired", ["timestamp"]);
InspectorBackend.registerEvent("Page.frameAttached", ["frameId", "parentFrameId"]);
InspectorBackend.registerEvent("Page.frameNavigated", ["frame"]);
InspectorBackend.registerEvent("Page.frameDetached", ["frameId"]);
InspectorBackend.registerEvent("Page.frameStartedLoading", ["frameId"]);
InspectorBackend.registerEvent("Page.frameStoppedLoading", ["frameId"]);
InspectorBackend.registerEvent("Page.frameScheduledNavigation", ["frameId", "delay"]);
InspectorBackend.registerEvent("Page.frameClearedScheduledNavigation", ["frameId"]);
InspectorBackend.registerEvent("Page.frameResized", []);
InspectorBackend.registerEvent("Page.javascriptDialogOpening", ["message", "type"]);
InspectorBackend.registerEvent("Page.javascriptDialogClosed", ["result"]);
InspectorBackend.registerEvent("Page.screencastFrame", ["data", "metadata", "sessionId"]);
InspectorBackend.registerEvent("Page.screencastVisibilityChanged", ["visible"]);
InspectorBackend.registerEvent("Page.colorPicked", ["color"]);
InspectorBackend.registerEvent("Page.interstitialShown", []);
InspectorBackend.registerEvent("Page.interstitialHidden", []);
InspectorBackend.registerCommand("Page.enable", [], [], false);
InspectorBackend.registerCommand("Page.disable", [], [], false);
InspectorBackend.registerCommand("Page.addScriptToEvaluateOnLoad", [{"name": "scriptSource", "type": "string", "optional": false}], ["identifier"], false);
InspectorBackend.registerCommand("Page.removeScriptToEvaluateOnLoad", [{"name": "identifier", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Page.setAutoAttachToCreatedPages", [{"name": "autoAttach", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("Page.reload", [{"name": "ignoreCache", "type": "boolean", "optional": true}, {"name": "scriptToEvaluateOnLoad", "type": "string", "optional": true}], [], false);
InspectorBackend.registerCommand("Page.navigate", [{"name": "url", "type": "string", "optional": false}], ["frameId"], false);
InspectorBackend.registerCommand("Page.getNavigationHistory", [], ["currentIndex", "entries"], false);
InspectorBackend.registerCommand("Page.navigateToHistoryEntry", [{"name": "entryId", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("Page.getCookies", [], ["cookies"], false);
InspectorBackend.registerCommand("Page.deleteCookie", [{"name": "cookieName", "type": "string", "optional": false}, {"name": "url", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Page.getResourceTree", [], ["frameTree"], false);
InspectorBackend.registerCommand("Page.getResourceContent", [{"name": "frameId", "type": "string", "optional": false}, {"name": "url", "type": "string", "optional": false}], ["content", "base64Encoded"], false);
InspectorBackend.registerCommand("Page.searchInResource", [{"name": "frameId", "type": "string", "optional": false}, {"name": "url", "type": "string", "optional": false}, {"name": "query", "type": "string", "optional": false}, {"name": "caseSensitive", "type": "boolean", "optional": true}, {"name": "isRegex", "type": "boolean", "optional": true}], ["result"], false);
InspectorBackend.registerCommand("Page.setDocumentContent", [{"name": "frameId", "type": "string", "optional": false}, {"name": "html", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Page.setDeviceMetricsOverride", [{"name": "width", "type": "number", "optional": false}, {"name": "height", "type": "number", "optional": false}, {"name": "deviceScaleFactor", "type": "number", "optional": false}, {"name": "mobile", "type": "boolean", "optional": false}, {"name": "fitWindow", "type": "boolean", "optional": false}, {"name": "scale", "type": "number", "optional": true}, {"name": "offsetX", "type": "number", "optional": true}, {"name": "offsetY", "type": "number", "optional": true}, {"name": "screenWidth", "type": "number", "optional": true}, {"name": "screenHeight", "type": "number", "optional": true}, {"name": "positionX", "type": "number", "optional": true}, {"name": "positionY", "type": "number", "optional": true}, {"name": "screenOrientation", "type": "object", "optional": true}], [], false);
InspectorBackend.registerCommand("Page.clearDeviceMetricsOverride", [], [], false);
InspectorBackend.registerCommand("Page.setGeolocationOverride", [{"name": "latitude", "type": "number", "optional": true}, {"name": "longitude", "type": "number", "optional": true}, {"name": "accuracy", "type": "number", "optional": true}], [], false);
InspectorBackend.registerCommand("Page.clearGeolocationOverride", [], [], false);
InspectorBackend.registerCommand("Page.setDeviceOrientationOverride", [{"name": "alpha", "type": "number", "optional": false}, {"name": "beta", "type": "number", "optional": false}, {"name": "gamma", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("Page.clearDeviceOrientationOverride", [], [], false);
InspectorBackend.registerCommand("Page.setTouchEmulationEnabled", [{"name": "enabled", "type": "boolean", "optional": false}, {"name": "configuration", "type": "string", "optional": true}], [], false);
InspectorBackend.registerCommand("Page.captureScreenshot", [], ["data"], false);
InspectorBackend.registerCommand("Page.startScreencast", [{"name": "format", "type": "string", "optional": true}, {"name": "quality", "type": "number", "optional": true}, {"name": "maxWidth", "type": "number", "optional": true}, {"name": "maxHeight", "type": "number", "optional": true}, {"name": "everyNthFrame", "type": "number", "optional": true}], [], false);
InspectorBackend.registerCommand("Page.stopScreencast", [], [], false);
InspectorBackend.registerCommand("Page.screencastFrameAck", [{"name": "sessionId", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("Page.handleJavaScriptDialog", [{"name": "accept", "type": "boolean", "optional": false}, {"name": "promptText", "type": "string", "optional": true}], [], false);
InspectorBackend.registerCommand("Page.setColorPickerEnabled", [{"name": "enabled", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("Page.setOverlayMessage", [{"name": "message", "type": "string", "optional": true}], [], false);
InspectorBackend.registerCommand("Page.requestAppBanner", [], ["result"], false);

// Rendering.
InspectorBackend.registerCommand("Rendering.setShowPaintRects", [{"name": "result", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("Rendering.setShowDebugBorders", [{"name": "show", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("Rendering.setShowFPSCounter", [{"name": "show", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("Rendering.setShowScrollBottleneckRects", [{"name": "show", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("Rendering.setShowViewportSizeOnResize", [{"name": "show", "type": "boolean", "optional": false}], [], false);

// Emulation.
InspectorBackend.registerEnum("Emulation.ScreenOrientationType", {PortraitPrimary: "portraitPrimary", PortraitSecondary: "portraitSecondary", LandscapePrimary: "landscapePrimary", LandscapeSecondary: "landscapeSecondary"});
InspectorBackend.registerCommand("Emulation.setDeviceMetricsOverride", [{"name": "width", "type": "number", "optional": false}, {"name": "height", "type": "number", "optional": false}, {"name": "deviceScaleFactor", "type": "number", "optional": false}, {"name": "mobile", "type": "boolean", "optional": false}, {"name": "fitWindow", "type": "boolean", "optional": false}, {"name": "scale", "type": "number", "optional": true}, {"name": "offsetX", "type": "number", "optional": true}, {"name": "offsetY", "type": "number", "optional": true}, {"name": "screenWidth", "type": "number", "optional": true}, {"name": "screenHeight", "type": "number", "optional": true}, {"name": "positionX", "type": "number", "optional": true}, {"name": "positionY", "type": "number", "optional": true}, {"name": "screenOrientation", "type": "object", "optional": true}], [], false);
InspectorBackend.registerCommand("Emulation.clearDeviceMetricsOverride", [], [], false);
InspectorBackend.registerCommand("Emulation.resetPageScaleFactor", [], [], false);
InspectorBackend.registerCommand("Emulation.setPageScaleFactor", [{"name": "pageScaleFactor", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("Emulation.setScriptExecutionDisabled", [{"name": "value", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("Emulation.setGeolocationOverride", [{"name": "latitude", "type": "number", "optional": true}, {"name": "longitude", "type": "number", "optional": true}, {"name": "accuracy", "type": "number", "optional": true}], [], false);
InspectorBackend.registerCommand("Emulation.clearGeolocationOverride", [], [], false);
InspectorBackend.registerCommand("Emulation.setTouchEmulationEnabled", [{"name": "enabled", "type": "boolean", "optional": false}, {"name": "configuration", "type": "string", "optional": true}], [], false);
InspectorBackend.registerCommand("Emulation.setEmulatedMedia", [{"name": "media", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Emulation.setCPUThrottlingRate", [{"name": "rate", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("Emulation.canEmulate", [], ["result"], false);

// Runtime.
InspectorBackend.registerEnum("Runtime.RemoteObjectType", {Object: "object", Function: "function", Undefined: "undefined", String: "string", Number: "number", Boolean: "boolean", Symbol: "symbol"});
InspectorBackend.registerEnum("Runtime.RemoteObjectSubtype", {Array: "array", Null: "null", Node: "node", Regexp: "regexp", Date: "date", Map: "map", Set: "set", Iterator: "iterator", Generator: "generator", Error: "error"});
InspectorBackend.registerEnum("Runtime.ObjectPreviewType", {Object: "object", Function: "function", Undefined: "undefined", String: "string", Number: "number", Boolean: "boolean", Symbol: "symbol"});
InspectorBackend.registerEnum("Runtime.ObjectPreviewSubtype", {Array: "array", Null: "null", Node: "node", Regexp: "regexp", Date: "date", Map: "map", Set: "set", Iterator: "iterator", Generator: "generator", Error: "error"});
InspectorBackend.registerEnum("Runtime.PropertyPreviewType", {Object: "object", Function: "function", Undefined: "undefined", String: "string", Number: "number", Boolean: "boolean", Symbol: "symbol", Accessor: "accessor"});
InspectorBackend.registerEnum("Runtime.PropertyPreviewSubtype", {Array: "array", Null: "null", Node: "node", Regexp: "regexp", Date: "date", Map: "map", Set: "set", Iterator: "iterator", Generator: "generator", Error: "error"});
InspectorBackend.registerEnum("Runtime.CallArgumentType", {Object: "object", Function: "function", Undefined: "undefined", String: "string", Number: "number", Boolean: "boolean", Symbol: "symbol"});
InspectorBackend.registerEvent("Runtime.executionContextCreated", ["context"]);
InspectorBackend.registerEvent("Runtime.executionContextDestroyed", ["executionContextId"]);
InspectorBackend.registerEvent("Runtime.executionContextsCleared", []);
InspectorBackend.registerCommand("Runtime.evaluate", [{"name": "expression", "type": "string", "optional": false}, {"name": "objectGroup", "type": "string", "optional": true}, {"name": "includeCommandLineAPI", "type": "boolean", "optional": true}, {"name": "doNotPauseOnExceptionsAndMuteConsole", "type": "boolean", "optional": true}, {"name": "contextId", "type": "number", "optional": true}, {"name": "returnByValue", "type": "boolean", "optional": true}, {"name": "generatePreview", "type": "boolean", "optional": true}], ["result", "wasThrown", "exceptionDetails"], false);
InspectorBackend.registerCommand("Runtime.callFunctionOn", [{"name": "objectId", "type": "string", "optional": false}, {"name": "functionDeclaration", "type": "string", "optional": false}, {"name": "arguments", "type": "object", "optional": true}, {"name": "doNotPauseOnExceptionsAndMuteConsole", "type": "boolean", "optional": true}, {"name": "returnByValue", "type": "boolean", "optional": true}, {"name": "generatePreview", "type": "boolean", "optional": true}], ["result", "wasThrown"], false);
InspectorBackend.registerCommand("Runtime.getProperties", [{"name": "objectId", "type": "string", "optional": false}, {"name": "ownProperties", "type": "boolean", "optional": true}, {"name": "accessorPropertiesOnly", "type": "boolean", "optional": true}, {"name": "generatePreview", "type": "boolean", "optional": true}], ["result", "internalProperties", "exceptionDetails"], false);
InspectorBackend.registerCommand("Runtime.releaseObject", [{"name": "objectId", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Runtime.releaseObjectGroup", [{"name": "objectGroup", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Runtime.run", [], [], false);
InspectorBackend.registerCommand("Runtime.enable", [], [], false);
InspectorBackend.registerCommand("Runtime.disable", [], [], false);
InspectorBackend.registerCommand("Runtime.isRunRequired", [], ["result"], false);
InspectorBackend.registerCommand("Runtime.setCustomObjectFormatterEnabled", [{"name": "enabled", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("Runtime.compileScript", [{"name": "expression", "type": "string", "optional": false}, {"name": "sourceURL", "type": "string", "optional": false}, {"name": "persistScript", "type": "boolean", "optional": false}, {"name": "executionContextId", "type": "number", "optional": false}], ["scriptId", "exceptionDetails"], false);
InspectorBackend.registerCommand("Runtime.runScript", [{"name": "scriptId", "type": "string", "optional": false}, {"name": "executionContextId", "type": "number", "optional": false}, {"name": "objectGroup", "type": "string", "optional": true}, {"name": "doNotPauseOnExceptionsAndMuteConsole", "type": "boolean", "optional": true}, {"name": "includeCommandLineAPI", "type": "boolean", "optional": true}], ["result", "exceptionDetails"], false);

// Console.
InspectorBackend.registerEnum("Console.ConsoleMessageSource", {XML: "xml", Javascript: "javascript", Network: "network", ConsoleAPI: "console-api", Storage: "storage", Appcache: "appcache", Rendering: "rendering", Security: "security", Other: "other", Deprecation: "deprecation"});
InspectorBackend.registerEnum("Console.ConsoleMessageLevel", {Log: "log", Warning: "warning", Error: "error", Debug: "debug", Info: "info", RevokedError: "revokedError"});
InspectorBackend.registerEnum("Console.ConsoleMessageType", {Log: "log", Dir: "dir", DirXML: "dirxml", Table: "table", Trace: "trace", Clear: "clear", StartGroup: "startGroup", StartGroupCollapsed: "startGroupCollapsed", EndGroup: "endGroup", Assert: "assert", Profile: "profile", ProfileEnd: "profileEnd"});
InspectorBackend.registerEvent("Console.messageAdded", ["message"]);
InspectorBackend.registerEvent("Console.messageRepeatCountUpdated", ["count", "timestamp"]);
InspectorBackend.registerEvent("Console.messagesCleared", []);
InspectorBackend.registerCommand("Console.enable", [], [], false);
InspectorBackend.registerCommand("Console.disable", [], [], false);
InspectorBackend.registerCommand("Console.clearMessages", [], [], false);

// Security.
InspectorBackend.registerEnum("Security.SecurityState", {Unknown: "unknown", Neutral: "neutral", Insecure: "insecure", Warning: "warning", Secure: "secure", Info: "info"});
InspectorBackend.registerEvent("Security.securityStateChanged", ["securityState", "explanations", "mixedContentStatus", "schemeIsCryptographic"]);
InspectorBackend.registerCommand("Security.enable", [], [], false);
InspectorBackend.registerCommand("Security.disable", [], [], false);

// Network.
InspectorBackend.registerEnum("Network.ResourcePriority", {VeryLow: "VeryLow", Low: "Low", Medium: "Medium", High: "High", VeryHigh: "VeryHigh"});
InspectorBackend.registerEnum("Network.RequestMixedContentType", {Blockable: "blockable", OptionallyBlockable: "optionally-blockable", None: "none"});
InspectorBackend.registerEnum("Network.BlockedReason", {Csp: "csp", MixedContent: "mixed-content", Origin: "origin", Inspector: "inspector", Other: "other"});
InspectorBackend.registerEnum("Network.InitiatorType", {Parser: "parser", Script: "script", Other: "other"});
InspectorBackend.registerEvent("Network.requestWillBeSent", ["requestId", "frameId", "loaderId", "documentURL", "request", "timestamp", "wallTime", "initiator", "redirectResponse", "type"]);
InspectorBackend.registerEvent("Network.requestServedFromCache", ["requestId"]);
InspectorBackend.registerEvent("Network.responseReceived", ["requestId", "frameId", "loaderId", "timestamp", "type", "response"]);
InspectorBackend.registerEvent("Network.dataReceived", ["requestId", "timestamp", "dataLength", "encodedDataLength"]);
InspectorBackend.registerEvent("Network.loadingFinished", ["requestId", "timestamp", "encodedDataLength"]);
InspectorBackend.registerEvent("Network.loadingFailed", ["requestId", "timestamp", "type", "errorText", "canceled", "blockedReason"]);
InspectorBackend.registerEvent("Network.webSocketWillSendHandshakeRequest", ["requestId", "timestamp", "wallTime", "request"]);
InspectorBackend.registerEvent("Network.webSocketHandshakeResponseReceived", ["requestId", "timestamp", "response"]);
InspectorBackend.registerEvent("Network.webSocketCreated", ["requestId", "url"]);
InspectorBackend.registerEvent("Network.webSocketClosed", ["requestId", "timestamp"]);
InspectorBackend.registerEvent("Network.webSocketFrameReceived", ["requestId", "timestamp", "response"]);
InspectorBackend.registerEvent("Network.webSocketFrameError", ["requestId", "timestamp", "errorMessage"]);
InspectorBackend.registerEvent("Network.webSocketFrameSent", ["requestId", "timestamp", "response"]);
InspectorBackend.registerEvent("Network.eventSourceMessageReceived", ["requestId", "timestamp", "eventName", "eventId", "data"]);
InspectorBackend.registerCommand("Network.enable", [], [], false);
InspectorBackend.registerCommand("Network.disable", [], [], false);
InspectorBackend.registerCommand("Network.setUserAgentOverride", [{"name": "userAgent", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Network.setExtraHTTPHeaders", [{"name": "headers", "type": "object", "optional": false}], [], false);
InspectorBackend.registerCommand("Network.getResponseBody", [{"name": "requestId", "type": "string", "optional": false}], ["body", "base64Encoded"], false);
InspectorBackend.registerCommand("Network.addBlockedURL", [{"name": "url", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Network.removeBlockedURL", [{"name": "url", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Network.replayXHR", [{"name": "requestId", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Network.setMonitoringXHREnabled", [{"name": "enabled", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("Network.canClearBrowserCache", [], ["result"], false);
InspectorBackend.registerCommand("Network.clearBrowserCache", [], [], false);
InspectorBackend.registerCommand("Network.canClearBrowserCookies", [], ["result"], false);
InspectorBackend.registerCommand("Network.clearBrowserCookies", [], [], false);
InspectorBackend.registerCommand("Network.getCookies", [], ["cookies"], false);
InspectorBackend.registerCommand("Network.deleteCookie", [{"name": "cookieName", "type": "string", "optional": false}, {"name": "url", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Network.canEmulateNetworkConditions", [], ["result"], false);
InspectorBackend.registerCommand("Network.emulateNetworkConditions", [{"name": "offline", "type": "boolean", "optional": false}, {"name": "latency", "type": "number", "optional": false}, {"name": "downloadThroughput", "type": "number", "optional": false}, {"name": "uploadThroughput", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("Network.setCacheDisabled", [{"name": "cacheDisabled", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("Network.setDataSizeLimitsForTest", [{"name": "maxTotalSize", "type": "number", "optional": false}, {"name": "maxResourceSize", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("Network.getCertificateDetails", [{"name": "certificateId", "type": "number", "optional": false}], ["result"], false);
InspectorBackend.registerCommand("Network.showCertificateViewer", [{"name": "certificateId", "type": "number", "optional": false}], [], false);

// Database.
InspectorBackend.registerEvent("Database.addDatabase", ["database"]);
InspectorBackend.registerCommand("Database.enable", [], [], false);
InspectorBackend.registerCommand("Database.disable", [], [], false);
InspectorBackend.registerCommand("Database.getDatabaseTableNames", [{"name": "databaseId", "type": "string", "optional": false}], ["tableNames"], false);
InspectorBackend.registerCommand("Database.executeSQL", [{"name": "databaseId", "type": "string", "optional": false}, {"name": "query", "type": "string", "optional": false}], ["columnNames", "values", "sqlError"], false);

// IndexedDB.
InspectorBackend.registerEnum("IndexedDB.KeyType", {Number: "number", String: "string", Date: "date", Array: "array"});
InspectorBackend.registerEnum("IndexedDB.KeyPathType", {Null: "null", String: "string", Array: "array"});
InspectorBackend.registerCommand("IndexedDB.enable", [], [], false);
InspectorBackend.registerCommand("IndexedDB.disable", [], [], false);
InspectorBackend.registerCommand("IndexedDB.requestDatabaseNames", [{"name": "securityOrigin", "type": "string", "optional": false}], ["databaseNames"], false);
InspectorBackend.registerCommand("IndexedDB.requestDatabase", [{"name": "securityOrigin", "type": "string", "optional": false}, {"name": "databaseName", "type": "string", "optional": false}], ["databaseWithObjectStores"], false);
InspectorBackend.registerCommand("IndexedDB.requestData", [{"name": "securityOrigin", "type": "string", "optional": false}, {"name": "databaseName", "type": "string", "optional": false}, {"name": "objectStoreName", "type": "string", "optional": false}, {"name": "indexName", "type": "string", "optional": false}, {"name": "skipCount", "type": "number", "optional": false}, {"name": "pageSize", "type": "number", "optional": false}, {"name": "keyRange", "type": "object", "optional": true}], ["objectStoreDataEntries", "hasMore"], false);
InspectorBackend.registerCommand("IndexedDB.clearObjectStore", [{"name": "securityOrigin", "type": "string", "optional": false}, {"name": "databaseName", "type": "string", "optional": false}, {"name": "objectStoreName", "type": "string", "optional": false}], [], false);

// CacheStorage.
InspectorBackend.registerCommand("CacheStorage.requestCacheNames", [{"name": "securityOrigin", "type": "string", "optional": false}], ["caches"], false);
InspectorBackend.registerCommand("CacheStorage.requestEntries", [{"name": "cacheId", "type": "string", "optional": false}, {"name": "skipCount", "type": "number", "optional": false}, {"name": "pageSize", "type": "number", "optional": false}], ["cacheDataEntries", "hasMore"], false);
InspectorBackend.registerCommand("CacheStorage.deleteCache", [{"name": "cacheId", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("CacheStorage.deleteEntry", [{"name": "cacheId", "type": "string", "optional": false}, {"name": "request", "type": "string", "optional": false}], [], false);

// DOMStorage.
InspectorBackend.registerEvent("DOMStorage.domStorageItemsCleared", ["storageId"]);
InspectorBackend.registerEvent("DOMStorage.domStorageItemRemoved", ["storageId", "key"]);
InspectorBackend.registerEvent("DOMStorage.domStorageItemAdded", ["storageId", "key", "newValue"]);
InspectorBackend.registerEvent("DOMStorage.domStorageItemUpdated", ["storageId", "key", "oldValue", "newValue"]);
InspectorBackend.registerCommand("DOMStorage.enable", [], [], false);
InspectorBackend.registerCommand("DOMStorage.disable", [], [], false);
InspectorBackend.registerCommand("DOMStorage.getDOMStorageItems", [{"name": "storageId", "type": "object", "optional": false}], ["entries"], false);
InspectorBackend.registerCommand("DOMStorage.setDOMStorageItem", [{"name": "storageId", "type": "object", "optional": false}, {"name": "key", "type": "string", "optional": false}, {"name": "value", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("DOMStorage.removeDOMStorageItem", [{"name": "storageId", "type": "object", "optional": false}, {"name": "key", "type": "string", "optional": false}], [], false);

// ApplicationCache.
InspectorBackend.registerEvent("ApplicationCache.applicationCacheStatusUpdated", ["frameId", "manifestURL", "status"]);
InspectorBackend.registerEvent("ApplicationCache.networkStateUpdated", ["isNowOnline"]);
InspectorBackend.registerCommand("ApplicationCache.getFramesWithManifests", [], ["frameIds"], false);
InspectorBackend.registerCommand("ApplicationCache.enable", [], [], false);
InspectorBackend.registerCommand("ApplicationCache.getManifestForFrame", [{"name": "frameId", "type": "string", "optional": false}], ["manifestURL"], false);
InspectorBackend.registerCommand("ApplicationCache.getApplicationCacheForFrame", [{"name": "frameId", "type": "string", "optional": false}], ["applicationCache"], false);

// DOM.
InspectorBackend.registerEnum("DOM.PseudoType", {FirstLine: "first-line", FirstLetter: "first-letter", Before: "before", After: "after", Backdrop: "backdrop", Selection: "selection", FirstLineInherited: "first-line-inherited", Scrollbar: "scrollbar", ScrollbarThumb: "scrollbar-thumb", ScrollbarButton: "scrollbar-button", ScrollbarTrack: "scrollbar-track", ScrollbarTrackPiece: "scrollbar-track-piece", ScrollbarCorner: "scrollbar-corner", Resizer: "resizer", InputListButton: "input-list-button"});
InspectorBackend.registerEnum("DOM.ShadowRootType", {UserAgent: "user-agent", Open: "open", Closed: "closed"});
InspectorBackend.registerEnum("DOM.InspectMode", {SearchForNode: "searchForNode", SearchForUAShadowDOM: "searchForUAShadowDOM", ShowLayoutEditor: "showLayoutEditor", None: "none"});
InspectorBackend.registerEvent("DOM.documentUpdated", []);
InspectorBackend.registerEvent("DOM.inspectNodeRequested", ["backendNodeId"]);
InspectorBackend.registerEvent("DOM.setChildNodes", ["parentId", "nodes"]);
InspectorBackend.registerEvent("DOM.attributeModified", ["nodeId", "name", "value"]);
InspectorBackend.registerEvent("DOM.attributeRemoved", ["nodeId", "name"]);
InspectorBackend.registerEvent("DOM.inlineStyleInvalidated", ["nodeIds"]);
InspectorBackend.registerEvent("DOM.characterDataModified", ["nodeId", "characterData"]);
InspectorBackend.registerEvent("DOM.childNodeCountUpdated", ["nodeId", "childNodeCount"]);
InspectorBackend.registerEvent("DOM.childNodeInserted", ["parentNodeId", "previousNodeId", "node"]);
InspectorBackend.registerEvent("DOM.childNodeRemoved", ["parentNodeId", "nodeId"]);
InspectorBackend.registerEvent("DOM.shadowRootPushed", ["hostId", "root"]);
InspectorBackend.registerEvent("DOM.shadowRootPopped", ["hostId", "rootId"]);
InspectorBackend.registerEvent("DOM.pseudoElementAdded", ["parentId", "pseudoElement"]);
InspectorBackend.registerEvent("DOM.pseudoElementRemoved", ["parentId", "pseudoElementId"]);
InspectorBackend.registerEvent("DOM.distributedNodesUpdated", ["insertionPointId", "distributedNodes"]);
InspectorBackend.registerEvent("DOM.nodeHighlightRequested", ["nodeId"]);
InspectorBackend.registerCommand("DOM.enable", [], [], false);
InspectorBackend.registerCommand("DOM.disable", [], [], false);
InspectorBackend.registerCommand("DOM.getDocument", [], ["root"], false);
InspectorBackend.registerCommand("DOM.requestChildNodes", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "depth", "type": "number", "optional": true}], [], false);
InspectorBackend.registerCommand("DOM.querySelector", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "selector", "type": "string", "optional": false}], ["nodeId"], false);
InspectorBackend.registerCommand("DOM.querySelectorAll", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "selector", "type": "string", "optional": false}], ["nodeIds"], false);
InspectorBackend.registerCommand("DOM.setNodeName", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "name", "type": "string", "optional": false}], ["nodeId"], false);
InspectorBackend.registerCommand("DOM.setNodeValue", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "value", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("DOM.removeNode", [{"name": "nodeId", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("DOM.setAttributeValue", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "name", "type": "string", "optional": false}, {"name": "value", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("DOM.setAttributesAsText", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "text", "type": "string", "optional": false}, {"name": "name", "type": "string", "optional": true}], [], false);
InspectorBackend.registerCommand("DOM.removeAttribute", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "name", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("DOM.getOuterHTML", [{"name": "nodeId", "type": "number", "optional": false}], ["outerHTML"], false);
InspectorBackend.registerCommand("DOM.setOuterHTML", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "outerHTML", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("DOM.performSearch", [{"name": "query", "type": "string", "optional": false}, {"name": "includeUserAgentShadowDOM", "type": "boolean", "optional": true}], ["searchId", "resultCount"], false);
InspectorBackend.registerCommand("DOM.getSearchResults", [{"name": "searchId", "type": "string", "optional": false}, {"name": "fromIndex", "type": "number", "optional": false}, {"name": "toIndex", "type": "number", "optional": false}], ["nodeIds"], false);
InspectorBackend.registerCommand("DOM.discardSearchResults", [{"name": "searchId", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("DOM.requestNode", [{"name": "objectId", "type": "string", "optional": false}], ["nodeId"], false);
InspectorBackend.registerCommand("DOM.setInspectMode", [{"name": "mode", "type": "string", "optional": false}, {"name": "highlightConfig", "type": "object", "optional": true}], [], false);
InspectorBackend.registerCommand("DOM.highlightRect", [{"name": "x", "type": "number", "optional": false}, {"name": "y", "type": "number", "optional": false}, {"name": "width", "type": "number", "optional": false}, {"name": "height", "type": "number", "optional": false}, {"name": "color", "type": "object", "optional": true}, {"name": "outlineColor", "type": "object", "optional": true}], [], false);
InspectorBackend.registerCommand("DOM.highlightQuad", [{"name": "quad", "type": "object", "optional": false}, {"name": "color", "type": "object", "optional": true}, {"name": "outlineColor", "type": "object", "optional": true}], [], false);
InspectorBackend.registerCommand("DOM.highlightNode", [{"name": "highlightConfig", "type": "object", "optional": false}, {"name": "nodeId", "type": "number", "optional": true}, {"name": "backendNodeId", "type": "number", "optional": true}, {"name": "objectId", "type": "string", "optional": true}], [], false);
InspectorBackend.registerCommand("DOM.hideHighlight", [], [], false);
InspectorBackend.registerCommand("DOM.highlightFrame", [{"name": "frameId", "type": "string", "optional": false}, {"name": "contentColor", "type": "object", "optional": true}, {"name": "contentOutlineColor", "type": "object", "optional": true}], [], false);
InspectorBackend.registerCommand("DOM.pushNodeByPathToFrontend", [{"name": "path", "type": "string", "optional": false}], ["nodeId"], false);
InspectorBackend.registerCommand("DOM.pushNodesByBackendIdsToFrontend", [{"name": "backendNodeIds", "type": "object", "optional": false}], ["nodeIds"], false);
InspectorBackend.registerCommand("DOM.setInspectedNode", [{"name": "nodeId", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("DOM.resolveNode", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "objectGroup", "type": "string", "optional": true}], ["object"], false);
InspectorBackend.registerCommand("DOM.getAttributes", [{"name": "nodeId", "type": "number", "optional": false}], ["attributes"], false);
InspectorBackend.registerCommand("DOM.copyTo", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "targetNodeId", "type": "number", "optional": false}, {"name": "insertBeforeNodeId", "type": "number", "optional": true}], ["nodeId"], false);
InspectorBackend.registerCommand("DOM.moveTo", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "targetNodeId", "type": "number", "optional": false}, {"name": "insertBeforeNodeId", "type": "number", "optional": true}], ["nodeId"], false);
InspectorBackend.registerCommand("DOM.undo", [], [], false);
InspectorBackend.registerCommand("DOM.redo", [], [], false);
InspectorBackend.registerCommand("DOM.markUndoableState", [], [], false);
InspectorBackend.registerCommand("DOM.focus", [{"name": "nodeId", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("DOM.setFileInputFiles", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "files", "type": "object", "optional": false}], [], false);
InspectorBackend.registerCommand("DOM.getBoxModel", [{"name": "nodeId", "type": "number", "optional": false}], ["model"], false);
InspectorBackend.registerCommand("DOM.getNodeForLocation", [{"name": "x", "type": "number", "optional": false}, {"name": "y", "type": "number", "optional": false}], ["nodeId"], false);
InspectorBackend.registerCommand("DOM.getRelayoutBoundary", [{"name": "nodeId", "type": "number", "optional": false}], ["nodeId"], false);
InspectorBackend.registerCommand("DOM.getHighlightObjectForTest", [{"name": "nodeId", "type": "number", "optional": false}], ["highlight"], false);

// CSS.
InspectorBackend.registerEnum("CSS.StyleSheetOrigin", {Injected: "injected", UserAgent: "user-agent", Inspector: "inspector", Regular: "regular"});
InspectorBackend.registerEnum("CSS.CSSMediaSource", {MediaRule: "mediaRule", ImportRule: "importRule", LinkedSheet: "linkedSheet", InlineSheet: "inlineSheet"});
InspectorBackend.registerEvent("CSS.mediaQueryResultChanged", []);
InspectorBackend.registerEvent("CSS.styleSheetChanged", ["styleSheetId"]);
InspectorBackend.registerEvent("CSS.styleSheetAdded", ["header"]);
InspectorBackend.registerEvent("CSS.styleSheetRemoved", ["styleSheetId"]);
InspectorBackend.registerEvent("CSS.layoutEditorChange", ["styleSheetId", "changeRange"]);
InspectorBackend.registerCommand("CSS.enable", [], [], false);
InspectorBackend.registerCommand("CSS.disable", [], [], false);
InspectorBackend.registerCommand("CSS.getMatchedStylesForNode", [{"name": "nodeId", "type": "number", "optional": false}], ["inlineStyle", "attributesStyle", "matchedCSSRules", "pseudoElements", "inherited", "cssKeyframesRules"], false);
InspectorBackend.registerCommand("CSS.getInlineStylesForNode", [{"name": "nodeId", "type": "number", "optional": false}], ["inlineStyle", "attributesStyle"], false);
InspectorBackend.registerCommand("CSS.getComputedStyleForNode", [{"name": "nodeId", "type": "number", "optional": false}], ["computedStyle"], false);
InspectorBackend.registerCommand("CSS.getPlatformFontsForNode", [{"name": "nodeId", "type": "number", "optional": false}], ["fonts"], false);
InspectorBackend.registerCommand("CSS.getStyleSheetText", [{"name": "styleSheetId", "type": "string", "optional": false}], ["text"], false);
InspectorBackend.registerCommand("CSS.setStyleSheetText", [{"name": "styleSheetId", "type": "string", "optional": false}, {"name": "text", "type": "string", "optional": false}], ["sourceMapURL"], false);
InspectorBackend.registerCommand("CSS.setRuleSelector", [{"name": "styleSheetId", "type": "string", "optional": false}, {"name": "range", "type": "object", "optional": false}, {"name": "selector", "type": "string", "optional": false}], ["selectorList"], false);
InspectorBackend.registerCommand("CSS.setKeyframeKey", [{"name": "styleSheetId", "type": "string", "optional": false}, {"name": "range", "type": "object", "optional": false}, {"name": "keyText", "type": "string", "optional": false}], ["keyText"], false);
InspectorBackend.registerCommand("CSS.setStyleTexts", [{"name": "edits", "type": "object", "optional": false}], ["styles"], false);
InspectorBackend.registerCommand("CSS.setMediaText", [{"name": "styleSheetId", "type": "string", "optional": false}, {"name": "range", "type": "object", "optional": false}, {"name": "text", "type": "string", "optional": false}], ["media"], false);
InspectorBackend.registerCommand("CSS.createStyleSheet", [{"name": "frameId", "type": "string", "optional": false}], ["styleSheetId"], false);
InspectorBackend.registerCommand("CSS.addRule", [{"name": "styleSheetId", "type": "string", "optional": false}, {"name": "ruleText", "type": "string", "optional": false}, {"name": "location", "type": "object", "optional": false}], ["rule"], false);
InspectorBackend.registerCommand("CSS.forcePseudoState", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "forcedPseudoClasses", "type": "object", "optional": false}], [], false);
InspectorBackend.registerCommand("CSS.getMediaQueries", [], ["medias"], false);
InspectorBackend.registerCommand("CSS.setEffectivePropertyValueForNode", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "propertyName", "type": "string", "optional": false}, {"name": "value", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("CSS.getBackgroundColors", [{"name": "nodeId", "type": "number", "optional": false}], ["backgroundColors"], false);

// IO.
InspectorBackend.registerCommand("IO.read", [{"name": "handle", "type": "string", "optional": false}, {"name": "offset", "type": "number", "optional": true}, {"name": "size", "type": "number", "optional": true}], ["data", "eof"], false);
InspectorBackend.registerCommand("IO.close", [{"name": "handle", "type": "string", "optional": false}], [], false);

// Debugger.
InspectorBackend.registerEnum("Debugger.GeneratorObjectDetailsStatus", {Running: "running", Suspended: "suspended", Closed: "closed"});
InspectorBackend.registerEnum("Debugger.ScopeType", {Global: "global", Local: "local", With: "with", Closure: "closure", Catch: "catch", Block: "block", Script: "script"});
InspectorBackend.registerEnum("Debugger.PromiseDetailsStatus", {Pending: "pending", Resolved: "resolved", Rejected: "rejected"});
InspectorBackend.registerEvent("Debugger.globalObjectCleared", []);
InspectorBackend.registerEvent("Debugger.scriptParsed", ["scriptId", "url", "startLine", "startColumn", "endLine", "endColumn", "executionContextId", "isContentScript", "isInternalScript", "isLiveEdit", "sourceMapURL", "hasSourceURL", "deprecatedCommentWasUsed"]);
InspectorBackend.registerEvent("Debugger.scriptFailedToParse", ["scriptId", "url", "startLine", "startColumn", "endLine", "endColumn", "executionContextId", "isContentScript", "isInternalScript", "sourceMapURL", "hasSourceURL", "deprecatedCommentWasUsed"]);
InspectorBackend.registerEvent("Debugger.breakpointResolved", ["breakpointId", "location"]);
InspectorBackend.registerEvent("Debugger.paused", ["callFrames", "reason", "data", "hitBreakpoints", "asyncStackTrace"]);
InspectorBackend.registerEvent("Debugger.resumed", []);
InspectorBackend.registerEvent("Debugger.promiseUpdated", ["eventType", "promise"]);
InspectorBackend.registerEvent("Debugger.asyncOperationStarted", ["operation"]);
InspectorBackend.registerEvent("Debugger.asyncOperationCompleted", ["id"]);
InspectorBackend.registerCommand("Debugger.enable", [], [], false);
InspectorBackend.registerCommand("Debugger.disable", [], [], false);
InspectorBackend.registerCommand("Debugger.setBreakpointsActive", [{"name": "active", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("Debugger.setSkipAllPauses", [{"name": "skipped", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("Debugger.setBreakpointByUrl", [{"name": "lineNumber", "type": "number", "optional": false}, {"name": "url", "type": "string", "optional": true}, {"name": "urlRegex", "type": "string", "optional": true}, {"name": "columnNumber", "type": "number", "optional": true}, {"name": "condition", "type": "string", "optional": true}], ["breakpointId", "locations"], false);
InspectorBackend.registerCommand("Debugger.setBreakpoint", [{"name": "location", "type": "object", "optional": false}, {"name": "condition", "type": "string", "optional": true}], ["breakpointId", "actualLocation"], false);
InspectorBackend.registerCommand("Debugger.removeBreakpoint", [{"name": "breakpointId", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Debugger.continueToLocation", [{"name": "location", "type": "object", "optional": false}, {"name": "interstatementLocation", "type": "boolean", "optional": true}], [], false);
InspectorBackend.registerCommand("Debugger.stepOver", [], [], false);
InspectorBackend.registerCommand("Debugger.stepInto", [], [], false);
InspectorBackend.registerCommand("Debugger.stepOut", [], [], false);
InspectorBackend.registerCommand("Debugger.pause", [], [], false);
InspectorBackend.registerCommand("Debugger.resume", [], [], false);
InspectorBackend.registerCommand("Debugger.stepIntoAsync", [], [], false);
InspectorBackend.registerCommand("Debugger.searchInContent", [{"name": "scriptId", "type": "string", "optional": false}, {"name": "query", "type": "string", "optional": false}, {"name": "caseSensitive", "type": "boolean", "optional": true}, {"name": "isRegex", "type": "boolean", "optional": true}], ["result"], false);
InspectorBackend.registerCommand("Debugger.canSetScriptSource", [], ["result"], false);
InspectorBackend.registerCommand("Debugger.setScriptSource", [{"name": "scriptId", "type": "string", "optional": false}, {"name": "scriptSource", "type": "string", "optional": false}, {"name": "preview", "type": "boolean", "optional": true}], ["callFrames", "stackChanged", "asyncStackTrace", "compileError"], false);
InspectorBackend.registerCommand("Debugger.restartFrame", [{"name": "callFrameId", "type": "string", "optional": false}], ["callFrames", "asyncStackTrace"], false);
InspectorBackend.registerCommand("Debugger.getScriptSource", [{"name": "scriptId", "type": "string", "optional": false}], ["scriptSource"], false);
InspectorBackend.registerCommand("Debugger.getFunctionDetails", [{"name": "functionId", "type": "string", "optional": false}], ["details"], false);
InspectorBackend.registerCommand("Debugger.getGeneratorObjectDetails", [{"name": "objectId", "type": "string", "optional": false}], ["details"], false);
InspectorBackend.registerCommand("Debugger.getCollectionEntries", [{"name": "objectId", "type": "string", "optional": false}], ["entries"], false);
InspectorBackend.registerCommand("Debugger.setPauseOnExceptions", [{"name": "state", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Debugger.evaluateOnCallFrame", [{"name": "callFrameId", "type": "string", "optional": false}, {"name": "expression", "type": "string", "optional": false}, {"name": "objectGroup", "type": "string", "optional": true}, {"name": "includeCommandLineAPI", "type": "boolean", "optional": true}, {"name": "doNotPauseOnExceptionsAndMuteConsole", "type": "boolean", "optional": true}, {"name": "returnByValue", "type": "boolean", "optional": true}, {"name": "generatePreview", "type": "boolean", "optional": true}], ["result", "wasThrown", "exceptionDetails"], false);
InspectorBackend.registerCommand("Debugger.setVariableValue", [{"name": "scopeNumber", "type": "number", "optional": false}, {"name": "variableName", "type": "string", "optional": false}, {"name": "newValue", "type": "object", "optional": false}, {"name": "callFrameId", "type": "string", "optional": true}, {"name": "functionObjectId", "type": "string", "optional": true}], [], false);
InspectorBackend.registerCommand("Debugger.getStepInPositions", [{"name": "callFrameId", "type": "string", "optional": false}], ["stepInPositions"], false);
InspectorBackend.registerCommand("Debugger.getBacktrace", [], ["callFrames", "asyncStackTrace"], false);
InspectorBackend.registerCommand("Debugger.setAsyncCallStackDepth", [{"name": "maxDepth", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("Debugger.enablePromiseTracker", [{"name": "captureStacks", "type": "boolean", "optional": true}], [], false);
InspectorBackend.registerCommand("Debugger.disablePromiseTracker", [], [], false);
InspectorBackend.registerCommand("Debugger.getPromiseById", [{"name": "promiseId", "type": "number", "optional": false}, {"name": "objectGroup", "type": "string", "optional": true}], ["promise"], false);
InspectorBackend.registerCommand("Debugger.flushAsyncOperationEvents", [], [], false);
InspectorBackend.registerCommand("Debugger.setAsyncOperationBreakpoint", [{"name": "operationId", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("Debugger.removeAsyncOperationBreakpoint", [{"name": "operationId", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("Debugger.setBlackboxedRanges", [{"name": "scriptId", "type": "string", "optional": false}, {"name": "positions", "type": "object", "optional": false}], [], false);

// DOMDebugger.
InspectorBackend.registerEnum("DOMDebugger.DOMBreakpointType", {SubtreeModified: "subtree-modified", AttributeModified: "attribute-modified", NodeRemoved: "node-removed"});
InspectorBackend.registerCommand("DOMDebugger.setDOMBreakpoint", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "type", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("DOMDebugger.removeDOMBreakpoint", [{"name": "nodeId", "type": "number", "optional": false}, {"name": "type", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("DOMDebugger.setEventListenerBreakpoint", [{"name": "eventName", "type": "string", "optional": false}, {"name": "targetName", "type": "string", "optional": true}], [], false);
InspectorBackend.registerCommand("DOMDebugger.removeEventListenerBreakpoint", [{"name": "eventName", "type": "string", "optional": false}, {"name": "targetName", "type": "string", "optional": true}], [], false);
InspectorBackend.registerCommand("DOMDebugger.setInstrumentationBreakpoint", [{"name": "eventName", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("DOMDebugger.removeInstrumentationBreakpoint", [{"name": "eventName", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("DOMDebugger.setXHRBreakpoint", [{"name": "url", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("DOMDebugger.removeXHRBreakpoint", [{"name": "url", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("DOMDebugger.getEventListeners", [{"name": "objectId", "type": "string", "optional": false}], ["listeners"], false);

// Profiler.
InspectorBackend.registerEvent("Profiler.consoleProfileStarted", ["id", "location", "title"]);
InspectorBackend.registerEvent("Profiler.consoleProfileFinished", ["id", "location", "profile", "title"]);
InspectorBackend.registerCommand("Profiler.enable", [], [], false);
InspectorBackend.registerCommand("Profiler.disable", [], [], false);
InspectorBackend.registerCommand("Profiler.setSamplingInterval", [{"name": "interval", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("Profiler.start", [], [], false);
InspectorBackend.registerCommand("Profiler.stop", [], ["profile"], false);

// HeapProfiler.
InspectorBackend.registerEvent("HeapProfiler.addHeapSnapshotChunk", ["chunk"]);
InspectorBackend.registerEvent("HeapProfiler.resetProfiles", []);
InspectorBackend.registerEvent("HeapProfiler.reportHeapSnapshotProgress", ["done", "total", "finished"]);
InspectorBackend.registerEvent("HeapProfiler.lastSeenObjectId", ["lastSeenObjectId", "timestamp"]);
InspectorBackend.registerEvent("HeapProfiler.heapStatsUpdate", ["statsUpdate"]);
InspectorBackend.registerCommand("HeapProfiler.enable", [], [], false);
InspectorBackend.registerCommand("HeapProfiler.disable", [], [], false);
InspectorBackend.registerCommand("HeapProfiler.startTrackingHeapObjects", [{"name": "trackAllocations", "type": "boolean", "optional": true}], [], false);
InspectorBackend.registerCommand("HeapProfiler.stopTrackingHeapObjects", [{"name": "reportProgress", "type": "boolean", "optional": true}], [], false);
InspectorBackend.registerCommand("HeapProfiler.takeHeapSnapshot", [{"name": "reportProgress", "type": "boolean", "optional": true}], [], false);
InspectorBackend.registerCommand("HeapProfiler.collectGarbage", [], [], false);
InspectorBackend.registerCommand("HeapProfiler.getObjectByHeapObjectId", [{"name": "objectId", "type": "string", "optional": false}, {"name": "objectGroup", "type": "string", "optional": true}], ["result"], false);
InspectorBackend.registerCommand("HeapProfiler.addInspectedHeapObject", [{"name": "heapObjectId", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("HeapProfiler.getHeapObjectId", [{"name": "objectId", "type": "string", "optional": false}], ["heapSnapshotObjectId"], false);
InspectorBackend.registerCommand("HeapProfiler.startSampling", [], [], false);
InspectorBackend.registerCommand("HeapProfiler.stopSampling", [], ["profile"], false);

// Worker.
InspectorBackend.registerEvent("Worker.workerCreated", ["workerId", "url", "inspectorConnected"]);
InspectorBackend.registerEvent("Worker.workerTerminated", ["workerId"]);
InspectorBackend.registerEvent("Worker.dispatchMessageFromWorker", ["workerId", "message"]);
InspectorBackend.registerCommand("Worker.enable", [], [], false);
InspectorBackend.registerCommand("Worker.disable", [], [], false);
InspectorBackend.registerCommand("Worker.sendMessageToWorker", [{"name": "workerId", "type": "string", "optional": false}, {"name": "message", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Worker.connectToWorker", [{"name": "workerId", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Worker.disconnectFromWorker", [{"name": "workerId", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("Worker.setAutoconnectToWorkers", [{"name": "value", "type": "boolean", "optional": false}], [], false);

// ServiceWorker.
InspectorBackend.registerEnum("ServiceWorker.ServiceWorkerVersionRunningStatus", {Stopped: "stopped", Starting: "starting", Running: "running", Stopping: "stopping"});
InspectorBackend.registerEnum("ServiceWorker.ServiceWorkerVersionStatus", {New: "new", Installing: "installing", Installed: "installed", Activating: "activating", Activated: "activated", Redundant: "redundant"});
InspectorBackend.registerEvent("ServiceWorker.workerCreated", ["workerId", "url", "versionId"]);
InspectorBackend.registerEvent("ServiceWorker.workerTerminated", ["workerId"]);
InspectorBackend.registerEvent("ServiceWorker.dispatchMessage", ["workerId", "message"]);
InspectorBackend.registerEvent("ServiceWorker.workerRegistrationUpdated", ["registrations"]);
InspectorBackend.registerEvent("ServiceWorker.workerVersionUpdated", ["versions"]);
InspectorBackend.registerEvent("ServiceWorker.workerErrorReported", ["errorMessage"]);
InspectorBackend.registerEvent("ServiceWorker.debugOnStartUpdated", ["debugOnStart"]);
InspectorBackend.registerCommand("ServiceWorker.enable", [], [], false);
InspectorBackend.registerCommand("ServiceWorker.disable", [], [], false);
InspectorBackend.registerCommand("ServiceWorker.sendMessage", [{"name": "workerId", "type": "string", "optional": false}, {"name": "message", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("ServiceWorker.stop", [{"name": "workerId", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("ServiceWorker.unregister", [{"name": "scopeURL", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("ServiceWorker.updateRegistration", [{"name": "scopeURL", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("ServiceWorker.startWorker", [{"name": "scopeURL", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("ServiceWorker.stopWorker", [{"name": "versionId", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("ServiceWorker.inspectWorker", [{"name": "versionId", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("ServiceWorker.setDebugOnStart", [{"name": "debugOnStart", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("ServiceWorker.setForceUpdateOnPageLoad", [{"name": "registrationId", "type": "string", "optional": false}, {"name": "forceUpdateOnPageLoad", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("ServiceWorker.deliverPushMessage", [{"name": "origin", "type": "string", "optional": false}, {"name": "registrationId", "type": "string", "optional": false}, {"name": "data", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("ServiceWorker.getTargetInfo", [{"name": "targetId", "type": "string", "optional": false}], ["targetInfo"], false);
InspectorBackend.registerCommand("ServiceWorker.activateTarget", [{"name": "targetId", "type": "string", "optional": false}], [], false);

// Input.
InspectorBackend.registerEnum("Input.TouchPointState", {TouchPressed: "touchPressed", TouchReleased: "touchReleased", TouchMoved: "touchMoved", TouchStationary: "touchStationary", TouchCancelled: "touchCancelled"});
InspectorBackend.registerEnum("Input.GestureSourceType", {Default: "default", Touch: "touch", Mouse: "mouse"});
InspectorBackend.registerCommand("Input.dispatchKeyEvent", [{"name": "type", "type": "string", "optional": false}, {"name": "modifiers", "type": "number", "optional": true}, {"name": "timestamp", "type": "number", "optional": true}, {"name": "text", "type": "string", "optional": true}, {"name": "unmodifiedText", "type": "string", "optional": true}, {"name": "keyIdentifier", "type": "string", "optional": true}, {"name": "code", "type": "string", "optional": true}, {"name": "key", "type": "string", "optional": true}, {"name": "windowsVirtualKeyCode", "type": "number", "optional": true}, {"name": "nativeVirtualKeyCode", "type": "number", "optional": true}, {"name": "autoRepeat", "type": "boolean", "optional": true}, {"name": "isKeypad", "type": "boolean", "optional": true}, {"name": "isSystemKey", "type": "boolean", "optional": true}], [], false);
InspectorBackend.registerCommand("Input.dispatchMouseEvent", [{"name": "type", "type": "string", "optional": false}, {"name": "x", "type": "number", "optional": false}, {"name": "y", "type": "number", "optional": false}, {"name": "modifiers", "type": "number", "optional": true}, {"name": "timestamp", "type": "number", "optional": true}, {"name": "button", "type": "string", "optional": true}, {"name": "clickCount", "type": "number", "optional": true}], [], false);
InspectorBackend.registerCommand("Input.dispatchTouchEvent", [{"name": "type", "type": "string", "optional": false}, {"name": "touchPoints", "type": "object", "optional": false}, {"name": "modifiers", "type": "number", "optional": true}, {"name": "timestamp", "type": "number", "optional": true}], [], false);
InspectorBackend.registerCommand("Input.emulateTouchFromMouseEvent", [{"name": "type", "type": "string", "optional": false}, {"name": "x", "type": "number", "optional": false}, {"name": "y", "type": "number", "optional": false}, {"name": "timestamp", "type": "number", "optional": false}, {"name": "button", "type": "string", "optional": false}, {"name": "deltaX", "type": "number", "optional": true}, {"name": "deltaY", "type": "number", "optional": true}, {"name": "modifiers", "type": "number", "optional": true}, {"name": "clickCount", "type": "number", "optional": true}], [], false);
InspectorBackend.registerCommand("Input.synthesizePinchGesture", [{"name": "x", "type": "number", "optional": false}, {"name": "y", "type": "number", "optional": false}, {"name": "scaleFactor", "type": "number", "optional": false}, {"name": "relativeSpeed", "type": "number", "optional": true}, {"name": "gestureSourceType", "type": "string", "optional": true}], [], false);
InspectorBackend.registerCommand("Input.synthesizeScrollGesture", [{"name": "x", "type": "number", "optional": false}, {"name": "y", "type": "number", "optional": false}, {"name": "xDistance", "type": "number", "optional": true}, {"name": "yDistance", "type": "number", "optional": true}, {"name": "xOverscroll", "type": "number", "optional": true}, {"name": "yOverscroll", "type": "number", "optional": true}, {"name": "preventFling", "type": "boolean", "optional": true}, {"name": "speed", "type": "number", "optional": true}, {"name": "gestureSourceType", "type": "string", "optional": true}, {"name": "repeatCount", "type": "number", "optional": true}, {"name": "repeatDelayMs", "type": "number", "optional": true}, {"name": "interactionMarkerName", "type": "string", "optional": true}], [], false);
InspectorBackend.registerCommand("Input.synthesizeTapGesture", [{"name": "x", "type": "number", "optional": false}, {"name": "y", "type": "number", "optional": false}, {"name": "duration", "type": "number", "optional": true}, {"name": "tapCount", "type": "number", "optional": true}, {"name": "gestureSourceType", "type": "string", "optional": true}], [], false);

// LayerTree.
InspectorBackend.registerEnum("LayerTree.ScrollRectType", {RepaintsOnScroll: "RepaintsOnScroll", TouchEventHandler: "TouchEventHandler", WheelEventHandler: "WheelEventHandler"});
InspectorBackend.registerEvent("LayerTree.layerTreeDidChange", ["layers"]);
InspectorBackend.registerEvent("LayerTree.layerPainted", ["layerId", "clip"]);
InspectorBackend.registerCommand("LayerTree.enable", [], [], false);
InspectorBackend.registerCommand("LayerTree.disable", [], [], false);
InspectorBackend.registerCommand("LayerTree.compositingReasons", [{"name": "layerId", "type": "string", "optional": false}], ["compositingReasons"], false);
InspectorBackend.registerCommand("LayerTree.makeSnapshot", [{"name": "layerId", "type": "string", "optional": false}], ["snapshotId"], false);
InspectorBackend.registerCommand("LayerTree.loadSnapshot", [{"name": "tiles", "type": "object", "optional": false}], ["snapshotId"], false);
InspectorBackend.registerCommand("LayerTree.releaseSnapshot", [{"name": "snapshotId", "type": "string", "optional": false}], [], false);
InspectorBackend.registerCommand("LayerTree.profileSnapshot", [{"name": "snapshotId", "type": "string", "optional": false}, {"name": "minRepeatCount", "type": "number", "optional": true}, {"name": "minDuration", "type": "number", "optional": true}, {"name": "clipRect", "type": "object", "optional": true}], ["timings"], false);
InspectorBackend.registerCommand("LayerTree.replaySnapshot", [{"name": "snapshotId", "type": "string", "optional": false}, {"name": "fromStep", "type": "number", "optional": true}, {"name": "toStep", "type": "number", "optional": true}, {"name": "scale", "type": "number", "optional": true}], ["dataURL"], false);
InspectorBackend.registerCommand("LayerTree.snapshotCommandLog", [{"name": "snapshotId", "type": "string", "optional": false}], ["commandLog"], false);

// DeviceOrientation.
InspectorBackend.registerCommand("DeviceOrientation.setDeviceOrientationOverride", [{"name": "alpha", "type": "number", "optional": false}, {"name": "beta", "type": "number", "optional": false}, {"name": "gamma", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("DeviceOrientation.clearDeviceOrientationOverride", [], [], false);

// Tracing.
InspectorBackend.registerEvent("Tracing.dataCollected", ["value"]);
InspectorBackend.registerEvent("Tracing.tracingComplete", ["stream"]);
InspectorBackend.registerEvent("Tracing.bufferUsage", ["percentFull", "eventCount", "value"]);
InspectorBackend.registerCommand("Tracing.start", [{"name": "categories", "type": "string", "optional": true}, {"name": "options", "type": "string", "optional": true}, {"name": "bufferUsageReportingInterval", "type": "number", "optional": true}, {"name": "transferMode", "type": "string", "optional": true}], [], false);
InspectorBackend.registerCommand("Tracing.end", [], [], false);
InspectorBackend.registerCommand("Tracing.getCategories", [], ["categories"], false);
InspectorBackend.registerCommand("Tracing.requestMemoryDump", [], ["dumpGuid", "success"], false);
InspectorBackend.registerCommand("Tracing.recordClockSyncMarker", [{"name": "syncId", "type": "string", "optional": false}], [], false);

// Animation.
InspectorBackend.registerEnum("Animation.AnimationType", {CSSTransition: "CSSTransition", CSSAnimation: "CSSAnimation", WebAnimation: "WebAnimation"});
InspectorBackend.registerEvent("Animation.animationCreated", ["id"]);
InspectorBackend.registerEvent("Animation.animationStarted", ["animation"]);
InspectorBackend.registerEvent("Animation.animationCanceled", ["id"]);
InspectorBackend.registerCommand("Animation.enable", [], [], false);
InspectorBackend.registerCommand("Animation.disable", [], [], false);
InspectorBackend.registerCommand("Animation.getPlaybackRate", [], ["playbackRate"], false);
InspectorBackend.registerCommand("Animation.setPlaybackRate", [{"name": "playbackRate", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("Animation.getCurrentTime", [{"name": "id", "type": "string", "optional": false}], ["currentTime"], false);
InspectorBackend.registerCommand("Animation.setPaused", [{"name": "animations", "type": "object", "optional": false}, {"name": "paused", "type": "boolean", "optional": false}], [], false);
InspectorBackend.registerCommand("Animation.setTiming", [{"name": "animationId", "type": "string", "optional": false}, {"name": "duration", "type": "number", "optional": false}, {"name": "delay", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("Animation.seekAnimations", [{"name": "animations", "type": "object", "optional": false}, {"name": "currentTime", "type": "number", "optional": false}], [], false);
InspectorBackend.registerCommand("Animation.releaseAnimations", [{"name": "animations", "type": "object", "optional": false}], [], false);
InspectorBackend.registerCommand("Animation.resolveAnimation", [{"name": "animationId", "type": "string", "optional": false}], ["remoteObject"], false);

// Accessibility.
InspectorBackend.registerEnum("Accessibility.AXValueType", {Boolean: "boolean", Tristate: "tristate", BooleanOrUndefined: "booleanOrUndefined", Idref: "idref", IdrefList: "idrefList", Integer: "integer", Node: "node", NodeList: "nodeList", Number: "number", String: "string", ComputedString: "computedString", Token: "token", TokenList: "tokenList", DomRelation: "domRelation", Role: "role", InternalRole: "internalRole", ValueUndefined: "valueUndefined"});
InspectorBackend.registerEnum("Accessibility.AXValueSourceType", {Attribute: "attribute", Implicit: "implicit", Style: "style", Contents: "contents", Placeholder: "placeholder", RelatedElement: "relatedElement"});
InspectorBackend.registerEnum("Accessibility.AXValueNativeSourceType", {Figcaption: "figcaption", Label: "label", Labelfor: "labelfor", Labelwrapped: "labelwrapped", Legend: "legend", Tablecaption: "tablecaption", Title: "title", Other: "other"});
InspectorBackend.registerEnum("Accessibility.AXGlobalStates", {Disabled: "disabled", Hidden: "hidden", HiddenRoot: "hiddenRoot", Invalid: "invalid"});
InspectorBackend.registerEnum("Accessibility.AXLiveRegionAttributes", {Live: "live", Atomic: "atomic", Relevant: "relevant", Busy: "busy", Root: "root"});
InspectorBackend.registerEnum("Accessibility.AXWidgetAttributes", {Autocomplete: "autocomplete", Haspopup: "haspopup", Level: "level", Multiselectable: "multiselectable", Orientation: "orientation", Multiline: "multiline", Readonly: "readonly", Required: "required", Valuemin: "valuemin", Valuemax: "valuemax", Valuetext: "valuetext"});
InspectorBackend.registerEnum("Accessibility.AXWidgetStates", {Checked: "checked", Expanded: "expanded", Pressed: "pressed", Selected: "selected"});
InspectorBackend.registerEnum("Accessibility.AXRelationshipAttributes", {Activedescendant: "activedescendant", Flowto: "flowto", Controls: "controls", Describedby: "describedby", Labelledby: "labelledby", Owns: "owns"});
InspectorBackend.registerCommand("Accessibility.getAXNode", [{"name": "nodeId", "type": "number", "optional": false}], ["accessibilityNode"], false);


;/* InspectorBackendHostedMode.js */
// Copyright (c) 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//This should be executed immediately after InspectorBackend and InspectorBackendCommands

WebInspector.InspectorBackendHostedMode = {};

/**
 * @param {string} jsonUrl
 */
WebInspector.InspectorBackendHostedMode.loadFromJSONIfNeeded = function(jsonUrl)
{
    if (InspectorBackend.isInitialized())
        return;

    var xhr = new XMLHttpRequest();
    xhr.open("GET", jsonUrl, false);
    xhr.send(null);

    var schema = JSON.parse(xhr.responseText);
    var code = WebInspector.InspectorBackendHostedMode.generateCommands(schema);
    eval(code);
}

/**
 * @param {*} schema
 * @return {string}
 */
WebInspector.InspectorBackendHostedMode.generateCommands = function(schema)
{
    var jsTypes = { integer: "number", array: "object" };
    var rawTypes = {};
    var result = [];

    var domains = schema["domains"] || [];
    for (var i = 0; i < domains.length; ++i) {
        var domain = domains[i];
        for (var j = 0; domain.types && j < domain.types.length; ++j) {
            var type = domain.types[j];
            rawTypes[domain.domain + "." + type.id] = jsTypes[type.type] || type.type;
        }
    }

    function toUpperCase(groupIndex, group0, group1)
    {
        return [group0, group1][groupIndex].toUpperCase();
    }
    function generateEnum(enumName, items)
    {
        var members = [];
        for (var m = 0; m < items.length; ++m) {
            var value = items[m];
            var name = value.replace(/-(\w)/g, toUpperCase.bind(null, 1)).toTitleCase();
            name = name.replace(/HTML|XML|WML|API/ig, toUpperCase.bind(null, 0));
            members.push(name + ": \"" + value +"\"");
        }
        return "InspectorBackend.registerEnum(\"" + enumName + "\", {" + members.join(", ") + "});";
    }

    for (var i = 0; i < domains.length; ++i) {
        var domain = domains[i];

        var types = domain["types"] || [];
        for (var j = 0; j < types.length; ++j) {
            var type = types[j];
            if ((type["type"] === "string") && type["enum"])
                result.push(generateEnum(domain.domain + "." + type.id, type["enum"]));
            else if (type["type"] === "object") {
                var properties = type["properties"] || [];
                for (var k = 0; k < properties.length; ++k) {
                    var property = properties[k];
                    if ((property["type"] === "string") && property["enum"])
                        result.push(generateEnum(domain.domain + "." + type.id + property["name"].toTitleCase(), property["enum"]));
                }
            }
        }

        var commands = domain["commands"] || [];
        for (var j = 0; j < commands.length; ++j) {
            var command = commands[j];
            var parameters = command["parameters"];
            var paramsText = [];
            for (var k = 0; parameters && k < parameters.length; ++k) {
                var parameter = parameters[k];

                var type;
                if (parameter.type)
                    type = jsTypes[parameter.type] || parameter.type;
                else {
                    var ref = parameter["$ref"];
                    if (ref.indexOf(".") !== -1)
                        type = rawTypes[ref];
                    else
                        type = rawTypes[domain.domain + "." + ref];
                }

                var text = "{\"name\": \"" + parameter.name + "\", \"type\": \"" + type + "\", \"optional\": " + (parameter.optional ? "true" : "false") + "}";
                paramsText.push(text);
            }

            var returnsText = [];
            var returns = command["returns"] || [];
            for (var k = 0; k < returns.length; ++k) {
                var parameter = returns[k];
                returnsText.push("\"" + parameter.name + "\"");
            }
            var hasErrorData = String(Boolean(command.error));
            result.push("InspectorBackend.registerCommand(\"" + domain.domain + "." + command.name + "\", [" + paramsText.join(", ") + "], [" + returnsText.join(", ") + "], " + hasErrorData + ");");
        }

        for (var j = 0; domain.events && j < domain.events.length; ++j) {
            var event = domain.events[j];
            var paramsText = [];
            for (var k = 0; event.parameters && k < event.parameters.length; ++k) {
                var parameter = event.parameters[k];
                paramsText.push("\"" + parameter.name + "\"");
            }
            result.push("InspectorBackend.registerEvent(\"" + domain.domain + "." + event.name + "\", [" + paramsText.join(", ") + "]);");
        }
    }
    return result.join("\n");
}

WebInspector.InspectorBackendHostedMode.loadFromJSONIfNeeded("../protocol.json");
;/* Target.js */
/*
 * Copyright 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/**
 * @constructor
 * @extends {Protocol.Agents}
 * @param {!WebInspector.TargetManager} targetManager
 * @param {string} name
 * @param {number} type
 * @param {!InspectorBackendClass.Connection} connection
 * @param {?WebInspector.Target} parentTarget
 */
WebInspector.Target = function(targetManager, name, type, connection, parentTarget)
{
    Protocol.Agents.call(this, connection.agentsMap());
    this._targetManager = targetManager;
    this._name = name;
    this._type = type;
    this._connection = connection;
    this._parentTarget = parentTarget;
    connection.addEventListener(InspectorBackendClass.Connection.Events.Disconnected, this._onDisconnect, this);
    this._id = WebInspector.Target._nextId++;

    /** @type {!Map.<!Function, !WebInspector.SDKModel>} */
    this._modelByConstructor = new Map();

    /** @type {!WebInspector.ConsoleModel} */
    this.consoleModel = new WebInspector.ConsoleModel(this);
    /** @type {!WebInspector.NetworkManager} */
    this.networkManager = new WebInspector.NetworkManager(this);
    /** @type {!WebInspector.ResourceTreeModel} */
    this.resourceTreeModel = new WebInspector.ResourceTreeModel(this);
    /** @type {!WebInspector.NetworkLog} */
    this.networkLog = new WebInspector.NetworkLog(this);

    /** @type {!WebInspector.RuntimeModel} */
    this.runtimeModel = new WebInspector.RuntimeModel(this);
    if (this.hasJSContext())
        new WebInspector.DebuggerModel(this);

    if (this._type === WebInspector.Target.Type.Page) {
        new WebInspector.DOMModel(this);
        new WebInspector.CSSStyleModel(this);
    }

    /** @type {?WebInspector.WorkerManager} */
    this.workerManager = !this.isDedicatedWorker() ? new WebInspector.WorkerManager(this) : null;
    /** @type {!WebInspector.CPUProfilerModel} */
    this.cpuProfilerModel = new WebInspector.CPUProfilerModel(this);
    /** @type {!WebInspector.HeapProfilerModel} */
    this.heapProfilerModel = new WebInspector.HeapProfilerModel(this);

    this.tracingManager = new WebInspector.TracingManager(this);

    if (this.isPage())
        this.serviceWorkerManager = new WebInspector.ServiceWorkerManager(this);
}

/**
 * @enum {number}
 */
WebInspector.Target.Type = {
    Page: 1,
    DedicatedWorker: 2,
    ServiceWorker: 4
}

WebInspector.Target._nextId = 1;

WebInspector.Target.prototype = {
    /**
     * @return {number}
     */
    id: function()
    {
        return this._id;
    },

    /**
     *
     * @return {string}
     */
    name: function()
    {
        return this._name;
    },

    /**
     *
     * @return {!WebInspector.TargetManager}
     */
    targetManager: function()
    {
        return this._targetManager;
    },

    /**
     * @param {string} label
     * @return {string}
     */
    decorateLabel: function(label)
    {
        return this.isWorker() ? "\u2699 " + label : label;
    },

    /**
     * @override
     * @param {string} domain
     * @param {!Object} dispatcher
     */
    registerDispatcher: function(domain, dispatcher)
    {
        this._connection.registerDispatcher(domain, dispatcher);
    },

    /**
     * @return {boolean}
     */
    isPage: function()
    {
        return this._type === WebInspector.Target.Type.Page;
    },

    /**
     * @return {boolean}
     */
    isWorker: function()
    {
        return this.isDedicatedWorker() || this.isServiceWorker();
    },

    /**
     * @return {boolean}
     */
    isDedicatedWorker: function()
    {
        return this._type === WebInspector.Target.Type.DedicatedWorker;
    },

    /**
     * @return {boolean}
     */
    isServiceWorker: function()
    {
        return this._type === WebInspector.Target.Type.ServiceWorker;
    },

    /**
     * @return {boolean}
     */
    hasJSContext: function()
    {
        return !this.isServiceWorker();
    },

    /**
     * @return {?WebInspector.Target}
     */
    parentTarget: function()
    {
        return this._parentTarget;
    },

    _onDisconnect: function()
    {
        this._targetManager.removeTarget(this);
        this._dispose();
    },

    _dispose: function()
    {
        this._targetManager.dispatchEventToListeners(WebInspector.TargetManager.Events.TargetDisposed, this);
        this.networkManager.dispose();
        this.cpuProfilerModel.dispose();
        WebInspector.ServiceWorkerCacheModel.fromTarget(this).dispose();
        if (this.workerManager)
            this.workerManager.dispose();
    },

    /**
     * @return {boolean}
     */
    isDetached: function()
    {
        return this._connection.isClosed();
    },

    /**
     * @param {!Function} modelClass
     * @return {?WebInspector.SDKModel}
     */
    model: function(modelClass)
    {
        return this._modelByConstructor.get(modelClass) || null;
    },

    __proto__: Protocol.Agents.prototype
}

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @param {!WebInspector.Target} target
 */
WebInspector.SDKObject = function(target)
{
    WebInspector.Object.call(this);
    this._target = target;
}

WebInspector.SDKObject.prototype = {
    /**
     * @return {!WebInspector.Target}
     */
    target: function()
    {
        return this._target;
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!Function} modelClass
 * @param {!WebInspector.Target} target
 */
WebInspector.SDKModel = function(modelClass, target)
{
    WebInspector.SDKObject.call(this, target);
    target._modelByConstructor.set(modelClass, this);
}

WebInspector.SDKModel.prototype = {
    /**
     * @return {!Promise}
     */
    suspendModel: function()
    {
        return Promise.resolve();
    },

    /**
     * @return {!Promise}
     */
    resumeModel: function()
    {
        return Promise.resolve();
    },

    __proto__: WebInspector.SDKObject.prototype
}

/**
 * @constructor
 * @extends {WebInspector.Object}
 */
WebInspector.TargetManager = function()
{
    WebInspector.Object.call(this);
    /** @type {!Array.<!WebInspector.Target>} */
    this._targets = [];
    /** @type {!Array.<!WebInspector.TargetManager.Observer>} */
    this._observers = [];
    this._observerTypeSymbol = Symbol("observerType");
    /** @type {!Object.<string, !Array.<{modelClass: !Function, thisObject: (!Object|undefined), listener: function(!WebInspector.Event)}>>} */
    this._modelListeners = {};
    this._isSuspended = false;
}

WebInspector.TargetManager.Events = {
    InspectedURLChanged: "InspectedURLChanged",
    MainFrameNavigated: "MainFrameNavigated",
    Load: "Load",
    PageReloadRequested: "PageReloadRequested",
    WillReloadPage: "WillReloadPage",
    TargetDisposed: "TargetDisposed",
    SuspendStateChanged: "SuspendStateChanged"
}

WebInspector.TargetManager.prototype = {
    suspendAllTargets: function()
    {
        if (this._isSuspended)
            return;
        this._isSuspended = true;
        this.dispatchEventToListeners(WebInspector.TargetManager.Events.SuspendStateChanged);

        for (var i = 0; i < this._targets.length; ++i) {
            for (var model of this._targets[i]._modelByConstructor.values())
                model.suspendModel();
        }
    },

    /**
     * @return {!Promise}
     */
    resumeAllTargets: function()
    {
        if (!this._isSuspended)
            throw new Error("Not suspended");
        this._isSuspended = false;
        this.dispatchEventToListeners(WebInspector.TargetManager.Events.SuspendStateChanged);

        var promises = [];
        for (var i = 0; i < this._targets.length; ++i) {
            for (var model of this._targets[i]._modelByConstructor.values())
                promises.push(model.resumeModel());
        }
        return Promise.all(promises);
    },

    suspendAndResumeAllTargets: function()
    {
        this.suspendAllTargets();
        this.resumeAllTargets();
    },

    /**
     * @return {boolean}
     */
    allTargetsSuspended: function()
    {
        return this._isSuspended;
    },

    /**
     * @return {string}
     */
    inspectedPageURL: function()
    {
        if (!this._targets.length)
            return "";

        return this._targets[0].resourceTreeModel.inspectedPageURL();
    },

    /**
     * @return {string}
     */
    inspectedPageDomain: function()
    {
        if (!this._targets.length)
            return "";

        return this._targets[0].resourceTreeModel.inspectedPageDomain();
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _redispatchEvent: function(event)
    {
        this.dispatchEventToListeners(event.type, event.data);
    },

    /**
     * @param {boolean=} ignoreCache
     * @param {string=} injectedScript
     */
    reloadPage: function(ignoreCache, injectedScript)
    {
        if (this._targets.length)
            this._targets[0].resourceTreeModel.reloadPage(ignoreCache, injectedScript);
    },

    /**
     * @param {!Function} modelClass
     * @param {string} eventType
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    addModelListener: function(modelClass, eventType, listener, thisObject)
    {
        for (var i = 0; i < this._targets.length; ++i) {
            var model = this._targets[i]._modelByConstructor.get(modelClass);
            if (model)
                model.addEventListener(eventType, listener, thisObject);
        }
        if (!this._modelListeners[eventType])
            this._modelListeners[eventType] = [];
        this._modelListeners[eventType].push({ modelClass: modelClass, thisObject: thisObject, listener: listener });
    },

    /**
     * @param {!Function} modelClass
     * @param {string} eventType
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    removeModelListener: function(modelClass, eventType, listener, thisObject)
    {
        if (!this._modelListeners[eventType])
            return;

        for (var i = 0; i < this._targets.length; ++i) {
            var model = this._targets[i]._modelByConstructor.get(modelClass);
            if (model)
                model.removeEventListener(eventType, listener, thisObject);
        }

        var listeners = this._modelListeners[eventType];
        for (var i = 0; i < listeners.length; ++i) {
            if (listeners[i].modelClass === modelClass && listeners[i].listener === listener && listeners[i].thisObject === thisObject)
                listeners.splice(i--, 1);
        }
        if (!listeners.length)
            delete this._modelListeners[eventType];
    },

    /**
     * @param {!WebInspector.TargetManager.Observer} targetObserver
     * @param {number=} type
     */
    observeTargets: function(targetObserver, type)
    {
        if (this._observerTypeSymbol in targetObserver)
            throw new Error("Observer can only be registered once");
        targetObserver[this._observerTypeSymbol] = type || 0x7fff;
        this.targets(type).forEach(targetObserver.targetAdded.bind(targetObserver));
        this._observers.push(targetObserver);
    },

    /**
     * @param {!WebInspector.TargetManager.Observer} targetObserver
     */
    unobserveTargets: function(targetObserver)
    {
        delete targetObserver[this._observerTypeSymbol];
        this._observers.remove(targetObserver);
    },

    /**
     * @param {string} name
     * @param {number} type
     * @param {!InspectorBackendClass.Connection} connection
     * @param {?WebInspector.Target} parentTarget
     * @return {!WebInspector.Target}
     */
    createTarget: function(name, type, connection, parentTarget)
    {
        var target = new WebInspector.Target(this, name, type, connection, parentTarget);
        this.addTarget(target);
        return target;
    },

    /**
     * @param {number} type
     * @return {!Array<!WebInspector.TargetManager.Observer>}
     */
    _observersByType: function(type)
    {
        var result = [];
        for (var observer of this._observers) {
            if (observer[this._observerTypeSymbol] & type)
                result.push(observer);
        }
        return result;
    },

    /**
     * @param {!WebInspector.Target} target
     */
    addTarget: function(target)
    {
        this._targets.push(target);
        if (this._targets.length === 1) {
            target.resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.InspectedURLChanged, this._redispatchEvent, this);
            target.resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.MainFrameNavigated, this._redispatchEvent, this);
            target.resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.Load, this._redispatchEvent, this);
            target.resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.PageReloadRequested, this._redispatchEvent, this);
            target.resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.WillReloadPage, this._redispatchEvent, this);
        }
        var copy = this._observersByType(target._type);
        for (var i = 0; i < copy.length; ++i)
            copy[i].targetAdded(target);

        for (var eventType in this._modelListeners) {
            var listeners = this._modelListeners[eventType];
            for (var i = 0; i < listeners.length; ++i) {
                var model = target._modelByConstructor.get(listeners[i].modelClass);
                if (model)
                    model.addEventListener(eventType, listeners[i].listener, listeners[i].thisObject);
            }
        }
    },

    /**
     * @param {!WebInspector.Target} target
     */
    removeTarget: function(target)
    {
        this._targets.remove(target);
        if (this._targets.length === 0) {
            target.resourceTreeModel.removeEventListener(WebInspector.ResourceTreeModel.EventTypes.InspectedURLChanged, this._redispatchEvent, this);
            target.resourceTreeModel.removeEventListener(WebInspector.ResourceTreeModel.EventTypes.MainFrameNavigated, this._redispatchEvent, this);
            target.resourceTreeModel.removeEventListener(WebInspector.ResourceTreeModel.EventTypes.Load, this._redispatchEvent, this);
            target.resourceTreeModel.removeEventListener(WebInspector.ResourceTreeModel.EventTypes.WillReloadPage, this._redispatchEvent, this);
        }
        var copy = this._observersByType(target._type);
        for (var i = 0; i < copy.length; ++i)
            copy[i].targetRemoved(target);

        for (var eventType in this._modelListeners) {
            var listeners = this._modelListeners[eventType];
            for (var i = 0; i < listeners.length; ++i) {
                var model = target._modelByConstructor.get(listeners[i].modelClass);
                if (model)
                    model.removeEventListener(eventType, listeners[i].listener, listeners[i].thisObject);
            }
        }
    },

    /**
     * @param {number=} type
     * @return {boolean}
     */
    hasTargets: function(type)
    {
        return !!this.targets(type).length;
    },

    /**
     * @param {number=} type
     * @return {!Array.<!WebInspector.Target>}
     */
    targets: function(type)
    {
        if (!type)
            return this._targets.slice();

        var result = [];
        for (var target of this._targets) {
            if (target._type & type)
                result.push(target);
        }
        return result;
    },

    /**
     * @return {!Array.<!WebInspector.Target>}
     */
    targetsWithJSContext: function()
    {
        var result = [];
        for (var target of this._targets) {
            if (target.hasJSContext())
                result.push(target);
        }
        return result;
    },

    /**
     *
     * @param {number} id
     * @return {?WebInspector.Target}
     */
    targetById: function(id)
    {
        for (var i = 0; i < this._targets.length; ++i) {
            if (this._targets[i].id() === id)
                return this._targets[i];
        }
        return null;
    },

    /**
     * @return {?WebInspector.Target}
     */
    mainTarget: function()
    {
        return this._targets[0] || null;
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @interface
 */
WebInspector.TargetManager.Observer = function()
{
}

WebInspector.TargetManager.Observer.prototype = {
    /**
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target) { },

    /**
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target) { },
}

/**
 * @type {!WebInspector.TargetManager}
 */
WebInspector.targetManager = new WebInspector.TargetManager();
;/* ApplicationCacheModel.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. AND ITS CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE INC.
 * OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!WebInspector.Target} target
 */
WebInspector.ApplicationCacheModel = function(target)
{
    WebInspector.SDKObject.call(this, target);

    target.registerApplicationCacheDispatcher(new WebInspector.ApplicationCacheDispatcher(this));
    this._agent = target.applicationCacheAgent();
    this._agent.enable();

    target.resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.FrameNavigated, this._frameNavigated, this);
    target.resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.FrameDetached, this._frameDetached, this);

    this._statuses = {};
    this._manifestURLsByFrame = {};

    this._mainFrameNavigated();

    this._onLine = true;
}

WebInspector.ApplicationCacheModel.EventTypes = {
    FrameManifestStatusUpdated: "FrameManifestStatusUpdated",
    FrameManifestAdded: "FrameManifestAdded",
    FrameManifestRemoved: "FrameManifestRemoved",
    NetworkStateChanged: "NetworkStateChanged"
}

WebInspector.ApplicationCacheModel.prototype = {
    _frameNavigated: function(event)
    {
        var frame = /** @type {!WebInspector.ResourceTreeFrame} */ (event.data);
        if (frame.isMainFrame()) {
            this._mainFrameNavigated();
            return;
        }

        this._agent.getManifestForFrame(frame.id, this._manifestForFrameLoaded.bind(this, frame.id));
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _frameDetached: function(event)
    {
        var frame = /** @type {!WebInspector.ResourceTreeFrame} */ (event.data);
        this._frameManifestRemoved(frame.id);
    },

    _mainFrameNavigated: function()
    {
        this._agent.getFramesWithManifests(this._framesWithManifestsLoaded.bind(this));
    },

    /**
     * @param {string} frameId
     * @param {?Protocol.Error} error
     * @param {string} manifestURL
     */
    _manifestForFrameLoaded: function(frameId, error, manifestURL)
    {
        if (error) {
            console.error(error);
            return;
        }

        if (!manifestURL)
            this._frameManifestRemoved(frameId);
    },

    /**
     * @param {?Protocol.Error} error
     * @param {!Array.<!ApplicationCacheAgent.FrameWithManifest>} framesWithManifests
     */
    _framesWithManifestsLoaded: function(error, framesWithManifests)
    {
        if (error) {
            console.error(error);
            return;
        }

        for (var i = 0; i < framesWithManifests.length; ++i)
            this._frameManifestUpdated(framesWithManifests[i].frameId, framesWithManifests[i].manifestURL, framesWithManifests[i].status);
    },

    /**
     * @param {string} frameId
     * @param {string} manifestURL
     * @param {number} status
     */
    _frameManifestUpdated: function(frameId, manifestURL, status)
    {
        if (status === applicationCache.UNCACHED) {
            this._frameManifestRemoved(frameId);
            return;
        }

        if (!manifestURL)
            return;

        if (this._manifestURLsByFrame[frameId] && manifestURL !== this._manifestURLsByFrame[frameId])
            this._frameManifestRemoved(frameId);

        var statusChanged = this._statuses[frameId] !== status;
        this._statuses[frameId] = status;

        if (!this._manifestURLsByFrame[frameId]) {
            this._manifestURLsByFrame[frameId] = manifestURL;
            this.dispatchEventToListeners(WebInspector.ApplicationCacheModel.EventTypes.FrameManifestAdded, frameId);
        }

        if (statusChanged)
            this.dispatchEventToListeners(WebInspector.ApplicationCacheModel.EventTypes.FrameManifestStatusUpdated, frameId);
    },

    /**
     * @param {string} frameId
     */
    _frameManifestRemoved: function(frameId)
    {
        if (!this._manifestURLsByFrame[frameId])
            return;

        delete this._manifestURLsByFrame[frameId];
        delete this._statuses[frameId];

        this.dispatchEventToListeners(WebInspector.ApplicationCacheModel.EventTypes.FrameManifestRemoved, frameId);
    },

    /**
     * @param {string} frameId
     * @return {string}
     */
    frameManifestURL: function(frameId)
    {
        return this._manifestURLsByFrame[frameId] || "";
    },

    /**
     * @param {string} frameId
     * @return {number}
     */
    frameManifestStatus: function(frameId)
    {
        return this._statuses[frameId] || applicationCache.UNCACHED;
    },

    /**
     * @return {boolean}
     */
    get onLine()
    {
        return this._onLine;
    },

    /**
     * @param {string} frameId
     * @param {string} manifestURL
     * @param {number} status
     */
    _statusUpdated: function(frameId, manifestURL, status)
    {
        this._frameManifestUpdated(frameId, manifestURL, status);
    },

    /**
     * @param {string} frameId
     * @param {function(?ApplicationCacheAgent.ApplicationCache)} callback
     */
    requestApplicationCache: function(frameId, callback)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {!ApplicationCacheAgent.ApplicationCache} applicationCache
         */
        function callbackWrapper(error, applicationCache)
        {
            if (error) {
                console.error(error);
                callback(null);
                return;
            }

            callback(applicationCache);
        }

        this._agent.getApplicationCacheForFrame(frameId, callbackWrapper);
    },

    /**
     * @param {boolean} isNowOnline
     */
    _networkStateUpdated: function(isNowOnline)
    {
        this._onLine = isNowOnline;
        this.dispatchEventToListeners(WebInspector.ApplicationCacheModel.EventTypes.NetworkStateChanged, isNowOnline);
    },

    __proto__: WebInspector.SDKObject.prototype
}

/**
 * @constructor
 * @implements {ApplicationCacheAgent.Dispatcher}
 */
WebInspector.ApplicationCacheDispatcher = function(applicationCacheModel)
{
    this._applicationCacheModel = applicationCacheModel;
}

WebInspector.ApplicationCacheDispatcher.prototype = {
    /**
     * @override
     * @param {string} frameId
     * @param {string} manifestURL
     * @param {number} status
     */
    applicationCacheStatusUpdated: function(frameId, manifestURL, status)
    {
        this._applicationCacheModel._statusUpdated(frameId, manifestURL, status);
    },

    /**
     * @override
     * @param {boolean} isNowOnline
     */
    networkStateUpdated: function(isNowOnline)
    {
        this._applicationCacheModel._networkStateUpdated(isNowOnline);
    }
}
;/* ConsoleModel.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKModel}
 * @param {!WebInspector.Target} target
 */
WebInspector.ConsoleModel = function(target)
{
    WebInspector.SDKModel.call(this, WebInspector.ConsoleModel, target);

    /** @type {!Array.<!WebInspector.ConsoleMessage>} */
    this._messages = [];
    /** @type {!Map<number, !WebInspector.ConsoleMessage>} */
    this._messageById = new Map();
    this._warnings = 0;
    this._errors = 0;
    this._revokedErrors = 0;
    this._consoleAgent = target.consoleAgent();
    target.registerConsoleDispatcher(new WebInspector.ConsoleDispatcher(this));
    this._enableAgent();
}

WebInspector.ConsoleModel.Events = {
    ConsoleCleared: "ConsoleCleared",
    MessageAdded: "MessageAdded",
    MessageUpdated: "MessageUpdated",
    CommandEvaluated: "CommandEvaluated",
}

WebInspector.ConsoleModel.prototype = {
    _enableAgent: function()
    {
        this._enablingConsole = true;

        /**
         * @this {WebInspector.ConsoleModel}
         */
        function callback()
        {
            delete this._enablingConsole;
        }
        this._consoleAgent.enable(callback.bind(this));
    },

    /**
     * @param {!WebInspector.ConsoleMessage} msg
     */
    addMessage: function(msg)
    {
        if (this._isBlacklisted(msg))
            return;

        if (msg.level === WebInspector.ConsoleMessage.MessageLevel.RevokedError && msg._relatedMessageId) {
            var relatedMessage = this._messageById.get(msg._relatedMessageId);
            if (!relatedMessage)
                return;
            this._errors--;
            this._revokedErrors++;
            relatedMessage.level = WebInspector.ConsoleMessage.MessageLevel.RevokedError;
            this.dispatchEventToListeners(WebInspector.ConsoleModel.Events.MessageUpdated, relatedMessage);
            return;
        }

        this._messages.push(msg);
        if (msg._messageId)
            this._messageById.set(msg._messageId, msg);
        this._incrementErrorWarningCount(msg);
        this.dispatchEventToListeners(WebInspector.ConsoleModel.Events.MessageAdded, msg);
    },

    /**
     * @param {!WebInspector.ConsoleMessage} msg
     */
    _incrementErrorWarningCount: function(msg)
    {
        switch (msg.level) {
            case WebInspector.ConsoleMessage.MessageLevel.Warning:
                this._warnings++;
                break;
            case WebInspector.ConsoleMessage.MessageLevel.Error:
                this._errors++;
                break;
            case WebInspector.ConsoleMessage.MessageLevel.RevokedError:
                this._revokedErrors++;
                break;
        }
    },

    /**
     * @param {!WebInspector.ConsoleMessage} msg
     * @return {boolean}
     */
    _isBlacklisted: function(msg)
    {
        if (msg.source != WebInspector.ConsoleMessage.MessageSource.Network || msg.level != WebInspector.ConsoleMessage.MessageLevel.Error || !msg.url || !msg.url.startsWith("chrome-extension"))
            return false;

        // ignore Chromecast's cast_sender spam
        if (msg.url.includes("://boadgeojelhgndaghljhdicfkmllpafd") ||  msg.url.includes("://dliochdbjfkdbacpmhlcpmleaejidimm") ||  msg.url.includes("://pkedcjkdefgpdelpbcmbmeomcjbeemfm") || msg.url.includes("://fjhoaacokmgbjemoflkofnenfaiekifl") || msg.url.includes("://ekpaaapppgpmolpcldedioblbkmijaca"))
            return true;

        return false;
    },

    /**
     * @return {!Array.<!WebInspector.ConsoleMessage>}
     */
    messages: function()
    {
        return this._messages;
    },

    requestClearMessages: function()
    {
        this._consoleAgent.clearMessages();
        this._messagesCleared();
    },

    _messagesCleared: function()
    {
        this._messages = [];
        this._messageById.clear();
        this._errors = 0;
        this._revokedErrors = 0;
        this._warnings = 0;
        this.dispatchEventToListeners(WebInspector.ConsoleModel.Events.ConsoleCleared);
    },

    /**
     * @return {number}
     */
    errors: function()
    {
        return this._errors;
    },

    /**
     * @return {number}
     */
    revokedErrors: function()
    {
        return this._revokedErrors;
    },

    /**
     * @return {number}
     */
    warnings: function()
    {
        return this._warnings;
    },

    __proto__: WebInspector.SDKModel.prototype
}

/**
 * @param {!WebInspector.ExecutionContext} executionContext
 * @param {string} text
 * @param {boolean=} useCommandLineAPI
 */
WebInspector.ConsoleModel.evaluateCommandInConsole = function(executionContext, text, useCommandLineAPI)
{
    var target = executionContext.target();

    var commandMessage = new WebInspector.ConsoleMessage(target, WebInspector.ConsoleMessage.MessageSource.JS, null, text, WebInspector.ConsoleMessage.MessageType.Command);
    commandMessage.setExecutionContextId(executionContext.id);
    target.consoleModel.addMessage(commandMessage);

    /**
     * @param {?WebInspector.RemoteObject} result
     * @param {boolean} wasThrown
     * @param {?RuntimeAgent.RemoteObject=} valueResult
     * @param {?RuntimeAgent.ExceptionDetails=} exceptionDetails
     */
    function printResult(result, wasThrown, valueResult, exceptionDetails)
    {
        if (!result)
            return;

        WebInspector.console.showPromise().then(reportUponEvaluation);
        function reportUponEvaluation()
        {
            target.consoleModel.dispatchEventToListeners(WebInspector.ConsoleModel.Events.CommandEvaluated, {result: result, wasThrown: wasThrown, text: text, commandMessage: commandMessage, exceptionDetails: exceptionDetails});
        }
    }
    if (/^\s*\{/.test(text) && /\}\s*$/.test(text))
        text = '(' + text + ')';
    executionContext.evaluate(text, "console", !!useCommandLineAPI, false, false, true, printResult);

    WebInspector.userMetrics.actionTaken(WebInspector.UserMetrics.Action.ConsoleEvaluated);
}

WebInspector.ConsoleModel.clearConsole = function()
{
    var targets = WebInspector.targetManager.targets();
    for (var i = 0; i < targets.length; ++i)
        targets[i].consoleModel.requestClearMessages();
}


/**
 * @constructor
 * @param {?WebInspector.Target} target
 * @param {string} source
 * @param {?string} level
 * @param {string} messageText
 * @param {string=} type
 * @param {?string=} url
 * @param {number=} line
 * @param {number=} column
 * @param {!NetworkAgent.RequestId=} requestId
 * @param {!Array.<!RuntimeAgent.RemoteObject>=} parameters
 * @param {!RuntimeAgent.StackTrace=} stackTrace
 * @param {number=} timestamp
 * @param {!RuntimeAgent.ExecutionContextId=} executionContextId
 * @param {?string=} scriptId
 * @param {number=} messageId
 * @param {number=} relatedMessageId
 */
WebInspector.ConsoleMessage = function(target, source, level, messageText, type, url, line, column, requestId, parameters, stackTrace, timestamp, executionContextId, scriptId, messageId, relatedMessageId)
{
    this._target = target;
    this.source = source;
    this.level = level;
    this.messageText = messageText;
    this.type = type || WebInspector.ConsoleMessage.MessageType.Log;
    /** @type {string|undefined} */
    this.url = url || undefined;
    /** @type {number} */
    this.line = line || 0;
    /** @type {number} */
    this.column = column || 0;
    this.parameters = parameters;
    /** @type {!RuntimeAgent.StackTrace|undefined} */
    this.stackTrace = stackTrace;
    this.timestamp = timestamp || Date.now();
    this.executionContextId = executionContextId || 0;
    this.scriptId = scriptId || null;
    this._messageId = messageId || 0;
    this._relatedMessageId = relatedMessageId || 0;

    this.request = requestId ? target.networkLog.requestForId(requestId) : null;

    if (this.request) {
        var initiator = this.request.initiator();
        if (initiator) {
            this.stackTrace = initiator.stack || undefined;
            if (initiator.url) {
                this.url = initiator.url;
                this.line = initiator.lineNumber || 0;
            }
        }
    }
}

WebInspector.ConsoleMessage.prototype = {
    /**
     * @return {?WebInspector.Target}
     */
    target: function()
    {
        return this._target;
    },

    /**
     * @param {!WebInspector.ConsoleMessage} originatingMessage
     */
    setOriginatingMessage: function(originatingMessage)
    {
        this._originatingConsoleMessage = originatingMessage;
        this.executionContextId = originatingMessage.executionContextId;
    },

    /**
     * @param {!RuntimeAgent.ExecutionContextId} executionContextId
     */
    setExecutionContextId: function(executionContextId)
    {
        this.executionContextId = executionContextId;
    },

    /**
     * @return {?WebInspector.ConsoleMessage}
     */
    originatingMessage: function()
    {
        return this._originatingConsoleMessage;
    },

    /**
     * @return {boolean}
     */
    isGroupMessage: function()
    {
        return this.type === WebInspector.ConsoleMessage.MessageType.StartGroup ||
            this.type === WebInspector.ConsoleMessage.MessageType.StartGroupCollapsed ||
            this.type === WebInspector.ConsoleMessage.MessageType.EndGroup;
    },

    /**
     * @return {boolean}
     */
    isGroupStartMessage: function()
    {
        return this.type === WebInspector.ConsoleMessage.MessageType.StartGroup ||
            this.type === WebInspector.ConsoleMessage.MessageType.StartGroupCollapsed;
    },

    /**
     * @return {boolean}
     */
    isErrorOrWarning: function()
    {
        return (this.level === WebInspector.ConsoleMessage.MessageLevel.Warning || this.level === WebInspector.ConsoleMessage.MessageLevel.Error);
    },

    /**
     * @param {?WebInspector.ConsoleMessage} msg
     * @return {boolean}
     */
    isEqual: function(msg)
    {
        if (!msg)
            return false;

        if (this._messageId || msg._messageId)
            return false;
        if (this._relatedMessageId || msg._relatedMessageId)
            return false;

        if (!this._isEqualStackTraces(this.stackTrace, msg.stackTrace))
            return false;

        if (this.parameters) {
            if (!msg.parameters || this.parameters.length !== msg.parameters.length)
                return false;

            for (var i = 0; i < msg.parameters.length; ++i) {
                // Never treat objects as equal - their properties might change over time.
                if (this.parameters[i].type !== msg.parameters[i].type || msg.parameters[i].type === "object" || this.parameters[i].value !== msg.parameters[i].value)
                    return false;
            }
        }

        return (this.target() === msg.target())
            && (this.source === msg.source)
            && (this.type === msg.type)
            && (this.level === msg.level)
            && (this.line === msg.line)
            && (this.url === msg.url)
            && (this.messageText === msg.messageText)
            && (this.request === msg.request)
            && (this.executionContextId === msg.executionContextId)
            && (this.scriptId === msg.scriptId);
    },

    /**
     * @param {!RuntimeAgent.StackTrace|undefined} stackTrace1
     * @param {!RuntimeAgent.StackTrace|undefined} stackTrace2
     * @return {boolean}
     */
    _isEqualStackTraces: function(stackTrace1, stackTrace2)
    {
        if (!stackTrace1 !== !stackTrace2)
            return false;
        if (!stackTrace1)
            return true;
        var callFrames1 = stackTrace1.callFrames;
        var callFrames2 = stackTrace2.callFrames;
        if (callFrames1.length !== callFrames2.length)
            return false;
        for (var i = 0, n = callFrames1.length; i < n; ++i) {
            if (callFrames1[i].url !== callFrames2[i].url ||
                callFrames1[i].functionName !== callFrames2[i].functionName ||
                callFrames1[i].lineNumber !== callFrames2[i].lineNumber ||
                callFrames1[i].columnNumber !== callFrames2[i].columnNumber)
                return false;
        }
        return this._isEqualStackTraces(stackTrace1.parent, stackTrace2.parent);
    }
}

// Note: Keep these constants in sync with the ones in Console.h
/**
 * @enum {string}
 */
WebInspector.ConsoleMessage.MessageSource = {
    XML: "xml",
    JS: "javascript",
    Network: "network",
    ConsoleAPI: "console-api",
    Storage: "storage",
    AppCache: "appcache",
    Rendering: "rendering",
    CSS: "css",
    Security: "security",
    Other: "other",
    Deprecation: "deprecation"
}

/**
 * @enum {string}
 */
WebInspector.ConsoleMessage.MessageType = {
    Log: "log",
    Dir: "dir",
    DirXML: "dirxml",
    Table: "table",
    Trace: "trace",
    Clear: "clear",
    StartGroup: "startGroup",
    StartGroupCollapsed: "startGroupCollapsed",
    EndGroup: "endGroup",
    Assert: "assert",
    Result: "result",
    Profile: "profile",
    ProfileEnd: "profileEnd",
    Command: "command"
}

/**
 * @enum {string}
 */
WebInspector.ConsoleMessage.MessageLevel = {
    Log: "log",
    Info: "info",
    Warning: "warning",
    Error: "error",
    Debug: "debug",
    RevokedError: "revokedError"
};

/**
 * @param {!WebInspector.ConsoleMessage} a
 * @param {!WebInspector.ConsoleMessage} b
 * @return {number}
 */
WebInspector.ConsoleMessage.timestampComparator = function (a, b)
{
    return a.timestamp - b.timestamp;
}

/**
 * @constructor
 * @implements {ConsoleAgent.Dispatcher}
 * @param {!WebInspector.ConsoleModel} console
 */
WebInspector.ConsoleDispatcher = function(console)
{
    this._console = console;
}

WebInspector.ConsoleDispatcher.prototype = {
    /**
     * @override
     * @param {!ConsoleAgent.ConsoleMessage} payload
     */
    messageAdded: function(payload)
    {
        var consoleMessage = new WebInspector.ConsoleMessage(
            this._console.target(),
            payload.source,
            payload.level,
            payload.text,
            payload.type,
            payload.url,
            payload.line,
            payload.column,
            payload.networkRequestId,
            payload.parameters,
            payload.stack,
            payload.timestamp * 1000, // Convert to ms.
            payload.executionContextId,
            payload.scriptId,
            payload.messageId,
            payload.relatedMessageId);
        this._console.addMessage(consoleMessage);
    },

    /**
     * @override
     * @param {number} count
     */
    messageRepeatCountUpdated: function(count)
    {
    },

    /**
     * @override
     */
    messagesCleared: function()
    {
        if (!WebInspector.moduleSetting("preserveConsoleLog").get())
            this._console._messagesCleared();
    }
}

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @implements {WebInspector.TargetManager.Observer}
 */
WebInspector.MultitargetConsoleModel = function()
{
    WebInspector.targetManager.observeTargets(this);
    WebInspector.targetManager.addModelListener(WebInspector.ConsoleModel, WebInspector.ConsoleModel.Events.MessageAdded, this._consoleMessageAdded, this);
    WebInspector.targetManager.addModelListener(WebInspector.ConsoleModel, WebInspector.ConsoleModel.Events.MessageUpdated, this._consoleMessageUpdated, this);
    WebInspector.targetManager.addModelListener(WebInspector.ConsoleModel, WebInspector.ConsoleModel.Events.CommandEvaluated, this._commandEvaluated, this);
}

WebInspector.MultitargetConsoleModel.prototype = {
    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target)
    {
        if (!this._mainTarget) {
            this._mainTarget = target;
            target.consoleModel.addEventListener(WebInspector.ConsoleModel.Events.ConsoleCleared, this._consoleCleared, this);
        }
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target)
    {
        if (this._mainTarget === target) {
            delete this._mainTarget;
            target.consoleModel.removeEventListener(WebInspector.ConsoleModel.Events.ConsoleCleared, this._consoleCleared, this);
        }
    },

    /**
     * @return {!Array.<!WebInspector.ConsoleMessage>}
     */
    messages: function()
    {
        var targets = WebInspector.targetManager.targets();
        var result = [];
        for (var i = 0; i < targets.length; ++i)
            result = result.concat(targets[i].consoleModel.messages());
        return result;
    },

    _consoleCleared: function()
    {
        this.dispatchEventToListeners(WebInspector.ConsoleModel.Events.ConsoleCleared);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _consoleMessageAdded: function(event)
    {
        this.dispatchEventToListeners(WebInspector.ConsoleModel.Events.MessageAdded, event.data);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _consoleMessageUpdated: function(event)
    {
        this.dispatchEventToListeners(WebInspector.ConsoleModel.Events.MessageUpdated, event.data);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _commandEvaluated: function(event)
    {
        this.dispatchEventToListeners(WebInspector.ConsoleModel.Events.CommandEvaluated, event.data);
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @type {!WebInspector.MultitargetConsoleModel}
 */
WebInspector.multitargetConsoleModel;
;/* ContentProviders.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @implements {WebInspector.ContentProvider}
 * @param {string} sourceURL
 * @param {!WebInspector.ResourceType} contentType
 */
WebInspector.CompilerSourceMappingContentProvider = function(sourceURL, contentType)
{
    this._sourceURL = sourceURL;
    this._contentType = contentType;
}

WebInspector.CompilerSourceMappingContentProvider.prototype = {
    /**
     * @override
     * @return {string}
     */
    contentURL: function()
    {
        return this._sourceURL;
    },

    /**
     * @override
     * @return {!WebInspector.ResourceType}
     */
    contentType: function()
    {
        return this._contentType;
    },

    /**
     * @override
     * @return {!Promise<?string>}
     */
    requestContent: function()
    {
        var callback;
        var promise = new Promise(fulfill => callback = fulfill);
        WebInspector.multitargetNetworkManager.loadResource(this._sourceURL, contentLoaded.bind(this));
        return promise;

        /**
         * @param {number} statusCode
         * @param {!Object.<string, string>} headers
         * @param {string} content
         * @this {WebInspector.CompilerSourceMappingContentProvider}
         */
        function contentLoaded(statusCode, headers, content)
        {
            if (statusCode >= 400) {
                console.error("Could not load content for " + this._sourceURL + " : " + "HTTP status code: " + statusCode);
                callback(null);
                return;
            }

            callback(content);
        }
    },

    /**
     * @override
     * @param {string} query
     * @param {boolean} caseSensitive
     * @param {boolean} isRegex
     * @param {function(!Array.<!WebInspector.ContentProvider.SearchMatch>)} callback
     */
    searchInContent: function(query, caseSensitive, isRegex, callback)
    {
        this.requestContent().then(contentLoaded);

        /**
         * @param {?string} content
         */
        function contentLoaded(content)
        {
            if (typeof content !== "string") {
                callback([]);
                return;
            }

            callback(WebInspector.ContentProvider.performSearchInContent(content, query, caseSensitive, isRegex));
        }
    }
}
;/* CookieParser.js */
/*
 * Copyright (C) 2010 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// Ideally, we would rely on platform support for parsing a cookie, since
// this would save us from any potential inconsistency. However, exposing
// platform cookie parsing logic would require quite a bit of additional
// plumbing, and at least some platforms lack support for parsing Cookie,
// which is in a format slightly different from Set-Cookie and is normally
// only required on the server side.

/**
 * @constructor
 * @param {!WebInspector.Target} target
 */
WebInspector.CookieParser = function(target)
{
    this._target = target;
}

/**
 * @constructor
 * @param {string} key
 * @param {string|undefined} value
 * @param {number} position
 */
WebInspector.CookieParser.KeyValue = function(key, value, position)
{
    this.key = key;
    this.value = value;
    this.position = position;
}

WebInspector.CookieParser.prototype = {
    /**
     * @return {!Array.<!WebInspector.Cookie>}
     */
    cookies: function()
    {
        return this._cookies;
    },

    /**
     * @param {string|undefined} cookieHeader
     * @return {?Array.<!WebInspector.Cookie>}
     */
    parseCookie: function(cookieHeader)
    {
        if (!this._initialize(cookieHeader))
            return null;

        for (var kv = this._extractKeyValue(); kv; kv = this._extractKeyValue()) {
            if (kv.key.charAt(0) === "$" && this._lastCookie)
                this._lastCookie.addAttribute(kv.key.slice(1), kv.value);
            else if (kv.key.toLowerCase() !== "$version" && typeof kv.value === "string")
                this._addCookie(kv, WebInspector.Cookie.Type.Request);
            this._advanceAndCheckCookieDelimiter();
        }
        this._flushCookie();
        return this._cookies;
    },

    /**
     * @param {string|undefined} setCookieHeader
     * @return {?Array.<!WebInspector.Cookie>}
     */
    parseSetCookie: function(setCookieHeader)
    {
        if (!this._initialize(setCookieHeader))
            return null;
        for (var kv = this._extractKeyValue(); kv; kv = this._extractKeyValue()) {
            if (this._lastCookie)
                this._lastCookie.addAttribute(kv.key, kv.value);
            else
                this._addCookie(kv, WebInspector.Cookie.Type.Response);
            if (this._advanceAndCheckCookieDelimiter())
                this._flushCookie();
        }
        this._flushCookie();
        return this._cookies;
    },

    /**
     * @param {string|undefined} headerValue
     * @return {boolean}
     */
    _initialize: function(headerValue)
    {
        this._input = headerValue;
        if (typeof headerValue !== "string")
            return false;
        this._cookies = [];
        this._lastCookie = null;
        this._originalInputLength = this._input.length;
        return true;
    },

    _flushCookie: function()
    {
        if (this._lastCookie)
            this._lastCookie.setSize(this._originalInputLength - this._input.length - this._lastCookiePosition);
        this._lastCookie = null;
    },

    /**
     * @return {?WebInspector.CookieParser.KeyValue}
     */
    _extractKeyValue: function()
    {
        if (!this._input || !this._input.length)
            return null;
        // Note: RFCs offer an option for quoted values that may contain commas and semicolons.
        // Many browsers/platforms do not support this, however (see http://webkit.org/b/16699
        // and http://crbug.com/12361). The logic below matches latest versions of IE, Firefox,
        // Chrome and Safari on some old platforms. The latest version of Safari supports quoted
        // cookie values, though.
        var keyValueMatch = /^[ \t]*([^\s=;]+)[ \t]*(?:=[ \t]*([^;\n]*))?/.exec(this._input);
        if (!keyValueMatch) {
            console.log("Failed parsing cookie header before: " + this._input);
            return null;
        }

        var result = new WebInspector.CookieParser.KeyValue(keyValueMatch[1], keyValueMatch[2] && keyValueMatch[2].trim(), this._originalInputLength - this._input.length);
        this._input = this._input.slice(keyValueMatch[0].length);
        return result;
    },

    /**
     * @return {boolean}
     */
    _advanceAndCheckCookieDelimiter: function()
    {
        var match = /^\s*[\n;]\s*/.exec(this._input);
        if (!match)
            return false;
        this._input = this._input.slice(match[0].length);
        return match[0].match("\n") !== null;
    },

    /**
     * @param {!WebInspector.CookieParser.KeyValue} keyValue
     * @param {!WebInspector.Cookie.Type} type
     */
    _addCookie: function(keyValue, type)
    {
        if (this._lastCookie)
            this._lastCookie.setSize(keyValue.position - this._lastCookiePosition);
        // Mozilla bug 169091: Mozilla, IE and Chrome treat single token (w/o "=") as
        // specifying a value for a cookie with empty name.
        this._lastCookie = typeof keyValue.value === "string" ? new WebInspector.Cookie(this._target, keyValue.key, keyValue.value, type) :
            new WebInspector.Cookie(this._target, "", keyValue.key, type);
        this._lastCookiePosition = keyValue.position;
        this._cookies.push(this._lastCookie);
    }
};

/**
 * @param {!WebInspector.Target} target
 * @param {string|undefined} header
 * @return {?Array.<!WebInspector.Cookie>}
 */
WebInspector.CookieParser.parseCookie = function(target, header)
{
    return (new WebInspector.CookieParser(target)).parseCookie(header);
}

/**
 * @param {!WebInspector.Target} target
 * @param {string|undefined} header
 * @return {?Array.<!WebInspector.Cookie>}
 */
WebInspector.CookieParser.parseSetCookie = function(target, header)
{
    return (new WebInspector.CookieParser(target)).parseSetCookie(header);
}

/**
 * @constructor
 * @param {!WebInspector.Target} target
 * @param {string} name
 * @param {string} value
 * @param {?WebInspector.Cookie.Type} type
 */
WebInspector.Cookie = function(target, name, value, type)
{
    this._target = target;
    this._name = name;
    this._value = value;
    this._type = type;
    this._attributes = {};
}

WebInspector.Cookie.prototype = {
    /**
     * @return {string}
     */
    name: function()
    {
        return this._name;
    },

    /**
     * @return {string}
     */
    value: function()
    {
        return this._value;
    },

    /**
     * @return {?WebInspector.Cookie.Type}
     */
    type: function()
    {
        return this._type;
    },

    /**
     * @return {boolean}
     */
    httpOnly: function()
    {
        return "httponly" in this._attributes;
    },

    /**
     * @return {boolean}
     */
    secure: function()
    {
        return "secure" in this._attributes;
    },

    /**
     * @return {boolean}
     */
    sameSite: function ()
    {
        return "samesite" in this._attributes;
    },

    /**
     * @return {boolean}
     */
    session: function()
    {
        // RFC 2965 suggests using Discard attribute to mark session cookies, but this does not seem to be widely used.
        // Check for absence of explicitly max-age or expiry date instead.
        return !("expires" in this._attributes || "max-age" in this._attributes);
    },

    /**
     * @return {string}
     */
    path: function()
    {
        return this._attributes["path"];
    },

    /**
     * @return {string}
     */
    port: function()
    {
        return this._attributes["port"];
    },

    /**
     * @return {string}
     */
    domain: function()
    {
        return this._attributes["domain"];
    },

    /**
     * @return {string}
     */
    expires: function()
    {
        return this._attributes["expires"];
    },

    /**
     * @return {string}
     */
    maxAge: function()
    {
        return this._attributes["max-age"];
    },

    /**
     * @return {number}
     */
    size: function()
    {
        return this._size;
    },

    /**
     * @param {number} size
     */
    setSize: function(size)
    {
        this._size = size;
    },

    /**
     * @return {?Date}
     */
    expiresDate: function(requestDate)
    {
        // RFC 6265 indicates that the max-age attribute takes precedence over the expires attribute
        if (this.maxAge()) {
            var targetDate = requestDate === null ? new Date() : requestDate;
            return new Date(targetDate.getTime() + 1000 * this.maxAge());
        }

        if (this.expires())
            return new Date(this.expires());

        return null;
    },

    /**
     * @return {!Object}
     */
    attributes: function()
    {
        return this._attributes;
    },

    /**
     * @param {string} key
     * @param {string=} value
     */
    addAttribute: function(key, value)
    {
        this._attributes[key.toLowerCase()] = value;
    },

    /**
     * @param {function(?Protocol.Error)=} callback
     */
    remove: function(callback)
    {
        this._target.networkAgent().deleteCookie(this.name(), (this.secure() ? "https://" : "http://") + this.domain() + this.path(), callback);
    }
}

/**
 * @enum {number}
 */
WebInspector.Cookie.Type = {
    Request: 0,
    Response: 1
};

WebInspector.Cookies = {}

/**
 * @param {function(!Array.<!WebInspector.Cookie>)} callback
 */
WebInspector.Cookies.getCookiesAsync = function(callback)
{
    var allCookies = [];
    /**
     * @param {!WebInspector.Target} target
     * @param {?Protocol.Error} error
     * @param {!Array.<!NetworkAgent.Cookie>} cookies
     */
    function mycallback(target, error, cookies)
    {
        if (error) {
            console.error(error);
            return;
        }
        for (var i = 0; i < cookies.length; ++i)
            allCookies.push(WebInspector.Cookies._parseProtocolCookie(target, cookies[i]));
    }

    var barrier = new CallbackBarrier();
    for (var target of WebInspector.targetManager.targets(WebInspector.Target.Type.Page))
        target.networkAgent().getCookies(barrier.createCallback(mycallback.bind(null, target)));
    barrier.callWhenDone(callback.bind(null, allCookies));
}

/**
 * @param {!WebInspector.Target} target
 * @param {!NetworkAgent.Cookie} protocolCookie
 * @return {!WebInspector.Cookie}
 */
WebInspector.Cookies._parseProtocolCookie = function(target, protocolCookie)
{
    var cookie = new WebInspector.Cookie(target, protocolCookie.name, protocolCookie.value, null);
    cookie.addAttribute("domain", protocolCookie["domain"]);
    cookie.addAttribute("path", protocolCookie["path"]);
    cookie.addAttribute("port", protocolCookie["port"]);
    if (protocolCookie["expires"])
        cookie.addAttribute("expires", protocolCookie["expires"]);
    if (protocolCookie["httpOnly"])
        cookie.addAttribute("httpOnly");
    if (protocolCookie["secure"])
        cookie.addAttribute("secure");
    if (protocolCookie["sameSite"])
        cookie.addAttribute("sameSite");
    cookie.setSize(protocolCookie["size"]);
    return cookie;
}

/**
 * @param {!WebInspector.Cookie} cookie
 * @param {string} resourceURL
 * @return {boolean}
 */
WebInspector.Cookies.cookieMatchesResourceURL = function(cookie, resourceURL)
{
    var url = resourceURL.asParsedURL();
    if (!url || !WebInspector.Cookies.cookieDomainMatchesResourceDomain(cookie.domain(), url.host))
        return false;
    return (url.path.startsWith(cookie.path())
        && (!cookie.port() || url.port == cookie.port())
        && (!cookie.secure() || url.scheme === "https"));
}

/**
 * @param {string} cookieDomain
 * @param {string} resourceDomain
 * @return {boolean}
 */
WebInspector.Cookies.cookieDomainMatchesResourceDomain = function(cookieDomain, resourceDomain)
{
    if (cookieDomain.charAt(0) !== '.')
        return resourceDomain === cookieDomain;
    return !!resourceDomain.match(new RegExp("^([^\\.]+\\.)*" + cookieDomain.substring(1).escapeForRegExp() + "$", "i"));
}
;/* CPUProfileDataModel.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


/**
 * @constructor
 * @param {!ProfilerAgent.CPUProfile} profile
 */
WebInspector.CPUProfileDataModel = function(profile)
{
    this.profileHead = profile.head;
    this.samples = profile.samples;
    this.timestamps = profile.timestamps;
    this.profileStartTime = profile.startTime * 1000;
    this.profileEndTime = profile.endTime * 1000;
    this._assignParentsInProfile();
    if (this.samples) {
        this._sortSamples();
        this._normalizeTimestamps();
        this._buildIdToNodeMap();
        this._fixMissingSamples();
    }
    if (!WebInspector.moduleSetting("showNativeFunctionsInJSProfile").get())
        this._filterNativeFrames();
    this._assignDepthsInProfile();
    this._calculateTimes(profile);
}

WebInspector.CPUProfileDataModel.prototype = {
    /**
     * @param {!ProfilerAgent.CPUProfile} profile
     */
    _calculateTimes: function(profile)
    {
        function totalHitCount(node) {
            var result = node.hitCount;
            for (var i = 0; i < node.children.length; i++)
                result += totalHitCount(node.children[i]);
            return result;
        }
        profile.totalHitCount = totalHitCount(profile.head);

        var duration = this.profileEndTime - this.profileStartTime;
        var samplingInterval = duration / profile.totalHitCount;
        this.samplingInterval = samplingInterval;

        function calculateTimesForNode(node) {
            node.selfTime = node.hitCount * samplingInterval;
            var totalHitCount = node.hitCount;
            for (var i = 0; i < node.children.length; i++)
                totalHitCount += calculateTimesForNode(node.children[i]);
            node.totalTime = totalHitCount * samplingInterval;
            return totalHitCount;
        }
        calculateTimesForNode(profile.head);
    },

    _filterNativeFrames: function()
    {
        if (this.samples) {
            for (var i = 0; i < this.samples.length; ++i) {
                var node = this.nodeByIndex(i);
                while (isNativeNode(node))
                    node = node.parent;
                this.samples[i] = node.id;
            }
        }
        processSubtree(this.profileHead);

        /**
         * @param {!ProfilerAgent.CPUProfileNode} node
         * @return {boolean}
         */
        function isNativeNode(node)
        {
            return !!node.url && node.url.startsWith("native ");
        }

        /**
         * @param {!ProfilerAgent.CPUProfileNode} node
         */
        function processSubtree(node)
        {
            var nativeChildren = [];
            var children = node.children;
            for (var i = 0, j = 0; i < children.length; ++i) {
                var child = children[i];
                if (isNativeNode(child)) {
                    nativeChildren.push(child);
                } else {
                    children[j++] = child;
                    processSubtree(child);
                }
            }
            children.length = j;
            nativeChildren.forEach(mergeChildren.bind(null, node));
        }

        /**
         * @param {!ProfilerAgent.CPUProfileNode} node
         * @param {!ProfilerAgent.CPUProfileNode} nativeNode
         */
        function mergeChildren(node, nativeNode)
        {
            node.hitCount += nativeNode.hitCount;
            for (var i = 0; i < nativeNode.children.length; ++i) {
                var child = nativeNode.children[i];
                if (isNativeNode(child)) {
                    mergeChildren(node, child);
                } else {
                    node.children.push(child);
                    child.parent = node;
                    processSubtree(child);
                }
            }
        }
    },

    _assignParentsInProfile: function()
    {
        var head = this.profileHead;
        head.parent = null;
        var nodesToTraverse = [ head ];
        while (nodesToTraverse.length) {
            var parent = nodesToTraverse.pop();
            var children = parent.children;
            var length = children.length;
            for (var i = 0; i < length; ++i) {
                var child = children[i];
                child.parent = parent;
                if (child.children.length)
                    nodesToTraverse.push(child);
            }
        }
    },

    _assignDepthsInProfile: function()
    {
        var head = this.profileHead;
        head.depth = -1;
        this.maxDepth = 0;
        var nodesToTraverse = [ head ];
        while (nodesToTraverse.length) {
            var parent = nodesToTraverse.pop();
            var depth = parent.depth + 1;
            if (depth > this.maxDepth)
                this.maxDepth = depth;
            var children = parent.children;
            var length = children.length;
            for (var i = 0; i < length; ++i) {
                var child = children[i];
                child.depth = depth;
                if (child.children.length)
                    nodesToTraverse.push(child);
            }
        }
    },

    _sortSamples: function()
    {
        var timestamps = this.timestamps;
        if (!timestamps)
            return;
        var samples = this.samples;
        var indices = timestamps.map((x, index) => index);
        indices.sort((a, b) => timestamps[a] - timestamps[b]);
        for (var i = 0; i < timestamps.length; ++i) {
            var index = indices[i];
            if (index === i)
                continue;
            // Move items in a cycle.
            var savedTimestamp = timestamps[i];
            var savedSample = samples[i];
            var currentIndex = i;
            while (index !== i) {
                samples[currentIndex] = samples[index];
                timestamps[currentIndex] = timestamps[index];
                currentIndex = index;
                index = indices[index];
                indices[currentIndex] = currentIndex;
            }
            samples[currentIndex] = savedSample;
            timestamps[currentIndex] = savedTimestamp;
        }
    },

    _normalizeTimestamps: function()
    {
        var timestamps = this.timestamps;
        if (!timestamps) {
            // Support loading old CPU profiles that are missing timestamps.
            // Derive timestamps from profile start and stop times.
            var profileStartTime = this.profileStartTime;
            var interval = (this.profileEndTime - profileStartTime) / this.samples.length;
            timestamps = new Float64Array(this.samples.length + 1);
            for (var i = 0; i < timestamps.length; ++i)
                timestamps[i] = profileStartTime + i * interval;
            this.timestamps = timestamps;
            return;
        }

        // Convert samples from usec to msec
        for (var i = 0; i < timestamps.length; ++i)
            timestamps[i] /= 1000;
        var averageSample = (timestamps.peekLast() - timestamps[0]) / (timestamps.length - 1);
        // Add an extra timestamp used to calculate the last sample duration.
        this.timestamps.push(timestamps.peekLast() + averageSample);
        this.profileStartTime = timestamps[0];
        this.profileEndTime = timestamps.peekLast();
    },

    _buildIdToNodeMap: function()
    {
        /** @type {!Object.<number, !ProfilerAgent.CPUProfileNode>} */
        this._idToNode = {};
        var idToNode = this._idToNode;
        var stack = [this.profileHead];
        while (stack.length) {
            var node = stack.pop();
            idToNode[node.id] = node;
            for (var i = 0; i < node.children.length; i++)
                stack.push(node.children[i]);
        }

        var topLevelNodes = this.profileHead.children;
        for (var i = 0; i < topLevelNodes.length && !(this.gcNode && this.programNode && this.idleNode); i++) {
            var node = topLevelNodes[i];
            if (node.functionName === "(garbage collector)")
                this.gcNode = node;
            else if (node.functionName === "(program)")
                this.programNode = node;
            else if (node.functionName === "(idle)")
                this.idleNode = node;
        }
    },

    _fixMissingSamples: function()
    {
        // Sometimes sampler is not able to parse the JS stack and returns
        // a (program) sample instead. The issue leads to call frames belong
        // to the same function invocation being split apart.
        // Here's a workaround for that. When there's a single (program) sample
        // between two call stacks sharing the same bottom node, it is replaced
        // with the preceeding sample.
        var samples = this.samples;
        var samplesCount = samples.length;
        if (!this.programNode || samplesCount < 3)
            return;
        var idToNode = this._idToNode;
        var programNodeId = this.programNode.id;
        var gcNodeId = this.gcNode ? this.gcNode.id : -1;
        var idleNodeId = this.idleNode ? this.idleNode.id : -1;
        var prevNodeId = samples[0];
        var nodeId = samples[1];
        for (var sampleIndex = 1; sampleIndex < samplesCount - 1; sampleIndex++) {
            var nextNodeId = samples[sampleIndex + 1];
            if (nodeId === programNodeId && !isSystemNode(prevNodeId) && !isSystemNode(nextNodeId)
                && bottomNode(idToNode[prevNodeId]) === bottomNode(idToNode[nextNodeId])) {
                samples[sampleIndex] = prevNodeId;
            }
            prevNodeId = nodeId;
            nodeId = nextNodeId;
        }

        /**
         * @param {!ProfilerAgent.CPUProfileNode} node
         * @return {!ProfilerAgent.CPUProfileNode}
         */
        function bottomNode(node)
        {
            while (node.parent.parent)
                node = node.parent;
            return node;
        }

        /**
         * @param {number} nodeId
         * @return {boolean}
         */
        function isSystemNode(nodeId)
        {
            return nodeId === programNodeId || nodeId === gcNodeId || nodeId === idleNodeId;
        }
    },

    /**
     * @param {function(number, !ProfilerAgent.CPUProfileNode, number)} openFrameCallback
     * @param {function(number, !ProfilerAgent.CPUProfileNode, number, number, number)} closeFrameCallback
     * @param {number=} startTime
     * @param {number=} stopTime
     */
    forEachFrame: function(openFrameCallback, closeFrameCallback, startTime, stopTime)
    {
        if (!this.profileHead)
            return;

        startTime = startTime || 0;
        stopTime = stopTime || Infinity;
        var samples = this.samples;
        var timestamps = this.timestamps;
        var idToNode = this._idToNode;
        var gcNode = this.gcNode;
        var samplesCount = samples.length;
        var startIndex = timestamps.lowerBound(startTime);
        var stackTop = 0;
        var stackNodes = [];
        var prevId = this.profileHead.id;
        var sampleTime = timestamps[samplesCount];
        var gcParentNode = null;

        if (!this._stackStartTimes)
            this._stackStartTimes = new Float64Array(this.maxDepth + 2);
        var stackStartTimes = this._stackStartTimes;
        if (!this._stackChildrenDuration)
            this._stackChildrenDuration = new Float64Array(this.maxDepth + 2);
        var stackChildrenDuration = this._stackChildrenDuration;

        for (var sampleIndex = startIndex; sampleIndex < samplesCount; sampleIndex++) {
            sampleTime = timestamps[sampleIndex];
            if (sampleTime >= stopTime)
                break;
            var id = samples[sampleIndex];
            if (id === prevId)
                continue;
            var node = idToNode[id];
            var prevNode = idToNode[prevId];

            if (node === gcNode) {
                // GC samples have no stack, so we just put GC node on top of the last recorded sample.
                gcParentNode = prevNode;
                openFrameCallback(gcParentNode.depth + 1, gcNode, sampleTime);
                stackStartTimes[++stackTop] = sampleTime;
                stackChildrenDuration[stackTop] = 0;
                prevId = id;
                continue;
            }
            if (prevNode === gcNode) {
                // end of GC frame
                var start = stackStartTimes[stackTop];
                var duration = sampleTime - start;
                stackChildrenDuration[stackTop - 1] += duration;
                closeFrameCallback(gcParentNode.depth + 1, gcNode, start, duration, duration - stackChildrenDuration[stackTop]);
                --stackTop;
                prevNode = gcParentNode;
                prevId = prevNode.id;
                gcParentNode = null;
            }

            while (node.depth > prevNode.depth) {
                stackNodes.push(node);
                node = node.parent;
            }

            // Go down to the LCA and close current intervals.
            while (prevNode !== node) {
                var start = stackStartTimes[stackTop];
                var duration = sampleTime - start;
                stackChildrenDuration[stackTop - 1] += duration;
                closeFrameCallback(prevNode.depth, prevNode, start, duration, duration - stackChildrenDuration[stackTop]);
                --stackTop;
                if (node.depth === prevNode.depth) {
                    stackNodes.push(node);
                    node = node.parent;
                }
                prevNode = prevNode.parent;
            }

            // Go up the nodes stack and open new intervals.
            while (stackNodes.length) {
                node = stackNodes.pop();
                openFrameCallback(node.depth, node, sampleTime);
                stackStartTimes[++stackTop] = sampleTime;
                stackChildrenDuration[stackTop] = 0;
            }

            prevId = id;
        }

        if (idToNode[prevId] === gcNode) {
            var start = stackStartTimes[stackTop];
            var duration = sampleTime - start;
            stackChildrenDuration[stackTop - 1] += duration;
            closeFrameCallback(gcParentNode.depth + 1, node, start, duration, duration - stackChildrenDuration[stackTop]);
            --stackTop;
        }

        for (var node = idToNode[prevId]; node.parent; node = node.parent) {
            var start = stackStartTimes[stackTop];
            var duration = sampleTime - start;
            stackChildrenDuration[stackTop - 1] += duration;
            closeFrameCallback(node.depth, node, start, duration, duration - stackChildrenDuration[stackTop]);
            --stackTop;
        }
    },

    /**
     * @param {number} index
     * @return {!ProfilerAgent.CPUProfileNode}
     */
    nodeByIndex: function(index)
    {
        return this._idToNode[this.samples[index]];
    }

}
;/* CPUProfilerModel.js */
/*
 * Copyright (C) 2014 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. AND ITS CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE INC.
 * OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKModel}
 * @param {!WebInspector.Target} target
 * @implements {ProfilerAgent.Dispatcher}
 */
WebInspector.CPUProfilerModel = function(target)
{
    WebInspector.SDKModel.call(this, WebInspector.CPUProfilerModel, target);
    this._isRecording = false;
    target.registerProfilerDispatcher(this);
    target.profilerAgent().enable();

    this._configureCpuProfilerSamplingInterval();
    WebInspector.moduleSetting("highResolutionCpuProfiling").addChangeListener(this._configureCpuProfilerSamplingInterval, this);
}

/** @enum {symbol} */
WebInspector.CPUProfilerModel.EventTypes = {
    ConsoleProfileStarted: Symbol("ConsoleProfileStarted"),
    ConsoleProfileFinished: Symbol("ConsoleProfileFinished")
};

/** @typedef {!{id: string, scriptLocation: !WebInspector.DebuggerModel.Location, title: (string|undefined), cpuProfile: (!ProfilerAgent.CPUProfile|undefined)}} */
WebInspector.CPUProfilerModel.EventData;

WebInspector.CPUProfilerModel.prototype = {
    _configureCpuProfilerSamplingInterval: function()
    {
        var intervalUs = WebInspector.moduleSetting("highResolutionCpuProfiling").get() ? 100 : 1000;
        this.target().profilerAgent().setSamplingInterval(intervalUs);
    },

    /**
     * @override
     * @param {string} id
     * @param {!DebuggerAgent.Location} scriptLocation
     * @param {string=} title
     */
    consoleProfileStarted: function(id, scriptLocation, title)
    {
        this._dispatchProfileEvent(WebInspector.CPUProfilerModel.EventTypes.ConsoleProfileStarted, id, scriptLocation, title);
    },

    /**
     * @override
     * @param {string} id
     * @param {!DebuggerAgent.Location} scriptLocation
     * @param {!ProfilerAgent.CPUProfile} cpuProfile
     * @param {string=} title
     */
    consoleProfileFinished: function(id, scriptLocation, cpuProfile, title)
    {
        this._dispatchProfileEvent(WebInspector.CPUProfilerModel.EventTypes.ConsoleProfileFinished, id, scriptLocation, title, cpuProfile);
    },

    /**
     * @param {symbol} eventName
     * @param {string} id
     * @param {!DebuggerAgent.Location} scriptLocation
     * @param {string=} title
     * @param {!ProfilerAgent.CPUProfile=} cpuProfile
     */
    _dispatchProfileEvent: function(eventName, id, scriptLocation, title, cpuProfile)
    {
        // Make sure ProfilesPanel is initialized and CPUProfileType is created.
        self.runtime.loadModulePromise("profiler").then(_ => {
            var debuggerModel = /** @type {!WebInspector.DebuggerModel} */ (WebInspector.DebuggerModel.fromTarget(this.target()));
            var debuggerLocation = WebInspector.DebuggerModel.Location.fromPayload(debuggerModel, scriptLocation);
            var globalId = this.target().id() + "." + id;
            var data = /** @type {!WebInspector.CPUProfilerModel.EventData} */ ({id: globalId, scriptLocation: debuggerLocation, cpuProfile: cpuProfile, title: title});
            this.dispatchEventToListeners(eventName, data);
        });
    },

    /**
      * @return {boolean}
      */
    isRecordingProfile: function()
    {
        return this._isRecording;
    },

    startRecording: function()
    {
        this._isRecording = true;
        this.target().profilerAgent().start();
        WebInspector.userMetrics.actionTaken(WebInspector.UserMetrics.Action.ProfilesCPUProfileTaken);
    },

    /**
     * @return {!Promise.<?ProfilerAgent.CPUProfile>}
     */
    stopRecording: function()
    {
        /**
         * @param {?Protocol.Error} error
         * @param {?ProfilerAgent.CPUProfile} profile
         * @return {?ProfilerAgent.CPUProfile}
         */
        function extractProfile(error, profile)
        {
            return !error && profile ? profile : null;
        }
        this._isRecording = false;
        return this.target().profilerAgent().stop(extractProfile);
    },

    dispose: function()
    {
        WebInspector.moduleSetting("highResolutionCpuProfiling").removeChangeListener(this._configureCpuProfilerSamplingInterval, this);
    },

    __proto__: WebInspector.SDKModel.prototype
}
;/* CSSMetadata.js */
/*
 * Copyright (C) 2010 Nikita Vasilyev. All rights reserved.
 * Copyright (C) 2010 Joseph Pecoraro. All rights reserved.
 * Copyright (C) 2010 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {!Array.<!{name: string, longhands: !Array.<string>}|string>} properties
 */
WebInspector.CSSMetadata = function(properties)
{
    this._values = /** !Array.<string> */ ([]);
    this._longhands = {};
    this._shorthands = {};
    for (var i = 0; i < properties.length; ++i) {
        var property = properties[i];
        if (typeof property === "string") {
            this._values.push(property);
            continue;
        }
        var propertyName = property.name;
        if (!CSS.supports(propertyName, "initial"))
            continue;
        this._values.push(propertyName);

        var longhands = properties[i].longhands;
        if (longhands) {
            this._longhands[propertyName] = longhands;
            for (var j = 0; j < longhands.length; ++j) {
                var longhandName = longhands[j];
                var shorthands = this._shorthands[longhandName];
                if (!shorthands) {
                    shorthands = [];
                    this._shorthands[longhandName] = shorthands;
                }
                shorthands.push(propertyName);
            }
        }
    }
    this._values.sort();
}

/**
 * @type {!WebInspector.CSSMetadata}
 */
WebInspector.CSSMetadata.cssPropertiesMetainfo = new WebInspector.CSSMetadata([]);

/**
 * @param {string} propertyName
 * @return {boolean}
 */
WebInspector.CSSMetadata.isColorAwareProperty = function(propertyName)
{
    return !!WebInspector.CSSMetadata._colorAwareProperties[propertyName.toLowerCase()];
}

/**
 * @param {string} propertyName
 * @return {boolean}
 */
WebInspector.CSSMetadata.isLengthProperty = function(propertyName)
{
    if (propertyName === "line-height")
        return false;
    if (!WebInspector.CSSMetadata._distancePropertiesKeySet)
        WebInspector.CSSMetadata._distancePropertiesKeySet = WebInspector.CSSMetadata._distanceProperties.keySet();
    return WebInspector.CSSMetadata._distancePropertiesKeySet[propertyName] || propertyName.startsWith("margin") || propertyName.startsWith("padding") || propertyName.indexOf("width") !== -1 || propertyName.indexOf("height") !== -1;
}

/**
 * @param {string} propertyName
 * @return {boolean}
 */
WebInspector.CSSMetadata.isBezierAwareProperty = function(propertyName)
{
    return !!WebInspector.CSSMetadata._bezierAwareProperties[propertyName.toLowerCase()];
}

// Originally taken from http://www.w3.org/TR/CSS21/propidx.html and augmented.
WebInspector.CSSMetadata.InheritedProperties = [
    "azimuth", "border-collapse", "border-spacing", "caption-side", "color", "cursor", "direction", "elevation",
    "empty-cells", "font-family", "font-size", "font-style", "font-variant", "font-weight", "font", "letter-spacing",
    "line-height", "list-style-image", "list-style-position", "list-style-type", "list-style", "orphans", "overflow-wrap", "pitch-range",
    "pitch", "quotes", "resize", "richness", "speak-header", "speak-numeral", "speak-punctuation", "speak", "speech-rate", "stress",
    "text-align", "text-indent", "text-transform", "text-shadow", "-webkit-user-select", "visibility", "voice-family", "volume", "white-space", "widows",
    "word-spacing", "word-wrap", "zoom"
].keySet();

// These non-standard Blink-specific properties augment the InheritedProperties.
WebInspector.CSSMetadata.NonStandardInheritedProperties = [
    "-webkit-font-smoothing"
].keySet();

/**
 * @param {string} name
 * @return {string}
 */
WebInspector.CSSMetadata.canonicalPropertyName = function(name)
{
    if (!name || name.length < 9 || name.charAt(0) !== "-")
        return name.toLowerCase();
    var match = name.match(/(?:-webkit-)(.+)/);
    var propertiesSet = WebInspector.CSSMetadata.cssPropertiesMetainfoKeySet();
    var hasSupportedProperties = WebInspector.CSSMetadata.cssPropertiesMetainfo._values.length > 0;
    if (!match || (hasSupportedProperties && !propertiesSet.hasOwnProperty(match[1].toLowerCase())))
        return name.toLowerCase();
    return match[1].toLowerCase();
}

/**
 * @param {string} propertyName
 * @return {boolean}
 */
WebInspector.CSSMetadata.isCSSPropertyName = function(propertyName)
{
    if (propertyName.startsWith("-moz-") || propertyName.startsWith("-o-") || propertyName.startsWith("-webkit-") || propertyName.startsWith("-ms-"))
        return true;
    var hasSupportedProperties = WebInspector.CSSMetadata.cssPropertiesMetainfo._values.length > 0;
    return !hasSupportedProperties || WebInspector.CSSMetadata.cssPropertiesMetainfoKeySet().hasOwnProperty(propertyName);
}

/**
 * @param {string} propertyName
 * @return {boolean}
 */
WebInspector.CSSMetadata.isPropertyInherited = function(propertyName)
{
    return !!(WebInspector.CSSMetadata.InheritedProperties[WebInspector.CSSMetadata.canonicalPropertyName(propertyName)]
            || WebInspector.CSSMetadata.NonStandardInheritedProperties[propertyName.toLowerCase()]);
}

WebInspector.CSSMetadata._distanceProperties = [
    'background-position', 'border-spacing', 'bottom', 'font-size', 'height', 'left', 'letter-spacing', 'max-height', 'max-width', 'min-height',
    'min-width', 'right', 'text-indent', 'top', 'width', 'word-spacing'
];

WebInspector.CSSMetadata._bezierAwareProperties = [
    "animation", "animation-timing-function", "transition", "transition-timing-function", "-webkit-animation", "-webkit-animation-timing-function",
    "-webkit-transition", "-webkit-transition-timing-function"
].keySet();

WebInspector.CSSMetadata._colorAwareProperties = [
    "background", "background-color", "background-image", "border", "border-color", "border-top", "border-right", "border-bottom",
    "border-left", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "box-shadow", "color",
    "fill", "outline", "outline-color", "stroke", "text-shadow", "-webkit-box-shadow", "-webkit-column-rule-color",
    "-webkit-text-decoration-color", "-webkit-text-emphasis", "-webkit-text-emphasis-color"
].keySet();

WebInspector.CSSMetadata._propertyDataMap = {
    "table-layout": { values: [
        "auto", "fixed"
    ] },
    "visibility": { values: [
        "hidden", "visible", "collapse"
    ] },
    "background-repeat": { values: [
        "repeat", "repeat-x", "repeat-y", "no-repeat", "space", "round"
    ] },
    "content": { values: [
        "list-item", "close-quote", "no-close-quote", "no-open-quote", "open-quote"
    ] },
    "list-style-image": { values: [
        "none"
    ] },
    "clear": { values: [
        "none", "left", "right", "both"
    ] },
    "overflow-x": { values: [
        "hidden", "auto", "visible", "overlay", "scroll"
    ] },
    "stroke-linejoin": { values: [
        "round", "miter", "bevel"
    ] },
    "baseline-shift": { values: [
        "baseline", "sub", "super"
    ] },
    "border-bottom-width": { values: [
        "medium", "thick", "thin"
    ] },
    "margin-top-collapse": { values: [
        "collapse", "separate", "discard"
    ] },
    "max-height": { values: [
        "none"
    ] },
    "box-orient": { values: [
        "horizontal", "vertical", "inline-axis", "block-axis"
    ], },
    "font-stretch": { values: [
        "normal", "wider", "narrower", "ultra-condensed", "extra-condensed", "condensed", "semi-condensed",
        "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"
    ] },
    "-webkit-background-composite": { values: [
        "highlight", "clear", "copy", "source-over", "source-in", "source-out", "source-atop", "destination-over",
        "destination-in", "destination-out", "destination-atop", "xor", "plus-darker", "plus-lighter"
    ] },
    "border-left-width": { values: [
        "medium", "thick", "thin"
    ] },
    "box-shadow": { values: [
        "inset", "none"
    ] },
    "writing-mode": { values: [
        "horizontal-tb", "vertical-rl", "vertical-lr"
    ] },
    "-webkit-writing-mode": { values: [
        "lr", "rl", "tb", "lr-tb", "rl-tb", "tb-rl", "horizontal-tb", "vertical-rl", "vertical-lr", "horizontal-bt"
    ] },
    "border-collapse": { values: [
        "collapse", "separate"
    ] },
    "page-break-inside": { values: [
        "auto", "avoid"
    ] },
    "border-top-width": { values: [
        "medium", "thick", "thin"
    ] },
    "outline-color": { values: [
        "invert"
    ] },
    "outline-style": { values: [
        "none", "hidden", "inset", "groove", "ridge", "outset", "dotted", "dashed", "solid", "double"
    ] },
    "cursor": { values: [
        "none", "copy", "auto", "crosshair", "default", "pointer", "move", "vertical-text", "cell", "context-menu",
        "alias", "progress", "no-drop", "not-allowed", "-webkit-zoom-in", "-webkit-zoom-out", "e-resize", "ne-resize",
        "nw-resize", "n-resize", "se-resize", "sw-resize", "s-resize", "w-resize", "ew-resize", "ns-resize",
        "nesw-resize", "nwse-resize", "col-resize", "row-resize", "text", "wait", "help", "all-scroll", "-webkit-grab",
        "-webkit-grabbing"
    ] },
    "border-width": { values: [
        "medium", "thick", "thin"
    ] },
    "border-style": { values: [
        "none", "hidden", "inset", "groove", "ridge", "outset", "dotted", "dashed", "solid", "double"
    ] },
    "size": { values: [
        "a3", "a4", "a5", "b4", "b5", "landscape", "ledger", "legal", "letter", "portrait"
    ] },
    "background-size": { values: [
        "contain", "cover"
    ] },
    "direction": { values: [
        "ltr", "rtl"
    ] },
    "enable-background": { values: [
        "accumulate", "new"
    ] },
    "float": { values: [
        "none", "left", "right"
    ] },
    "overflow-y": { values: [
        "hidden", "auto", "visible", "overlay", "scroll"
    ] },
    "margin-bottom-collapse": { values: [
        "collapse",  "separate", "discard"
    ] },
    "box-reflect": { values: [
        "left", "right", "above", "below"
    ] },
    "overflow": { values: [
        "hidden", "auto", "visible", "overlay", "scroll"
    ] },
    "text-rendering": { values: [
        "auto", "optimizeSpeed", "optimizeLegibility", "geometricPrecision"
    ] },
    "text-align": { values: [
        "-webkit-auto", "start", "end", "left", "right", "center", "justify", "-webkit-left", "-webkit-right", "-webkit-center"
    ] },
    "list-style-position": { values: [
        "outside", "inside", "hanging"
    ] },
    "margin-bottom": { values: [
        "auto"
    ] },
    "color-interpolation": { values: [
        "linearrgb"
    ] },
    "background-origin": { values: [
        "border-box", "content-box", "padding-box"
    ] },
    "word-wrap": { values: [
        "normal", "break-word"
    ] },
    "font-weight": { values: [
        "normal", "bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "700", "800", "900"
    ] },
    "margin-before-collapse": { values: [
        "collapse", "separate", "discard"
    ] },
    "text-transform": { values: [
        "none", "capitalize", "uppercase", "lowercase"
    ] },
    "border-right-style": { values: [
        "none", "hidden", "inset", "groove", "ridge", "outset", "dotted", "dashed", "solid", "double"
    ] },
    "border-left-style": { values: [
        "none", "hidden", "inset", "groove", "ridge", "outset", "dotted", "dashed", "solid", "double"
    ] },
    "-webkit-text-emphasis": { values: [
        "circle", "filled", "open", "dot", "double-circle", "triangle", "sesame"
    ] },
    "font-style": { values: [
        "italic", "oblique", "normal"
    ] },
    "speak": { values: [
        "none", "normal", "spell-out", "digits", "literal-punctuation", "no-punctuation"
    ] },
    "color-rendering": { values: [
        "auto", "optimizeSpeed", "optimizeQuality"
    ] },
    "list-style-type": { values: [
        "none", "inline", "disc", "circle", "square", "decimal", "decimal-leading-zero", "arabic-indic", "binary", "bengali",
        "cambodian", "khmer", "devanagari", "gujarati", "gurmukhi", "kannada", "lower-hexadecimal", "lao", "malayalam",
        "mongolian", "myanmar", "octal", "oriya", "persian", "urdu", "telugu", "tibetan", "thai", "upper-hexadecimal",
        "lower-roman", "upper-roman", "lower-greek", "lower-alpha", "lower-latin", "upper-alpha", "upper-latin", "afar",
        "ethiopic-halehame-aa-et", "ethiopic-halehame-aa-er", "amharic", "ethiopic-halehame-am-et", "amharic-abegede",
        "ethiopic-abegede-am-et", "cjk-earthly-branch", "cjk-heavenly-stem", "ethiopic", "ethiopic-halehame-gez",
        "ethiopic-abegede", "ethiopic-abegede-gez", "hangul-consonant", "hangul", "lower-norwegian", "oromo",
        "ethiopic-halehame-om-et", "sidama", "ethiopic-halehame-sid-et", "somali", "ethiopic-halehame-so-et", "tigre",
        "ethiopic-halehame-tig", "tigrinya-er", "ethiopic-halehame-ti-er", "tigrinya-er-abegede",
        "ethiopic-abegede-ti-er", "tigrinya-et", "ethiopic-halehame-ti-et", "tigrinya-et-abegede",
        "ethiopic-abegede-ti-et", "upper-greek", "upper-norwegian", "asterisks", "footnotes", "hebrew", "armenian",
        "lower-armenian", "upper-armenian", "georgian", "cjk-ideographic", "hiragana", "katakana", "hiragana-iroha",
        "katakana-iroha"
    ] },
    "text-combine-upright": { values: [
        "none", "all"
    ] },
    "-webkit-text-combine": { values: [
        "none", "horizontal"
    ] },
    "text-orientation": { values: [
        "mixed", "upright", "sideways"
    ] },
    "outline": { values: [
        "none", "hidden", "inset", "groove", "ridge", "outset", "dotted", "dashed", "solid", "double"
    ] },
    "font": { values: [
        "caption", "icon", "menu", "message-box", "small-caption", "-webkit-mini-control", "-webkit-small-control",
        "-webkit-control", "status-bar", "italic", "oblique", "small-caps", "normal", "bold", "bolder", "lighter",
        "100", "200", "300", "400", "500", "600", "700", "800", "900", "xx-small", "x-small", "small", "medium",
        "large", "x-large", "xx-large", "-webkit-xxx-large", "smaller", "larger", "serif", "sans-serif", "cursive",
        "fantasy", "monospace", "-webkit-body", "-webkit-pictograph"
    ] },
    "dominant-baseline": { values: [
        "middle", "auto", "central", "text-before-edge", "text-after-edge", "ideographic", "alphabetic", "hanging",
        "mathematical", "use-script", "no-change", "reset-size"
    ] },
    "display": { values: [
        "none", "inline", "block", "list-item", "run-in", "inline-block", "table", "inline-table",
        "table-row-group", "table-header-group", "table-footer-group", "table-row", "table-column-group",
        "table-column", "table-cell", "table-caption", "-webkit-box", "-webkit-inline-box",
        "flex", "inline-flex", "grid", "inline-grid"
    ] },
    "-webkit-text-emphasis-position": { values: [
        "over", "under"
    ] },
    "image-rendering": { values: [
        "auto", "optimizeSpeed", "optimizeQuality", "pixelated"
    ] },
    "alignment-baseline": { values: [
        "baseline", "middle", "auto", "before-edge", "after-edge", "central", "text-before-edge", "text-after-edge",
        "ideographic", "alphabetic", "hanging", "mathematical"
    ] },
    "outline-width": { values: [
        "medium", "thick", "thin"
    ] },
    "box-align": { values: [
        "baseline", "center", "stretch", "start", "end"
    ] },
    "border-right-width": { values: [
        "medium", "thick", "thin"
    ] },
    "border-top-style": { values: [
        "none", "hidden", "inset", "groove", "ridge", "outset", "dotted", "dashed", "solid", "double"
    ] },
    "line-height": { values: [
        "normal"
    ] },
    "text-overflow": { values: [
        "clip", "ellipsis"
    ] },
    "overflow-wrap": { values: [
        "normal", "break-word"
    ] },
    "box-direction": { values: [
        "normal", "reverse"
    ] },
    "margin-after-collapse": { values: [
        "collapse", "separate", "discard"
    ] },
    "page-break-before": { values: [
        "left", "right", "auto", "always", "avoid"
    ] },
    "border-image": { values: [
        "repeat", "stretch"
    ] },
    "text-decoration": { values: [
        "blink", "line-through", "overline", "underline"
    ] },
    "position": { values: [
        "absolute", "fixed", "relative", "static"
    ] },
    "font-family": { values: [
        "serif", "sans-serif", "cursive", "fantasy", "monospace", "-webkit-body", "-webkit-pictograph"
    ] },
    "text-overflow-mode": { values: [
        "clip", "ellipsis"
    ] },
    "border-bottom-style": { values: [
        "none", "hidden", "inset", "groove", "ridge", "outset", "dotted", "dashed", "solid", "double"
    ] },
    "unicode-bidi": { values: [
        "normal", "bidi-override", "embed", "isolate", "isolate-override", "plaintext"
    ] },
    "clip-rule": { values: [
        "nonzero", "evenodd"
    ] },
    "margin-left": { values: [
        "auto"
    ] },
    "margin-top": { values: [
        "auto"
    ] },
    "zoom": { values: [
        "normal", "document", "reset"
    ] },
    "max-width": { values: [
        "none"
    ] },
    "caption-side": { values: [
        "top", "bottom"
    ] },
    "empty-cells": { values: [
        "hide", "show"
    ] },
    "pointer-events": { values: [
        "none", "all", "auto", "visible", "visiblepainted", "visiblefill", "visiblestroke", "painted", "fill", "stroke", "bounding-box"
    ] },
    "letter-spacing": { values: [
        "normal"
    ] },
    "background-clip": { values: [
        "border-box", "content-box", "padding-box"
    ] },
    "-webkit-font-smoothing": { values: [
        "none", "auto", "antialiased", "subpixel-antialiased"
    ] },
    "border": { values: [
        "none", "hidden", "inset", "groove", "ridge", "outset", "dotted", "dashed", "solid", "double"
    ] },
    "font-size": { values: [
        "xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "-webkit-xxx-large", "smaller",
        "larger"
    ] },
    "font-variant": { values: [
        "small-caps", "normal"
    ] },
    "vertical-align": { values: [
        "baseline", "middle", "sub", "super", "text-top", "text-bottom", "top", "bottom", "-webkit-baseline-middle"
    ] },
    "white-space": { values: [
        "normal", "nowrap", "pre", "pre-line", "pre-wrap"
    ] },
    "box-lines": { values: [
        "single", "multiple"
    ] },
    "page-break-after": { values: [
        "left", "right", "auto", "always", "avoid"
    ] },
    "clip-path": { values: [
        "none"
    ] },
    "margin": { values: [
        "auto"
    ] },
    "margin-right": { values: [
        "auto"
    ] },
    "word-break": { values: [
        "normal", "break-all", "break-word"
    ] },
    "word-spacing": { values: [
        "normal"
    ] },
    "-webkit-text-emphasis-style": { values: [
        "circle", "filled", "open", "dot", "double-circle", "triangle", "sesame"
    ] },
    "transform": { values: [
        "scale", "scaleX", "scaleY", "scale3d", "rotate", "rotateX", "rotateY", "rotateZ", "rotate3d", "skew", "skewX", "skewY",
        "translate", "translateX", "translateY", "translateZ", "translate3d", "matrix", "matrix3d", "perspective"
    ] },
    "image-resolution": { values: [
        "from-image", "snap"
    ] },
    "box-sizing": { values: [
        "content-box", "border-box"
    ] },
    "clip": { values: [
        "auto"
    ] },
    "resize": { values: [
        "none", "both", "horizontal", "vertical"
    ] },
    "align-content": { values: [
        "flex-start", "flex-end", "center", "space-between", "space-around", "stretch"
    ] },
    "align-items": {  values: [
        "flex-start", "flex-end", "center", "baseline", "stretch"
    ] },
    "align-self": {  values: [
        "auto", "flex-start", "flex-end", "center", "baseline", "stretch"
    ] },
    "flex-direction": { values: [
        "row", "row-reverse", "column", "column-reverse"
    ] },
    "justify-content": { values: [
        "flex-start", "flex-end", "center", "space-between", "space-around"
    ] },
    "flex-wrap": { values: [
        "nowrap", "wrap", "wrap-reverse"
    ] },
    "perspective": { values: [
        "none"
    ] },
    "perspective-origin": { values: [
        "left", "center", "right", "top", "bottom"
    ] },
    "transform-origin": { values: [
        "left", "center", "right", "top", "bottom"
    ] },
    "transform-style": { values: [
        "flat", "preserve-3d"
    ] },
    "transition-timing-function": { values: [
        "ease", "linear", "ease-in", "ease-out", "ease-in-out", "step-start", "step-end", "steps", "cubic-bezier"
    ] },
    "animation-timing-function": { values: [
        "ease", "linear", "ease-in", "ease-out", "ease-in-out", "step-start", "step-end", "steps", "cubic-bezier"
    ] },
    "animation-direction": { values: [
        "normal", "reverse", "alternate", "alternate-reverse"
    ] },
    "animation-play-state": { values: [
        "running", "paused"
    ] },
    "animation-fill-mode": { values: [
        "none", "forwards", "backwards", "both"
    ] },
    "-webkit-backface-visibility": { values: [
        "visible", "hidden"
    ] },
    "-webkit-box-decoration-break": { values: [
        "slice", "clone"
    ] },
    "-webkit-column-break-after": { values: [
        "auto", "always", "avoid", "left", "right", "page", "column", "avoid-page", "avoid-column"
    ] },
    "-webkit-column-break-before": { values: [
        "auto", "always", "avoid", "left", "right", "page", "column", "avoid-page", "avoid-column"
    ] },
    "-webkit-column-break-inside": { values: [
        "auto", "avoid", "avoid-page", "avoid-column"
    ] },
    "-webkit-column-span": { values: [
        "none", "all"
    ] },
    "-webkit-column-count": { values: [
        "auto"
    ] },
    "-webkit-column-gap": { values: [
        "normal"
    ] },
    "-webkit-filter": { values: [
        "url", "blur", "brightness", "contrast", "drop-shadow", "grayscale", "hue-rotate", "invert", "opacity", "saturate", "sepia"
    ] },
    "-webkit-line-break": { values: [
        "auto", "loose", "normal", "strict"
    ] },
    "text-align-last": { values: [
        "auto", "start", "end", "left", "right", "center", "justify"
    ] },
    "-webkit-text-decoration-line": { values: [
        "none", "underline", "overline", "line-through", "blink"
    ] },
    "-webkit-text-decoration-style": { values: [
        "solid", "double", "dotted", "dashed", "wavy"
    ] },
    "-webkit-text-decoration-skip": { values: [
        "none", "objects", "spaces", "ink", "edges", "box-decoration"
    ] },
    "mix-blend-mode": { values: [
        "normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light",
        "difference", "exclusion", "hue", "saturation", "color", "luminosity", "unset"
    ] },
    "background-blend-mode": { values: [
        "normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light",
        "difference", "exclusion", "hue", "saturation", "color", "luminosity", "unset"
    ] },
}

/**
 * @param {string} propertyName
 * @return {!WebInspector.CSSMetadata}
 */
WebInspector.CSSMetadata.keywordsForProperty = function(propertyName)
{
    var acceptedKeywords = ["inherit", "initial"];
    var descriptor = WebInspector.CSSMetadata.descriptor(propertyName);
    if (descriptor && descriptor.values)
        acceptedKeywords.push.apply(acceptedKeywords, descriptor.values);
    if (WebInspector.CSSMetadata.isColorAwareProperty(propertyName)) {
        acceptedKeywords.push("currentColor");
        for (var color in WebInspector.Color.Nicknames)
            acceptedKeywords.push(color);
    }
    return new WebInspector.CSSMetadata(acceptedKeywords);
}

/**
 * @param {string} propertyName
 * @return {?Object}
 */
WebInspector.CSSMetadata.descriptor = function(propertyName)
{
    if (!propertyName)
        return null;
    var unprefixedName = propertyName.replace(/^-webkit-/, "");
    propertyName = propertyName.toLowerCase();
    var entry = WebInspector.CSSMetadata._propertyDataMap[propertyName];
    if (!entry && unprefixedName !== propertyName)
        entry = WebInspector.CSSMetadata._propertyDataMap[unprefixedName];
    return entry || null;
}

WebInspector.CSSMetadata.initializeWithSupportedProperties = function(properties)
{
    WebInspector.CSSMetadata.cssPropertiesMetainfo = new WebInspector.CSSMetadata(properties);
}

/**
 * @return {!Object.<string, boolean>}
 */
WebInspector.CSSMetadata.cssPropertiesMetainfoKeySet = function()
{
    if (!WebInspector.CSSMetadata._cssPropertiesMetainfoKeySet)
        WebInspector.CSSMetadata._cssPropertiesMetainfoKeySet = WebInspector.CSSMetadata.cssPropertiesMetainfo.keySet();
    return WebInspector.CSSMetadata._cssPropertiesMetainfoKeySet;
}

// Weight of CSS properties based on their usage from https://www.chromestatus.com/metrics/css/popularity
WebInspector.CSSMetadata.Weight = {
    "align-content": 57,
    "align-items": 129,
    "align-self": 55,
    "animation": 175,
    "animation-delay": 114,
    "animation-direction": 113,
    "animation-duration": 137,
    "animation-fill-mode": 132,
    "animation-iteration-count": 124,
    "animation-name": 139,
    "animation-play-state": 104,
    "animation-timing-function": 141,
    "backface-visibility": 123,
    "background": 260,
    "background-attachment": 119,
    "background-clip": 165,
    "background-color": 259,
    "background-image": 246,
    "background-origin": 107,
    "background-position": 237,
    "background-position-x": 108,
    "background-position-y": 93,
    "background-repeat": 234,
    "background-size": 203,
    "border": 263,
    "border-bottom": 233,
    "border-bottom-color": 190,
    "border-bottom-left-radius": 186,
    "border-bottom-right-radius": 185,
    "border-bottom-style": 150,
    "border-bottom-width": 179,
    "border-collapse": 209,
    "border-color": 226,
    "border-image": 89,
    "border-image-outset": 50,
    "border-image-repeat": 49,
    "border-image-slice": 58,
    "border-image-source": 32,
    "border-image-width": 52,
    "border-left": 221,
    "border-left-color": 174,
    "border-left-style": 142,
    "border-left-width": 172,
    "border-radius": 224,
    "border-right": 223,
    "border-right-color": 182,
    "border-right-style": 130,
    "border-right-width": 178,
    "border-spacing": 198,
    "border-style": 206,
    "border-top": 231,
    "border-top-color": 192,
    "border-top-left-radius": 187,
    "border-top-right-radius": 189,
    "border-top-style": 152,
    "border-top-width": 180,
    "border-width": 214,
    "bottom": 227,
    "box-shadow": 213,
    "box-sizing": 216,
    "caption-side": 96,
    "clear": 229,
    "clip": 173,
    "clip-rule": 5,
    "color": 256,
    "content": 219,
    "counter-increment": 111,
    "counter-reset": 110,
    "cursor": 250,
    "direction": 176,
    "display": 262,
    "empty-cells": 99,
    "fill": 140,
    "fill-opacity": 82,
    "fill-rule": 22,
    "filter": 160,
    "flex": 133,
    "flex-basis": 66,
    "flex-direction": 85,
    "flex-flow": 94,
    "flex-grow": 112,
    "flex-shrink": 61,
    "flex-wrap": 68,
    "float": 252,
    "font": 211,
    "font-family": 254,
    "font-kerning": 18,
    "font-size": 264,
    "font-stretch": 77,
    "font-style": 220,
    "font-variant": 161,
    "font-weight": 257,
    "height": 266,
    "image-rendering": 90,
    "justify-content": 127,
    "left": 248,
    "letter-spacing": 188,
    "line-height": 244,
    "list-style": 215,
    "list-style-image": 145,
    "list-style-position": 149,
    "list-style-type": 199,
    "margin": 267,
    "margin-bottom": 241,
    "margin-left": 243,
    "margin-right": 238,
    "margin-top": 253,
    "mask": 20,
    "max-height": 205,
    "max-width": 225,
    "min-height": 217,
    "min-width": 218,
    "object-fit": 33,
    "opacity": 251,
    "order": 117,
    "orphans": 146,
    "outline": 222,
    "outline-color": 153,
    "outline-offset": 147,
    "outline-style": 151,
    "outline-width": 148,
    "overflow": 255,
    "overflow-wrap": 105,
    "overflow-x": 184,
    "overflow-y": 196,
    "padding": 265,
    "padding-bottom": 230,
    "padding-left": 235,
    "padding-right": 232,
    "padding-top": 240,
    "page": 8,
    "page-break-after": 120,
    "page-break-before": 69,
    "page-break-inside": 121,
    "perspective": 92,
    "perspective-origin": 103,
    "pointer-events": 183,
    "position": 261,
    "quotes": 158,
    "resize": 168,
    "right": 245,
    "shape-rendering": 38,
    "size": 64,
    "speak": 118,
    "src": 170,
    "stop-color": 42,
    "stop-opacity": 31,
    "stroke": 98,
    "stroke-dasharray": 36,
    "stroke-dashoffset": 3,
    "stroke-linecap": 30,
    "stroke-linejoin": 21,
    "stroke-miterlimit": 12,
    "stroke-opacity": 34,
    "stroke-width": 87,
    "table-layout": 171,
    "tab-size": 46,
    "text-align": 260,
    "text-anchor": 35,
    "text-decoration": 247,
    "text-indent": 207,
    "text-overflow": 204,
    "text-rendering": 155,
    "text-shadow": 208,
    "text-transform": 202,
    "top": 258,
    "touch-action": 80,
    "transform": 181,
    "transform-origin": 162,
    "transform-style": 86,
    "transition": 193,
    "transition-delay": 134,
    "transition-duration": 135,
    "transition-property": 131,
    "transition-timing-function": 122,
    "unicode-bidi": 156,
    "unicode-range": 136,
    "vertical-align": 236,
    "visibility": 242,
    "-webkit-appearance": 191,
    "-webkit-backface-visibility": 154,
    "-webkit-background-clip": 164,
    "-webkit-background-origin": 40,
    "-webkit-background-size": 163,
    "-webkit-border-end": 9,
    "-webkit-border-horizontal-spacing": 81,
    "-webkit-border-image": 75,
    "-webkit-border-radius": 212,
    "-webkit-border-start": 10,
    "-webkit-border-start-color": 16,
    "-webkit-border-start-width": 13,
    "-webkit-border-vertical-spacing": 43,
    "-webkit-box-align": 101,
    "-webkit-box-direction": 51,
    "-webkit-box-flex": 128,
    "-webkit-box-lines": 2,
    "-webkit-box-ordinal-group": 91,
    "-webkit-box-orient": 144,
    "-webkit-box-pack": 106,
    "-webkit-box-reflect": 39,
    "-webkit-box-shadow": 210,
    "-webkit-column-break-inside": 60,
    "-webkit-column-count": 84,
    "-webkit-column-gap": 76,
    "-webkit-column-rule": 25,
    "-webkit-column-rule-color": 23,
    "-webkit-columns": 44,
    "-webkit-column-span": 29,
    "-webkit-column-width": 47,
    "-webkit-filter": 159,
    "-webkit-font-feature-settings": 59,
    "-webkit-font-smoothing": 177,
    "-webkit-highlight": 1,
    "-webkit-line-break": 45,
    "-webkit-line-clamp": 126,
    "-webkit-margin-after": 67,
    "-webkit-margin-before": 70,
    "-webkit-margin-collapse": 14,
    "-webkit-margin-end": 65,
    "-webkit-margin-start": 100,
    "-webkit-margin-top-collapse": 78,
    "-webkit-mask": 19,
    "-webkit-mask-box-image": 72,
    "-webkit-mask-image": 88,
    "-webkit-mask-position": 54,
    "-webkit-mask-repeat": 63,
    "-webkit-mask-size": 79,
    "-webkit-padding-after": 15,
    "-webkit-padding-before": 28,
    "-webkit-padding-end": 48,
    "-webkit-padding-start": 73,
    "-webkit-print-color-adjust": 83,
    "-webkit-rtl-ordering": 7,
    "-webkit-tap-highlight-color": 169,
    "-webkit-text-emphasis-color": 11,
    "-webkit-text-fill-color": 71,
    "-webkit-text-security": 17,
    "-webkit-text-stroke": 56,
    "-webkit-text-stroke-color": 37,
    "-webkit-text-stroke-width": 53,
    "-webkit-user-drag": 95,
    "-webkit-user-modify": 62,
    "-webkit-user-select": 194,
    "-webkit-writing-mode": 4,
    "white-space": 228,
    "widows": 115,
    "width": 268,
    "will-change": 74,
    "word-break": 166,
    "word-spacing": 157,
    "word-wrap": 197,
    "writing-mode": 41,
    "z-index": 239,
    "zoom": 200
};


WebInspector.CSSMetadata.prototype = {
    /**
     * @param {string} prefix
     * @return {!Array.<string>}
     */
    startsWith: function(prefix)
    {
        var firstIndex = this._firstIndexOfPrefix(prefix);
        if (firstIndex === -1)
            return [];

        var results = [];
        while (firstIndex < this._values.length && this._values[firstIndex].startsWith(prefix))
            results.push(this._values[firstIndex++]);
        return results;
    },

    /**
     * @param {!Array.<string>} properties
     * @return {number}
     */
    mostUsedOf: function(properties)
    {
        var maxWeight = 0;
        var index = 0;
        for (var i = 0; i < properties.length; i++) {
            var weight = WebInspector.CSSMetadata.Weight[properties[i]];
            if (!weight)
                weight = WebInspector.CSSMetadata.Weight[WebInspector.CSSMetadata.canonicalPropertyName(properties[i])];
            if (weight > maxWeight) {
                maxWeight = weight;
                index = i;
            }
        }
        return index;
    },

    _firstIndexOfPrefix: function(prefix)
    {
        if (!this._values.length)
            return -1;
        if (!prefix)
            return 0;

        var maxIndex = this._values.length - 1;
        var minIndex = 0;
        var foundIndex;

        do {
            var middleIndex = (maxIndex + minIndex) >> 1;
            if (this._values[middleIndex].startsWith(prefix)) {
                foundIndex = middleIndex;
                break;
            }
            if (this._values[middleIndex] < prefix)
                minIndex = middleIndex + 1;
            else
                maxIndex = middleIndex - 1;
        } while (minIndex <= maxIndex);

        if (foundIndex === undefined)
            return -1;

        while (foundIndex && this._values[foundIndex - 1].startsWith(prefix))
            foundIndex--;

        return foundIndex;
    },

    /**
     * @return {!Object.<string, boolean>}
     */
    keySet: function()
    {
        if (!this._keySet)
            this._keySet = this._values.keySet();
        return this._keySet;
    },

    /**
     * @param {string} str
     * @param {string} prefix
     * @return {string}
     */
    next: function(str, prefix)
    {
        return this._closest(str, prefix, 1);
    },

    /**
     * @param {string} str
     * @param {string} prefix
     * @return {string}
     */
    previous: function(str, prefix)
    {
        return this._closest(str, prefix, -1);
    },

    /**
     * @param {string} str
     * @param {string} prefix
     * @param {number} shift
     * @return {string}
     */
    _closest: function(str, prefix, shift)
    {
        if (!str)
            return "";

        var index = this._values.indexOf(str);
        if (index === -1)
            return "";

        if (!prefix) {
            index = (index + this._values.length + shift) % this._values.length;
            return this._values[index];
        }

        var propertiesWithPrefix = this.startsWith(prefix);
        var j = propertiesWithPrefix.indexOf(str);
        j = (j + propertiesWithPrefix.length + shift) % propertiesWithPrefix.length;
        return propertiesWithPrefix[j];
    },

    /**
     * @param {string} shorthand
     * @return {?Array.<string>}
     */
    longhands: function(shorthand)
    {
        return this._longhands[shorthand];
    },

    /**
     * @param {string} longhand
     * @return {?Array.<string>}
     */
    shorthands: function(longhand)
    {
        return this._shorthands[longhand];
    }
}

WebInspector.CSSMetadata.initializeWithSupportedProperties([]);
;/* CSSParser.js */
/**
 * Copyright 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/**
 * @constructor
 * @extends {WebInspector.Object}
 */
WebInspector.CSSParser = function()
{
    this._worker = new WorkerRuntime.Worker("script_formatter_worker");
    this._worker.onmessage = this._onRuleChunk.bind(this);
    this._rules = [];
}

WebInspector.CSSParser.Events = {
    RulesParsed: "RulesParsed"
}

WebInspector.CSSParser.prototype = {
    /**
     * @param {!WebInspector.CSSStyleSheetHeader} styleSheetHeader
     * @param {function(!Array.<!WebInspector.CSSParser.Rule>)=} callback
     */
    fetchAndParse: function(styleSheetHeader, callback)
    {
        this._lock();
        this._finishedCallback = callback;
        styleSheetHeader.requestContent().then(this._innerParse.bind(this));
    },

    /**
     * @param {string} text
     * @param {function(!Array.<!WebInspector.CSSParser.Rule>)=} callback
     */
    parse: function(text, callback)
    {
        this._lock();
        this._finishedCallback = callback;
        this._innerParse(text);
    },

    /**
     * @param {string} text
     * @return {!Promise<!Array.<!WebInspector.CSSParser.Rule>>}
     */
    parsePromise: function(text)
    {
        return new Promise(promiseConstructor.bind(this));

        /**
         * @param {function()} succ
         * @param {function()} fail
         * @this {WebInspector.CSSParser}
         */
        function promiseConstructor(succ, fail)
        {
            this.parse(text, succ);
        }
    },

    dispose: function()
    {
        if (this._worker) {
            this._worker.terminate();
            delete this._worker;
            this._runFinishedCallback([]);
        }
    },

    /**
     * @return {!Array.<!WebInspector.CSSParser.Rule>}
     */
    rules: function()
    {
        return this._rules;
    },

    _lock: function()
    {
        console.assert(!this._parsingStyleSheet, "Received request to parse stylesheet before previous was completed.");
        this._parsingStyleSheet = true;
    },

    _unlock: function()
    {
        delete this._parsingStyleSheet;
    },

    /**
     * @param {?string} text
     */
    _innerParse: function(text)
    {
        this._rules = [];
        this._worker.postMessage({ method: "parseCSS", params: { content: text } });
    },

    /**
     * @param {!MessageEvent} event
     */
    _onRuleChunk: function(event)
    {
        var data = /** @type {!WebInspector.CSSParser.DataChunk} */ (event.data);
        var chunk = data.chunk;
        for (var i = 0; i < chunk.length; ++i)
            this._rules.push(chunk[i]);

        if (data.isLastChunk)
            this._onFinishedParsing();
        this.dispatchEventToListeners(WebInspector.CSSParser.Events.RulesParsed);
    },

    _onFinishedParsing: function()
    {
        this._unlock();
        this._runFinishedCallback(this._rules);
    },

    /**
     * @param {!Array<!WebInspector.CSSRule>} rules
     */
    _runFinishedCallback: function(rules)
    {
        var callback = this._finishedCallback;
        delete this._finishedCallback;
        if (callback)
            callback.call(null, rules);
    },

    __proto__: WebInspector.Object.prototype,
}

/**
 * @typedef {{isLastChunk: boolean, chunk: !Array.<!WebInspector.CSSParser.Rule>}}
 */
WebInspector.CSSParser.DataChunk;

/**
 * @constructor
 */
WebInspector.CSSParser.StyleRule = function()
{
    /** @type {string} */
    this.selectorText;
    /** @type {!WebInspector.CSSParser.Range} */
    this.styleRange;
    /** @type {number} */
    this.lineNumber;
    /** @type {number} */
    this.columnNumber;
    /** @type {!Array.<!WebInspector.CSSParser.Property>} */
    this.properties;
}

/**
 * @typedef {{atRule: string, lineNumber: number, columnNumber: number}}
 */
WebInspector.CSSParser.AtRule;

/**
 * @typedef {(WebInspector.CSSParser.StyleRule|WebInspector.CSSParser.AtRule)}
 */
WebInspector.CSSParser.Rule;

/**
 * @typedef {{startLine: number, startColumn: number, endLine: number, endColumn: number}}
 */
WebInspector.CSSParser.Range;

/**
 * @constructor
 */
WebInspector.CSSParser.Property = function()
{
    /** @type {string} */
    this.name;
    /** @type {!WebInspector.CSSParser.Range} */
    this.nameRange;
    /** @type {string} */
    this.value;
    /** @type {!WebInspector.CSSParser.Range} */
    this.valueRange;
    /** @type {!WebInspector.CSSParser.Range} */
    this.range;
    /** @type {(boolean|undefined)} */
    this.disabled;
}

/**
 * @constructor
 */
WebInspector.CSSParserService = function()
{
    this._cssParser = null;
    this._cssRequests = [];
    this._terminated = false;
}

WebInspector.CSSParserService.prototype = {
    /**
     * @param {string} text
     * @return {!Promise<!Array.<!WebInspector.CSSParser.Rule>>}
     */
    parseCSS: function(text)
    {
        console.assert(!this._terminated, "Illegal call parseCSS on terminated CSSParserService.");
        if (!this._cssParser)
            this._cssParser = new WebInspector.CSSParser();
        var request = new WebInspector.CSSParserService.ParseRequest(text);
        this._cssRequests.push(request);
        this._maybeParseCSS();
        return request.parsedPromise;
    },

    _maybeParseCSS: function()
    {
        if (this._terminated || this._isParsingCSS || !this._cssRequests.length)
            return;
        this._isParsingCSS = true;
        var request = this._cssRequests.shift();
        this._cssParser.parsePromise(request.text)
            .catchException(/** @type {!Array.<!WebInspector.CSSParser.Rule>} */([]))
            .then(onCSSParsed.bind(this));

        /**
         * @param {!Array.<!WebInspector.CSSParser.Rule>} rules
         * @this {WebInspector.CSSParserService}
         */
        function onCSSParsed(rules)
        {
            request.parsedCallback.call(null, rules);
            this._isParsingCSS = false;
            this._maybeParseCSS();
        }
    },

    dispose: function()
    {
        if (this._terminated)
            return;
        this._terminated = true;
        if (this._cssParser)
            this._cssParser.dispose();
        for (var request of this._cssRequests)
            request.parsedCallback.call(null, /** @type {!Array.<!WebInspector.CSSParser.Rule>} */([]));
        this._cssRequests = [];
    },
}

/**
 * @constructor
 * @param {string} text
 */
WebInspector.CSSParserService.ParseRequest = function(text)
{
    this.text = text;
    /** @type {function(!Array.<!WebInspector.CSSParser.Rule>)} */
    this.parsedCallback;
    this.parsedPromise = new Promise(fulfill => this.parsedCallback = fulfill);
}
;/* CSSStyleModel.js */
/*
 * Copyright (C) 2010 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKModel}
 * @param {!WebInspector.Target} target
 */
WebInspector.CSSStyleModel = function(target)
{
    WebInspector.SDKModel.call(this, WebInspector.CSSStyleModel, target);
    this._domModel = WebInspector.DOMModel.fromTarget(target);
    this._agent = target.cssAgent();
    this._styleLoader = new WebInspector.CSSStyleModel.ComputedStyleLoader(this);
    target.resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.MainFrameNavigated, this._mainFrameNavigated, this);
    target.registerCSSDispatcher(new WebInspector.CSSDispatcher(this));
    this._agent.enable().then(this._wasEnabled.bind(this));
    /** @type {!Map.<string, !WebInspector.CSSStyleSheetHeader>} */
    this._styleSheetIdToHeader = new Map();
    /** @type {!Map.<string, !Object.<!PageAgent.FrameId, !Array.<!CSSAgent.StyleSheetId>>>} */
    this._styleSheetIdsForURL = new Map();
}

/**
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {!Array.<!CSSAgent.RuleMatch>|undefined} matchArray
 * @return {!Array.<!WebInspector.CSSStyleRule>}
 */
WebInspector.CSSStyleModel.parseRuleMatchArrayPayload = function(cssModel, matchArray)
{
    if (!matchArray)
        return [];

    var result = [];
    for (var i = 0; i < matchArray.length; ++i)
        result.push(new WebInspector.CSSStyleRule(cssModel, matchArray[i].rule, matchArray[i].matchingSelectors));
    return result;
}
WebInspector.CSSStyleModel.Events = {
    LayoutEditorChange: "LayoutEditorChange",
    MediaQueryResultChanged: "MediaQueryResultChanged",
    ModelWasEnabled: "ModelWasEnabled",
    PseudoStateForced: "PseudoStateForced",
    StyleSheetAdded: "StyleSheetAdded",
    StyleSheetChanged: "StyleSheetChanged",
    StyleSheetRemoved: "StyleSheetRemoved"
}

WebInspector.CSSStyleModel.MediaTypes = ["all", "braille", "embossed", "handheld", "print", "projection", "screen", "speech", "tty", "tv"];

WebInspector.CSSStyleModel.PseudoStateMarker = "pseudo-state-marker";

WebInspector.CSSStyleModel.prototype = {
    /**
     * @param {!Array<!CSSAgent.StyleSheetId>} styleSheetIds
     * @param {!Array<!WebInspector.TextRange>} ranges
     * @param {!Array<string>} texts
     * @param {boolean} majorChange
     * @return {!Promise<?Array<!CSSAgent.CSSStyle>>}
     */
    setStyleTexts: function(styleSheetIds, ranges, texts, majorChange)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {?Array<!CSSAgent.CSSStyle>} stylePayloads
         * @return {?Array<!CSSAgent.CSSStyle>}
         * @this {WebInspector.CSSStyleModel}
         */
        function parsePayload(error, stylePayloads)
        {
            if (error || !stylePayloads || !stylePayloads.length)
                return null;

            if (majorChange)
                this._domModel.markUndoableState();
            var uniqueIDs = new Set(styleSheetIds);
            for (var styleSheetId of uniqueIDs)
                this._fireStyleSheetChanged(styleSheetId);
            return stylePayloads;
        }

        console.assert(styleSheetIds.length === ranges.length && ranges.length === texts.length, "Array lengths must be equal");
        var edits = [];
        for (var i = 0; i < styleSheetIds.length; ++i) {
            edits.push({
                styleSheetId: styleSheetIds[i],
                range: ranges[i].serializeToObject(),
                text: texts[i]
            });
        }

        return this._agent.setStyleTexts(edits, parsePayload.bind(this))
            .catchException(/** @type {?Array<!CSSAgent.CSSStyle>} */(null));
    },

    /**
     * @return {!Promise.<!Array.<!WebInspector.CSSMedia>>}
     */
    mediaQueriesPromise: function()
    {
        /**
         * @param {?Protocol.Error} error
         * @param {?Array.<!CSSAgent.CSSMedia>} payload
         * @return {!Array.<!WebInspector.CSSMedia>}
         * @this {!WebInspector.CSSStyleModel}
         */
        function parsePayload(error, payload)
        {
            return !error && payload ? WebInspector.CSSMedia.parseMediaArrayPayload(this, payload) : [];
        }

        return this._agent.getMediaQueries(parsePayload.bind(this));
    },

    /**
     * @return {boolean}
     */
    isEnabled: function()
    {
        return this._isEnabled;
    },

    /**
     * @param {?Protocol.Error} error
     */
    _wasEnabled: function(error)
    {
        if (error) {
            console.error("Failed to enabled CSS agent: " + error);
            return;
        }
        this._isEnabled = true;
        this.dispatchEventToListeners(WebInspector.CSSStyleModel.Events.ModelWasEnabled);
    },

    /**
     * @param {!DOMAgent.NodeId} nodeId
     * @return {!Promise.<?WebInspector.CSSStyleModel.MatchedStyleResult>}
     */
    matchedStylesPromise: function(nodeId)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {?CSSAgent.CSSStyle=} inlinePayload
         * @param {?CSSAgent.CSSStyle=} attributesPayload
         * @param {!Array.<!CSSAgent.RuleMatch>=} matchedPayload
         * @param {!Array.<!CSSAgent.PseudoElementMatches>=} pseudoPayload
         * @param {!Array.<!CSSAgent.InheritedStyleEntry>=} inheritedPayload
         * @param {!Array.<!CSSAgent.CSSKeyframesRule>=} animationsPayload
         * @return {?WebInspector.CSSStyleModel.MatchedStyleResult}
         * @this {WebInspector.CSSStyleModel}
         */
        function callback(error, inlinePayload, attributesPayload, matchedPayload, pseudoPayload, inheritedPayload, animationsPayload)
        {
            if (error)
                return null;

             var node = this._domModel.nodeForId(nodeId);
             if (!node)
                return null;

            return new WebInspector.CSSStyleModel.MatchedStyleResult(this, node, inlinePayload, attributesPayload, matchedPayload, pseudoPayload, inheritedPayload, animationsPayload);
        }

        return this._agent.getMatchedStylesForNode(nodeId, callback.bind(this));
    },

    /**
     * @param {!DOMAgent.NodeId} nodeId
     * @return {!Promise.<?Map.<string, string>>}
     */
    computedStylePromise: function(nodeId)
    {
        return this._styleLoader.computedStylePromise(nodeId);
    },

    /**
     * @param {number} nodeId
     * @return {!Promise<?Array<string>>}
     */
    backgroundColorsPromise: function(nodeId)
    {
        /**
         * @param {?string} error
         * @param {!Array<string>=} backgroundColors
         * @return {?Array<string>}
         */
        function backgroundColorsCallback(error, backgroundColors) {
            return !error && backgroundColors ? backgroundColors : null;
        }
        return this._agent.getBackgroundColors(nodeId, backgroundColorsCallback);
    },

    /**
     * @param {number} nodeId
     * @return {!Promise.<?Array.<!CSSAgent.PlatformFontUsage>>}
     */
    platformFontsPromise: function(nodeId)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {?Array.<!CSSAgent.PlatformFontUsage>} fonts
         * @return {?Array.<!CSSAgent.PlatformFontUsage>}
         */
        function platformFontsCallback(error, fonts)
        {
            return !error && fonts ? fonts : null;
        }

        return this._agent.getPlatformFontsForNode(nodeId, platformFontsCallback);
    },

    /**
     * @return {!Array.<!WebInspector.CSSStyleSheetHeader>}
     */
    allStyleSheets: function()
    {
        var values = this._styleSheetIdToHeader.valuesArray();
        /**
         * @param {!WebInspector.CSSStyleSheetHeader} a
         * @param {!WebInspector.CSSStyleSheetHeader} b
         * @return {number}
         */
        function styleSheetComparator(a, b)
        {
            if (a.sourceURL < b.sourceURL)
                return -1;
            else if (a.sourceURL > b.sourceURL)
                return 1;
            return a.startLine - b.startLine || a.startColumn - b.startColumn;
        }
        values.sort(styleSheetComparator);

        return values;
    },

    /**
     * @param {!DOMAgent.NodeId} nodeId
     * @return {!Promise.<?WebInspector.CSSStyleModel.InlineStyleResult>}
     */
    inlineStylesPromise: function(nodeId)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {?CSSAgent.CSSStyle=} inlinePayload
         * @param {?CSSAgent.CSSStyle=} attributesStylePayload
         * @return {?WebInspector.CSSStyleModel.InlineStyleResult}
         * @this {WebInspector.CSSStyleModel}
         */
        function callback(error, inlinePayload, attributesStylePayload)
        {
            if (error || !inlinePayload)
                return null;
            var inlineStyle = inlinePayload ? new WebInspector.CSSStyleDeclaration(this, null, inlinePayload, WebInspector.CSSStyleDeclaration.Type.Inline) : null;
            var attributesStyle = attributesStylePayload ? new WebInspector.CSSStyleDeclaration(this, null, attributesStylePayload, WebInspector.CSSStyleDeclaration.Type.Attributes) : null;
            return new WebInspector.CSSStyleModel.InlineStyleResult(inlineStyle, attributesStyle);
        }

        return this._agent.getInlineStylesForNode(nodeId, callback.bind(this));
    },

    /**
     * @param {!WebInspector.DOMNode} node
     * @param {string} pseudoClass
     * @param {boolean} enable
     * @return {boolean}
     */
    forcePseudoState: function(node, pseudoClass, enable)
    {
        var pseudoClasses = node.marker(WebInspector.CSSStyleModel.PseudoStateMarker) || [];
        if (enable) {
            if (pseudoClasses.indexOf(pseudoClass) >= 0)
                return false;
            pseudoClasses.push(pseudoClass);
            node.setMarker(WebInspector.CSSStyleModel.PseudoStateMarker, pseudoClasses);
        } else {
            if (pseudoClasses.indexOf(pseudoClass) < 0)
                return false;
            pseudoClasses.remove(pseudoClass);
            if (!pseudoClasses.length)
                node.setMarker(WebInspector.CSSStyleModel.PseudoStateMarker, null);
        }

        this._agent.forcePseudoState(node.id, pseudoClasses);
        this.dispatchEventToListeners(WebInspector.CSSStyleModel.Events.PseudoStateForced, { node: node, pseudoClass: pseudoClass, enable: enable });
        return true;
    },

    /**
     * @param {!WebInspector.DOMNode} node
     * @return {?Array<string>} state
     */
    pseudoState: function(node)
    {
        return node.marker(WebInspector.CSSStyleModel.PseudoStateMarker) || [];
    },

    /**
     * @param {!WebInspector.CSSMedia} media
     * @param {string} newMediaText
     * @param {function(?WebInspector.CSSMedia)} userCallback
     */
    setMediaText: function(media, newMediaText, userCallback)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {!CSSAgent.CSSMedia} mediaPayload
         * @return {?WebInspector.CSSMedia}
         * @this {WebInspector.CSSStyleModel}
         */
        function parsePayload(error, mediaPayload)
        {
            if (!mediaPayload)
                return null;
            this._domModel.markUndoableState();
            this._fireStyleSheetChanged(media.parentStyleSheetId);
            return WebInspector.CSSMedia.parsePayload(this, mediaPayload);
        }

        console.assert(!!media.parentStyleSheetId);
        WebInspector.userMetrics.actionTaken(WebInspector.UserMetrics.Action.StyleRuleEdited);
        this._agent.setMediaText(media.parentStyleSheetId, media.range, newMediaText, parsePayload.bind(this))
            .catchException(null)
            .then(userCallback);
    },

    /**
     * @param {!DOMAgent.NodeId} nodeId
     * @param {!Array.<!WebInspector.CSSValue>} selectors
     * @return {!Promise<?Array<number>>}
     */
    _computeMatchingSelectors: function(nodeId, selectors)
    {
        var ownerDocumentId = this._ownerDocumentId(nodeId);
        if (!ownerDocumentId || !selectors)
            return Promise.resolve(/** @type {?Array<number>} */(null));
        var matchingSelectors = [];
        var allSelectorsBarrier = new CallbackBarrier();
        for (var i = 0; i < selectors.length; ++i) {
            var boundCallback = allSelectorsBarrier.createCallback(selectorQueried.bind(null, i, nodeId, matchingSelectors));
            this._domModel.querySelectorAll(ownerDocumentId, selectors[i].text, boundCallback);
        }
        return new Promise(promiseConstructor);

        /**
         * @param {function(!Array<number>)} resolve
         */
        function promiseConstructor(resolve)
        {
            allSelectorsBarrier.callWhenDone(function() {
                resolve(matchingSelectors);
            });
        }

        /**
         * @param {number} index
         * @param {!DOMAgent.NodeId} nodeId
         * @param {!Array.<number>} matchingSelectors
         * @param {!Array.<!DOMAgent.NodeId>=} matchingNodeIds
         */
        function selectorQueried(index, nodeId, matchingSelectors, matchingNodeIds)
        {
            if (!matchingNodeIds)
                return;
            if (matchingNodeIds.indexOf(nodeId) !== -1)
                matchingSelectors.push(index);
        }
    },

    /**
     * @param {!CSSAgent.StyleSheetId} styleSheetId
     * @param {!WebInspector.DOMNode} node
     * @param {string} ruleText
     * @param {!WebInspector.TextRange} ruleLocation
     * @param {function(?WebInspector.CSSStyleRule)} userCallback
     */
    addRule: function(styleSheetId, node, ruleText, ruleLocation, userCallback)
    {
        this._agent.addRule(styleSheetId, ruleText, ruleLocation, parsePayload.bind(this))
            .then(onRuleParsed.bind(this))
            .catchException(null)
            .then(userCallback);

        /**
         * @param {?Protocol.Error} error
         * @param {?CSSAgent.CSSRule} rulePayload
         * @return {?WebInspector.CSSStyleRule}
         * @this {WebInspector.CSSStyleModel}
         */
        function parsePayload(error, rulePayload)
        {
            if (error || !rulePayload)
                return null;
            this._domModel.markUndoableState();
            this._fireStyleSheetChanged(styleSheetId);
            return new WebInspector.CSSStyleRule(this, rulePayload);
        }

        /**
         * @param {?WebInspector.CSSStyleRule} rule
         * @return {!Promise<?WebInspector.CSSStyleRule>}
         * @this {WebInspector.CSSStyleModel}
         */
        function onRuleParsed(rule)
        {
            if (!rule)
                return Promise.resolve(/** @type {?WebInspector.CSSStyleRule} */(null));

            return this._computeMatchingSelectors(node.id, rule.selectors)
                .then(updateMatchingSelectors.bind(null, rule));
        }

        /**
         * @param {!WebInspector.CSSStyleRule} rule
         * @param {?Array<number>} matchingSelectors
         * @return {?WebInspector.CSSStyleRule}
         */
        function updateMatchingSelectors(rule, matchingSelectors)
        {
            if (!matchingSelectors)
                return null;
            rule.matchingSelectors = matchingSelectors;
            return rule;
        }
    },

    /**
     * @param {!WebInspector.DOMNode} node
     * @param {function(?WebInspector.CSSStyleSheetHeader)} userCallback
     */
    requestViaInspectorStylesheet: function(node, userCallback)
    {
        var frameId = node.frameId() || this.target().resourceTreeModel.mainFrame.id;
        var headers = this._styleSheetIdToHeader.valuesArray();
        for (var i = 0; i < headers.length; ++i) {
            var styleSheetHeader = headers[i];
            if (styleSheetHeader.frameId === frameId && styleSheetHeader.isViaInspector()) {
                userCallback(styleSheetHeader);
                return;
            }
        }

        /**
         * @param {?Protocol.Error} error
         * @param {?CSSAgent.StyleSheetId} styleSheetId
         * @return {?WebInspector.CSSStyleSheetHeader}
         * @this {WebInspector.CSSStyleModel}
         */
        function innerCallback(error, styleSheetId)
        {
            return !error && styleSheetId ? this._styleSheetIdToHeader.get(styleSheetId) || null : null;
        }

        this._agent.createStyleSheet(frameId, innerCallback.bind(this))
            .catchException(null)
            .then(userCallback)
    },

    mediaQueryResultChanged: function()
    {
        this.dispatchEventToListeners(WebInspector.CSSStyleModel.Events.MediaQueryResultChanged);
    },

    /**
     * @param {!CSSAgent.StyleSheetId} id
     * @return {?WebInspector.CSSStyleSheetHeader}
     */
    styleSheetHeaderForId: function(id)
    {
        return this._styleSheetIdToHeader.get(id) || null;
    },

    /**
     * @return {!Array.<!WebInspector.CSSStyleSheetHeader>}
     */
    styleSheetHeaders: function()
    {
        return this._styleSheetIdToHeader.valuesArray();
    },

    /**
     * @param {!DOMAgent.NodeId} nodeId
     * @return {?DOMAgent.NodeId}
     */
    _ownerDocumentId: function(nodeId)
    {
        var node = this._domModel.nodeForId(nodeId);
        if (!node)
            return null;
        return node.ownerDocument ? node.ownerDocument.id : null;
    },

    /**
     * @param {!CSSAgent.StyleSheetId} styleSheetId
     */
    _fireStyleSheetChanged: function(styleSheetId)
    {
        this.dispatchEventToListeners(WebInspector.CSSStyleModel.Events.StyleSheetChanged, { styleSheetId: styleSheetId });
    },

    /**
     * @param {!CSSAgent.CSSStyleSheetHeader} header
     */
    _styleSheetAdded: function(header)
    {
        console.assert(!this._styleSheetIdToHeader.get(header.styleSheetId));
        var styleSheetHeader = new WebInspector.CSSStyleSheetHeader(this, header);
        this._styleSheetIdToHeader.set(header.styleSheetId, styleSheetHeader);
        var url = styleSheetHeader.resourceURL();
        if (!this._styleSheetIdsForURL.get(url))
            this._styleSheetIdsForURL.set(url, {});
        var frameIdToStyleSheetIds = this._styleSheetIdsForURL.get(url);
        var styleSheetIds = frameIdToStyleSheetIds[styleSheetHeader.frameId];
        if (!styleSheetIds) {
            styleSheetIds = [];
            frameIdToStyleSheetIds[styleSheetHeader.frameId] = styleSheetIds;
        }
        styleSheetIds.push(styleSheetHeader.id);
        this.dispatchEventToListeners(WebInspector.CSSStyleModel.Events.StyleSheetAdded, styleSheetHeader);
    },

    /**
     * @param {!CSSAgent.StyleSheetId} id
     */
    _styleSheetRemoved: function(id)
    {
        var header = this._styleSheetIdToHeader.get(id);
        console.assert(header);
        if (!header)
            return;
        this._styleSheetIdToHeader.remove(id);
        var url = header.resourceURL();
        var frameIdToStyleSheetIds = /** @type {!Object.<!PageAgent.FrameId, !Array.<!CSSAgent.StyleSheetId>>} */ (this._styleSheetIdsForURL.get(url));
        console.assert(frameIdToStyleSheetIds, "No frameId to styleSheetId map is available for given style sheet URL.");
        frameIdToStyleSheetIds[header.frameId].remove(id);
        if (!frameIdToStyleSheetIds[header.frameId].length) {
            delete frameIdToStyleSheetIds[header.frameId];
            if (!Object.keys(frameIdToStyleSheetIds).length)
                this._styleSheetIdsForURL.remove(url);
        }
        this.dispatchEventToListeners(WebInspector.CSSStyleModel.Events.StyleSheetRemoved, header);
    },

    /**
     * @param {string} url
     * @return {!Array.<!CSSAgent.StyleSheetId>}
     */
    styleSheetIdsForURL: function(url)
    {
        var frameIdToStyleSheetIds = this._styleSheetIdsForURL.get(url);
        if (!frameIdToStyleSheetIds)
            return [];

        var result = [];
        for (var frameId in frameIdToStyleSheetIds)
            result = result.concat(frameIdToStyleSheetIds[frameId]);
        return result;
    },

    /**
     * @param {!CSSAgent.StyleSheetId} styleSheetId
     * @param {string} newText
     * @param {boolean} majorChange
     * @return {!Promise.<?Protocol.Error>}
     */
    setStyleSheetText: function(styleSheetId, newText, majorChange)
    {
        var header = this._styleSheetIdToHeader.get(styleSheetId);
        console.assert(header);
        return header._setContentPromise(newText).then(callback.bind(this));

        /**
         * @param {?Protocol.Error} error
         * @return {?Protocol.Error}
         * @this {WebInspector.CSSStyleModel}
         */
        function callback(error)
        {
            if (error)
                return error;
            if (majorChange)
                this._domModel.markUndoableState();
            this._fireStyleSheetChanged(styleSheetId);
            return null;
        }
    },

    _mainFrameNavigated: function()
    {
        this._resetStyleSheets();
    },

    _resetStyleSheets: function()
    {
        var headers = this._styleSheetIdToHeader.valuesArray();
        this._styleSheetIdsForURL.clear();
        this._styleSheetIdToHeader.clear();
        for (var i = 0; i < headers.length; ++i)
            this.dispatchEventToListeners(WebInspector.CSSStyleModel.Events.StyleSheetRemoved, headers[i]);
    },

    /**
     * @override
     * @return {!Promise}
     */
    suspendModel: function()
    {
        this._isEnabled = false;
        return this._agent.disable().then(this._resetStyleSheets.bind(this));
    },

    /**
     * @override
     * @return {!Promise}
     */
    resumeModel: function()
    {
        return this._agent.enable().then(this._wasEnabled.bind(this));
    },

    /**
     * @param {!CSSAgent.StyleSheetId} id
     * @param {!CSSAgent.SourceRange} range
     */
    _layoutEditorChange: function(id, range)
    {
        this.dispatchEventToListeners(WebInspector.CSSStyleModel.Events.LayoutEditorChange, {id: id, range: range});
    },

    /**
     * @param {number} nodeId
     * @param {string} name
     * @param {string} value
     */
    setEffectivePropertyValueForNode: function(nodeId, name, value)
    {
        this._agent.setEffectivePropertyValueForNode(nodeId, name, value);
    },

    __proto__: WebInspector.SDKModel.prototype
}

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!WebInspector.CSSStyleSheetHeader} header
 * @param {number} lineNumber
 * @param {number=} columnNumber
 */
WebInspector.CSSLocation = function(header, lineNumber, columnNumber)
{
    WebInspector.SDKObject.call(this, header.target());
    this._header = header;
    this.styleSheetId = header.id;
    this.url = header.resourceURL();
    this.lineNumber = lineNumber;
    this.columnNumber = columnNumber || 0;
}

WebInspector.CSSLocation.prototype = {
    /**
     * @return {!WebInspector.CSSStyleModel}
     */
    cssModel: function()
    {
        return this._header.cssModel();
    },

    /**
     * @return {!WebInspector.CSSStyleSheetHeader}
     */
    header: function()
    {
        return this._header;
    },

    __proto__: WebInspector.SDKObject.prototype
}

/**
 * @constructor
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {?WebInspector.CSSRule} parentRule
 * @param {!CSSAgent.CSSStyle} payload
 * @param {!WebInspector.CSSStyleDeclaration.Type} type
 */
WebInspector.CSSStyleDeclaration = function(cssModel, parentRule, payload, type)
{
    this._cssModel = cssModel;
    this.parentRule = parentRule;
    this._reinitialize(payload);
    this.type = type;
}

/** @enum {string} */
WebInspector.CSSStyleDeclaration.Type = {
    Regular: "Regular",
    Inline: "Inline",
    Attributes: "Attributes"
}

WebInspector.CSSStyleDeclaration.prototype = {
    /**
     * @param {!CSSAgent.CSSStyle} payload
     */
    _reinitialize: function(payload)
    {
        this.styleSheetId = payload.styleSheetId;
        this.range = payload.range ? WebInspector.TextRange.fromObject(payload.range) : null;

        var shorthandEntries = payload.shorthandEntries;
        /** @type {!Map.<string, string>} */
        this._shorthandValues = new Map();
        /** @type {!Set.<string>} */
        this._shorthandIsImportant = new Set();
        for (var i = 0; i < shorthandEntries.length; ++i) {
            this._shorthandValues.set(shorthandEntries[i].name, shorthandEntries[i].value);
            if (shorthandEntries[i].important)
                this._shorthandIsImportant.add(shorthandEntries[i].name);
        }

        this._allProperties = [];
        for (var i = 0; i < payload.cssProperties.length; ++i) {
            var property = WebInspector.CSSProperty.parsePayload(this, i, payload.cssProperties[i]);
            this._allProperties.push(property);
        }

        this._generateSyntheticPropertiesIfNeeded();
        this._computeInactiveProperties();

        this._activePropertyMap = new Map();
        for (var property of this._allProperties) {
            if (!property.activeInStyle())
                continue;
            this._activePropertyMap.set(property.name, property);
        }

        this.cssText = payload.cssText;
        this._leadingProperties = null;
    },

    _generateSyntheticPropertiesIfNeeded: function()
    {
        if (this.range)
            return;

        if (!this._shorthandValues.size)
            return;

        var propertiesSet = new Set();
        for (var property of this._allProperties)
            propertiesSet.add(property.name);

        var generatedProperties = [];
        // For style-based properties, generate shorthands with values when possible.
        for (var property of this._allProperties) {
            // For style-based properties, try generating shorthands.
            var shorthands = WebInspector.CSSMetadata.cssPropertiesMetainfo.shorthands(property.name) || [];
            for (var shorthand of shorthands) {
                if (propertiesSet.has(shorthand))
                    continue;  // There already is a shorthand this longhands falls under.
                var shorthandValue = this._shorthandValues.get(shorthand);
                if (!shorthandValue)
                    continue;  // Never generate synthetic shorthands when no value is available.

                // Generate synthetic shorthand we have a value for.
                var shorthandImportance = !!this._shorthandIsImportant.has(shorthand);
                var shorthandProperty = new WebInspector.CSSProperty(this, this.allProperties.length, shorthand, shorthandValue, shorthandImportance, false, true, false);
                generatedProperties.push(shorthandProperty);
                propertiesSet.add(shorthand);
            }
        }
        this._allProperties = this._allProperties.concat(generatedProperties);
    },

    /**
     * @return {!Array.<!WebInspector.CSSProperty>}
     */
    _computeLeadingProperties: function()
    {
        /**
         * @param {!WebInspector.CSSProperty} property
         * @return {boolean}
         */
        function propertyHasRange(property)
        {
            return !!property.range;
        }

        if (this.range)
            return this._allProperties.filter(propertyHasRange);

        var leadingProperties = [];
        for (var property of this._allProperties) {
            var shorthands = WebInspector.CSSMetadata.cssPropertiesMetainfo.shorthands(property.name) || [];
            var belongToAnyShorthand = false;
            for (var shorthand of shorthands) {
                if (this._shorthandValues.get(shorthand)) {
                    belongToAnyShorthand = true;
                    break;
                }
            }
            if (!belongToAnyShorthand)
                leadingProperties.push(property);
        }

        return leadingProperties;
    },

    /**
     * @return {!Array.<!WebInspector.CSSProperty>}
     */
    leadingProperties: function()
    {
        if (!this._leadingProperties)
            this._leadingProperties = this._computeLeadingProperties();
        return this._leadingProperties;
    },

    /**
     * @return {!WebInspector.Target}
     */
    target: function()
    {
        return this._cssModel.target();
    },

    /**
     * @return {!WebInspector.CSSStyleModel}
     */
    cssModel: function()
    {
        return this._cssModel;
    },

    /**
     * @param {string} styleSheetId
     * @param {!WebInspector.TextRange} oldRange
     * @param {!WebInspector.TextRange} newRange
     */
    sourceStyleSheetEdited: function(styleSheetId, oldRange, newRange)
    {
        if (this.styleSheetId !== styleSheetId)
            return;
        if (this.range)
            this.range = this.range.rebaseAfterTextEdit(oldRange, newRange);
        for (var i = 0; i < this._allProperties.length; ++i)
            this._allProperties[i].sourceStyleSheetEdited(styleSheetId, oldRange, newRange);
    },

    _computeInactiveProperties: function()
    {
        var activeProperties = {};
        for (var i = 0; i < this._allProperties.length; ++i) {
            var property = this._allProperties[i];
            if (property.disabled || !property.parsedOk) {
                property._setActive(false);
                continue;
            }
            var canonicalName = WebInspector.CSSMetadata.canonicalPropertyName(property.name);
            var activeProperty = activeProperties[canonicalName];
            if (!activeProperty) {
                activeProperties[canonicalName] = property;
            } else if (!activeProperty.important || property.important) {
                activeProperty._setActive(false);
                activeProperties[canonicalName] = property;
            } else {
                property._setActive(false);
            }
        }
    },

    get allProperties()
    {
        return this._allProperties;
    },

    /**
     * @param {string} name
     * @return {string}
     */
    getPropertyValue: function(name)
    {
        var property = this._activePropertyMap.get(name);
        return property ? property.value : "";
    },

    /**
     * @param {string} name
     * @return {boolean}
     */
    isPropertyImplicit: function(name)
    {
        var property = this._activePropertyMap.get(name);
        return property ? property.implicit : "";
    },

    /**
     * @param {string} name
     * @return {!Array.<!WebInspector.CSSProperty>}
     */
    longhandProperties: function(name)
    {
        var longhands = WebInspector.CSSMetadata.cssPropertiesMetainfo.longhands(name);
        var result = [];
        for (var i = 0; longhands && i < longhands.length; ++i) {
            var property = this._activePropertyMap.get(longhands[i]);
            if (property)
                result.push(property);
        }
        return result;
    },

    /**
     * @param {number} index
     * @return {?WebInspector.CSSProperty}
     */
    propertyAt: function(index)
    {
        return (index < this.allProperties.length) ? this.allProperties[index] : null;
    },

    /**
     * @return {number}
     */
    pastLastSourcePropertyIndex: function()
    {
        for (var i = this.allProperties.length - 1; i >= 0; --i) {
            if (this.allProperties[i].range)
                return i + 1;
        }
        return 0;
    },

    /**
     * @param {number} index
     * @return {!WebInspector.TextRange}
     */
    _insertionRange: function(index)
    {
        var property = this.propertyAt(index);
        return property && property.range ? property.range.collapseToStart() : this.range.collapseToEnd();
    },

    /**
     * @param {number=} index
     * @return {!WebInspector.CSSProperty}
     */
    newBlankProperty: function(index)
    {
        index = (typeof index === "undefined") ? this.pastLastSourcePropertyIndex() : index;
        var property = new WebInspector.CSSProperty(this, index, "", "", false, false, true, false, "", this._insertionRange(index));
        return property;
    },

    /**
     * @param {string} text
     * @param {boolean} majorChange
     * @return {!Promise.<boolean>}
     */
    setText: function(text, majorChange)
    {
        /**
         * @param {?Array<!CSSAgent.CSSStyle>} stylePayloads
         * @return {boolean}
         * @this {WebInspector.CSSStyleDeclaration}
         */
        function onPayload(stylePayloads)
        {
            if (!stylePayloads)
                return false;
            this._reinitialize(stylePayloads[0]);
            return true;
        }

        return this._cssModel.setStyleTexts([this.styleSheetId], [this.range], [text], majorChange)
            .then(onPayload.bind(this))
            .catchException(false);
    },

    /**
     * @param {number} index
     * @param {string} name
     * @param {string} value
     * @param {function(boolean)=} userCallback
     */
    insertPropertyAt: function(index, name, value, userCallback)
    {
        this.newBlankProperty(index).setText(name + ": " + value + ";", false, true)
            .then(userCallback);
    },

    /**
     * @param {string} name
     * @param {string} value
     * @param {function(boolean)=} userCallback
     */
    appendProperty: function(name, value, userCallback)
    {
        this.insertPropertyAt(this.allProperties.length, name, value, userCallback);
    }
}

/**
 * @constructor
 * @param {!CSSAgent.Value} payload
 */
WebInspector.CSSValue = function(payload)
{
    this.text = payload.text;
    if (payload.range)
        this.range = WebInspector.TextRange.fromObject(payload.range);
}

/**
 * @param {!CSSAgent.SelectorList} selectorList
 * @return {!Array<!WebInspector.CSSValue>}
 */
WebInspector.CSSValue.parseSelectorListPayload = function(selectorList)
{
    var selectors = [];
    for (var i = 0; i < selectorList.selectors.length; ++i) {
        var selectorPayload = selectorList.selectors[i];
        selectors.push(new WebInspector.CSSValue(selectorPayload));
    }
    return selectors;
}

WebInspector.CSSValue.prototype = {
    /**
     * @param {!WebInspector.TextRange} oldRange
     * @param {!WebInspector.TextRange} newRange
     */
    sourceStyleRuleEdited: function(oldRange, newRange)
    {
        if (!this.range)
            return;
        this.range = this.range.rebaseAfterTextEdit(oldRange, newRange);
    }
}

/**
 * @constructor
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {{style: !CSSAgent.CSSStyle, styleSheetId: (string|undefined), origin: !CSSAgent.StyleSheetOrigin}} payload
 */
WebInspector.CSSRule = function(cssModel, payload)
{
    this._cssModel = cssModel;
    this.styleSheetId = payload.styleSheetId;

    if (this.styleSheetId) {
        var styleSheetHeader = cssModel.styleSheetHeaderForId(this.styleSheetId);
        this.sourceURL = styleSheetHeader.sourceURL;
    }
    this.origin = payload.origin;
    this.style = new WebInspector.CSSStyleDeclaration(this._cssModel, this, payload.style, WebInspector.CSSStyleDeclaration.Type.Regular);
}

WebInspector.CSSRule.prototype = {
    /**
     * @param {string} styleSheetId
     * @param {!WebInspector.TextRange} oldRange
     * @param {!WebInspector.TextRange} newRange
     */
    sourceStyleSheetEdited: function(styleSheetId, oldRange, newRange)
    {
        this.style.sourceStyleSheetEdited(styleSheetId, oldRange, newRange);
    },

    /**
     * @return {string}
     */
    resourceURL: function()
    {
        if (!this.styleSheetId)
            return "";
        var styleSheetHeader = this._cssModel.styleSheetHeaderForId(this.styleSheetId);
        return styleSheetHeader.resourceURL();
    },

    /**
     * @return {boolean}
     */
    isUserAgent: function()
    {
        return this.origin === CSSAgent.StyleSheetOrigin.UserAgent;
    },

    /**
     * @return {boolean}
     */
    isInjected: function()
    {
        return this.origin === CSSAgent.StyleSheetOrigin.Injected;
    },

    /**
     * @return {boolean}
     */
    isViaInspector: function()
    {
        return this.origin === CSSAgent.StyleSheetOrigin.Inspector;
    },

    /**
     * @return {boolean}
     */
    isRegular: function()
    {
        return this.origin === CSSAgent.StyleSheetOrigin.Regular;
    }
}

/**
 * @constructor
 * @extends {WebInspector.CSSRule}
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {!CSSAgent.CSSRule} payload
 * @param {!Array.<number>=} matchingSelectors
 */
WebInspector.CSSStyleRule = function(cssModel, payload, matchingSelectors)
{
    WebInspector.CSSRule.call(this, cssModel, payload);

    if (matchingSelectors)
        this.matchingSelectors = matchingSelectors;

    /** @type {!Array.<!WebInspector.CSSValue>} */
    this.selectors = WebInspector.CSSValue.parseSelectorListPayload(payload.selectorList);

    if (payload.media)
        this.media = WebInspector.CSSMedia.parseMediaArrayPayload(cssModel, payload.media);
}

/**
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {string} selectorText
 * @return {!WebInspector.CSSStyleRule}
 */
WebInspector.CSSStyleRule.createDummyRule = function(cssModel, selectorText)
{
    var dummyPayload = {
        selectorList: {
            selectors: [{ text: selectorText}],
        },
        style: {
            styleSheetId: "0",
            range: new WebInspector.TextRange(0, 0, 0, 0),
            shorthandEntries: [],
            cssProperties: []
        }
    };
    return new WebInspector.CSSStyleRule(cssModel, /** @type {!CSSAgent.CSSRule} */(dummyPayload));
}

WebInspector.CSSStyleRule.prototype = {
    /**
     * @param {!DOMAgent.NodeId} nodeId
     * @param {string} newSelector
     * @return {!Promise.<boolean>}
     */
    setSelectorText: function(nodeId, newSelector)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {?CSSAgent.SelectorList} selectorPayload
         * @return {?Array.<!WebInspector.CSSValue>}
         * @this {WebInspector.CSSRule}
         */
        function callback(error, selectorPayload)
        {
            if (error || !selectorPayload)
                return null;
            this._cssModel._domModel.markUndoableState();
            this._cssModel._fireStyleSheetChanged(/** @type {string} */(this.styleSheetId));
            return WebInspector.CSSValue.parseSelectorListPayload(selectorPayload);
        }

        if (!this.styleSheetId)
            throw "No rule stylesheet id";
        var range = this.selectorRange();
        if (!range)
            throw "Rule selector is not editable";
        WebInspector.userMetrics.actionTaken(WebInspector.UserMetrics.Action.StyleRuleEdited);
        return this._cssModel._agent.setRuleSelector(this.styleSheetId, range, newSelector, callback.bind(this))
            .then(onNewSelectors.bind(this))
            .catchException(false);

        /**
         * @param {?Array<!WebInspector.CSSValue>} selectors
         * @return {!Promise<boolean>}
         * @this {WebInspector.CSSRule}
         */
        function onNewSelectors(selectors)
        {
            if (!selectors)
                return Promise.resolve(false);
            return this._cssModel._computeMatchingSelectors(nodeId, selectors)
                .then(onMatchingSelectors.bind(this, selectors));
        }

        /**
         * @param {!Array<!WebInspector.CSSValue>} selectors
         * @param {?Array<number>} matchingSelectors
         * @return {boolean}
         * @this {WebInspector.CSSRule}
         */
        function onMatchingSelectors(selectors, matchingSelectors)
        {
            if (!matchingSelectors)
                return false;
            this.selectors = selectors;
            this.matchingSelectors = matchingSelectors;
            return true;
        }
    },

    /**
     * @return {string}
     */
    selectorText: function()
    {
        return this.selectors.select("text").join(", ");
    },

    /**
     * @return {?WebInspector.TextRange}
     */
    selectorRange: function()
    {
        var firstRange = this.selectors[0].range;
        if (!firstRange)
            return null;
        var lastRange = this.selectors.peekLast().range;
        return new WebInspector.TextRange(firstRange.startLine, firstRange.startColumn, lastRange.endLine, lastRange.endColumn);
    },

    /**
     * @param {number} selectorIndex
     * @return {number}
     */
    lineNumberInSource: function(selectorIndex)
    {
        var selector = this.selectors[selectorIndex];
        if (!selector || !selector.range || !this.styleSheetId)
            return 0;
        var styleSheetHeader = this._cssModel.styleSheetHeaderForId(this.styleSheetId);
        return styleSheetHeader.lineNumberInSource(selector.range.startLine);
    },

    /**
     * @param {number} selectorIndex
     * @return {number|undefined}
     */
    columnNumberInSource: function(selectorIndex)
    {
        var selector = this.selectors[selectorIndex];
        if (!selector || !selector.range || !this.styleSheetId)
            return undefined;
        var styleSheetHeader = this._cssModel.styleSheetHeaderForId(this.styleSheetId);
        console.assert(styleSheetHeader);
        return styleSheetHeader.columnNumberInSource(selector.range.startLine, selector.range.startColumn);
    },

    /**
     * @override
     * @param {string} styleSheetId
     * @param {!WebInspector.TextRange} oldRange
     * @param {!WebInspector.TextRange} newRange
     */
    sourceStyleSheetEdited: function(styleSheetId, oldRange, newRange)
    {
        this._sourceStyleSheetEditedWithMedia(styleSheetId, oldRange, newRange, null, null);
    },

    /**
     * @param {string} styleSheetId
     * @param {!WebInspector.TextRange} oldRange
     * @param {!WebInspector.TextRange} newRange
     * @param {?WebInspector.CSSMedia} oldMedia
     * @param {?WebInspector.CSSMedia} newMedia
     */
    _sourceStyleSheetEditedWithMedia: function(styleSheetId, oldRange, newRange, oldMedia, newMedia)
    {
        if (this.styleSheetId === styleSheetId) {
            for (var i = 0; i < this.selectors.length; ++i)
                this.selectors[i].sourceStyleRuleEdited(oldRange, newRange);
        }
        if (this.media) {
            for (var i = 0; i < this.media.length; ++i) {
                if (oldMedia && newMedia && oldMedia.equal(this.media[i])) {
                    this.media[i] = newMedia;
                } else {
                    this.media[i].sourceStyleSheetEdited(styleSheetId, oldRange, newRange);
                }
            }
        }
        WebInspector.CSSRule.prototype.sourceStyleSheetEdited.call(this, styleSheetId, oldRange, newRange);
    },

    /**
     * @param {!WebInspector.CSSMedia} oldMedia
     * @param {!WebInspector.CSSMedia} newMedia
     */
    mediaEdited: function(oldMedia, newMedia)
    {
        this._sourceStyleSheetEditedWithMedia(/** @type {string} */ (oldMedia.parentStyleSheetId), oldMedia.range, newMedia.range, oldMedia, newMedia);
    },

    __proto__: WebInspector.CSSRule.prototype
}

/**
 * @constructor
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {!CSSAgent.CSSKeyframesRule} payload
 */
WebInspector.CSSKeyframesRule = function(cssModel, payload)
{
    this._cssModel = cssModel;
    this._animationName = new WebInspector.CSSValue(payload.animationName);
    this._keyframes = payload.keyframes.map(keyframeRule => new WebInspector.CSSKeyframeRule(cssModel, keyframeRule));
}

WebInspector.CSSKeyframesRule.prototype = {
    /**
     * @return {!WebInspector.CSSValue}
     */
    name: function()
    {
        return this._animationName;
    },

    /**
     * @return {!Array.<!WebInspector.CSSKeyframeRule>}
     */
    keyframes: function()
    {
        return this._keyframes;
    }
}

/**
 * @constructor
 * @extends {WebInspector.CSSRule}
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {!CSSAgent.CSSKeyframeRule} payload
 */
WebInspector.CSSKeyframeRule = function(cssModel, payload)
{
    WebInspector.CSSRule.call(this, cssModel, payload);
    this._keyText = new WebInspector.CSSValue(payload.keyText);
}

WebInspector.CSSKeyframeRule.prototype = {
    /**
     * @return {!WebInspector.CSSValue}
        */
    key: function()
    {
        return this._keyText;
    },

    /**
     * @override
     * @param {string} styleSheetId
     * @param {!WebInspector.TextRange} oldRange
     * @param {!WebInspector.TextRange} newRange
     */
    sourceStyleSheetEdited: function(styleSheetId, oldRange, newRange)
    {
        if (this.styleSheetId === styleSheetId)
            this._keyText.sourceStyleRuleEdited(oldRange, newRange);
        WebInspector.CSSRule.prototype.sourceStyleSheetEdited.call(this, styleSheetId, oldRange, newRange);
    },

    /**
     * @param {string} newKeyText
     * @return {!Promise.<boolean>}
     */
    setKeyText: function(newKeyText)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {!CSSAgent.Value} payload
         * @return {boolean}
         * @this {WebInspector.CSSKeyframeRule}
         */
        function callback(error, payload)
        {
            if (error || !payload)
                return false;
            this._cssModel._domModel.markUndoableState();
            this._cssModel._fireStyleSheetChanged(/** @type {string} */(this.styleSheetId));
            this._keyText = new WebInspector.CSSValue(payload);
            return true;
        }

        if (!this.styleSheetId)
            throw "No rule stylesheet id";
        var range = this._keyText.range;
        if (!range)
            throw "Keyframe key is not editable";
        WebInspector.userMetrics.actionTaken(WebInspector.UserMetrics.Action.StyleRuleEdited);
        return this._cssModel._agent.setKeyframeKey(this.styleSheetId, range, newKeyText, callback.bind(this))
            .catchException(false);
    },

    __proto__: WebInspector.CSSRule.prototype
}

/**
 * @constructor
 * @param {!WebInspector.CSSStyleDeclaration} ownerStyle
 * @param {number} index
 * @param {string} name
 * @param {string} value
 * @param {boolean} important
 * @param {boolean} disabled
 * @param {boolean} parsedOk
 * @param {boolean} implicit
 * @param {?string=} text
 * @param {!CSSAgent.SourceRange=} range
 */
WebInspector.CSSProperty = function(ownerStyle, index, name, value, important, disabled, parsedOk, implicit, text, range)
{
    this.ownerStyle = ownerStyle;
    this.index = index;
    this.name = name;
    this.value = value;
    this.important = important;
    this.disabled = disabled;
    this.parsedOk = parsedOk;
    this.implicit = implicit; // A longhand, implicitly set by missing values of shorthand.
    this.text = text;
    this.range = range ? WebInspector.TextRange.fromObject(range) : null;
    this._active = true;
}

/**
 * @param {!WebInspector.CSSStyleDeclaration} ownerStyle
 * @param {number} index
 * @param {!CSSAgent.CSSProperty} payload
 * @return {!WebInspector.CSSProperty}
 */
WebInspector.CSSProperty.parsePayload = function(ownerStyle, index, payload)
{
    // The following default field values are used in the payload:
    // important: false
    // parsedOk: true
    // implicit: false
    // disabled: false
    var result = new WebInspector.CSSProperty(
        ownerStyle, index, payload.name, payload.value, payload.important || false, payload.disabled || false, ("parsedOk" in payload) ? !!payload.parsedOk : true, !!payload.implicit, payload.text, payload.range);
    return result;
}

WebInspector.CSSProperty.prototype = {
    /**
     * @param {string} styleSheetId
     * @param {!WebInspector.TextRange} oldRange
     * @param {!WebInspector.TextRange} newRange
     */
    sourceStyleSheetEdited: function(styleSheetId, oldRange, newRange)
    {
        if (this.ownerStyle.styleSheetId !== styleSheetId)
            return;
        if (this.range)
            this.range = this.range.rebaseAfterTextEdit(oldRange, newRange);
    },

    /**
     * @param {boolean} active
     */
    _setActive: function(active)
    {
        this._active = active;
    },

    get propertyText()
    {
        if (this.text !== undefined)
            return this.text;

        if (this.name === "")
            return "";
        return this.name + ": " + this.value + (this.important ? " !important" : "") + ";";
    },

    /**
     * @return {boolean}
     */
    activeInStyle: function()
    {
        return this._active;
    },

    /**
     * @param {string} propertyText
     * @param {boolean} majorChange
     * @param {boolean} overwrite
     * @return {!Promise.<boolean>}
     */
    setText: function(propertyText, majorChange, overwrite)
    {
        if (!this.ownerStyle)
            return Promise.reject(new Error("No ownerStyle for property"));

        if (!this.ownerStyle.styleSheetId)
            return Promise.reject(new Error("No owner style id"));

        if (!this.range || !this.ownerStyle.range)
            return Promise.reject(new Error("Style not editable"));

        if (majorChange)
            WebInspector.userMetrics.actionTaken(WebInspector.UserMetrics.Action.StyleRuleEdited);

        if (overwrite && propertyText === this.propertyText) {
            if (majorChange)
                this.ownerStyle._cssModel._domModel.markUndoableState();
            return Promise.resolve(true);
        }

        var range = this.range.relativeTo(this.ownerStyle.range.startLine, this.ownerStyle.range.startColumn);
        var indentation = this.ownerStyle.cssText ? this._detectIndentation(this.ownerStyle.cssText) : WebInspector.moduleSetting("textEditorIndent").get();
        var endIndentation = this.ownerStyle.cssText ? indentation.substring(0, this.ownerStyle.range.endColumn) : "";
        var newStyleText = range.replaceInText(this.ownerStyle.cssText || "", String.sprintf(";%s;", propertyText));

        return self.runtime.instancePromise(WebInspector.TokenizerFactory)
            .then(this._formatStyle.bind(this, newStyleText, indentation, endIndentation))
            .then(setStyleText.bind(this));

        /**
         * @param {string} styleText
         * @this {WebInspector.CSSProperty}
         * @return {!Promise.<boolean>}
         */
        function setStyleText(styleText)
        {
            return this.ownerStyle.setText(styleText, majorChange);
        }
    },

    /**
     * @param {string} styleText
     * @param {string} indentation
     * @param {string} endIndentation
     * @param {!WebInspector.TokenizerFactory} tokenizerFactory
     * @return {string}
     */
    _formatStyle: function(styleText, indentation, endIndentation, tokenizerFactory)
    {
        if (indentation)
            indentation = "\n" + indentation;
        var result = "";
        var propertyText;
        var insideProperty = false;
        var tokenize = tokenizerFactory.createTokenizer("text/css");

        tokenize("*{" + styleText + "}", processToken);
        if (insideProperty)
            result += propertyText;
        result = result.substring(2, result.length - 1).trimRight();
        return result + (indentation ? "\n" + endIndentation : "");

        /**
         * @param {string} token
         * @param {?string} tokenType
         * @param {number} column
         * @param {number} newColumn
         */
        function processToken(token, tokenType, column, newColumn)
        {
            if (!insideProperty) {
                var disabledProperty = tokenType && tokenType.includes("css-comment") && isDisabledProperty(token);
                var isPropertyStart = tokenType && (tokenType.includes("css-string") || tokenType.includes("css-meta") || tokenType.includes("css-property") || tokenType.includes("css-variable-2"));
                if (disabledProperty) {
                    result = result.trimRight() + indentation + token;
                } else if (isPropertyStart) {
                    insideProperty = true;
                    propertyText = token;
                } else if (token !== ";") {
                    result += token;
                }
                return;
            }

            if (token === "}" || token === ";") {
                result = result.trimRight() + indentation + propertyText.trim() + ";";
                insideProperty = false;
                if (token === "}")
                    result += "}";
            } else {
                propertyText += token;
            }
        }

        /**
         * @param {string} text
         * @return {boolean}
         */
        function isDisabledProperty(text)
        {
            var colon = text.indexOf(":");
            if (colon === -1)
                return false;
            var propertyName = text.substring(2, colon).trim();
            return WebInspector.CSSMetadata.isCSSPropertyName(propertyName);
        }
    },

    /**
     * @param {string} text
     * @return {string}
     */
    _detectIndentation: function(text)
    {
        var lines = text.split("\n");
        if (lines.length < 2)
            return "";
        return WebInspector.TextUtils.lineIndent(lines[1]);
    },

    /**
     * @param {string} newValue
     * @param {boolean} majorChange
     * @param {boolean} overwrite
     * @param {function(boolean)=} userCallback
     */
    setValue: function(newValue, majorChange, overwrite, userCallback)
    {
        var text = this.name + ": " + newValue + (this.important ? " !important" : "") + ";";
        this.setText(text, majorChange, overwrite).then(userCallback);
    },

    /**
     * @param {boolean} disabled
     * @return {!Promise.<boolean>}
     */
    setDisabled: function(disabled)
    {
        if (!this.ownerStyle)
            return Promise.resolve(false);
        if (disabled === this.disabled)
            return Promise.resolve(true);
        var propertyText = this.text.trim();
        var text = disabled ? "/* " + propertyText + " */" : this.text.substring(2, propertyText.length - 2).trim();
        return this.setText(text, true, true);
    }
}

/**
 * @constructor
 * @param {!CSSAgent.MediaQuery} payload
 */
WebInspector.CSSMediaQuery = function(payload)
{
    this._active = payload.active;
    this._expressions = [];
    for (var j = 0; j < payload.expressions.length; ++j)
        this._expressions.push(WebInspector.CSSMediaQueryExpression.parsePayload(payload.expressions[j]));
}

/**
 * @param {!CSSAgent.MediaQuery} payload
 * @return {!WebInspector.CSSMediaQuery}
 */
WebInspector.CSSMediaQuery.parsePayload = function(payload)
{
    return new WebInspector.CSSMediaQuery(payload);
}

WebInspector.CSSMediaQuery.prototype = {
    /**
     * @return {boolean}
     */
    active: function()
    {
        return this._active;
    },

    /**
     * @return {!Array.<!WebInspector.CSSMediaQueryExpression>}
     */
    expressions: function()
    {
        return this._expressions;
    }
}

/**
 * @constructor
 * @param {!CSSAgent.MediaQueryExpression} payload
 */
WebInspector.CSSMediaQueryExpression = function(payload)
{
    this._value = payload.value;
    this._unit = payload.unit;
    this._feature = payload.feature;
    this._valueRange = payload.valueRange ? WebInspector.TextRange.fromObject(payload.valueRange) : null;
    this._computedLength = payload.computedLength || null;
}

/**
 * @param {!CSSAgent.MediaQueryExpression} payload
 * @return {!WebInspector.CSSMediaQueryExpression}
 */
WebInspector.CSSMediaQueryExpression.parsePayload = function(payload)
{
    return new WebInspector.CSSMediaQueryExpression(payload);
}

WebInspector.CSSMediaQueryExpression.prototype = {
    /**
     * @return {number}
     */
    value: function()
    {
        return this._value;
    },

    /**
     * @return {string}
     */
    unit: function()
    {
        return this._unit;
    },

    /**
     * @return {string}
     */
    feature: function()
    {
        return this._feature;
    },

    /**
     * @return {?WebInspector.TextRange}
     */
    valueRange: function()
    {
        return this._valueRange;
    },

    /**
     * @return {?number}
     */
    computedLength: function()
    {
        return this._computedLength;
    }
}


/**
 * @constructor
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {!CSSAgent.CSSMedia} payload
 */
WebInspector.CSSMedia = function(cssModel, payload)
{
    this._cssModel = cssModel;
    this.text = payload.text;
    this.source = payload.source;
    this.sourceURL = payload.sourceURL || "";
    this.range = payload.range ? WebInspector.TextRange.fromObject(payload.range) : null;
    this.parentStyleSheetId = payload.parentStyleSheetId;
    this.mediaList = null;
    if (payload.mediaList) {
        this.mediaList = [];
        for (var i = 0; i < payload.mediaList.length; ++i)
            this.mediaList.push(WebInspector.CSSMediaQuery.parsePayload(payload.mediaList[i]));
    }
}

WebInspector.CSSMedia.Source = {
    LINKED_SHEET: "linkedSheet",
    INLINE_SHEET: "inlineSheet",
    MEDIA_RULE: "mediaRule",
    IMPORT_RULE: "importRule"
};

/**
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {!CSSAgent.CSSMedia} payload
 * @return {!WebInspector.CSSMedia}
 */
WebInspector.CSSMedia.parsePayload = function(cssModel, payload)
{
    return new WebInspector.CSSMedia(cssModel, payload);
}

/**
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {!Array.<!CSSAgent.CSSMedia>} payload
 * @return {!Array.<!WebInspector.CSSMedia>}
 */
WebInspector.CSSMedia.parseMediaArrayPayload = function(cssModel, payload)
{
    var result = [];
    for (var i = 0; i < payload.length; ++i)
        result.push(WebInspector.CSSMedia.parsePayload(cssModel, payload[i]));
    return result;
}

WebInspector.CSSMedia.prototype = {
    /**
     * @param {string} styleSheetId
     * @param {!WebInspector.TextRange} oldRange
     * @param {!WebInspector.TextRange} newRange
     */
    sourceStyleSheetEdited: function(styleSheetId, oldRange, newRange)
    {
        if (this.parentStyleSheetId !== styleSheetId)
            return;
        if (this.range)
            this.range = this.range.rebaseAfterTextEdit(oldRange, newRange);
    },

    /**
     * @param {!WebInspector.CSSMedia} other
     * @return {boolean}
     */
    equal: function(other)
    {
        if (!this.parentStyleSheetId || !this.range || !other.range)
            return false;
        return  this.parentStyleSheetId === other.parentStyleSheetId && this.range.equal(other.range);
    },

    /**
     * @return {boolean}
     */
    active: function()
    {
        if (!this.mediaList)
            return true;
        for (var i = 0; i < this.mediaList.length; ++i) {
            if (this.mediaList[i].active())
                return true;
        }
        return false;
    },

    /**
     * @return {number|undefined}
     */
    lineNumberInSource: function()
    {
        if (!this.range)
            return undefined;
        var header = this.header();
        if (!header)
            return undefined;
        return header.lineNumberInSource(this.range.startLine);
    },

    /**
     * @return {number|undefined}
     */
    columnNumberInSource: function()
    {
        if (!this.range)
            return undefined;
        var header = this.header();
        if (!header)
            return undefined;
        return header.columnNumberInSource(this.range.startLine, this.range.startColumn);
    },

    /**
     * @return {?WebInspector.CSSStyleSheetHeader}
     */
    header: function()
    {
        return this.parentStyleSheetId ? this._cssModel.styleSheetHeaderForId(this.parentStyleSheetId) : null;
    },

    /**
     * @return {?WebInspector.CSSLocation}
     */
    rawLocation: function()
    {
        var header = this.header();
        if (!header || this.lineNumberInSource() === undefined)
            return null;
        var lineNumber = Number(this.lineNumberInSource());
        return new WebInspector.CSSLocation(header, lineNumber, this.columnNumberInSource());
    }
}

/**
 * @constructor
 * @implements {WebInspector.ContentProvider}
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {!CSSAgent.CSSStyleSheetHeader} payload
 */
WebInspector.CSSStyleSheetHeader = function(cssModel, payload)
{
    this._cssModel = cssModel;
    this.id = payload.styleSheetId;
    this.frameId = payload.frameId;
    this.sourceURL = payload.sourceURL;
    this.hasSourceURL = !!payload.hasSourceURL;
    this.sourceMapURL = payload.sourceMapURL;
    this.origin = payload.origin;
    this.title = payload.title;
    this.disabled = payload.disabled;
    this.isInline = payload.isInline;
    this.startLine = payload.startLine;
    this.startColumn = payload.startColumn;
    if (payload.ownerNode)
        this.ownerNode = new WebInspector.DeferredDOMNode(cssModel.target(), payload.ownerNode);
}

WebInspector.CSSStyleSheetHeader.prototype = {
    /**
     * @return {!WebInspector.Target}
     */
    target: function()
    {
        return this._cssModel.target();
    },

    /**
     * @return {!WebInspector.CSSStyleModel}
     */
    cssModel: function()
    {
        return this._cssModel;
    },

    /**
     * @return {string}
     */
    resourceURL: function()
    {
        return this.isViaInspector() ? this._viaInspectorResourceURL() : this.sourceURL;
    },

    /**
     * @return {string}
     */
    _viaInspectorResourceURL: function()
    {
        var frame = this._cssModel.target().resourceTreeModel.frameForId(this.frameId);
        console.assert(frame);
        var parsedURL = new WebInspector.ParsedURL(frame.url);
        var fakeURL = "inspector://" + parsedURL.host + parsedURL.folderPathComponents;
        if (!fakeURL.endsWith("/"))
            fakeURL += "/";
        fakeURL += "inspector-stylesheet";
        return fakeURL;
    },

    /**
     * @param {number} lineNumberInStyleSheet
     * @return {number}
     */
    lineNumberInSource: function(lineNumberInStyleSheet)
    {
        return this.startLine + lineNumberInStyleSheet;
    },

    /**
     * @param {number} lineNumberInStyleSheet
     * @param {number} columnNumberInStyleSheet
     * @return {number|undefined}
     */
    columnNumberInSource: function(lineNumberInStyleSheet, columnNumberInStyleSheet)
    {
        return (lineNumberInStyleSheet ? 0 : this.startColumn) + columnNumberInStyleSheet;
    },

    /**
     * @override
     * @return {string}
     */
    contentURL: function()
    {
        return this.resourceURL();
    },

    /**
     * @override
     * @return {!WebInspector.ResourceType}
     */
    contentType: function()
    {
        return WebInspector.resourceTypes.Stylesheet;
    },

    /**
     * @param {string} text
     * @return {string}
     */
    _trimSourceURL: function(text)
    {
        var sourceURLIndex = text.lastIndexOf("/*# sourceURL=");
        if (sourceURLIndex === -1) {
            sourceURLIndex = text.lastIndexOf("/*@ sourceURL=");
            if (sourceURLIndex === -1)
                return text;
        }
        var sourceURLLineIndex = text.lastIndexOf("\n", sourceURLIndex);
        if (sourceURLLineIndex === -1)
            return text;
        var sourceURLLine = text.substr(sourceURLLineIndex + 1).split("\n", 1)[0];
        var sourceURLRegex = /[\040\t]*\/\*[#@] sourceURL=[\040\t]*([^\s]*)[\040\t]*\*\/[\040\t]*$/;
        if (sourceURLLine.search(sourceURLRegex) === -1)
            return text;
        return text.substr(0, sourceURLLineIndex) + text.substr(sourceURLLineIndex + sourceURLLine.length + 1);
    },

    /**
     * @override
     * @return {!Promise<?string>}
     */
    requestContent: function()
    {
        return this._cssModel._agent.getStyleSheetText(this.id, textCallback.bind(this))
            .catchException(/** @type {?string} */(""));

        /**
         * @param {?Protocol.Error} error
         * @param {?string} text
         * @return {string}
         * @this {WebInspector.CSSStyleSheetHeader}
         */
        function textCallback(error, text)
        {
            if (error || text === null) {
                WebInspector.console.error("Failed to get text for stylesheet " + this.id + ": " + error)
                text = "";
                // Fall through.
            }
            return this._trimSourceURL(text);
        }
    },

    /**
     * @override
     */
    searchInContent: function(query, caseSensitive, isRegex, callback)
    {
        function performSearch(content)
        {
            callback(WebInspector.ContentProvider.performSearchInContent(content, query, caseSensitive, isRegex));
        }

        // searchInContent should call back later.
        this.requestContent().then(performSearch);
    },

    /**
     * @param {string} newText
     * @return {!Promise.<?Protocol.Error>}
     */
    _setContentPromise: function(newText)
    {
        newText = this._trimSourceURL(newText);
        if (this.hasSourceURL)
            newText += "\n/*# sourceURL=" + this.sourceURL + " */";
        return this._cssModel._agent.setStyleSheetText(this.id, newText, callback.bind(this));

        /**
         * @param {?Protocol.Error} error
         * @param {string=} sourceMapURL
         * @return {?Protocol.Error}
         * @this {WebInspector.CSSStyleSheetHeader}
         */
        function callback(error, sourceMapURL)
        {
            this.sourceMapURL = sourceMapURL;
            return error || null;
        }
    },

    /**
     * @return {boolean}
     */
    isViaInspector: function()
    {
        return this.origin === "inspector";
    }
}

/**
 * @constructor
 * @implements {CSSAgent.Dispatcher}
 * @param {!WebInspector.CSSStyleModel} cssModel
 */
WebInspector.CSSDispatcher = function(cssModel)
{
    this._cssModel = cssModel;
}

WebInspector.CSSDispatcher.prototype = {
    /**
     * @override
     */
    mediaQueryResultChanged: function()
    {
        this._cssModel.mediaQueryResultChanged();
    },

    /**
     * @override
     * @param {!CSSAgent.StyleSheetId} styleSheetId
     */
    styleSheetChanged: function(styleSheetId)
    {
        this._cssModel._fireStyleSheetChanged(styleSheetId);
    },

    /**
     * @override
     * @param {!CSSAgent.CSSStyleSheetHeader} header
     */
    styleSheetAdded: function(header)
    {
        this._cssModel._styleSheetAdded(header);
    },

    /**
     * @override
     * @param {!CSSAgent.StyleSheetId} id
     */
    styleSheetRemoved: function(id)
    {
        this._cssModel._styleSheetRemoved(id);
    },

    /**
     * @override
     * @param {!CSSAgent.StyleSheetId} id
     * @param {!CSSAgent.SourceRange} range
     */
    layoutEditorChange: function(id, range)
    {
        this._cssModel._layoutEditorChange(id, range);
    },
}

/**
 * @constructor
 * @param {!WebInspector.CSSStyleModel} cssModel
 */
WebInspector.CSSStyleModel.ComputedStyleLoader = function(cssModel)
{
    this._cssModel = cssModel;
    /** @type {!Map.<!DOMAgent.NodeId, !Promise.<?WebInspector.CSSStyleDeclaration>>} */
    this._nodeIdToPromise = new Map();
}

WebInspector.CSSStyleModel.ComputedStyleLoader.prototype = {
    /**
     * @param {!DOMAgent.NodeId} nodeId
     * @return {!Promise.<?Map.<string, string>>}
     */
    computedStylePromise: function(nodeId)
    {
        if (!this._nodeIdToPromise[nodeId])
            this._nodeIdToPromise[nodeId] = this._cssModel._agent.getComputedStyleForNode(nodeId, parsePayload).then(cleanUp.bind(this));

        return this._nodeIdToPromise[nodeId];

        /**
         * @param {?Protocol.Error} error
         * @param {!Array.<!CSSAgent.CSSComputedStyleProperty>} computedPayload
         * @return {?Map.<string, string>}
         */
        function parsePayload(error, computedPayload)
        {
            if (error || !computedPayload || !computedPayload.length)
                return null;
            var result = new Map();
            for (var property of computedPayload)
                result.set(property.name, property.value);
            return result;
        }

        /**
         * @param {?Map.<string, string>} computedStyle
         * @return {?Map.<string, string>}
         * @this {WebInspector.CSSStyleModel.ComputedStyleLoader}
         */
        function cleanUp(computedStyle)
        {
            delete this._nodeIdToPromise[nodeId];
            return computedStyle;
        }
    }
}

/**
 * @param {!WebInspector.Target} target
 * @return {?WebInspector.CSSStyleModel}
 */
WebInspector.CSSStyleModel.fromTarget = function(target)
{
    if (!target.isPage())
        return null;
    return /** @type {?WebInspector.CSSStyleModel} */ (target.model(WebInspector.CSSStyleModel));
}

/**
 * @param {!WebInspector.DOMNode} node
 * @return {!WebInspector.CSSStyleModel}
 */
WebInspector.CSSStyleModel.fromNode = function(node)
{
    return /** @type {!WebInspector.CSSStyleModel} */ (WebInspector.CSSStyleModel.fromTarget(node.target()));
}

/**
 * @constructor
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {!WebInspector.DOMNode} node
 * @param {?CSSAgent.CSSStyle=} inlinePayload
 * @param {?CSSAgent.CSSStyle=} attributesPayload
 * @param {!Array.<!CSSAgent.RuleMatch>=} matchedPayload
 * @param {!Array.<!CSSAgent.PseudoElementMatches>=} pseudoPayload
 * @param {!Array.<!CSSAgent.InheritedStyleEntry>=} inheritedPayload
 * @param {!Array.<!CSSAgent.CSSKeyframesRule>=} animationsPayload
 */
WebInspector.CSSStyleModel.MatchedStyleResult = function(cssModel, node, inlinePayload, attributesPayload, matchedPayload, pseudoPayload, inheritedPayload, animationsPayload)
{
    this._cssModel = cssModel;
    this._node = node;
    this._nodeStyles = [];
    this._nodeForStyle = new Map();
    this._inheritedStyles = new Set();
    this._keyframes = [];

    /**
     * @this {WebInspector.CSSStyleModel.MatchedStyleResult}
     */
    function addAttributesStyle()
    {
        if (!attributesPayload)
            return;
        var style = new WebInspector.CSSStyleDeclaration(cssModel, null, attributesPayload, WebInspector.CSSStyleDeclaration.Type.Attributes);
        this._nodeForStyle.set(style, this._node);
        this._nodeStyles.push(style);
    }

    // Inline style has the greatest specificity.
    if (inlinePayload && this._node.nodeType() === Node.ELEMENT_NODE) {
        var style = new WebInspector.CSSStyleDeclaration(cssModel, null, inlinePayload, WebInspector.CSSStyleDeclaration.Type.Inline);
        this._nodeForStyle.set(style, this._node);
        this._nodeStyles.push(style);
    }

    // Add rules in reverse order to match the cascade order.
    var addedAttributesStyle;
    var matchedRules = WebInspector.CSSStyleModel.parseRuleMatchArrayPayload(cssModel, matchedPayload);
    for (var i = matchedRules.length - 1; i >= 0; --i) {
        var rule = matchedRules[i];
        if ((rule.isInjected() || rule.isUserAgent()) && !addedAttributesStyle) {
            // Show element's Style Attributes after all author rules.
            addedAttributesStyle = true;
            addAttributesStyle.call(this);
        }
        this._nodeForStyle.set(rule.style, this._node);
        this._nodeStyles.push(rule.style);
    }

    if (!addedAttributesStyle)
        addAttributesStyle.call(this);

    // Walk the node structure and identify styles with inherited properties.
    var parentNode = this._node.parentNode;
    for (var i = 0; inheritedPayload && i < inheritedPayload.length; ++i) {
        var entryPayload = inheritedPayload[i];
        var inheritedInlineStyle = entryPayload.inlineStyle ? new WebInspector.CSSStyleDeclaration(cssModel, null, entryPayload.inlineStyle, WebInspector.CSSStyleDeclaration.Type.Inline) : null;
        var inheritedMatchedCSSRules = entryPayload.matchedCSSRules ? WebInspector.CSSStyleModel.parseRuleMatchArrayPayload(cssModel, entryPayload.matchedCSSRules) : null;
        if (inheritedInlineStyle && this._containsInherited(inheritedInlineStyle)) {
            this._nodeForStyle.set(inheritedInlineStyle, parentNode);
            this._nodeStyles.push(inheritedInlineStyle);
            this._inheritedStyles.add(inheritedInlineStyle);
        }

        for (var j = inheritedMatchedCSSRules.length - 1; j >= 0; --j) {
            var inheritedRule = inheritedMatchedCSSRules[j];
            if (!this._containsInherited(inheritedRule.style))
                continue;
            this._nodeForStyle.set(inheritedRule.style, parentNode);
            this._nodeStyles.push(inheritedRule.style);
            this._inheritedStyles.add(inheritedRule.style);
        }
        parentNode = parentNode.parentNode;
    }

    // Set up pseudo styles map.
    this._pseudoStyles = new Map();
    if (pseudoPayload) {
        for (var i = 0; i < pseudoPayload.length; ++i) {
            var entryPayload = pseudoPayload[i];
            var pseudoElement = this._node.pseudoElements().get(entryPayload.pseudoType);
            var pseudoStyles = [];
            var rules = WebInspector.CSSStyleModel.parseRuleMatchArrayPayload(cssModel, entryPayload.matches);
            for (var j = rules.length - 1; j >= 0; --j) {
                var pseudoRule = rules[j];
                pseudoStyles.push(pseudoRule.style);
                this._nodeForStyle.set(pseudoRule.style, pseudoElement);
            }
            this._pseudoStyles.set(entryPayload.pseudoType, pseudoStyles);
        }
    }

    if (animationsPayload)
        this._keyframes = animationsPayload.map(rule => new WebInspector.CSSKeyframesRule(cssModel, rule));

    this.resetActiveProperties();
}

WebInspector.CSSStyleModel.MatchedStyleResult.prototype = {
    /**
     * @return {!WebInspector.DOMNode}
     */
    node: function()
    {
        return this._node;
    },

    /**
     * @param {!WebInspector.CSSStyleDeclaration} style
     * @return {boolean}
     */
    hasMatchingSelectors: function(style)
    {
        return style.parentRule ? style.parentRule.matchingSelectors && style.parentRule.matchingSelectors.length > 0 && this.mediaMatches(style) : true;
    },

    /**
     * @param {!WebInspector.CSSStyleDeclaration} style
     * @return {boolean}
     */
    mediaMatches: function(style)
    {
        var media = style.parentRule ? style.parentRule.media : [];
        for (var i = 0; media && i < media.length; ++i) {
            if (!media[i].active())
                return false;
        }
        return true;
    },

    /**
     * @return {!Array<!WebInspector.CSSStyleDeclaration>}
     */
    nodeStyles: function()
    {
        return this._nodeStyles;
    },

    /**
     * @return {!Array.<!WebInspector.CSSKeyframesRule>}
     */
    keyframes: function()
    {
        return this._keyframes;
    },

    /**
     * @return {!Map.<!DOMAgent.PseudoType, !Array<!WebInspector.CSSStyleDeclaration>>}
     */
    pseudoStyles: function()
    {
        return this._pseudoStyles;
    },

    /**
     * @param {!WebInspector.CSSStyleDeclaration} style
     * @return {boolean}
     */
    _containsInherited: function(style)
    {
        var properties = style.allProperties;
        for (var i = 0; i < properties.length; ++i) {
            var property = properties[i];
            // Does this style contain non-overridden inherited property?
            if (property.activeInStyle() && WebInspector.CSSMetadata.isPropertyInherited(property.name))
                return true;
        }
        return false;
    },

    /**
     * @param {!WebInspector.CSSStyleDeclaration} style
     * @return {?WebInspector.DOMNode}
     */
    nodeForStyle: function(style)
    {
        return this._nodeForStyle.get(style) || null;
    },

    /**
     * @param {!WebInspector.CSSStyleDeclaration} style
     * @return {boolean}
     */
    isInherited: function(style)
    {
        return this._inheritedStyles.has(style);
    },

    /**
     * @param {!WebInspector.CSSProperty} property
     * @return {?WebInspector.CSSStyleModel.MatchedStyleResult.PropertyState}
     */
    propertyState: function(property)
    {
        if (this._propertiesState.size === 0) {
            this._computeActiveProperties(this._nodeStyles, this._propertiesState);
            for (var pseudoElementStyles of this._pseudoStyles.valuesArray())
                this._computeActiveProperties(pseudoElementStyles, this._propertiesState);
        }
        return this._propertiesState.get(property) || null;
    },

    resetActiveProperties: function()
    {
        /** @type {!Map<!WebInspector.CSSProperty, !WebInspector.CSSStyleModel.MatchedStyleResult.PropertyState>} */
        this._propertiesState = new Map();
    },

    /**
     * @param {!Array<!WebInspector.CSSStyleDeclaration>} styles
     * @param {!Map<!WebInspector.CSSProperty, !WebInspector.CSSStyleModel.MatchedStyleResult.PropertyState>} result
     */
    _computeActiveProperties: function(styles, result)
    {
        /** @type {!Set.<string>} */
        var foundImportantProperties = new Set();
        /** @type {!Map.<string, !Map<string, !WebInspector.CSSProperty>>} */
        var propertyToEffectiveRule = new Map();
        /** @type {!Map.<string, !WebInspector.DOMNode>} */
        var inheritedPropertyToNode = new Map();
        /** @type {!Set<string>} */
        var allUsedProperties = new Set();
        for (var i = 0; i < styles.length; ++i) {
            var style = styles[i];
            if (!this.hasMatchingSelectors(style))
                continue;

            /** @type {!Map<string, !WebInspector.CSSProperty>} */
            var styleActiveProperties = new Map();
            var allProperties = style.allProperties;
            for (var j = 0; j < allProperties.length; ++j) {
                var property = allProperties[j];

                // Do not pick non-inherited properties from inherited styles.
                var inherited = this.isInherited(style);
                if (inherited && !WebInspector.CSSMetadata.isPropertyInherited(property.name))
                    continue;

                if (!property.activeInStyle()) {
                    result.set(property, WebInspector.CSSStyleModel.MatchedStyleResult.PropertyState.Overloaded);
                    continue;
                }

                var canonicalName = WebInspector.CSSMetadata.canonicalPropertyName(property.name);
                if (foundImportantProperties.has(canonicalName)) {
                    result.set(property, WebInspector.CSSStyleModel.MatchedStyleResult.PropertyState.Overloaded);
                    continue;
                }

                if (!property.important && allUsedProperties.has(canonicalName)) {
                    result.set(property, WebInspector.CSSStyleModel.MatchedStyleResult.PropertyState.Overloaded);
                    continue;
                }

                var isKnownProperty = propertyToEffectiveRule.has(canonicalName);
                var inheritedFromNode = inherited ? this.nodeForStyle(style) : null;
                if (!isKnownProperty && inheritedFromNode && !inheritedPropertyToNode.has(canonicalName))
                    inheritedPropertyToNode.set(canonicalName, inheritedFromNode);

                if (property.important) {
                    if (inherited && isKnownProperty && inheritedFromNode !== inheritedPropertyToNode.get(canonicalName)) {
                        result.set(property, WebInspector.CSSStyleModel.MatchedStyleResult.PropertyState.Overloaded);
                        continue;
                    }

                    foundImportantProperties.add(canonicalName);
                    if (isKnownProperty) {
                        var overloaded = /** @type {!WebInspector.CSSProperty} */(propertyToEffectiveRule.get(canonicalName).get(canonicalName));
                        result.set(overloaded, WebInspector.CSSStyleModel.MatchedStyleResult.PropertyState.Overloaded);
                        propertyToEffectiveRule.get(canonicalName).delete(canonicalName);
                    }
                }

                styleActiveProperties.set(canonicalName, property);
                allUsedProperties.add(canonicalName);
                propertyToEffectiveRule.set(canonicalName, styleActiveProperties);
                result.set(property, WebInspector.CSSStyleModel.MatchedStyleResult.PropertyState.Active);
            }

            // If every longhand of the shorthand is not active, then the shorthand is not active too.
            for (var property of style.leadingProperties()) {
                var canonicalName = WebInspector.CSSMetadata.canonicalPropertyName(property.name);
                if (!styleActiveProperties.has(canonicalName))
                    continue;
                var longhands = style.longhandProperties(property.name);
                if (!longhands.length)
                    continue;
                var notUsed = true;
                for (var longhand of longhands) {
                    var longhandCanonicalName = WebInspector.CSSMetadata.canonicalPropertyName(longhand.name);
                    notUsed = notUsed && !styleActiveProperties.has(longhandCanonicalName);
                }
                if (!notUsed)
                    continue;
                styleActiveProperties.delete(canonicalName);
                allUsedProperties.delete(canonicalName);
                result.set(property, WebInspector.CSSStyleModel.MatchedStyleResult.PropertyState.Overloaded);
            }
        }
    }
}

/** @enum {string} */
WebInspector.CSSStyleModel.MatchedStyleResult.PropertyState = {
    Active: "Active",
    Overloaded: "Overloaded"
}

/**
 * @constructor
 * @param {?WebInspector.CSSStyleDeclaration} inlineStyle
 * @param {?WebInspector.CSSStyleDeclaration} attributesStyle
 */
WebInspector.CSSStyleModel.InlineStyleResult = function(inlineStyle, attributesStyle)
{
    this.inlineStyle = inlineStyle;
    this.attributesStyle = attributesStyle;
}

;/* DOMModel.js */
/*
 * Copyright (C) 2009, 2010 Google Inc. All rights reserved.
 * Copyright (C) 2009 Joseph Pecoraro
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!WebInspector.DOMModel} domModel
 * @param {?WebInspector.DOMDocument} doc
 * @param {boolean} isInShadowTree
 * @param {!DOMAgent.Node} payload
 */
WebInspector.DOMNode = function(domModel, doc, isInShadowTree, payload)
{
    WebInspector.SDKObject.call(this, domModel.target());
    this._domModel = domModel;
    this._agent = domModel._agent;
    this.ownerDocument = doc;
    this._isInShadowTree = isInShadowTree;

    this.id = payload.nodeId;
    domModel._idToDOMNode[this.id] = this;
    this._nodeType = payload.nodeType;
    this._nodeName = payload.nodeName;
    this._localName = payload.localName;
    this._nodeValue = payload.nodeValue;
    this._pseudoType = payload.pseudoType;
    this._shadowRootType = payload.shadowRootType;
    this._frameId = payload.frameId || null;
    this._xmlVersion = payload.xmlVersion;

    this._shadowRoots = [];

    this._attributes = [];
    this._attributesMap = {};
    if (payload.attributes)
        this._setAttributesPayload(payload.attributes);

    this._markers = {};
    this._subtreeMarkerCount = 0;

    this._childNodeCount = payload.childNodeCount || 0;
    this._children = null;

    this.nextSibling = null;
    this.previousSibling = null;
    this.firstChild = null;
    this.lastChild = null;
    this.parentNode = null;

    if (payload.shadowRoots) {
        for (var i = 0; i < payload.shadowRoots.length; ++i) {
            var root = payload.shadowRoots[i];
            var node = new WebInspector.DOMNode(this._domModel, this.ownerDocument, true, root);
            this._shadowRoots.push(node);
            node.parentNode = this;
        }
    }

    if (payload.templateContent) {
        this._templateContent = new WebInspector.DOMNode(this._domModel, this.ownerDocument, true, payload.templateContent);
        this._templateContent.parentNode = this;
    }

    if (payload.importedDocument) {
        this._importedDocument = new WebInspector.DOMNode(this._domModel, this.ownerDocument, true, payload.importedDocument);
        this._importedDocument.parentNode = this;
    }

    if (payload.distributedNodes)
        this._setDistributedNodePayloads(payload.distributedNodes);

    if (payload.children)
        this._setChildrenPayload(payload.children);

    this._setPseudoElements(payload.pseudoElements);

    if (payload.contentDocument) {
        this._contentDocument = new WebInspector.DOMDocument(domModel, payload.contentDocument);
        this._children = [this._contentDocument];
        this._renumber();
    }

    if (this._nodeType === Node.ELEMENT_NODE) {
        // HTML and BODY from internal iframes should not overwrite top-level ones.
        if (this.ownerDocument && !this.ownerDocument.documentElement && this._nodeName === "HTML")
            this.ownerDocument.documentElement = this;
        if (this.ownerDocument && !this.ownerDocument.body && this._nodeName === "BODY")
            this.ownerDocument.body = this;
    } else if (this._nodeType === Node.DOCUMENT_TYPE_NODE) {
        this.publicId = payload.publicId;
        this.systemId = payload.systemId;
        this.internalSubset = payload.internalSubset;
    } else if (this._nodeType === Node.ATTRIBUTE_NODE) {
        this.name = payload.name;
        this.value = payload.value;
    }
}

/**
 * @enum {string}
 */
WebInspector.DOMNode.PseudoElementNames = {
    Before: "before",
    After: "after"
}

/**
 * @enum {string}
 */
WebInspector.DOMNode.ShadowRootTypes = {
    UserAgent: "user-agent",
    Open: "open",
    Closed: "closed"
}

WebInspector.DOMNode.prototype = {
    /**
     * @return {!WebInspector.DOMModel}
     */
    domModel: function()
    {
        return this._domModel;
    },

    /**
     * @return {?Array.<!WebInspector.DOMNode>}
     */
    children: function()
    {
        return this._children ? this._children.slice() : null;
    },

    /**
     * @return {boolean}
     */
    hasAttributes: function()
    {
        return this._attributes.length > 0;
    },

    /**
     * @return {number}
     */
    childNodeCount: function()
    {
        return this._childNodeCount;
    },

    /**
     * @return {boolean}
     */
    hasShadowRoots: function()
    {
        return !!this._shadowRoots.length;
    },

    /**
     * @return {!Array.<!WebInspector.DOMNode>}
     */
    shadowRoots: function()
    {
        return this._shadowRoots.slice();
    },

    /**
     * @return {?WebInspector.DOMNode}
     */
    templateContent: function()
    {
        return this._templateContent || null;
    },

    /**
     * @return {?WebInspector.DOMNode}
     */
    importedDocument: function()
    {
        return this._importedDocument || null;
    },

    /**
     * @return {number}
     */
    nodeType: function()
    {
        return this._nodeType;
    },

    /**
     * @return {string}
     */
    nodeName: function()
    {
        return this._nodeName;
    },

    /**
     * @return {string|undefined}
     */
    pseudoType: function()
    {
        return this._pseudoType;
    },

    /**
     * @return {boolean}
     */
    hasPseudoElements: function()
    {
        return this._pseudoElements.size > 0;
    },

    /**
     * @return {!Map<string, !WebInspector.DOMNode>}
     */
    pseudoElements: function()
    {
        return this._pseudoElements;
    },

    /**
     * @return {?WebInspector.DOMNode}
     */
    beforePseudoElement: function()
    {
        if (!this._pseudoElements)
            return null;
        return this._pseudoElements.get(WebInspector.DOMNode.PseudoElementNames.Before);
    },

    /**
     * @return {?WebInspector.DOMNode}
     */
    afterPseudoElement: function()
    {
        if (!this._pseudoElements)
            return null;
        return this._pseudoElements.get(WebInspector.DOMNode.PseudoElementNames.After);
    },

    /**
     * @return {boolean}
     */
    isInsertionPoint: function()
    {
        return !this.isXMLNode() && (this._nodeName === "SHADOW" || this._nodeName === "CONTENT");
    },

    /**
     * @return {!Array.<!WebInspector.DOMNodeShortcut>}
     */
    distributedNodes: function()
    {
        return this._distributedNodes || [];
    },

    /**
     * @return {boolean}
     */
    isInShadowTree: function()
    {
        return this._isInShadowTree;
    },

    /**
     * @return {?WebInspector.DOMNode}
     */
    ancestorShadowHost: function()
    {
        var ancestorShadowRoot = this.ancestorShadowRoot();
        return ancestorShadowRoot ? ancestorShadowRoot.parentNode : null;
    },

    /**
     * @return {?WebInspector.DOMNode}
     */
    ancestorShadowRoot: function()
    {
        if (!this._isInShadowTree)
            return null;

        var current = this;
        while (current && !current.isShadowRoot())
            current = current.parentNode;
        return current;
    },

    /**
     * @return {?WebInspector.DOMNode}
     */
    ancestorUserAgentShadowRoot: function()
    {
        var ancestorShadowRoot = this.ancestorShadowRoot();
        if (!ancestorShadowRoot)
            return null;
        return ancestorShadowRoot.shadowRootType() === WebInspector.DOMNode.ShadowRootTypes.UserAgent ? ancestorShadowRoot : null;
    },

    /**
     * @return {boolean}
     */
    isShadowRoot: function()
    {
        return !!this._shadowRootType;
    },

    /**
     * @return {?string}
     */
    shadowRootType: function()
    {
        return this._shadowRootType || null;
    },

    /**
     * @return {string}
     */
    nodeNameInCorrectCase: function()
    {
        var shadowRootType = this.shadowRootType();
        if (shadowRootType)
            return "#shadow-root (" + shadowRootType + ")";
        return this.isXMLNode() ? this.nodeName() : this.nodeName().toLowerCase();
    },

    /**
     * @param {string} name
     * @param {function(?Protocol.Error, number)=} callback
     */
    setNodeName: function(name, callback)
    {
        this._agent.setNodeName(this.id, name, this._domModel._markRevision(this, callback));
    },

    /**
     * @return {string}
     */
    localName: function()
    {
        return this._localName;
    },

    /**
     * @return {string}
     */
    nodeValue: function()
    {
        return this._nodeValue;
    },

    /**
     * @param {string} value
     * @param {function(?Protocol.Error)=} callback
     */
    setNodeValue: function(value, callback)
    {
        this._agent.setNodeValue(this.id, value, this._domModel._markRevision(this, callback));
    },

    /**
     * @param {string} name
     * @return {string}
     */
    getAttribute: function(name)
    {
        var attr = this._attributesMap[name];
        return attr ? attr.value : undefined;
    },

    /**
     * @param {string} name
     * @param {string} text
     * @param {function(?Protocol.Error)=} callback
     */
    setAttribute: function(name, text, callback)
    {
        this._agent.setAttributesAsText(this.id, text, name, this._domModel._markRevision(this, callback));
    },

    /**
     * @param {string} name
     * @param {string} value
     * @param {function(?Protocol.Error)=} callback
     */
    setAttributeValue: function(name, value, callback)
    {
        this._agent.setAttributeValue(this.id, name, value, this._domModel._markRevision(this, callback));
    },

    /**
     * @return {!Object}
     */
    attributes: function()
    {
        return this._attributes;
    },

    /**
     * @param {string} name
     * @param {function(?Protocol.Error)=} callback
     */
    removeAttribute: function(name, callback)
    {
        /**
         * @param {?Protocol.Error} error
         * @this {WebInspector.DOMNode}
         */
        function mycallback(error)
        {
            if (!error) {
                delete this._attributesMap[name];
                for (var i = 0;  i < this._attributes.length; ++i) {
                    if (this._attributes[i].name === name) {
                        this._attributes.splice(i, 1);
                        break;
                    }
                }
            }

            this._domModel._markRevision(this, callback)(error);
        }
        this._agent.removeAttribute(this.id, name, mycallback.bind(this));
    },

    /**
     * @param {function(?Array.<!WebInspector.DOMNode>)=} callback
     */
    getChildNodes: function(callback)
    {
        if (this._children) {
            if (callback)
                callback(this.children());
            return;
        }

        /**
         * @this {WebInspector.DOMNode}
         * @param {?Protocol.Error} error
         */
        function mycallback(error)
        {
            if (callback)
                callback(error ? null : this.children());
        }

        this._agent.requestChildNodes(this.id, undefined, mycallback.bind(this));
    },

    /**
     * @param {number} depth
     * @param {function(?Array.<!WebInspector.DOMNode>)=} callback
     */
    getSubtree: function(depth, callback)
    {
        /**
         * @this {WebInspector.DOMNode}
         * @param {?Protocol.Error} error
         */
        function mycallback(error)
        {
            if (callback)
                callback(error ? null : this._children);
        }

        this._agent.requestChildNodes(this.id, depth, mycallback.bind(this));
    },

    /**
     * @param {function(?Protocol.Error, string)=} callback
     */
    getOuterHTML: function(callback)
    {
        this._agent.getOuterHTML(this.id, callback);
    },

    /**
     * @param {string} html
     * @param {function(?Protocol.Error)=} callback
     */
    setOuterHTML: function(html, callback)
    {
        this._agent.setOuterHTML(this.id, html, this._domModel._markRevision(this, callback));
    },

    /**
     * @param {function(?Protocol.Error, !DOMAgent.NodeId=)=} callback
     */
    removeNode: function(callback)
    {
        this._agent.removeNode(this.id, this._domModel._markRevision(this, callback));
    },

    /**
     * @param {function(?string)=} callback
     */
    copyNode: function(callback)
    {
        function copy(error, text)
        {
            if (!error)
                InspectorFrontendHost.copyText(text);
            if (callback)
                callback(error ? null : text);
        }
        this._agent.getOuterHTML(this.id, copy);
    },

    /**
     * @return {string}
     */
    path: function()
    {
        /**
         * @param {?WebInspector.DOMNode} node
         */
        function canPush(node)
        {
            return node && ("index" in node || (node.isShadowRoot() && node.parentNode)) && node._nodeName.length;
        }

        var path = [];
        var node = this;
        while (canPush(node)) {
            var index = typeof node.index === "number" ? node.index : (node.shadowRootType() === WebInspector.DOMNode.ShadowRootTypes.UserAgent ? "u" : "a");
            path.push([index, node._nodeName]);
            node = node.parentNode;
        }
        path.reverse();
        return path.join(",");
    },

    /**
     * @param {!WebInspector.DOMNode} node
     * @return {boolean}
     */
    isAncestor: function(node)
    {
        if (!node)
            return false;

        var currentNode = node.parentNode;
        while (currentNode) {
            if (this === currentNode)
                return true;
            currentNode = currentNode.parentNode;
        }
        return false;
    },

    /**
     * @param {!WebInspector.DOMNode} descendant
     * @return {boolean}
     */
    isDescendant: function(descendant)
    {
        return descendant !== null && descendant.isAncestor(this);
    },

    /**
     * @return {?PageAgent.FrameId}
     */
    frameId: function()
    {
        var node = this;
        while (!node._frameId && node.parentNode)
            node = node.parentNode;
        return node._frameId;
    },

    /**
     * @param {!Array.<string>} attrs
     * @return {boolean}
     */
    _setAttributesPayload: function(attrs)
    {
        var attributesChanged = !this._attributes || attrs.length !== this._attributes.length * 2;
        var oldAttributesMap = this._attributesMap || {};

        this._attributes = [];
        this._attributesMap = {};

        for (var i = 0; i < attrs.length; i += 2) {
            var name = attrs[i];
            var value = attrs[i + 1];
            this._addAttribute(name, value);

            if (attributesChanged)
                continue;

            if (!oldAttributesMap[name] || oldAttributesMap[name].value !== value)
              attributesChanged = true;
        }
        return attributesChanged;
    },

    /**
     * @param {!WebInspector.DOMNode} prev
     * @param {!DOMAgent.Node} payload
     * @return {!WebInspector.DOMNode}
     */
    _insertChild: function(prev, payload)
    {
        var node = new WebInspector.DOMNode(this._domModel, this.ownerDocument, this._isInShadowTree, payload);
        this._children.splice(this._children.indexOf(prev) + 1, 0, node);
        this._renumber();
        return node;
    },

    /**
     * @param {!WebInspector.DOMNode} node
     */
    _removeChild: function(node)
    {
        if (node.pseudoType()) {
            this._pseudoElements.delete(node.pseudoType());
        } else {
            var shadowRootIndex = this._shadowRoots.indexOf(node);
            if (shadowRootIndex !== -1) {
                this._shadowRoots.splice(shadowRootIndex, 1);
            } else {
                console.assert(this._children.indexOf(node) !== -1);
                this._children.splice(this._children.indexOf(node), 1);
            }
        }
        node.parentNode = null;
        this._subtreeMarkerCount -= node._subtreeMarkerCount;
        if (node._subtreeMarkerCount)
            this._domModel.dispatchEventToListeners(WebInspector.DOMModel.Events.MarkersChanged, this);
        this._renumber();
    },

    /**
     * @param {!Array.<!DOMAgent.Node>} payloads
     */
    _setChildrenPayload: function(payloads)
    {
        // We set children in the constructor.
        if (this._contentDocument)
            return;

        this._children = [];
        for (var i = 0; i < payloads.length; ++i) {
            var payload = payloads[i];
            var node = new WebInspector.DOMNode(this._domModel, this.ownerDocument, this._isInShadowTree, payload);
            this._children.push(node);
        }
        this._renumber();
    },

    /**
     * @param {!Array.<!DOMAgent.Node>|undefined} payloads
     */
    _setPseudoElements: function(payloads)
    {
        this._pseudoElements = new Map();
        if (!payloads)
            return;

        for (var i = 0; i < payloads.length; ++i) {
            var node = new WebInspector.DOMNode(this._domModel, this.ownerDocument, this._isInShadowTree, payloads[i]);
            node.parentNode = this;
            this._pseudoElements.set(node.pseudoType(), node);
        }
    },

    /**
     * @param {!Array.<!DOMAgent.BackendNode>} payloads
     */
    _setDistributedNodePayloads: function(payloads)
    {
        this._distributedNodes = [];
        for (var payload of payloads)
            this._distributedNodes.push(new WebInspector.DOMNodeShortcut(this._domModel.target(), payload.backendNodeId, payload.nodeType, payload.nodeName));
    },

    _renumber: function()
    {
        this._childNodeCount = this._children.length;
        if (this._childNodeCount == 0) {
            this.firstChild = null;
            this.lastChild = null;
            return;
        }
        this.firstChild = this._children[0];
        this.lastChild = this._children[this._childNodeCount - 1];
        for (var i = 0; i < this._childNodeCount; ++i) {
            var child = this._children[i];
            child.index = i;
            child.nextSibling = i + 1 < this._childNodeCount ? this._children[i + 1] : null;
            child.previousSibling = i - 1 >= 0 ? this._children[i - 1] : null;
            child.parentNode = this;
        }
    },

    /**
     * @param {string} name
     * @param {string} value
     */
    _addAttribute: function(name, value)
    {
        var attr = {
            name: name,
            value: value,
            _node: this
        };
        this._attributesMap[name] = attr;
        this._attributes.push(attr);
    },

    /**
     * @param {string} name
     * @param {string} value
     */
    _setAttribute: function(name, value)
    {
        var attr = this._attributesMap[name];
        if (attr)
            attr.value = value;
        else
            this._addAttribute(name, value);
    },

    /**
     * @param {string} name
     */
    _removeAttribute: function(name)
    {
        var attr = this._attributesMap[name];
        if (attr) {
            this._attributes.remove(attr);
            delete this._attributesMap[name];
        }
    },

    /**
     * @param {!WebInspector.DOMNode} targetNode
     * @param {?WebInspector.DOMNode} anchorNode
     * @param {function(?Protocol.Error, !DOMAgent.NodeId=)=} callback
     */
    copyTo: function(targetNode, anchorNode, callback)
    {
        this._agent.copyTo(this.id, targetNode.id, anchorNode ? anchorNode.id : undefined, this._domModel._markRevision(this, callback));
    },

    /**
     * @param {!WebInspector.DOMNode} targetNode
     * @param {?WebInspector.DOMNode} anchorNode
     * @param {function(?Protocol.Error, !DOMAgent.NodeId=)=} callback
     */
    moveTo: function(targetNode, anchorNode, callback)
    {
        this._agent.moveTo(this.id, targetNode.id, anchorNode ? anchorNode.id : undefined, this._domModel._markRevision(this, callback));
    },

    /**
     * @return {boolean}
     */
    isXMLNode: function()
    {
        return !!this._xmlVersion;
    },

    /**
     * @param {string} name
     * @param {?*} value
     */
    setMarker: function(name, value)
    {
        if (value === null) {
            if (!this._markers.hasOwnProperty(name))
                return;

            delete this._markers[name];
            for (var node = this; node; node = node.parentNode)
                --node._subtreeMarkerCount;
            for (var node = this; node; node = node.parentNode)
                this._domModel.dispatchEventToListeners(WebInspector.DOMModel.Events.MarkersChanged, node);
            return;
        }

        if (this.parentNode && !this._markers.hasOwnProperty(name)) {
            for (var node = this; node; node = node.parentNode)
                ++node._subtreeMarkerCount;
        }
        this._markers[name] = value;
        for (var node = this; node; node = node.parentNode)
            this._domModel.dispatchEventToListeners(WebInspector.DOMModel.Events.MarkersChanged, node);
    },

    /**
     * @param {string} name
     * @return {?T}
     * @template T
     */
    marker: function(name)
    {
        return this._markers[name] || null;
    },

    /**
     * @return {!Array<string>}
     */
    markers: function()
    {
        return Object.values(this._markers);
    },

    /**
     * @param {function(!WebInspector.DOMNode, string)} visitor
     */
    traverseMarkers: function(visitor)
    {
        /**
         * @param {!WebInspector.DOMNode} node
         */
        function traverse(node)
        {
            if (!node._subtreeMarkerCount)
                return;
            for (var marker in node._markers)
                visitor(node, marker);
            if (!node._children)
                return;
            for (var child of node._children)
                traverse(child);
        }
        traverse(this);
    },

    /**
     * @param {string} url
     * @return {?string}
     */
    resolveURL: function(url)
    {
        if (!url)
            return url;
        for (var frameOwnerCandidate = this; frameOwnerCandidate; frameOwnerCandidate = frameOwnerCandidate.parentNode) {
            if (frameOwnerCandidate.baseURL)
                return WebInspector.ParsedURL.completeURL(frameOwnerCandidate.baseURL, url);
        }
        return null;
    },

    /**
     * @param {string=} mode
     * @param {!RuntimeAgent.RemoteObjectId=} objectId
     */
    highlight: function(mode, objectId)
    {
        this._domModel.highlightDOMNode(this.id, mode, undefined, objectId);
    },

    highlightForTwoSeconds: function()
    {
        this._domModel.highlightDOMNodeForTwoSeconds(this.id);
    },

    /**
     * @param {string=} objectGroup
     * @param {function(?WebInspector.RemoteObject)=} callback
     */
    resolveToObject: function(objectGroup, callback)
    {
        this._agent.resolveNode(this.id, objectGroup, mycallback.bind(this));

        /**
         * @param {?Protocol.Error} error
         * @param {!RuntimeAgent.RemoteObject} object
         * @this {WebInspector.DOMNode}
         */
        function mycallback(error, object)
        {
            if (!callback)
                return;

            if (error || !object)
                callback(null);
            else
                callback(this.target().runtimeModel.createRemoteObject(object));
        }
    },

    /**
     * @param {string=} objectGroup
     * @return {!Promise<!WebInspector.RemoteObject>}
     */
    resolveToObjectPromise: function(objectGroup)
    {
        return new Promise(resolveToObject.bind(this));
        /**
         * @param {function(?)} fulfill
         * @param {function(*)} reject
         * @this {WebInspector.DOMNode}
         */
        function resolveToObject(fulfill, reject)
        {
            this.resolveToObject(objectGroup, mycallback);
            function mycallback(object)
            {
                if (object)
                    fulfill(object)
                else
                    reject(null);
            }
        }
    },

    /**
     * @param {function(?DOMAgent.BoxModel)} callback
     */
    boxModel: function(callback)
    {
        this._agent.getBoxModel(this.id, this._domModel._wrapClientCallback(callback));
    },

    setAsInspectedNode: function()
    {
        var node = this;
        while (true) {
            var ancestor = node.ancestorUserAgentShadowRoot();
            if (!ancestor)
                break;
            ancestor = node.ancestorShadowHost();
            if (!ancestor)
                break
            // User agent shadow root, keep climbing up.
            node = ancestor;
        }
        this._agent.setInspectedNode(node.id);
    },

    __proto__: WebInspector.SDKObject.prototype
}

/**
 * @param {!WebInspector.Target} target
 * @param {number} backendNodeId
 * @constructor
 */
WebInspector.DeferredDOMNode = function(target, backendNodeId)
{
    this._domModel = WebInspector.DOMModel.fromTarget(target);
    this._backendNodeId = backendNodeId;
}

WebInspector.DeferredDOMNode.prototype = {
    /**
     * @param {function(?WebInspector.DOMNode)} callback
     */
    resolve: function(callback)
    {
        if (!this._domModel) {
            callback(null);
            return;
        }

        this._domModel.pushNodesByBackendIdsToFrontend(new Set([this._backendNodeId]), onGotNode.bind(this));

        /**
         * @param {?Map<number, ?WebInspector.DOMNode>} nodeIds
         * @this {WebInspector.DeferredDOMNode}
         */
        function onGotNode(nodeIds)
        {
            callback(nodeIds && (nodeIds.get(this._backendNodeId) || null));
        }
    },

    /**
     * @return {!Promise.<!WebInspector.DOMNode>}
     */
    resolvePromise: function()
    {
        /**
         * @param {function(?)} fulfill
         * @param {function(*)} reject
         * @this {WebInspector.DeferredDOMNode}
         */
        function resolveNode(fulfill, reject)
        {
            /**
             * @param {?WebInspector.DOMNode} node
             */
            function mycallback(node)
            {
                fulfill(node)
            }
            this.resolve(mycallback);
        }
        return new Promise(resolveNode.bind(this));
    },

    /**
     * @return {number}
     */
    backendNodeId: function()
    {
        return this._backendNodeId;
    },

    highlight: function()
    {
        if (this._domModel)
            this._domModel.highlightDOMNode(undefined, undefined, this._backendNodeId);
    }
}

/**
 * @constructor
 * @param {!WebInspector.Target} target
 * @param {number} backendNodeId
 * @param {number} nodeType
 * @param {string} nodeName
 */
WebInspector.DOMNodeShortcut = function(target, backendNodeId, nodeType, nodeName)
{
    this.nodeType = nodeType;
    this.nodeName = nodeName;
    this.deferredNode = new WebInspector.DeferredDOMNode(target, backendNodeId);
}

/**
 * @extends {WebInspector.DOMNode}
 * @constructor
 * @param {!WebInspector.DOMModel} domModel
 * @param {!DOMAgent.Node} payload
 */
WebInspector.DOMDocument = function(domModel, payload)
{
    WebInspector.DOMNode.call(this, domModel, this, false, payload);
    this.documentURL = payload.documentURL || "";
    this.baseURL = payload.baseURL || "";
    this._listeners = {};
}

WebInspector.DOMDocument.prototype = {
    __proto__: WebInspector.DOMNode.prototype
}

/**
 * @constructor
 * @extends {WebInspector.SDKModel}
 * @param {!WebInspector.Target} target
 */
WebInspector.DOMModel = function(target) {
    WebInspector.SDKModel.call(this, WebInspector.DOMModel, target);

    this._agent = target.domAgent();

    /** @type {!Object.<number, !WebInspector.DOMNode>} */
    this._idToDOMNode = {};
    /** @type {?WebInspector.DOMDocument} */
    this._document = null;
    /** @type {!Object.<number, boolean>} */
    this._attributeLoadNodeIds = {};
    target.registerDOMDispatcher(new WebInspector.DOMDispatcher(this));

    this._inspectModeEnabled = false;

    this._defaultHighlighter = new WebInspector.DefaultDOMNodeHighlighter(this._agent);
    this._highlighter = this._defaultHighlighter;

    this._agent.enable();
}

WebInspector.DOMModel.Events = {
    AttrModified: "AttrModified",
    AttrRemoved: "AttrRemoved",
    CharacterDataModified: "CharacterDataModified",
    DOMMutated: "DOMMutated",
    NodeInserted: "NodeInserted",
    NodeInspected: "NodeInspected",
    NodeHighlightedInOverlay: "NodeHighlightedInOverlay",
    NodeRemoved: "NodeRemoved",
    DocumentUpdated: "DocumentUpdated",
    ChildNodeCountUpdated: "ChildNodeCountUpdated",
    UndoRedoRequested: "UndoRedoRequested",
    UndoRedoCompleted: "UndoRedoCompleted",
    DistributedNodesChanged: "DistributedNodesChanged",
    ModelSuspended: "ModelSuspended",
    InspectModeWillBeToggled: "InspectModeWillBeToggled",
    MarkersChanged: "MarkersChanged"
}


/**
 * @param {!WebInspector.RemoteObject} object
 */
WebInspector.DOMModel.highlightObjectAsDOMNode = function(object)
{
    var domModel = WebInspector.DOMModel.fromTarget(object.target());
    if (domModel)
        domModel.highlightDOMNode(undefined, undefined, undefined, object.objectId);
}

/**
 * @return {!Array<!WebInspector.DOMModel>}
 */
WebInspector.DOMModel.instances = function()
{
    var result = [];
    for (var target of WebInspector.targetManager.targets()) {
        var domModel = WebInspector.DOMModel.fromTarget(target);
        if (domModel)
            result.push(domModel);
    }
    return result;
}

WebInspector.DOMModel.hideDOMNodeHighlight = function()
{
    for (var domModel of WebInspector.DOMModel.instances())
        domModel.highlightDOMNode(0);
}

WebInspector.DOMModel.cancelSearch = function()
{
    for (var domModel of WebInspector.DOMModel.instances())
        domModel._cancelSearch();
}

WebInspector.DOMModel.prototype = {
    /**
     * @param {!WebInspector.DOMNode} node
     */
    _scheduleMutationEvent: function(node)
    {
        if (!this.hasEventListeners(WebInspector.DOMModel.Events.DOMMutated))
            return;

        this._lastMutationId = (this._lastMutationId || 0) + 1;
        Promise.resolve().then(callObserve.bind(this, node, this._lastMutationId));

        /**
         * @this {WebInspector.DOMModel}
         * @param {!WebInspector.DOMNode} node
         * @param {number} mutationId
         */
        function callObserve(node, mutationId)
        {
            if (!this.hasEventListeners(WebInspector.DOMModel.Events.DOMMutated) || this._lastMutationId !== mutationId)
                return;

            this.dispatchEventToListeners(WebInspector.DOMModel.Events.DOMMutated, node);
        }
    },

    /**
     * @param {function(!WebInspector.DOMDocument)=} callback
     */
    requestDocument: function(callback)
    {
        if (this._document) {
            if (callback)
                callback(this._document);
            return;
        }

        if (this._pendingDocumentRequestCallbacks) {
            this._pendingDocumentRequestCallbacks.push(callback);
            return;
        }

        this._pendingDocumentRequestCallbacks = [callback];

        /**
         * @this {WebInspector.DOMModel}
         * @param {?Protocol.Error} error
         * @param {!DOMAgent.Node} root
         */
        function onDocumentAvailable(error, root)
        {
            if (!error)
                this._setDocument(root);

            for (var i = 0; i < this._pendingDocumentRequestCallbacks.length; ++i) {
                var callback = this._pendingDocumentRequestCallbacks[i];
                if (callback)
                    callback(this._document);
            }
            delete this._pendingDocumentRequestCallbacks;
        }

        this._agent.getDocument(onDocumentAvailable.bind(this));
    },

    /**
     * @return {?WebInspector.DOMDocument}
     */
    existingDocument: function()
    {
        return this._document;
    },

    /**
     * @param {!RuntimeAgent.RemoteObjectId} objectId
     * @param {function(?WebInspector.DOMNode)=} callback
     */
    pushNodeToFrontend: function(objectId, callback)
    {
        /**
         * @param {?DOMAgent.NodeId} nodeId
         * @this {!WebInspector.DOMModel}
         */
        function mycallback(nodeId)
        {
            callback(nodeId ? this.nodeForId(nodeId) : null);
        }
        this._dispatchWhenDocumentAvailable(this._agent.requestNode.bind(this._agent, objectId), mycallback.bind(this));
    },

    /**
     * @param {string} path
     * @param {function(?number)=} callback
     */
    pushNodeByPathToFrontend: function(path, callback)
    {
        this._dispatchWhenDocumentAvailable(this._agent.pushNodeByPathToFrontend.bind(this._agent, path), callback);
    },

    /**
     * @param {!Set<number>} backendNodeIds
     * @param {function(?Map<number, ?WebInspector.DOMNode>)} callback
     */
    pushNodesByBackendIdsToFrontend: function(backendNodeIds, callback)
    {
        var backendNodeIdsArray = Array.from(backendNodeIds.values());
        /**
         * @param {?Array<!DOMAgent.NodeId>} nodeIds
         * @this {!WebInspector.DOMModel}
         */
        function mycallback(nodeIds)
        {
            if (!nodeIds) {
                callback(null);
                return;
            }
            /** @type {!Map<number, ?WebInspector.DOMNode>} */
            var map = new Map();
            for (var i = 0; i < nodeIds.length; ++i) {
                if (nodeIds[i])
                    map.set(backendNodeIdsArray[i], this.nodeForId(nodeIds[i]));
            }
            callback(map);
        }
        this._dispatchWhenDocumentAvailable(this._agent.pushNodesByBackendIdsToFrontend.bind(this._agent, backendNodeIdsArray), mycallback.bind(this));
    },

    /**
     * @param {function(!T)=} callback
     * @return {function(?Protocol.Error, !T=)|undefined}
     * @template T
     */
    _wrapClientCallback: function(callback)
    {
        if (!callback)
            return;
        /**
         * @param {?Protocol.Error} error
         * @param {!T=} result
         * @template T
         */
        var wrapper = function(error, result)
        {
            // Caller is responsible for handling the actual error.
            callback(error ? null : result);
        };
        return wrapper;
    },

    /**
     * @param {function(function(?Protocol.Error, !T=)=)} func
     * @param {function(!T)=} callback
     * @template T
     */
    _dispatchWhenDocumentAvailable: function(func, callback)
    {
        var callbackWrapper = this._wrapClientCallback(callback);

        /**
         * @this {WebInspector.DOMModel}
         */
        function onDocumentAvailable()
        {
            if (this._document)
                func(callbackWrapper);
            else {
                if (callbackWrapper)
                    callbackWrapper("No document");
            }
        }
        this.requestDocument(onDocumentAvailable.bind(this));
    },

    /**
     * @param {!DOMAgent.NodeId} nodeId
     * @param {string} name
     * @param {string} value
     */
    _attributeModified: function(nodeId, name, value)
    {
        var node = this._idToDOMNode[nodeId];
        if (!node)
            return;

        node._setAttribute(name, value);
        this.dispatchEventToListeners(WebInspector.DOMModel.Events.AttrModified, { node: node, name: name });
        this._scheduleMutationEvent(node);
    },

    /**
     * @param {!DOMAgent.NodeId} nodeId
     * @param {string} name
     */
    _attributeRemoved: function(nodeId, name)
    {
        var node = this._idToDOMNode[nodeId];
        if (!node)
            return;
        node._removeAttribute(name);
        this.dispatchEventToListeners(WebInspector.DOMModel.Events.AttrRemoved, { node: node, name: name });
        this._scheduleMutationEvent(node);
    },

    /**
     * @param {!Array.<!DOMAgent.NodeId>} nodeIds
     */
    _inlineStyleInvalidated: function(nodeIds)
    {
        for (var i = 0; i < nodeIds.length; ++i)
            this._attributeLoadNodeIds[nodeIds[i]] = true;
        if ("_loadNodeAttributesTimeout" in this)
            return;
        this._loadNodeAttributesTimeout = setTimeout(this._loadNodeAttributes.bind(this), 20);
    },

    _loadNodeAttributes: function()
    {
        /**
         * @this {WebInspector.DOMModel}
         * @param {!DOMAgent.NodeId} nodeId
         * @param {?Protocol.Error} error
         * @param {!Array.<string>} attributes
         */
        function callback(nodeId, error, attributes)
        {
            if (error) {
                // We are calling _loadNodeAttributes asynchronously, it is ok if node is not found.
                return;
            }
            var node = this._idToDOMNode[nodeId];
            if (node) {
                if (node._setAttributesPayload(attributes)) {
                    this.dispatchEventToListeners(WebInspector.DOMModel.Events.AttrModified, { node: node, name: "style" });
                    this._scheduleMutationEvent(node);
                }
            }
        }

        delete this._loadNodeAttributesTimeout;

        for (var nodeId in this._attributeLoadNodeIds) {
            var nodeIdAsNumber = parseInt(nodeId, 10);
            this._agent.getAttributes(nodeIdAsNumber, callback.bind(this, nodeIdAsNumber));
        }
        this._attributeLoadNodeIds = {};
    },

    /**
     * @param {!DOMAgent.NodeId} nodeId
     * @param {string} newValue
     */
    _characterDataModified: function(nodeId, newValue)
    {
        var node = this._idToDOMNode[nodeId];
        node._nodeValue = newValue;
        this.dispatchEventToListeners(WebInspector.DOMModel.Events.CharacterDataModified, node);
        this._scheduleMutationEvent(node);
    },

    /**
     * @param {!DOMAgent.NodeId} nodeId
     * @return {?WebInspector.DOMNode}
     */
    nodeForId: function(nodeId)
    {
        return this._idToDOMNode[nodeId] || null;
    },

    _documentUpdated: function()
    {
        this._setDocument(null);
    },

    /**
     * @param {?DOMAgent.Node} payload
     */
    _setDocument: function(payload)
    {
        this._idToDOMNode = {};
        if (payload && "nodeId" in payload)
            this._document = new WebInspector.DOMDocument(this, payload);
        else
            this._document = null;
        this.dispatchEventToListeners(WebInspector.DOMModel.Events.DocumentUpdated, this._document);
    },

    /**
     * @param {!DOMAgent.Node} payload
     */
    _setDetachedRoot: function(payload)
    {
        if (payload.nodeName === "#document")
            new WebInspector.DOMDocument(this, payload);
        else
            new WebInspector.DOMNode(this, null, false, payload);
    },

    /**
     * @param {!DOMAgent.NodeId} parentId
     * @param {!Array.<!DOMAgent.Node>} payloads
     */
    _setChildNodes: function(parentId, payloads)
    {
        if (!parentId && payloads.length) {
            this._setDetachedRoot(payloads[0]);
            return;
        }

        var parent = this._idToDOMNode[parentId];
        parent._setChildrenPayload(payloads);
    },

    /**
     * @param {!DOMAgent.NodeId} nodeId
     * @param {number} newValue
     */
    _childNodeCountUpdated: function(nodeId, newValue)
    {
        var node = this._idToDOMNode[nodeId];
        node._childNodeCount = newValue;
        this.dispatchEventToListeners(WebInspector.DOMModel.Events.ChildNodeCountUpdated, node);
        this._scheduleMutationEvent(node);
    },

    /**
     * @param {!DOMAgent.NodeId} parentId
     * @param {!DOMAgent.NodeId} prevId
     * @param {!DOMAgent.Node} payload
     */
    _childNodeInserted: function(parentId, prevId, payload)
    {
        var parent = this._idToDOMNode[parentId];
        var prev = this._idToDOMNode[prevId];
        var node = parent._insertChild(prev, payload);
        this._idToDOMNode[node.id] = node;
        this.dispatchEventToListeners(WebInspector.DOMModel.Events.NodeInserted, node);
        this._scheduleMutationEvent(node);
    },

    /**
     * @param {!DOMAgent.NodeId} parentId
     * @param {!DOMAgent.NodeId} nodeId
     */
    _childNodeRemoved: function(parentId, nodeId)
    {
        var parent = this._idToDOMNode[parentId];
        var node = this._idToDOMNode[nodeId];
        parent._removeChild(node);
        this._unbind(node);
        this.dispatchEventToListeners(WebInspector.DOMModel.Events.NodeRemoved, {node: node, parent: parent});
        this._scheduleMutationEvent(node);
    },

    /**
     * @param {!DOMAgent.NodeId} hostId
     * @param {!DOMAgent.Node} root
     */
    _shadowRootPushed: function(hostId, root)
    {
        var host = this._idToDOMNode[hostId];
        if (!host)
            return;
        var node = new WebInspector.DOMNode(this, host.ownerDocument, true, root);
        node.parentNode = host;
        this._idToDOMNode[node.id] = node;
        host._shadowRoots.unshift(node);
        this.dispatchEventToListeners(WebInspector.DOMModel.Events.NodeInserted, node);
        this._scheduleMutationEvent(node);
    },

    /**
     * @param {!DOMAgent.NodeId} hostId
     * @param {!DOMAgent.NodeId} rootId
     */
    _shadowRootPopped: function(hostId, rootId)
    {
        var host = this._idToDOMNode[hostId];
        if (!host)
            return;
        var root = this._idToDOMNode[rootId];
        if (!root)
            return;
        host._removeChild(root);
        this._unbind(root);
        this.dispatchEventToListeners(WebInspector.DOMModel.Events.NodeRemoved, {node: root, parent: host});
        this._scheduleMutationEvent(root);
    },

    /**
     * @param {!DOMAgent.NodeId} parentId
     * @param {!DOMAgent.Node} pseudoElement
     */
    _pseudoElementAdded: function(parentId, pseudoElement)
    {
        var parent = this._idToDOMNode[parentId];
        if (!parent)
            return;
        var node = new WebInspector.DOMNode(this, parent.ownerDocument, false, pseudoElement);
        node.parentNode = parent;
        this._idToDOMNode[node.id] = node;
        console.assert(!parent._pseudoElements.get(node.pseudoType()));
        parent._pseudoElements.set(node.pseudoType(), node);
        this.dispatchEventToListeners(WebInspector.DOMModel.Events.NodeInserted, node);
        this._scheduleMutationEvent(node);
    },

    /**
     * @param {!DOMAgent.NodeId} parentId
     * @param {!DOMAgent.NodeId} pseudoElementId
     */
    _pseudoElementRemoved: function(parentId, pseudoElementId)
    {
        var parent = this._idToDOMNode[parentId];
        if (!parent)
            return;
        var pseudoElement = this._idToDOMNode[pseudoElementId];
        if (!pseudoElement)
            return;
        parent._removeChild(pseudoElement);
        this._unbind(pseudoElement);
        this.dispatchEventToListeners(WebInspector.DOMModel.Events.NodeRemoved, {node: pseudoElement, parent: parent});
        this._scheduleMutationEvent(pseudoElement);
    },

    /**
     * @param {!DOMAgent.NodeId} insertionPointId
     * @param {!Array.<!DOMAgent.BackendNode>} distributedNodes
     */
    _distributedNodesUpdated: function(insertionPointId, distributedNodes)
    {
        var insertionPoint = this._idToDOMNode[insertionPointId];
        if (!insertionPoint)
            return;
        insertionPoint._setDistributedNodePayloads(distributedNodes);
        this.dispatchEventToListeners(WebInspector.DOMModel.Events.DistributedNodesChanged, insertionPoint);
        this._scheduleMutationEvent(insertionPoint);
    },

    /**
     * @param {!WebInspector.DOMNode} node
     */
    _unbind: function(node)
    {
        delete this._idToDOMNode[node.id];
        for (var i = 0; node._children && i < node._children.length; ++i)
            this._unbind(node._children[i]);
        for (var i = 0; i < node._shadowRoots.length; ++i)
            this._unbind(node._shadowRoots[i]);
        var pseudoElements = node.pseudoElements();
        for (var value of pseudoElements.values())
            this._unbind(value);
        if (node._templateContent)
            this._unbind(node._templateContent);
    },

    /**
     * @param {!DOMAgent.BackendNodeId} backendNodeId
     */
    _inspectNodeRequested: function(backendNodeId)
    {
        var deferredNode = new WebInspector.DeferredDOMNode(this.target(), backendNodeId);
        this.dispatchEventToListeners(WebInspector.DOMModel.Events.NodeInspected, deferredNode);
    },

    /**
     * @param {string} query
     * @param {boolean} includeUserAgentShadowDOM
     * @param {function(number)} searchCallback
     */
    performSearch: function(query, includeUserAgentShadowDOM, searchCallback)
    {
        WebInspector.DOMModel.cancelSearch();

        /**
         * @param {?Protocol.Error} error
         * @param {string} searchId
         * @param {number} resultsCount
         * @this {WebInspector.DOMModel}
         */
        function callback(error, searchId, resultsCount)
        {
            this._searchId = searchId;
            searchCallback(resultsCount);
        }
        this._agent.performSearch(query, includeUserAgentShadowDOM, callback.bind(this));
    },

    /**
     * @param {string} query
     * @param {boolean} includeUserAgentShadowDOM
     * @return {!Promise.<number>}
     */
    performSearchPromise: function(query, includeUserAgentShadowDOM)
    {
        return new Promise(performSearch.bind(this));

        /**
         * @param {function(number)} resolve
         * @this {WebInspector.DOMModel}
         */
        function performSearch(resolve)
        {
            this._agent.performSearch(query, includeUserAgentShadowDOM, callback.bind(this));

            /**
             * @param {?Protocol.Error} error
             * @param {string} searchId
             * @param {number} resultsCount
             * @this {WebInspector.DOMModel}
             */
            function callback(error, searchId, resultsCount)
            {
                if (!error)
                    this._searchId = searchId;
                resolve(error ? 0 : resultsCount);
            }
        }
    },

    /**
     * @param {number} index
     * @param {?function(?WebInspector.DOMNode)} callback
     */
    searchResult: function(index, callback)
    {
        if (this._searchId)
            this._agent.getSearchResults(this._searchId, index, index + 1, searchResultsCallback.bind(this));
        else
            callback(null);

        /**
         * @param {?Protocol.Error} error
         * @param {!Array.<number>} nodeIds
         * @this {WebInspector.DOMModel}
         */
        function searchResultsCallback(error, nodeIds)
        {
            if (error) {
                console.error(error);
                callback(null);
                return;
            }
            if (nodeIds.length != 1)
                return;

            callback(this.nodeForId(nodeIds[0]));
        }
    },

    _cancelSearch: function()
    {
        if (this._searchId) {
            this._agent.discardSearchResults(this._searchId);
            delete this._searchId;
        }
    },

    /**
     * @param {!DOMAgent.NodeId} nodeId
     * @param {string} selectors
     * @param {function(?DOMAgent.NodeId)=} callback
     */
    querySelector: function(nodeId, selectors, callback)
    {
        this._agent.querySelector(nodeId, selectors, this._wrapClientCallback(callback));
    },

    /**
     * @param {!DOMAgent.NodeId} nodeId
     * @param {string} selectors
     * @param {function(!Array.<!DOMAgent.NodeId>=)=} callback
     */
    querySelectorAll: function(nodeId, selectors, callback)
    {
        this._agent.querySelectorAll(nodeId, selectors, this._wrapClientCallback(callback));
    },

    /**
     * @param {!DOMAgent.NodeId=} nodeId
     * @param {string=} mode
     * @param {!DOMAgent.BackendNodeId=} backendNodeId
     * @param {!RuntimeAgent.RemoteObjectId=} objectId
     */
    highlightDOMNode: function(nodeId, mode, backendNodeId, objectId)
    {
        this.highlightDOMNodeWithConfig(nodeId, { mode: mode }, backendNodeId, objectId);
    },

    /**
     * @param {!DOMAgent.NodeId=} nodeId
     * @param {!{mode: (string|undefined), showInfo: (boolean|undefined), selectors: (string|undefined)}=} config
     * @param {!DOMAgent.BackendNodeId=} backendNodeId
     * @param {!RuntimeAgent.RemoteObjectId=} objectId
     */
    highlightDOMNodeWithConfig: function(nodeId, config, backendNodeId, objectId)
    {
        config = config || { mode: "all", showInfo: undefined, selectors: undefined };
        if (this._hideDOMNodeHighlightTimeout) {
            clearTimeout(this._hideDOMNodeHighlightTimeout);
            delete this._hideDOMNodeHighlightTimeout;
        }
        var highlightConfig = this._buildHighlightConfig(config.mode);
        if (typeof config.showInfo !== "undefined")
            highlightConfig.showInfo = config.showInfo;
        if (typeof config.selectors !== "undefined")
            highlightConfig.selectorList = config.selectors;
        this._highlighter.highlightDOMNode(this.nodeForId(nodeId || 0), highlightConfig, backendNodeId, objectId);
    },

    /**
     * @param {!DOMAgent.NodeId} nodeId
     */
    highlightDOMNodeForTwoSeconds: function(nodeId)
    {
        this.highlightDOMNode(nodeId);
        this._hideDOMNodeHighlightTimeout = setTimeout(WebInspector.DOMModel.hideDOMNodeHighlight.bind(WebInspector.DOMModel), 2000);
    },

    /**
     * @param {!PageAgent.FrameId} frameId
     */
    highlightFrame: function(frameId)
    {
        this._highlighter.highlightFrame(frameId);
    },

    /**
     * @param {!DOMAgent.InspectMode} mode
     * @param {function(?Protocol.Error)=} callback
     */
    setInspectMode: function(mode, callback)
    {
        /**
         * @this {WebInspector.DOMModel}
         */
        function onDocumentAvailable()
        {
            this._inspectModeEnabled = mode !== DOMAgent.InspectMode.None;
            this.dispatchEventToListeners(WebInspector.DOMModel.Events.InspectModeWillBeToggled, this._inspectModeEnabled);
            this._highlighter.setInspectMode(mode, this._buildHighlightConfig(), callback);
        }
        this.requestDocument(onDocumentAvailable.bind(this));
    },

    /**
     * @return {boolean}
     */
    inspectModeEnabled: function()
    {
        return this._inspectModeEnabled;
    },

    /**
     * @param {string=} mode
     * @return {!DOMAgent.HighlightConfig}
     */
    _buildHighlightConfig: function(mode)
    {
        mode = mode || "all";
        var showRulers = WebInspector.moduleSetting("showMetricsRulers").get();
        var highlightConfig = { showInfo: mode === "all", showRulers: showRulers, showExtensionLines: showRulers };
        if (mode === "all" || mode === "content")
            highlightConfig.contentColor = WebInspector.Color.PageHighlight.Content.toProtocolRGBA();

        if (mode === "all" || mode === "padding")
            highlightConfig.paddingColor = WebInspector.Color.PageHighlight.Padding.toProtocolRGBA();

        if (mode === "all" || mode === "border")
            highlightConfig.borderColor = WebInspector.Color.PageHighlight.Border.toProtocolRGBA();

        if (mode === "all" || mode === "margin")
            highlightConfig.marginColor = WebInspector.Color.PageHighlight.Margin.toProtocolRGBA();

        if (mode === "all") {
            highlightConfig.eventTargetColor = WebInspector.Color.PageHighlight.EventTarget.toProtocolRGBA();
            highlightConfig.shapeColor = WebInspector.Color.PageHighlight.Shape.toProtocolRGBA();
            highlightConfig.shapeMarginColor = WebInspector.Color.PageHighlight.ShapeMargin.toProtocolRGBA();
            highlightConfig.displayAsMaterial = Runtime.experiments.isEnabled("inspectTooltip");
        }
        return highlightConfig;
    },

    /**
     * @param {!WebInspector.DOMNode} node
     * @param {function(?Protocol.Error, ...)=} callback
     * @return {function(...)}
     * @template T
     */
    _markRevision: function(node, callback)
    {
        /**
         * @param {?Protocol.Error} error
         * @this {WebInspector.DOMModel}
         */
        function wrapperFunction(error)
        {
            if (!error)
                this.markUndoableState();

            if (callback)
                callback.apply(this, arguments);
        }
        return wrapperFunction.bind(this);
    },

    markUndoableState: function()
    {
        this._agent.markUndoableState();
    },

    /**
     * @param {function(?Protocol.Error)=} callback
     */
    undo: function(callback)
    {
        /**
         * @param {?Protocol.Error} error
         * @this {WebInspector.DOMModel}
         */
        function mycallback(error)
        {
            this.dispatchEventToListeners(WebInspector.DOMModel.Events.UndoRedoCompleted);
            callback(error);
        }

        this.dispatchEventToListeners(WebInspector.DOMModel.Events.UndoRedoRequested);
        this._agent.undo(callback);
    },

    /**
     * @param {function(?Protocol.Error)=} callback
     */
    redo: function(callback)
    {
        /**
         * @param {?Protocol.Error} error
         * @this {WebInspector.DOMModel}
         */
        function mycallback(error)
        {
            this.dispatchEventToListeners(WebInspector.DOMModel.Events.UndoRedoCompleted);
            callback(error);
        }

        this.dispatchEventToListeners(WebInspector.DOMModel.Events.UndoRedoRequested);
        this._agent.redo(callback);
    },

    /**
     * @param {?WebInspector.DOMNodeHighlighter} highlighter
     */
    setHighlighter: function(highlighter)
    {
        this._highlighter = highlighter || this._defaultHighlighter;
    },

    /**
     * @param {number} x
     * @param {number} y
     * @param {function(?WebInspector.DOMNode)} callback
     */
    nodeForLocation: function(x, y, callback)
    {
        this._agent.getNodeForLocation(x, y, mycallback.bind(this));

        /**
         * @param {?Protocol.Error} error
         * @param {number} nodeId
         * @this {WebInspector.DOMModel}
         */
        function mycallback(error, nodeId)
        {
            if (error) {
                callback(null);
                return;
            }
            callback(this.nodeForId(nodeId));
        }
    },

    /**
     * @param {!WebInspector.RemoteObject} object
     * @param {function(?WebInspector.DOMNode)} callback
     */
    pushObjectAsNodeToFrontend: function(object, callback)
    {
        if (object.isNode())
            this.pushNodeToFrontend(object.objectId, callback);
        else
            callback(null);
    },

    /**
     * @override
     * @return {!Promise}
     */
    suspendModel: function()
    {
        return new Promise(promiseBody.bind(this));

        /**
         * @param {function()} fulfill
         * @this {WebInspector.DOMModel}
         */
        function promiseBody(fulfill)
        {
            this._agent.disable(callback.bind(this));

            /**
             * @this {WebInspector.DOMModel}
             */
            function callback()
            {
                this._setDocument(null);
                fulfill();
            }
        }
    },

    /**
     * @override
     * @return {!Promise}
     */
    resumeModel: function()
    {
        return new Promise(promiseBody.bind(this));

        /**
         * @param {function()} fulfill
         * @this {WebInspector.DOMModel}
         */
        function promiseBody(fulfill)
        {
            this._agent.enable(fulfill);
        }
    },

    /**
     * @param {!DOMAgent.NodeId} nodeId
     */
    nodeHighlightRequested: function(nodeId)
    {
        var node = this.nodeForId(nodeId);
        if (!node)
            return;

        this.dispatchEventToListeners(WebInspector.DOMModel.Events.NodeHighlightedInOverlay, node);
    },

    __proto__: WebInspector.SDKModel.prototype
}

/**
 * @constructor
 * @implements {DOMAgent.Dispatcher}
 * @param {!WebInspector.DOMModel} domModel
 */
WebInspector.DOMDispatcher = function(domModel)
{
    this._domModel = domModel;
}

WebInspector.DOMDispatcher.prototype = {
    /**
     * @override
     */
    documentUpdated: function()
    {
        this._domModel._documentUpdated();
    },

    /**
     * @override
     * @param {!DOMAgent.NodeId} nodeId
     */
    inspectNodeRequested: function(nodeId)
    {
        this._domModel._inspectNodeRequested(nodeId);
    },

    /**
     * @override
     * @param {!DOMAgent.NodeId} nodeId
     * @param {string} name
     * @param {string} value
     */
    attributeModified: function(nodeId, name, value)
    {
        this._domModel._attributeModified(nodeId, name, value);
    },

    /**
     * @override
     * @param {!DOMAgent.NodeId} nodeId
     * @param {string} name
     */
    attributeRemoved: function(nodeId, name)
    {
        this._domModel._attributeRemoved(nodeId, name);
    },

    /**
     * @override
     * @param {!Array.<!DOMAgent.NodeId>} nodeIds
     */
    inlineStyleInvalidated: function(nodeIds)
    {
        this._domModel._inlineStyleInvalidated(nodeIds);
    },

    /**
     * @override
     * @param {!DOMAgent.NodeId} nodeId
     * @param {string} characterData
     */
    characterDataModified: function(nodeId, characterData)
    {
        this._domModel._characterDataModified(nodeId, characterData);
    },

    /**
     * @override
     * @param {!DOMAgent.NodeId} parentId
     * @param {!Array.<!DOMAgent.Node>} payloads
     */
    setChildNodes: function(parentId, payloads)
    {
        this._domModel._setChildNodes(parentId, payloads);
    },

    /**
     * @override
     * @param {!DOMAgent.NodeId} nodeId
     * @param {number} childNodeCount
     */
    childNodeCountUpdated: function(nodeId, childNodeCount)
    {
        this._domModel._childNodeCountUpdated(nodeId, childNodeCount);
    },

    /**
     * @override
     * @param {!DOMAgent.NodeId} parentNodeId
     * @param {!DOMAgent.NodeId} previousNodeId
     * @param {!DOMAgent.Node} payload
     */
    childNodeInserted: function(parentNodeId, previousNodeId, payload)
    {
        this._domModel._childNodeInserted(parentNodeId, previousNodeId, payload);
    },

    /**
     * @override
     * @param {!DOMAgent.NodeId} parentNodeId
     * @param {!DOMAgent.NodeId} nodeId
     */
    childNodeRemoved: function(parentNodeId, nodeId)
    {
        this._domModel._childNodeRemoved(parentNodeId, nodeId);
    },

    /**
     * @override
     * @param {!DOMAgent.NodeId} hostId
     * @param {!DOMAgent.Node} root
     */
    shadowRootPushed: function(hostId, root)
    {
        this._domModel._shadowRootPushed(hostId, root);
    },

    /**
     * @override
     * @param {!DOMAgent.NodeId} hostId
     * @param {!DOMAgent.NodeId} rootId
     */
    shadowRootPopped: function(hostId, rootId)
    {
        this._domModel._shadowRootPopped(hostId, rootId);
    },

    /**
     * @override
     * @param {!DOMAgent.NodeId} parentId
     * @param {!DOMAgent.Node} pseudoElement
     */
    pseudoElementAdded: function(parentId, pseudoElement)
    {
        this._domModel._pseudoElementAdded(parentId, pseudoElement);
    },

    /**
     * @override
     * @param {!DOMAgent.NodeId} parentId
     * @param {!DOMAgent.NodeId} pseudoElementId
     */
    pseudoElementRemoved: function(parentId, pseudoElementId)
    {
        this._domModel._pseudoElementRemoved(parentId, pseudoElementId);
    },

    /**
     * @override
     * @param {!DOMAgent.NodeId} insertionPointId
     * @param {!Array.<!DOMAgent.BackendNode>} distributedNodes
     */
    distributedNodesUpdated: function(insertionPointId, distributedNodes)
    {
        this._domModel._distributedNodesUpdated(insertionPointId, distributedNodes);
    },

    /**
     * @override
     * @param {!DOMAgent.NodeId} nodeId
     */
    nodeHighlightRequested: function(nodeId)
    {
        this._domModel.nodeHighlightRequested(nodeId);
    }
}

/**
 * @interface
 */
WebInspector.DOMNodeHighlighter = function() {
}

WebInspector.DOMNodeHighlighter.prototype = {
    /**
     * @param {?WebInspector.DOMNode} node
     * @param {!DOMAgent.HighlightConfig} config
     * @param {!DOMAgent.BackendNodeId=} backendNodeId
     * @param {!RuntimeAgent.RemoteObjectId=} objectId
     */
    highlightDOMNode: function(node, config, backendNodeId, objectId) {},

    /**
     * @param {!DOMAgent.InspectMode} mode
     * @param {!DOMAgent.HighlightConfig} config
     * @param {function(?Protocol.Error)=} callback
     */
    setInspectMode: function(mode, config, callback) {},

    /**
     * @param {!PageAgent.FrameId} frameId
     */
    highlightFrame: function(frameId) {}
}

/**
 * @constructor
 * @implements {WebInspector.DOMNodeHighlighter}
 * @param {!Protocol.DOMAgent} agent
 */
WebInspector.DefaultDOMNodeHighlighter = function(agent)
{
    this._agent = agent;
}

WebInspector.DefaultDOMNodeHighlighter.prototype = {
    /**
     * @override
     * @param {?WebInspector.DOMNode} node
     * @param {!DOMAgent.HighlightConfig} config
     * @param {!DOMAgent.BackendNodeId=} backendNodeId
     * @param {!RuntimeAgent.RemoteObjectId=} objectId
     */
    highlightDOMNode: function(node, config, backendNodeId, objectId)
    {
        if (objectId || node || backendNodeId)
            this._agent.highlightNode(config, (objectId || backendNodeId) ? undefined : node.id, backendNodeId, objectId);
        else
            this._agent.hideHighlight();
    },

    /**
     * @override
     * @param {!DOMAgent.InspectMode} mode
     * @param {!DOMAgent.HighlightConfig} config
     * @param {function(?Protocol.Error)=} callback
     */
    setInspectMode: function(mode, config, callback)
    {
        this._agent.setInspectMode(mode, config, callback);
    },

    /**
     * @override
     * @param {!PageAgent.FrameId} frameId
     */
    highlightFrame: function(frameId)
    {
        this._agent.highlightFrame(frameId, WebInspector.Color.PageHighlight.Content.toProtocolRGBA(), WebInspector.Color.PageHighlight.ContentOutline.toProtocolRGBA());
    }
}

/**
 * @param {!WebInspector.Target} target
 * @return {?WebInspector.DOMModel}
 */
WebInspector.DOMModel.fromTarget = function(target)
{
    return /** @type {?WebInspector.DOMModel} */ (target.model(WebInspector.DOMModel));
}
;/* DebuggerModel.js */
/*
 * Copyright (C) 2010 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKModel}
 * @param {!WebInspector.Target} target
 */
WebInspector.DebuggerModel = function(target)
{
    WebInspector.SDKModel.call(this, WebInspector.DebuggerModel, target);

    target.registerDebuggerDispatcher(new WebInspector.DebuggerDispatcher(this));
    this._agent = target.debuggerAgent();
    WebInspector.targetManager.addEventListener(WebInspector.TargetManager.Events.TargetDisposed, this._targetDisposed, this);

    /** @type {?WebInspector.DebuggerPausedDetails} */
    this._debuggerPausedDetails = null;
    /** @type {!Object.<string, !WebInspector.Script>} */
    this._scripts = {};
    /** @type {!Map.<string, !Array.<!WebInspector.Script>>} */
    this._scriptsBySourceURL = new Map();

    /** @type {!WebInspector.Object} */
    this._breakpointResolvedEventTarget = new WebInspector.Object();

    this._isPausing = false;
    WebInspector.moduleSetting("pauseOnExceptionEnabled").addChangeListener(this._pauseOnExceptionStateChanged, this);
    WebInspector.moduleSetting("pauseOnCaughtException").addChangeListener(this._pauseOnExceptionStateChanged, this);
    WebInspector.moduleSetting("enableAsyncStackTraces").addChangeListener(this.asyncStackTracesStateChanged, this);

    this.enableDebugger();
}

/** @typedef {{location: ?WebInspector.DebuggerModel.Location, sourceURL: ?string, functionName: string, scopeChain: (Array.<!DebuggerAgent.Scope>|null)}} */
WebInspector.DebuggerModel.FunctionDetails;

/** @typedef {{location: ?WebInspector.DebuggerModel.Location, sourceURL: ?string, functionName: string, status: string}} */
WebInspector.DebuggerModel.GeneratorObjectDetails;

/**
 * Keep these in sync with WebCore::V8Debugger
 *
 * @enum {string}
 */
WebInspector.DebuggerModel.PauseOnExceptionsState = {
    DontPauseOnExceptions : "none",
    PauseOnAllExceptions : "all",
    PauseOnUncaughtExceptions: "uncaught"
};

/** @enum {string} */
WebInspector.DebuggerModel.Events = {
    AsyncOperationStarted: "AsyncOperationStarted",
    AsyncOperationCompleted: "AsyncOperationCompleted",
    DebuggerWasEnabled: "DebuggerWasEnabled",
    DebuggerWasDisabled: "DebuggerWasDisabled",
    BeforeDebuggerPaused: "BeforeDebuggerPaused",
    DebuggerPaused: "DebuggerPaused",
    DebuggerResumed: "DebuggerResumed",
    ParsedScriptSource: "ParsedScriptSource",
    FailedToParseScriptSource: "FailedToParseScriptSource",
    GlobalObjectCleared: "GlobalObjectCleared",
    CallFrameSelected: "CallFrameSelected",
    ConsoleCommandEvaluatedInSelectedCallFrame: "ConsoleCommandEvaluatedInSelectedCallFrame",
    PromiseUpdated: "PromiseUpdated",
}

/** @enum {string} */
WebInspector.DebuggerModel.BreakReason = {
    AsyncOperation: "AsyncOperation",
    DOM: "DOM",
    EventListener: "EventListener",
    XHR: "XHR",
    Exception: "exception",
    PromiseRejection: "promiseRejection",
    Assert: "assert",
    CSPViolation: "CSPViolation",
    DebugCommand: "debugCommand",
    Other: "other"
}

/**
 * @param {number=} value
 * @return {number}
 */
WebInspector.DebuggerModel.fromOneBased = function(value)
{
    // FIXME(webkit:62725): console stack trace line/column numbers are one-based.
    return value ? value - 1 : 0;
}

WebInspector.DebuggerModel.prototype = {
    /**
     * @return {boolean}
     */
    debuggerEnabled: function()
    {
        return !!this._debuggerEnabled;
    },

    /**
     * @param {function()=} callback
     */
    enableDebugger: function(callback)
    {
        if (this._debuggerEnabled) {
            if (callback)
                callback();
            return;
        }
        this._agent.enable(callback);
        this._debuggerEnabled = true;
        this._pauseOnExceptionStateChanged();
        this.asyncStackTracesStateChanged();
        this.dispatchEventToListeners(WebInspector.DebuggerModel.Events.DebuggerWasEnabled);
    },

    /**
     * @param {function()=} callback
     */
    disableDebugger: function(callback)
    {
        if (!this._debuggerEnabled) {
            if (callback)
                callback();
            return;
        }

        this._agent.disable(callback);
        this._debuggerEnabled = false;
        this._isPausing = false;
        this.asyncStackTracesStateChanged();
        this._globalObjectCleared();
        this.dispatchEventToListeners(WebInspector.DebuggerModel.Events.DebuggerWasDisabled);
    },

    /**
     * @param {boolean} skip
     */
    _skipAllPauses: function(skip)
    {
        if (this._skipAllPausesTimeout) {
            clearTimeout(this._skipAllPausesTimeout);
            delete this._skipAllPausesTimeout;
        }
        this._agent.setSkipAllPauses(skip);
    },

    /**
     * @param {number} timeout
     */
    skipAllPausesUntilReloadOrTimeout: function(timeout)
    {
        if (this._skipAllPausesTimeout)
            clearTimeout(this._skipAllPausesTimeout);
        this._agent.setSkipAllPauses(true);
        // If reload happens before the timeout, the flag will be already unset and the timeout callback won't change anything.
        this._skipAllPausesTimeout = setTimeout(this._skipAllPauses.bind(this, false), timeout);
    },

    _pauseOnExceptionStateChanged: function()
    {
        var state;
        if (!WebInspector.moduleSetting("pauseOnExceptionEnabled").get()) {
            state = WebInspector.DebuggerModel.PauseOnExceptionsState.DontPauseOnExceptions;
        } else if (WebInspector.moduleSetting("pauseOnCaughtException").get()) {
            state = WebInspector.DebuggerModel.PauseOnExceptionsState.PauseOnAllExceptions;
        } else {
            state = WebInspector.DebuggerModel.PauseOnExceptionsState.PauseOnUncaughtExceptions;
        }
        this._agent.setPauseOnExceptions(state);
    },

    asyncStackTracesStateChanged: function()
    {
        const maxAsyncStackChainDepth = 4;
        var enabled = WebInspector.moduleSetting("enableAsyncStackTraces").get() && this._debuggerEnabled;
        this._agent.setAsyncCallStackDepth(enabled ? maxAsyncStackChainDepth : 0);
    },

    stepInto: function()
    {
        this._agent.stepInto();
    },

    stepIntoAsync: function()
    {
        this._agent.stepIntoAsync();
    },

    stepOver: function()
    {
        this._agent.stepOver();
    },

    stepOut: function()
    {
        this._agent.stepOut();
    },

    resume: function()
    {
        this._agent.resume();
        this._isPausing = false;
    },

    pause: function()
    {
        this._isPausing = true;
        this._skipAllPauses(false);
        this._agent.pause();
    },

    /**
     * @param {boolean} active
     */
    setBreakpointsActive: function(active)
    {
        this._agent.setBreakpointsActive(active);
    },

    /**
     * @param {string} url
     * @param {number} lineNumber
     * @param {number=} columnNumber
     * @param {string=} condition
     * @param {function(?DebuggerAgent.BreakpointId, !Array.<!WebInspector.DebuggerModel.Location>)=} callback
     */
    setBreakpointByURL: function(url, lineNumber, columnNumber, condition, callback)
    {
        // Adjust column if needed.
        var minColumnNumber = 0;
        var scripts = this._scriptsBySourceURL.get(url) || [];
        for (var i = 0, l = scripts.length; i < l; ++i) {
            var script = scripts[i];
            if (lineNumber === script.lineOffset)
                minColumnNumber = minColumnNumber ? Math.min(minColumnNumber, script.columnOffset) : script.columnOffset;
        }
        columnNumber = Math.max(columnNumber, minColumnNumber);

        var target = this.target();
        /**
         * @param {?Protocol.Error} error
         * @param {!DebuggerAgent.BreakpointId} breakpointId
         * @param {!Array.<!DebuggerAgent.Location>} locations
         * @this {WebInspector.DebuggerModel}
         */
        function didSetBreakpoint(error, breakpointId, locations)
        {
            if (callback) {
                var rawLocations = locations ? locations.map(WebInspector.DebuggerModel.Location.fromPayload.bind(WebInspector.DebuggerModel.Location, this)) : [];
                callback(error ? null : breakpointId, rawLocations);
            }
        }
        this._agent.setBreakpointByUrl(lineNumber, url, undefined, columnNumber, condition, didSetBreakpoint.bind(this));
    },

    /**
     * @param {!WebInspector.DebuggerModel.Location} rawLocation
     * @param {string} condition
     * @param {function(?DebuggerAgent.BreakpointId, !Array.<!WebInspector.DebuggerModel.Location>)=} callback
     */
    setBreakpointBySourceId: function(rawLocation, condition, callback)
    {
        var target = this.target();

        /**
         * @this {WebInspector.DebuggerModel}
         * @param {?Protocol.Error} error
         * @param {!DebuggerAgent.BreakpointId} breakpointId
         * @param {!DebuggerAgent.Location} actualLocation
         */
        function didSetBreakpoint(error, breakpointId, actualLocation)
        {
            if (callback) {
                var location = WebInspector.DebuggerModel.Location.fromPayload(this, actualLocation);
                callback(error ? null : breakpointId, [location]);
            }
        }
        this._agent.setBreakpoint(rawLocation.payload(), condition, didSetBreakpoint.bind(this));
    },

    /**
     * @param {!DebuggerAgent.BreakpointId} breakpointId
     * @param {function()=} callback
     */
    removeBreakpoint: function(breakpointId, callback)
    {
        this._agent.removeBreakpoint(breakpointId, innerCallback);

        /**
         * @param {?Protocol.Error} error
         */
        function innerCallback(error)
        {
            if (error)
                console.error("Failed to remove breakpoint: " + error);
            if (callback)
                callback();
        }
    },

    /**
     * @param {string} objectId
     * @param {function(?Array.<!DebuggerAgent.CollectionEntry>)} callback
     */
    getCollectionEntries: function(objectId, callback)
    {
        this._agent.getCollectionEntries(objectId, innerCallback);

        /**
         * @param {?Protocol.Error} error
         * @param {?Array.<!DebuggerAgent.CollectionEntry>} response
         */
        function innerCallback(error, response)
        {
            if (error) {
                console.error(error);
                callback(null);
                return;
            }
            callback(response);
        }
    },

    /**
     * @param {boolean} captureStacks
     */
    enablePromiseTracker: function(captureStacks)
    {
        this._agent.enablePromiseTracker(captureStacks);
    },

    disablePromiseTracker: function()
    {
        this._agent.disablePromiseTracker();
    },

    /**
     * @param {number} promiseId
     * @param {string=} objectGroup
     * @param {function(?RuntimeAgent.RemoteObject)=} callback
     */
    getPromiseById: function(promiseId, objectGroup, callback)
    {
        this._agent.getPromiseById(promiseId, objectGroup, innerCallback);

        /**
         * @param {?Protocol.Error} error
         * @param {?RuntimeAgent.RemoteObject} promise
         */
        function innerCallback(error, promise)
        {
            if (error) {
                console.error(error);
                callback(null);
                return;
            }
            callback(promise);
        }
    },

    flushAsyncOperationEvents: function()
    {
        this._agent.flushAsyncOperationEvents();
    },

    /**
     * @param {number} operationId
     */
    setAsyncOperationBreakpoint: function(operationId)
    {
        this._agent.setAsyncOperationBreakpoint(operationId);
    },

    /**
     * @param {number} operationId
     */
    removeAsyncOperationBreakpoint: function(operationId)
    {
        this._agent.removeAsyncOperationBreakpoint(operationId);
    },

    /**
     * @param {!DebuggerAgent.BreakpointId} breakpointId
     * @param {!DebuggerAgent.Location} location
     */
    _breakpointResolved: function(breakpointId, location)
    {
        this._breakpointResolvedEventTarget.dispatchEventToListeners(breakpointId, WebInspector.DebuggerModel.Location.fromPayload(this, location));
    },

    _globalObjectCleared: function()
    {
        this._setDebuggerPausedDetails(null);
        this._reset();
        this.dispatchEventToListeners(WebInspector.DebuggerModel.Events.GlobalObjectCleared);
    },

    /**
     * @param {string} eventType
     * @param {!DebuggerAgent.PromiseDetails} promise
     */
    _promiseUpdated: function(eventType, promise)
    {
        this.dispatchEventToListeners(WebInspector.DebuggerModel.Events.PromiseUpdated, { eventType: eventType, promise: promise });
    },

    /**
     * @param {!DebuggerAgent.AsyncOperation} operation
     */
    _asyncOperationStarted: function(operation)
    {
        this.dispatchEventToListeners(WebInspector.DebuggerModel.Events.AsyncOperationStarted, operation);
    },

    /**
     * @param {number} operationId
     */
    _asyncOperationCompleted: function(operationId)
    {
        this.dispatchEventToListeners(WebInspector.DebuggerModel.Events.AsyncOperationCompleted, operationId);
    },

    _reset: function()
    {
        this._scripts = {};
        this._scriptsBySourceURL.clear();
    },

    /**
     * @return {!Object.<string, !WebInspector.Script>}
     */
    get scripts()
    {
        return this._scripts;
    },

    /**
     * @param {!RuntimeAgent.ScriptId} scriptId
     * @return {!WebInspector.Script}
     */
    scriptForId: function(scriptId)
    {
        return this._scripts[scriptId] || null;
    },

    /**
     * @return {!Array.<!WebInspector.Script>}
     */
    scriptsForSourceURL: function(sourceURL)
    {
        if (!sourceURL)
            return [];
        return this._scriptsBySourceURL.get(sourceURL) || [];
    },

    /**
     * @param {!RuntimeAgent.ScriptId} scriptId
     * @param {string} newSource
     * @param {function(?Protocol.Error, !DebuggerAgent.SetScriptSourceError=)} callback
     */
    setScriptSource: function(scriptId, newSource, callback)
    {
        this._scripts[scriptId].editSource(newSource, this._didEditScriptSource.bind(this, scriptId, newSource, callback));
    },

    /**
     * @param {!RuntimeAgent.ScriptId} scriptId
     * @param {string} newSource
     * @param {function(?Protocol.Error, !DebuggerAgent.SetScriptSourceError=)} callback
     * @param {?Protocol.Error} error
     * @param {!DebuggerAgent.SetScriptSourceError=} errorData
     * @param {!Array.<!DebuggerAgent.CallFrame>=} callFrames
     * @param {!DebuggerAgent.StackTrace=} asyncStackTrace
     * @param {boolean=} needsStepIn
     */
    _didEditScriptSource: function(scriptId, newSource, callback, error, errorData, callFrames, asyncStackTrace, needsStepIn)
    {
        if (needsStepIn) {
            this.stepInto();
            this._pendingLiveEditCallback = callback.bind(this, error, errorData);
            return;
        }

        if (!error && callFrames && callFrames.length)
            this._pausedScript(callFrames, this._debuggerPausedDetails.reason, this._debuggerPausedDetails.auxData, this._debuggerPausedDetails.breakpointIds, asyncStackTrace);
        callback(error, errorData);
    },

    /**
     * @return {?Array.<!WebInspector.DebuggerModel.CallFrame>}
     */
    get callFrames()
    {
        return this._debuggerPausedDetails ? this._debuggerPausedDetails.callFrames : null;
    },

    /**
     * @return {?WebInspector.DebuggerPausedDetails}
     */
    debuggerPausedDetails: function()
    {
        return this._debuggerPausedDetails;
    },

    /**
     * @param {?WebInspector.DebuggerPausedDetails} debuggerPausedDetails
     * @return {boolean}
     */
    _setDebuggerPausedDetails: function(debuggerPausedDetails)
    {
        this._isPausing = false;
        this._debuggerPausedDetails = debuggerPausedDetails;
        if (this._debuggerPausedDetails) {
            if (Runtime.experiments.isEnabled("emptySourceMapAutoStepping")) {
                if (this.dispatchEventToListeners(WebInspector.DebuggerModel.Events.BeforeDebuggerPaused, this._debuggerPausedDetails)) {
                    return false;
                }
            }
            this.dispatchEventToListeners(WebInspector.DebuggerModel.Events.DebuggerPaused, this._debuggerPausedDetails);
        }
        if (debuggerPausedDetails)
            this.setSelectedCallFrame(debuggerPausedDetails.callFrames[0]);
        else
            this.setSelectedCallFrame(null);
        return true;
    },

    /**
     * @param {!Array.<!DebuggerAgent.CallFrame>} callFrames
     * @param {string} reason
     * @param {!Object|undefined} auxData
     * @param {!Array.<string>} breakpointIds
     * @param {!DebuggerAgent.StackTrace=} asyncStackTrace
     */
    _pausedScript: function(callFrames, reason, auxData, breakpointIds, asyncStackTrace)
    {
        var pausedDetails = new WebInspector.DebuggerPausedDetails(this, callFrames, reason, auxData, breakpointIds, asyncStackTrace);
        if (this._setDebuggerPausedDetails(pausedDetails)) {
            if (this._pendingLiveEditCallback) {
                var callback = this._pendingLiveEditCallback;
                delete this._pendingLiveEditCallback;
                callback();
            }
        } else {
            this._agent.stepInto();
        }
    },

    _resumedScript: function()
    {
        this._setDebuggerPausedDetails(null);
        this.dispatchEventToListeners(WebInspector.DebuggerModel.Events.DebuggerResumed);
    },

    /**
     * @param {!RuntimeAgent.ScriptId} scriptId
     * @param {string} sourceURL
     * @param {number} startLine
     * @param {number} startColumn
     * @param {number} endLine
     * @param {number} endColumn
     * @param {!RuntimeAgent.ExecutionContextId} executionContextId
     * @param {boolean} isContentScript
     * @param {boolean} isInternalScript
     * @param {boolean} isLiveEdit
     * @param {string=} sourceMapURL
     * @param {boolean=} hasSourceURL
     * @param {boolean=} deprecatedCommentWasUsed
     * @param {boolean=} hasSyntaxError
     * @return {!WebInspector.Script}
     */
    _parsedScriptSource: function(scriptId, sourceURL, startLine, startColumn, endLine, endColumn, executionContextId, isContentScript, isInternalScript, isLiveEdit, sourceMapURL, hasSourceURL, deprecatedCommentWasUsed, hasSyntaxError)
    {
        var script = new WebInspector.Script(this, scriptId, sourceURL, startLine, startColumn, endLine, endColumn, executionContextId, isContentScript, isInternalScript, isLiveEdit, sourceMapURL, hasSourceURL);
        this._registerScript(script);
        if (!hasSyntaxError)
            this.dispatchEventToListeners(WebInspector.DebuggerModel.Events.ParsedScriptSource, script);
        else
            this.dispatchEventToListeners(WebInspector.DebuggerModel.Events.FailedToParseScriptSource, script);

        if (deprecatedCommentWasUsed) {
            var text = WebInspector.UIString("'//@ sourceURL' and '//@ sourceMappingURL' are deprecated, please use '//# sourceURL=' and '//# sourceMappingURL=' instead.");
            var msg = new WebInspector.ConsoleMessage(this.target(), WebInspector.ConsoleMessage.MessageSource.JS, WebInspector.ConsoleMessage.MessageLevel.Warning, text, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, scriptId);
            var consoleModel = this.target().consoleModel;
            if (consoleModel)
                consoleModel.addMessage(msg);
        }
        return script;
    },

    /**
     * @param {!WebInspector.Script} script
     */
    _registerScript: function(script)
    {
        this._scripts[script.scriptId] = script;
        if (script.isAnonymousScript())
            return;

        var scripts = this._scriptsBySourceURL.get(script.sourceURL);
        if (!scripts) {
            scripts = [];
            this._scriptsBySourceURL.set(script.sourceURL, scripts);
        }
        scripts.push(script);
    },

    /**
     * @param {!WebInspector.Script} script
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?WebInspector.DebuggerModel.Location}
     */
    createRawLocation: function(script, lineNumber, columnNumber)
    {
        if (script.sourceURL)
            return this.createRawLocationByURL(script.sourceURL, lineNumber, columnNumber);
        return new WebInspector.DebuggerModel.Location(this, script.scriptId, lineNumber, columnNumber);
    },

    /**
     * @param {string} sourceURL
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?WebInspector.DebuggerModel.Location}
     */
    createRawLocationByURL: function(sourceURL, lineNumber, columnNumber)
    {
        var closestScript = null;
        var scripts = this._scriptsBySourceURL.get(sourceURL) || [];
        for (var i = 0, l = scripts.length; i < l; ++i) {
            var script = scripts[i];
            if (!closestScript)
                closestScript = script;
            if (script.lineOffset > lineNumber || (script.lineOffset === lineNumber && script.columnOffset > columnNumber))
                continue;
            if (script.endLine < lineNumber || (script.endLine === lineNumber && script.endColumn <= columnNumber))
                continue;
            closestScript = script;
            break;
        }
        return closestScript ? new WebInspector.DebuggerModel.Location(this, closestScript.scriptId, lineNumber, columnNumber) : null;
    },

    /**
     * @param {!RuntimeAgent.ScriptId} scriptId
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?WebInspector.DebuggerModel.Location}
     */
    createRawLocationByScriptId: function(scriptId, lineNumber, columnNumber)
    {
        var script = this.scriptForId(scriptId);
        return script ? this.createRawLocation(script, lineNumber, columnNumber) : null;
    },

    /**
     * @param {!RuntimeAgent.StackTrace} stackTrace
     * @return {!Array<!WebInspector.DebuggerModel.Location>}
     */
    createRawLocationsByStackTrace: function(stackTrace)
    {
        var frames = [];
        while (stackTrace) {
            for (var frame of stackTrace.callFrames)
                frames.push(frame);
            stackTrace = stackTrace.parent;
        }

        var rawLocations = [];
        for (var frame of frames) {
            var rawLocation = this.createRawLocationByScriptId(frame.scriptId, WebInspector.DebuggerModel.fromOneBased(frame.lineNumber), WebInspector.DebuggerModel.fromOneBased(frame.columnNumber));
            if (rawLocation)
                rawLocations.push(rawLocation);
        }
        return rawLocations;
    },

    /**
     * @return {boolean}
     */
    isPaused: function()
    {
        return !!this.debuggerPausedDetails();
    },

    /**
     * @return {boolean}
     */
    isPausing: function()
    {
        return this._isPausing;
    },

    /**
     * @param {?WebInspector.DebuggerModel.CallFrame} callFrame
     */
    setSelectedCallFrame: function(callFrame)
    {
        this._selectedCallFrame = callFrame;
        if (!this._selectedCallFrame)
            return;

        this.dispatchEventToListeners(WebInspector.DebuggerModel.Events.CallFrameSelected, callFrame);
    },

    /**
     * @return {?WebInspector.DebuggerModel.CallFrame}
     */
    selectedCallFrame: function()
    {
        return this._selectedCallFrame;
    },

    /**
     * @param {string} code
     * @param {string} objectGroup
     * @param {boolean} includeCommandLineAPI
     * @param {boolean} doNotPauseOnExceptionsAndMuteConsole
     * @param {boolean} returnByValue
     * @param {boolean} generatePreview
     * @param {function(?WebInspector.RemoteObject, boolean, ?RuntimeAgent.RemoteObject=, ?RuntimeAgent.ExceptionDetails=)} callback
     */
    evaluateOnSelectedCallFrame: function(code, objectGroup, includeCommandLineAPI, doNotPauseOnExceptionsAndMuteConsole, returnByValue, generatePreview, callback)
    {
        /**
         * @param {?RuntimeAgent.RemoteObject} result
         * @param {boolean=} wasThrown
         * @param {?RuntimeAgent.ExceptionDetails=} exceptionDetails
         * @this {WebInspector.DebuggerModel}
         */
        function didEvaluate(result, wasThrown, exceptionDetails)
        {
            if (!result)
                callback(null, false);
            else if (returnByValue)
                callback(null, !!wasThrown, wasThrown ? null : result, exceptionDetails);
            else
                callback(this.target().runtimeModel.createRemoteObject(result), !!wasThrown, undefined, exceptionDetails);

            if (objectGroup === "console")
                this.dispatchEventToListeners(WebInspector.DebuggerModel.Events.ConsoleCommandEvaluatedInSelectedCallFrame);
        }

        this.selectedCallFrame().evaluate(code, objectGroup, includeCommandLineAPI, doNotPauseOnExceptionsAndMuteConsole, returnByValue, generatePreview, didEvaluate.bind(this));
    },

    /**
     * @param {!WebInspector.RemoteObject} remoteObject
     * @param {function(?WebInspector.DebuggerModel.FunctionDetails)} callback
     */
    functionDetails: function(remoteObject, callback)
    {
        this._agent.getFunctionDetails(remoteObject.objectId, didGetDetails.bind(this));

        /**
         * @param {?Protocol.Error} error
         * @param {!DebuggerAgent.FunctionDetails} response
         * @this {WebInspector.DebuggerModel}
         */
        function didGetDetails(error, response)
        {
            if (error) {
                callback(null);
                return;
            }
            var location = response.location;
            var script = this.scriptForId(location.scriptId);
            var rawLocation = script ? this.createRawLocation(script, location.lineNumber, location.columnNumber || 0) : null;
            var sourceURL = script ? script.contentURL() : null;
            callback({location: rawLocation, sourceURL: sourceURL, functionName: response.functionName, scopeChain: response.scopeChain || null});
        }
    },

    /**
     * @param {number} scopeNumber
     * @param {string} variableName
     * @param {!RuntimeAgent.CallArgument} newValue
     * @param {string} callFrameId
     * @param {string} functionObjectId
     * @param {function(string=)=} callback
     */
    setVariableValue: function(scopeNumber, variableName, newValue, callFrameId, functionObjectId, callback)
    {
        this._agent.setVariableValue(scopeNumber, variableName, newValue, callFrameId, functionObjectId, innerCallback);

        /**
         * @param {?Protocol.Error} error
         */
        function innerCallback(error)
        {
            if (error) {
                console.error(error);
                if (callback)
                    callback(error);
                return;
            }
            if (callback)
                callback();
        }
    },

    /**
     * @param {!WebInspector.RemoteObject} remoteObject
     * @param {function(?WebInspector.DebuggerModel.GeneratorObjectDetails)} callback
     */
    generatorObjectDetails: function(remoteObject, callback)
    {
        this._agent.getGeneratorObjectDetails(remoteObject.objectId, didGetDetails.bind(this));

        /**
         * @param {?Protocol.Error} error
         * @param {!DebuggerAgent.GeneratorObjectDetails} response
         * @this {WebInspector.DebuggerModel}
         */
        function didGetDetails(error, response)
        {
            if (error) {
                console.error(error);
                callback(null);
                return;
            }
            var location = response.location;
            var script = location && this.scriptForId(location.scriptId);
            var rawLocation = script ? this.createRawLocation(script, location.lineNumber, location.columnNumber || 0) : null;
            var sourceURL = script ? script.contentURL() : null;
            callback({location: rawLocation, sourceURL: sourceURL, functionName: response.functionName, status: response.status});
        }
    },

    /**
     * @param {!DebuggerAgent.BreakpointId} breakpointId
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    addBreakpointListener: function(breakpointId, listener, thisObject)
    {
        this._breakpointResolvedEventTarget.addEventListener(breakpointId, listener, thisObject)
    },

    /**
     * @param {!DebuggerAgent.BreakpointId} breakpointId
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    removeBreakpointListener: function(breakpointId, listener, thisObject)
    {
        this._breakpointResolvedEventTarget.removeEventListener(breakpointId, listener, thisObject);
    },


    /**
     * @param {!WebInspector.Event} event
     */
    _targetDisposed: function(event)
    {
        var target = /** @type {!WebInspector.Target} */ (event.data);
        if (target != this.target())
            return;
        WebInspector.moduleSetting("pauseOnExceptionEnabled").removeChangeListener(this._pauseOnExceptionStateChanged, this);
        WebInspector.moduleSetting("pauseOnCaughtException").removeChangeListener(this._pauseOnExceptionStateChanged, this);
        WebInspector.moduleSetting("enableAsyncStackTraces").removeChangeListener(this.asyncStackTracesStateChanged, this);
    },

    /**
     * @override
     * @return {!Promise}
     */
    suspendModel: function()
    {
        return new Promise(promiseBody.bind(this));

        /**
         * @param {function()} fulfill
         * @this {WebInspector.DebuggerModel}
         */
        function promiseBody(fulfill)
        {
            this.disableDebugger(fulfill);
        }
    },

    /**
     * @override
     * @return {!Promise}
     */
    resumeModel: function()
    {
        return new Promise(promiseBody.bind(this));

        /**
         * @param {function()} fulfill
         * @this {WebInspector.DebuggerModel}
         */
        function promiseBody(fulfill)
        {
            this.enableDebugger(fulfill);
        }
    },

    __proto__: WebInspector.SDKModel.prototype
}

WebInspector.DebuggerEventTypes = {
    JavaScriptPause: 0,
    JavaScriptBreakpoint: 1,
    NativeBreakpoint: 2
};

/**
 * @constructor
 * @implements {DebuggerAgent.Dispatcher}
 * @param {!WebInspector.DebuggerModel} debuggerModel
 */
WebInspector.DebuggerDispatcher = function(debuggerModel)
{
    this._debuggerModel = debuggerModel;
}

WebInspector.DebuggerDispatcher.prototype = {
    /**
     * @override
     * @param {!Array.<!DebuggerAgent.CallFrame>} callFrames
     * @param {string} reason
     * @param {!Object=} auxData
     * @param {!Array.<string>=} breakpointIds
     * @param {!DebuggerAgent.StackTrace=} asyncStackTrace
     */
    paused: function(callFrames, reason, auxData, breakpointIds, asyncStackTrace)
    {
        this._debuggerModel._pausedScript(callFrames, reason, auxData, breakpointIds || [], asyncStackTrace);
    },

    /**
     * @override
     */
    resumed: function()
    {
        this._debuggerModel._resumedScript();
    },

    /**
     * @override
     */
    globalObjectCleared: function()
    {
        this._debuggerModel._globalObjectCleared();
    },

    /**
     * @override
     * @param {!RuntimeAgent.ScriptId} scriptId
     * @param {string} sourceURL
     * @param {number} startLine
     * @param {number} startColumn
     * @param {number} endLine
     * @param {number} endColumn
     * @param {!RuntimeAgent.ExecutionContextId} executionContextId
     * @param {boolean=} isContentScript
     * @param {boolean=} isInternalScript
     * @param {boolean=} isLiveEdit
     * @param {string=} sourceMapURL
     * @param {boolean=} hasSourceURL
     * @param {boolean=} deprecatedCommentWasUsed
     */
    scriptParsed: function(scriptId, sourceURL, startLine, startColumn, endLine, endColumn, executionContextId, isContentScript, isInternalScript, isLiveEdit, sourceMapURL, hasSourceURL, deprecatedCommentWasUsed)
    {
        this._debuggerModel._parsedScriptSource(scriptId, sourceURL, startLine, startColumn, endLine, endColumn, executionContextId, !!isContentScript, !!isInternalScript, !!isLiveEdit, sourceMapURL, hasSourceURL, deprecatedCommentWasUsed, false);
    },

    /**
     * @override
     * @param {!RuntimeAgent.ScriptId} scriptId
     * @param {string} sourceURL
     * @param {number} startLine
     * @param {number} startColumn
     * @param {number} endLine
     * @param {number} endColumn
     * @param {!RuntimeAgent.ExecutionContextId} executionContextId
     * @param {boolean=} isContentScript
     * @param {boolean=} isInternalScript
     * @param {string=} sourceMapURL
     * @param {boolean=} hasSourceURL
     * @param {boolean=} deprecatedCommentWasUsed
     */
    scriptFailedToParse: function(scriptId, sourceURL, startLine, startColumn, endLine, endColumn, executionContextId, isContentScript, isInternalScript, sourceMapURL, hasSourceURL, deprecatedCommentWasUsed)
    {
        this._debuggerModel._parsedScriptSource(scriptId, sourceURL, startLine, startColumn, endLine, endColumn, executionContextId, !!isContentScript, !!isInternalScript, false, sourceMapURL, hasSourceURL, deprecatedCommentWasUsed, true);
    },

    /**
     * @override
     * @param {!DebuggerAgent.BreakpointId} breakpointId
     * @param {!DebuggerAgent.Location} location
     */
    breakpointResolved: function(breakpointId, location)
    {
        this._debuggerModel._breakpointResolved(breakpointId, location);
    },

    /**
     * @override
     * @param {string} eventType
     * @param {!DebuggerAgent.PromiseDetails} promise
     */
    promiseUpdated: function(eventType, promise)
    {
        this._debuggerModel._promiseUpdated(eventType, promise);
    },

    /**
     * @override
     * @param {!DebuggerAgent.AsyncOperation} operation
     */
    asyncOperationStarted: function(operation)
    {
        this._debuggerModel._asyncOperationStarted(operation);
    },

    /**
     * @override
     * @param {number} operationId
     */
    asyncOperationCompleted: function(operationId)
    {
        this._debuggerModel._asyncOperationCompleted(operationId);
    }
}

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!WebInspector.DebuggerModel} debuggerModel
 * @param {string} scriptId
 * @param {number} lineNumber
 * @param {number=} columnNumber
 */
WebInspector.DebuggerModel.Location = function(debuggerModel, scriptId, lineNumber, columnNumber)
{
    WebInspector.SDKObject.call(this, debuggerModel.target());
    this._debuggerModel = debuggerModel;
    this.scriptId = scriptId;
    this.lineNumber = lineNumber;
    this.columnNumber = columnNumber || 0;
}

/**
 * @param {!WebInspector.DebuggerModel} debuggerModel
 * @param {!DebuggerAgent.Location} payload
 * @return {!WebInspector.DebuggerModel.Location}
 */
WebInspector.DebuggerModel.Location.fromPayload = function(debuggerModel, payload)
{
    return new WebInspector.DebuggerModel.Location(debuggerModel, payload.scriptId, payload.lineNumber, payload.columnNumber);
}

WebInspector.DebuggerModel.Location.prototype = {
    /**
     * @return {!DebuggerAgent.Location}
     */
    payload: function()
    {
        return { scriptId: this.scriptId, lineNumber: this.lineNumber, columnNumber: this.columnNumber };
    },

    /**
     * @return {!WebInspector.Script}
     */
    script: function()
    {
        return this._debuggerModel.scriptForId(this.scriptId);
    },

    continueToLocation: function()
    {
        this._debuggerModel._agent.continueToLocation(this.payload());
    },

    /**
     * @return {string}
     */
    id: function()
    {
        return this.target().id() + ":" + this.scriptId + ":" + this.lineNumber + ":" + this.columnNumber;
    },

    __proto__: WebInspector.SDKObject.prototype
}

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!WebInspector.DebuggerModel} debuggerModel
 * @param {!WebInspector.Script} script
 * @param {!DebuggerAgent.CallFrame} payload
 * @param {boolean=} isAsync
 */
WebInspector.DebuggerModel.CallFrame = function(debuggerModel, script, payload, isAsync)
{
    var target = debuggerModel.target();
    WebInspector.SDKObject.call(this, target);
    this.debuggerModel = debuggerModel;
    this._debuggerAgent = debuggerModel._agent;
    this._script = script;
    this._payload = payload;
    this._isAsync = isAsync;
    this._location = WebInspector.DebuggerModel.Location.fromPayload(debuggerModel, payload.location);
    this._scopeChain = [];
    this._localScope = null;
    for (var i = 0; i < payload.scopeChain.length; ++i) {
        var scope = new WebInspector.DebuggerModel.Scope(this, i);
        this._scopeChain.push(scope);
        if (scope.type() === DebuggerAgent.ScopeType.Local)
            this._localScope = scope;
    }
    if (payload.functionLocation)
        this._functionLocation = WebInspector.DebuggerModel.Location.fromPayload(debuggerModel, payload.functionLocation);
}

/**
 * @param {!WebInspector.DebuggerModel} debuggerModel
 * @param {!Array.<!DebuggerAgent.CallFrame>} callFrames
 * @param {boolean=} isAsync
 * @return {!Array.<!WebInspector.DebuggerModel.CallFrame>}
 */
WebInspector.DebuggerModel.CallFrame.fromPayloadArray = function(debuggerModel, callFrames, isAsync)
{
    var result = [];
    for (var i = 0; i < callFrames.length; ++i) {
        var callFrame = callFrames[i];
        var script = debuggerModel.scriptForId(callFrame.location.scriptId);
        if (script)
            result.push(new WebInspector.DebuggerModel.CallFrame(debuggerModel, script, callFrame, isAsync));
    }
    return result;
}

WebInspector.DebuggerModel.CallFrame.prototype = {

    /**
     * @return {!WebInspector.Script}
     */
    get script()
    {
        return this._script;
    },

    /**
     * @return {string}
     */
    get id()
    {
        return this._payload.callFrameId;
    },

    /**
     * @return {!Array.<!WebInspector.DebuggerModel.Scope>}
     */
    scopeChain: function()
    {
        return this._scopeChain;
    },

    /**
     * @return {?WebInspector.DebuggerModel.Scope}
     */
    localScope: function()
    {
        return this._localScope;
    },

    /**
     * @return {?WebInspector.RemoteObject}
     */
    thisObject: function()
    {
        return this._payload.this ? this.target().runtimeModel.createRemoteObject(this._payload.this) : null;
    },

    /**
     * @return {?WebInspector.RemoteObject}
     */
    returnValue: function()
    {
        return this._payload.returnValue ?  this.target().runtimeModel.createRemoteObject(this._payload.returnValue) : null;
    },

    /**
     * @return {string}
     */
    get functionName()
    {
        return this._payload.functionName;
    },

    /**
     * @return {!WebInspector.DebuggerModel.Location}
     */
    location: function()
    {
        return this._location;
    },

    /**
     * @return {?WebInspector.DebuggerModel.Location}
     */
    functionLocation: function()
    {
        return this._functionLocation || null;
    },

    /**
     * @return {boolean}
     */
    isAsync: function()
    {
        return !!this._isAsync;
    },

    /**
     * @param {string} code
     * @param {string} objectGroup
     * @param {boolean} includeCommandLineAPI
     * @param {boolean} doNotPauseOnExceptionsAndMuteConsole
     * @param {boolean} returnByValue
     * @param {boolean} generatePreview
     * @param {function(?RuntimeAgent.RemoteObject, boolean=, ?RuntimeAgent.ExceptionDetails=)} callback
     */
    evaluate: function(code, objectGroup, includeCommandLineAPI, doNotPauseOnExceptionsAndMuteConsole, returnByValue, generatePreview, callback)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {!RuntimeAgent.RemoteObject} result
         * @param {boolean=} wasThrown
         * @param {?RuntimeAgent.ExceptionDetails=} exceptionDetails
         */
        function didEvaluateOnCallFrame(error, result, wasThrown, exceptionDetails)
        {
            if (error) {
                console.error(error);
                callback(null, false);
                return;
            }
            callback(result, wasThrown, exceptionDetails);
        }
        this._debuggerAgent.evaluateOnCallFrame(this._payload.callFrameId, code, objectGroup, includeCommandLineAPI, doNotPauseOnExceptionsAndMuteConsole, returnByValue, generatePreview, didEvaluateOnCallFrame);
    },

    /**
     * @param {function(?Protocol.Error=)=} callback
     */
    restart: function(callback)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {!Array.<!DebuggerAgent.CallFrame>=} callFrames
         * @param {!DebuggerAgent.StackTrace=} asyncStackTrace
         * @this {WebInspector.DebuggerModel.CallFrame}
         */
        function protocolCallback(error, callFrames, asyncStackTrace)
        {
            if (!error)
                this.debuggerModel.stepInto();
            if (callback)
                callback(error);
        }
        this._debuggerAgent.restartFrame(this._payload.callFrameId, protocolCallback.bind(this));
    },

    /**
     * @param {function(!Object)} callback
     */
    variableNames: function(callback)
    {
        var result = { this: true };

        function propertiesCollected(properties)
        {
            for (var i = 0; properties && i < properties.length; ++i)
                result[properties[i].name] = true;
            if (--pendingRequests == 0)
                callback(result);
        }

        var scopeChain = this.scopeChain();
        var pendingRequests = scopeChain.length;
        for (var i = 0; i < scopeChain.length; ++i) {
            var scope = scopeChain[i];
            var object = scope.object();
            object.getAllProperties(false, propertiesCollected);
        }
    },

    __proto__: WebInspector.SDKObject.prototype
}

/**
 * @constructor
 * @param {!WebInspector.DebuggerModel.CallFrame} callFrame
 * @param {number} ordinal
 */
WebInspector.DebuggerModel.Scope = function(callFrame, ordinal)
{
    this._callFrame = callFrame;
    this._payload = callFrame._payload.scopeChain[ordinal];
    this._type = this._payload.type;
    this._name = this._payload.name;
    this._ordinal = ordinal;
}

WebInspector.DebuggerModel.Scope.prototype = {
    /**
     * @return {string}
     */
    type: function()
    {
        return this._type;
    },

    /**
     * @return {string|undefined}
     */
    name: function()
    {
        return this._name;
    },

    /**
     * @return {!WebInspector.RemoteObject}
     */
    object: function()
    {
        if (this._object)
            return this._object;
        var runtimeModel = this._callFrame.target().runtimeModel;

        var declarativeScope = this._type !== DebuggerAgent.ScopeType.With && this._type !== DebuggerAgent.ScopeType.Global;
        if (declarativeScope)
            this._object = runtimeModel.createScopeRemoteObject(this._payload.object, new WebInspector.ScopeRef(this._ordinal, this._callFrame.id, undefined));
        else
            this._object = runtimeModel.createRemoteObject(this._payload.object);

        return this._callFrame.target().runtimeModel.createRemoteObject(this._payload.object);
    },

    /**
     * @return {string}
     */
    description: function()
    {
        var declarativeScope = this._type !== DebuggerAgent.ScopeType.With && this._type !== DebuggerAgent.ScopeType.Global;
        return declarativeScope ? "" : (this._payload.object.description || "");
    }
}

/**
 * @constructor
 * @param {!Array.<!WebInspector.DebuggerModel.CallFrame>} callFrames
 * @param {?WebInspector.DebuggerModel.StackTrace} asyncStackTrace
 * @param {string=} description
 */
WebInspector.DebuggerModel.StackTrace = function(callFrames, asyncStackTrace, description)
{
    this.callFrames = callFrames;
    this.asyncStackTrace = asyncStackTrace;
    this.description = description;
}

/**
 * @param {!WebInspector.DebuggerModel} debuggerModel
 * @param {!DebuggerAgent.StackTrace=} payload
 * @param {boolean=} isAsync
 * @return {?WebInspector.DebuggerModel.StackTrace}
 */
WebInspector.DebuggerModel.StackTrace.fromPayload = function(debuggerModel, payload, isAsync)
{
    if (!payload)
        return null;
    var callFrames = WebInspector.DebuggerModel.CallFrame.fromPayloadArray(debuggerModel, payload.callFrames, isAsync);
    if (!callFrames.length)
        return null;
    var asyncStackTrace = WebInspector.DebuggerModel.StackTrace.fromPayload(debuggerModel, payload.asyncStackTrace, true);
    return new WebInspector.DebuggerModel.StackTrace(callFrames, asyncStackTrace, payload.description);
}

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!WebInspector.DebuggerModel} debuggerModel
 * @param {!Array.<!DebuggerAgent.CallFrame>} callFrames
 * @param {string} reason
 * @param {!Object|undefined} auxData
 * @param {!Array.<string>} breakpointIds
 * @param {!DebuggerAgent.StackTrace=} asyncStackTrace
 */
WebInspector.DebuggerPausedDetails = function(debuggerModel, callFrames, reason, auxData, breakpointIds, asyncStackTrace)
{
    WebInspector.SDKObject.call(this, debuggerModel.target());
    this.debuggerModel = debuggerModel;
    this.callFrames = WebInspector.DebuggerModel.CallFrame.fromPayloadArray(debuggerModel, callFrames);
    this.reason = reason;
    this.auxData = auxData;
    this.breakpointIds = breakpointIds;
    this.asyncStackTrace = WebInspector.DebuggerModel.StackTrace.fromPayload(debuggerModel, asyncStackTrace, true);
}

WebInspector.DebuggerPausedDetails.prototype = {
    /**
     * @return {?WebInspector.RemoteObject}
     */
    exception: function()
    {
        if (this.reason !== WebInspector.DebuggerModel.BreakReason.Exception && this.reason !== WebInspector.DebuggerModel.BreakReason.PromiseRejection)
            return null;
        return this.target().runtimeModel.createRemoteObject(/** @type {!RuntimeAgent.RemoteObject} */(this.auxData));
    },

    __proto__: WebInspector.SDKObject.prototype
}

/**
 * @return {!Array<!WebInspector.DebuggerModel>}
 */
WebInspector.DebuggerModel.instances = function()
{
    var result = [];
    for (var target of WebInspector.targetManager.targets()) {
        var debuggerModel = WebInspector.DebuggerModel.fromTarget(target);
        if (debuggerModel)
            result.push(debuggerModel);
    }
    return result;
}

/**
 * @param {?WebInspector.Target} target
 * @return {?WebInspector.DebuggerModel}
 */
WebInspector.DebuggerModel.fromTarget = function(target)
{
    if (!target || !target.hasJSContext())
        return null;
    return /** @type {?WebInspector.DebuggerModel} */ (target.model(WebInspector.DebuggerModel));
}
;/* HAREntry.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// See http://www.softwareishard.com/blog/har-12-spec/
// for HAR specification.

// FIXME: Some fields are not yet supported due to back-end limitations.
// See https://bugs.webkit.org/show_bug.cgi?id=58127 for details.

/**
 * @constructor
 * @param {!WebInspector.NetworkRequest} request
 */
WebInspector.HAREntry = function(request)
{
    this._request = request;
}

WebInspector.HAREntry.prototype = {
    /**
     * @return {!Object}
     */
    build: function()
    {
        var entry = {
            startedDateTime: WebInspector.HARLog.pseudoWallTime(this._request, this._request.startTime),
            time: this._request.timing ? WebInspector.HAREntry._toMilliseconds(this._request.duration) : 0,
            request: this._buildRequest(),
            response: this._buildResponse(),
            cache: { }, // Not supported yet.
            timings: this._buildTimings()
        };

        if (this._request.connectionId !== "0")
            entry.connection = this._request.connectionId;
        var page = this._request.target().networkLog.pageLoadForRequest(this._request);
        if (page)
            entry.pageref = "page_" + page.id;
        return entry;
    },

    /**
     * @return {!Object}
     */
    _buildRequest: function()
    {
        var headersText = this._request.requestHeadersText();
        var res = {
            method: this._request.requestMethod,
            url: this._buildRequestURL(this._request.url),
            httpVersion: this._request.requestHttpVersion(),
            headers: this._request.requestHeaders(),
            queryString: this._buildParameters(this._request.queryParameters || []),
            cookies: this._buildCookies(this._request.requestCookies || []),
            headersSize: headersText ? headersText.length : -1,
            bodySize: this.requestBodySize
        };
        if (this._request.requestFormData)
            res.postData = this._buildPostData();

        return res;
    },

    /**
     * @return {!Object}
     */
    _buildResponse: function()
    {
        var headersText = this._request.responseHeadersText;
        return {
            status: this._request.statusCode,
            statusText: this._request.statusText,
            httpVersion: this._request.responseHttpVersion(),
            headers: this._request.responseHeaders,
            cookies: this._buildCookies(this._request.responseCookies || []),
            content: this._buildContent(),
            redirectURL: this._request.responseHeaderValue("Location") || "",
            headersSize: headersText ? headersText.length : -1,
            bodySize: this.responseBodySize,
            _transferSize: this._request.transferSize,
            _error: this._request.localizedFailDescription
        };
    },

    /**
     * @return {!Object}
     */
    _buildContent: function()
    {
        var content = {
            size: this._request.resourceSize,
            mimeType: this._request.mimeType || "x-unknown",
            // text: this._request.content // TODO: pull out into a boolean flag, as content can be huge (and needs to be requested with an async call)
        };
        var compression = this.responseCompression;
        if (typeof compression === "number")
            content.compression = compression;
        return content;
    },

    /**
     * @return {!Object}
     */
    _buildTimings: function()
    {
        // Order of events: request_start = 0, [proxy], [dns], [connect [ssl]], [send], receive_headers_end
        // HAR 'blocked' time is time before first network activity.

        var timing = this._request.timing;
        if (!timing)
            return {blocked: -1, dns: -1, connect: -1, send: 0, wait: 0, receive: 0, ssl: -1};

        function firstNonNegative(values)
        {
            for (var i = 0; i < values.length; ++i) {
                if (values[i] >= 0)
                    return values[i];
            }
            console.assert(false, "Incomplete request timing information.");
        }

        var blocked = firstNonNegative([timing.dnsStart, timing.connectStart, timing.sendStart]);

        var dns = -1;
        if (timing.dnsStart >= 0)
            dns = firstNonNegative([timing.connectStart, timing.sendStart]) - timing.dnsStart;

        var connect = -1;
        if (timing.connectStart >= 0)
            connect = timing.sendStart - timing.connectStart;

        var send = timing.sendEnd - timing.sendStart;
        var wait = timing.receiveHeadersEnd - timing.sendEnd;
        var receive = WebInspector.HAREntry._toMilliseconds(this._request.duration) - timing.receiveHeadersEnd;

        var ssl = -1;
        if (timing.sslStart >= 0 && timing.sslEnd >= 0)
            ssl = timing.sslEnd - timing.sslStart;

        return {blocked: blocked, dns: dns, connect: connect, send: send, wait: wait, receive: receive, ssl: ssl};
    },

    /**
     * @return {!Object}
     */
    _buildPostData: function()
    {
        var res = {
            mimeType: this._request.requestContentType(),
            text: this._request.requestFormData
        };
        if (this._request.formParameters)
            res.params = this._buildParameters(this._request.formParameters);
        return res;
    },

    /**
     * @param {!Array.<!Object>} parameters
     * @return {!Array.<!Object>}
     */
    _buildParameters: function(parameters)
    {
        return parameters.slice();
    },

    /**
     * @param {string} url
     * @return {string}
     */
    _buildRequestURL: function(url)
    {
        return url.split("#", 2)[0];
    },

    /**
     * @param {!Array.<!WebInspector.Cookie>} cookies
     * @return {!Array.<!Object>}
     */
    _buildCookies: function(cookies)
    {
        return cookies.map(this._buildCookie.bind(this));
    },

    /**
     * @param {!WebInspector.Cookie} cookie
     * @return {!Object}
     */
    _buildCookie: function(cookie)
    {
        return {
            name: cookie.name(),
            value: cookie.value(),
            path: cookie.path(),
            domain: cookie.domain(),
            expires: cookie.expiresDate(WebInspector.HARLog.pseudoWallTime(this._request, this._request.startTime)),
            httpOnly: cookie.httpOnly(),
            secure: cookie.secure()
        };
    },

    /**
     * @return {number}
     */
    get requestBodySize()
    {
        return !this._request.requestFormData ? 0 : this._request.requestFormData.length;
    },

    /**
     * @return {number}
     */
    get responseBodySize()
    {
        if (this._request.cached() || this._request.statusCode === 304)
            return 0;
        if (!this._request.responseHeadersText)
            return -1;
        return this._request.transferSize - this._request.responseHeadersText.length;
    },

    /**
     * @return {number|undefined}
     */
    get responseCompression()
    {
        if (this._request.cached() || this._request.statusCode === 304 || this._request.statusCode === 206)
            return;
        if (!this._request.responseHeadersText)
            return;
        return this._request.resourceSize - this.responseBodySize;
    }
}

/**
 * @param {number} time
 * @return {number}
 */
WebInspector.HAREntry._toMilliseconds = function(time)
{
    return time === -1 ? -1 : time * 1000;
}

/**
 * @constructor
 * @param {!Array.<!WebInspector.NetworkRequest>} requests
 */
WebInspector.HARLog = function(requests)
{
    this._requests = requests;
}

/**
 * @param {!WebInspector.NetworkRequest} request
 * @param {number} monotonicTime
 * @return {!Date}
 */
WebInspector.HARLog.pseudoWallTime = function(request, monotonicTime)
{
    return new Date(request.pseudoWallTime(monotonicTime) * 1000);
}

WebInspector.HARLog.prototype = {
    /**
     * @return {!Object}
     */
    build: function()
    {
        return {
            version: "1.2",
            creator: this._creator(),
            pages: this._buildPages(),
            entries: this._requests.map(this._convertResource.bind(this))
        }
    },

    _creator: function()
    {
        var webKitVersion = /AppleWebKit\/([^ ]+)/.exec(window.navigator.userAgent);

        return {
            name: "WebInspector",
            version: webKitVersion ? webKitVersion[1] : "n/a"
        };
    },

    /**
     * @return {!Array.<!Object>}
     */
    _buildPages: function()
    {
        var seenIdentifiers = {};
        var pages = [];
        for (var i = 0; i < this._requests.length; ++i) {
            var request = this._requests[i];
            var page = request.target().networkLog.pageLoadForRequest(request);
            if (!page || seenIdentifiers[page.id])
                continue;
            seenIdentifiers[page.id] = true;
            pages.push(this._convertPage(page, request));
        }
        return pages;
    },

    /**
     * @param {!WebInspector.PageLoad} page
     * @param {!WebInspector.NetworkRequest} request
     * @return {!Object}
     */
    _convertPage: function(page, request)
    {
        return {
            startedDateTime: WebInspector.HARLog.pseudoWallTime(request, page.startTime),
            id: "page_" + page.id,
            title: page.url, // We don't have actual page title here. URL is probably better than nothing.
            pageTimings: {
                onContentLoad: this._pageEventTime(page, page.contentLoadTime),
                onLoad: this._pageEventTime(page, page.loadTime)
            }
        }
    },

    /**
     * @param {!WebInspector.NetworkRequest} request
     * @return {!Object}
     */
    _convertResource: function(request)
    {
        return (new WebInspector.HAREntry(request)).build();
    },

    /**
     * @param {!WebInspector.PageLoad} page
     * @param {number} time
     * @return {number}
     */
    _pageEventTime: function(page, time)
    {
        var startTime = page.startTime;
        if (time === -1 || startTime === -1)
            return -1;
        return WebInspector.HAREntry._toMilliseconds(time - startTime);
    }
}
;/* NetworkLog.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!WebInspector.Target} target
 */
WebInspector.NetworkLog = function(target)
{
    WebInspector.SDKObject.call(this, target);

    this._requests = [];
    this._requestForId = {};
    target.networkManager.addEventListener(WebInspector.NetworkManager.EventTypes.RequestStarted, this._onRequestStarted, this);
    target.resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.MainFrameNavigated, this._onMainFrameNavigated, this);
    target.resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.Load, this._onLoad, this);
    target.resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.DOMContentLoaded, this._onDOMContentLoaded, this);
}

/**
 * @param {string} url
 * @return {?WebInspector.NetworkRequest}
 */
WebInspector.NetworkLog.requestForURL = function(url)
{
    for (var target of WebInspector.targetManager.targets()) {
        var result = target.networkLog.requestForURL(url);
        if (result)
            return result;
    }
    return null;
}

/**
 * @return {!Array.<!WebInspector.NetworkRequest>}
 */
WebInspector.NetworkLog.requests = function()
{
    var result = [];
    for (var target of WebInspector.targetManager.targets()) {
        result = result.concat(target.networkLog.requests());
    }
    return result;
}

WebInspector.NetworkLog.prototype = {
    /**
     * @return {!Array.<!WebInspector.NetworkRequest>}
     */
    requests: function()
    {
        return this._requests;
    },

    /**
     * @param {string} url
     * @return {?WebInspector.NetworkRequest}
     */
    requestForURL: function(url)
    {
        for (var i = 0; i < this._requests.length; ++i) {
            if (this._requests[i].url === url)
                return this._requests[i];
        }
        return null;
    },

    /**
     * @param {!WebInspector.NetworkRequest} request
     * @return {!WebInspector.PageLoad}
     */
    pageLoadForRequest: function(request)
    {
        return request.__page;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onMainFrameNavigated: function(event)
    {
        var mainFrame = /** type {WebInspector.ResourceTreeFrame} */ event.data;
        // Preserve requests from the new session.
        this._currentPageLoad = null;
        var oldRequests = this._requests.splice(0, this._requests.length);
        this._requestForId = {};
        for (var i = 0; i < oldRequests.length; ++i) {
            var request = oldRequests[i];
            if (request.loaderId === mainFrame.loaderId) {
                if (!this._currentPageLoad)
                    this._currentPageLoad = new WebInspector.PageLoad(request);
                this._requests.push(request);
                this._requestForId[request.requestId] = request;
                request.__page = this._currentPageLoad;
            }
        }
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onRequestStarted: function(event)
    {
        var request = /** @type {!WebInspector.NetworkRequest} */ (event.data);
        this._requests.push(request);
        this._requestForId[request.requestId] = request;
        request.__page = this._currentPageLoad;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onDOMContentLoaded: function(event)
    {
        if (this._currentPageLoad)
            this._currentPageLoad.contentLoadTime = event.data;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onLoad: function(event)
    {
        if (this._currentPageLoad)
            this._currentPageLoad.loadTime = event.data;
    },

    /**
     * @param {!NetworkAgent.RequestId} requestId
     * @return {?WebInspector.NetworkRequest}
     */
    requestForId: function(requestId)
    {
        return this._requestForId[requestId];
    },

    __proto__: WebInspector.SDKObject.prototype
}

/**
 * @constructor
 * @param {!WebInspector.NetworkRequest} mainRequest
 */
WebInspector.PageLoad = function(mainRequest)
{
    this.id = ++WebInspector.PageLoad._lastIdentifier;
    this.url = mainRequest.url;
    this.startTime = mainRequest.startTime;
}

WebInspector.PageLoad._lastIdentifier = 0;
;/* ServiceWorkerManager.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!WebInspector.Target} target
 */
WebInspector.ServiceWorkerManager = function(target)
{
    WebInspector.SDKObject.call(this, target);
    target.registerServiceWorkerDispatcher(new WebInspector.ServiceWorkerDispatcher(this));
    this._lastAnonymousTargetId = 0;
    this._agent = target.serviceWorkerAgent();
    /** @type {!Map.<string, !WebInspector.ServiceWorker>} */
    this._workers = new Map();
    /** @type {!Map.<string, !WebInspector.ServiceWorkerRegistration>} */
    this._registrations = new Map();
    this.enable();
}

WebInspector.ServiceWorkerManager.Events = {
    WorkersUpdated: "WorkersUpdated",
    RegistrationUpdated: "RegistrationUpdated",
    RegistrationDeleted: "RegistrationDeleted",
    DebugOnStartUpdated: "DebugOnStartUpdated"
}

WebInspector.ServiceWorkerManager.prototype = {
    enable: function()
    {
        if (this._enabled)
            return;
        this._enabled = true;

        this._agent.enable();
        WebInspector.targetManager.addEventListener(WebInspector.TargetManager.Events.MainFrameNavigated, this._mainFrameNavigated, this);
    },

    disable: function()
    {
        if (!this._enabled)
            return;
        this._enabled = false;

        for (var worker of this._workers.values())
            worker._connection.close();
        this._workers.clear();
        this._registrations.clear();
        this._agent.disable();
        WebInspector.targetManager.removeEventListener(WebInspector.TargetManager.Events.MainFrameNavigated, this._mainFrameNavigated, this);
    },

    /**
     * @return {!Iterable.<!WebInspector.ServiceWorker>}
     */
    workers: function()
    {
        return this._workers.values();
    },

    /**
     * @return {boolean}
     */
    hasWorkers: function()
    {
        return !!this._workers.size;
    },

    /**
     * @return {boolean}
     */
    debugOnStart: function()
    {
        return !!this._debugOnStart;
    },

    /**
     * @param {boolean} flag
     */
    setDebugOnStart: function(flag)
    {
        this._agent.setDebugOnStart(flag);
    },

    /**
     * @param {string} registrationId
     * @param {boolean} flag
     */
    setForceUpdateOnPageLoad: function(registrationId, flag)
    {
        this._agent.setForceUpdateOnPageLoad(registrationId, flag);
    },

    /**
     * @return {!Map.<string, !WebInspector.ServiceWorkerRegistration>}
     */
    registrations: function()
    {
        return this._registrations;
    },

    /**
     * @param {string} versionId
     * @return {?WebInspector.ServiceWorkerVersion}
     */
    findVersion: function(versionId)
    {
        for (var registration of this.registrations().values()) {
           var version = registration.versions.get(versionId);
           if (version)
              return version;
        }
        return null;
    },

    /**
     * @param {string} registrationId
     */
    deleteRegistration: function(registrationId)
    {
        var registration = this._registrations.get(registrationId);
        if (!registration)
            return;
        if (registration._isRedundant()) {
            this._registrations.delete(registrationId);
            this.dispatchEventToListeners(WebInspector.ServiceWorkerManager.Events.RegistrationDeleted, registration);
            return;
        }
        registration._deleting = true;
        for (var version of registration.versions.values())
            this.stopWorker(version.id);
        this._unregister(registration.scopeURL);
    },

    /**
     * @param {string} registrationId
     */
    updateRegistration: function(registrationId)
    {
        var registration = this._registrations.get(registrationId);
        if (!registration)
            return;
        this._agent.updateRegistration(registration.scopeURL);
    },

     /**
      * @param {string} registrationId
      * @param {string} data
      */
    deliverPushMessage: function(registrationId, data)
    {
        var registration = this._registrations.get(registrationId);
        if (!registration)
            return;
        var origin = WebInspector.ParsedURL.splitURLIntoPathComponents(registration.scopeURL)[0];
        this._agent.deliverPushMessage(origin, registrationId, data);
    },

    /**
     * @param {!ServiceWorkerAgent.TargetID} targetId
     */
    activateTarget: function(targetId)
    {
        this._agent.activateTarget(targetId);
    },

    /**
     * @param {string} scope
     */
    _unregister: function(scope)
    {
        this._agent.unregister(scope);
    },

    /**
     * @param {string} scope
     */
    startWorker: function(scope)
    {
        this._agent.startWorker(scope);
    },

    /**
     * @param {string} versionId
     */
    stopWorker: function(versionId)
    {
        this._agent.stopWorker(versionId);
    },

    /**
     * @param {string} versionId
     */
    inspectWorker: function(versionId)
    {
        this._agent.inspectWorker(versionId);
    },

    /**
     * @param {!ServiceWorkerAgent.TargetID} targetId
     * @param {function(?WebInspector.TargetInfo)=} callback
     */
    getTargetInfo: function(targetId, callback)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {?ServiceWorkerAgent.TargetInfo} targetInfo
         */
        function innerCallback(error, targetInfo)
        {
            if (error) {
                console.error(error);
                callback(null);
                return;
            }
            if (targetInfo)
                callback(new WebInspector.TargetInfo(targetInfo));
            else
                callback(null)
        }
        this._agent.getTargetInfo(targetId, innerCallback);
    },

    /**
     * @param {string} workerId
     * @param {string} url
     * @param {string} versionId
     */
    _workerCreated: function(workerId, url, versionId)
    {
        new WebInspector.ServiceWorker(this, workerId, url, versionId);
    },

    /**
     * @param {string} workerId
     */
    _workerTerminated: function(workerId)
    {
        var worker = this._workers.get(workerId);
        if (!worker)
            return;

        worker._closeConnection();
        this._workers.delete(workerId);

        this.dispatchEventToListeners(WebInspector.ServiceWorkerManager.Events.WorkersUpdated);
    },

    /**
     * @param {string} workerId
     * @param {string} message
     */
    _dispatchMessage: function(workerId, message)
    {
        var worker = this._workers.get(workerId);
        if (worker)
            worker._connection.dispatch(message);
    },

    /**
     * @param {!Array.<!ServiceWorkerAgent.ServiceWorkerRegistration>} registrations
     */
    _workerRegistrationUpdated: function(registrations)
    {
        for (var payload of registrations) {
            var registration = this._registrations.get(payload.registrationId);
            if (!registration) {
                registration = new WebInspector.ServiceWorkerRegistration(payload);
                this._registrations.set(payload.registrationId, registration);
                this.dispatchEventToListeners(WebInspector.ServiceWorkerManager.Events.RegistrationUpdated, registration);
                continue;
            }
            registration._update(payload);

            if (registration._shouldBeRemoved()) {
                this._registrations.delete(registration.id);
                this.dispatchEventToListeners(WebInspector.ServiceWorkerManager.Events.RegistrationDeleted, registration);
            } else {
                this.dispatchEventToListeners(WebInspector.ServiceWorkerManager.Events.RegistrationUpdated, registration);
            }
        }
    },

    /**
     * @param {!Array.<!ServiceWorkerAgent.ServiceWorkerVersion>} versions
     */
    _workerVersionUpdated: function(versions)
    {
        /** @type {!Set.<!WebInspector.ServiceWorkerRegistration>} */
        var registrations = new Set();
        for (var payload of versions) {
            var registration = this._registrations.get(payload.registrationId);
            if (!registration)
                continue;
            registration._updateVersion(payload);
            registrations.add(registration);
        }
        for (var registration of registrations) {
            if (registration._shouldBeRemoved()) {
                this._registrations.delete(registration.id);
                this.dispatchEventToListeners(WebInspector.ServiceWorkerManager.Events.RegistrationDeleted, registration);
            } else {
                this.dispatchEventToListeners(WebInspector.ServiceWorkerManager.Events.RegistrationUpdated, registration);
            }
        }
    },

    /**
     * @param {!ServiceWorkerAgent.ServiceWorkerErrorMessage} payload
     */
     _workerErrorReported: function(payload)
    {
        var registration = this._registrations.get(payload.registrationId);
        if (!registration)
            return;
        registration._addError(payload);
        this.dispatchEventToListeners(WebInspector.ServiceWorkerManager.Events.RegistrationUpdated, registration);
    },

    /**
     * @param {boolean} flag
     */
    _debugOnStartUpdated: function(flag)
    {
        this._debugOnStart = flag;
        this.dispatchEventToListeners(WebInspector.ServiceWorkerManager.Events.DebugOnStartUpdated, flag);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _mainFrameNavigated: function(event)
    {
        // Attach to the new worker set.
    },

    __proto__: WebInspector.SDKObject.prototype
}

/**
 * @constructor
 * @param {!WebInspector.ServiceWorkerManager} manager
 * @param {string} workerId
 * @param {string} url
 * @param {string} versionId
 */
WebInspector.ServiceWorker = function(manager, workerId, url, versionId)
{
    this._manager = manager;
    this._agent = manager.target().serviceWorkerAgent();
    this._workerId = workerId;
    this._connection = new WebInspector.ServiceWorkerConnection(this._agent, workerId);
    this._url = url;
    this._versionId = versionId;
    var parsedURL = url.asParsedURL();
    this._name = parsedURL ? parsedURL.lastPathComponentWithFragment()  : "#" + (++WebInspector.ServiceWorker._lastAnonymousTargetId);
    this._scope = parsedURL.host + parsedURL.folderPathComponents;

    this._manager._workers.set(workerId, this);
    this._target = WebInspector.targetManager.createTarget(this._name, WebInspector.Target.Type.ServiceWorker, this._connection, manager.target());
    this._manager.dispatchEventToListeners(WebInspector.ServiceWorkerManager.Events.WorkersUpdated);
    this._target.runtimeAgent().run();
}

WebInspector.ServiceWorker._lastAnonymousTargetId = 0;

WebInspector.ServiceWorker.prototype = {
    /**
     * @return {string}
     */
    name: function()
    {
        return this._name;
    },

    /**
     * @return {string}
     */
    url: function()
    {
        return this._url;
    },

    /**
     * @return {string}
     */
    versionId: function()
    {
        return this._versionId;
    },

    /**
     * @return {string}
     */
    scope: function()
    {
        return this._scope;
    },

    stop: function()
    {
        this._agent.stop(this._workerId);
    },

    _closeConnection: function()
    {
        this._connection._close();
        delete this._connection;
    }
}

/**
 * @constructor
 * @implements {ServiceWorkerAgent.Dispatcher}
 * @param {!WebInspector.ServiceWorkerManager} manager
 */
WebInspector.ServiceWorkerDispatcher = function(manager)
{
    this._manager = manager;
}

WebInspector.ServiceWorkerDispatcher.prototype = {
    /**
     * @override
     * @param {string} workerId
     * @param {string} url
     * @param {string} versionId
     */
    workerCreated: function(workerId, url, versionId)
    {
        this._manager._workerCreated(workerId, url, versionId);
    },

    /**
     * @override
     * @param {string} workerId
     */
    workerTerminated: function(workerId)
    {
        this._manager._workerTerminated(workerId);
    },

    /**
     * @override
     * @param {string} workerId
     * @param {string} message
     */
    dispatchMessage: function(workerId, message)
    {
        this._manager._dispatchMessage(workerId, message);
    },

    /**
     * @override
     * @param {!Array.<!ServiceWorkerAgent.ServiceWorkerRegistration>} registrations
     */
    workerRegistrationUpdated: function(registrations)
    {
        this._manager._workerRegistrationUpdated(registrations);
    },

    /**
     * @override
     * @param {!Array.<!ServiceWorkerAgent.ServiceWorkerVersion>} versions
     */
    workerVersionUpdated: function(versions)
    {
        this._manager._workerVersionUpdated(versions);
    },

    /**
     * @override
     * @param {!ServiceWorkerAgent.ServiceWorkerErrorMessage} errorMessage
     */
    workerErrorReported: function(errorMessage)
    {
        this._manager._workerErrorReported(errorMessage);
    },

    /**
     * @override
     * @param {boolean} flag
     */
    debugOnStartUpdated: function(flag)
    {
        this._manager._debugOnStartUpdated(flag);
    }
}

/**
 * @constructor
 * @extends {InspectorBackendClass.Connection}
 * @param {!Protocol.ServiceWorkerAgent} agent
 * @param {string} workerId
 */
WebInspector.ServiceWorkerConnection = function(agent, workerId)
{
    InspectorBackendClass.Connection.call(this);
    //FIXME: remove resourceTreeModel and others from worker targets
    this.suppressErrorsForDomains(["Worker", "Page", "CSS", "DOM", "DOMStorage", "Database", "Network", "IndexedDB"]);
    this._agent = agent;
    this._workerId = workerId;
}

WebInspector.ServiceWorkerConnection.prototype = {
    /**
     * @override
     * @param {!Object} messageObject
     */
    sendMessage: function(messageObject)
    {
        this._agent.sendMessage(this._workerId, JSON.stringify(messageObject));
    },

    _close: function()
    {
        this.connectionClosed("worker_terminated");
    },

    __proto__: InspectorBackendClass.Connection.prototype
}

/**
 * @constructor
 * @param {!ServiceWorkerAgent.TargetInfo} payload
 */
WebInspector.TargetInfo = function(payload)
{
    this.id = payload.id;
    this.type = payload.type;
    this.title = payload.title;
    this.url = payload.url;
}

WebInspector.TargetInfo.prototype = {
    /**
     * @return {boolean}
     */
    isWebContents: function()
    {
        return this.type == "web_contents";
    },
    /**
     * @return {boolean}
     */
    isFrame: function()
    {
        return this.type == "frame";
    },
}

/**
 * @constructor
 * @param {!ServiceWorkerAgent.ServiceWorkerErrorMessage} payload
 */
WebInspector.ServiceWorkerErrorMessage = function(payload)
{
    this.errorMessage = payload.errorMessage;
    this.sourceURL = payload.sourceURL;
    this.lineNumber = payload.lineNumber;
    this.columnNumber = payload.columnNumber;
}

/**
 * @constructor
 * @param {!WebInspector.ServiceWorkerRegistration} registration
 * @param {!ServiceWorkerAgent.ServiceWorkerVersion} payload
 */
WebInspector.ServiceWorkerVersion = function(registration, payload)
{
    this.registration = registration;
    this._update(payload);
    /** @type {!Array<!WebInspector.ServiceWorkerErrorMessage>} */
    this.errorMessages = [];
}

/**
 * @enum {string}
 */
WebInspector.ServiceWorkerVersion.Modes = {
    Installing: "installing",
    Waiting: "waiting",
    Active: "active",
    Redundant: "redundant"
}

WebInspector.ServiceWorkerVersion.prototype = {
    /**
     * @param {!ServiceWorkerAgent.ServiceWorkerVersion} payload
     */
    _update: function(payload)
    {
        this.id = payload.versionId;
        this.scriptURL = payload.scriptURL;
        this.runningStatus = payload.runningStatus;
        this.status = payload.status;
        this.scriptLastModified = payload.scriptLastModified;
        this.scriptResponseTime = payload.scriptResponseTime;
        this.controlledClients = []
        for (var i = 0; i < payload.controlledClients.length; ++i) {
            this.controlledClients.push(payload.controlledClients[i]);
        }
    },

    /**
     * @return {boolean}
     */
    isStartable: function()
    {
        return !this.registration.isDeleted && this.isActivated() && this.isStopped();
    },

    /**
     * @return {boolean}
     */
    isStoppedAndRedundant: function()
    {
        return this.runningStatus == ServiceWorkerAgent.ServiceWorkerVersionRunningStatus.Stopped && this.status == ServiceWorkerAgent.ServiceWorkerVersionStatus.Redundant;
    },

    /**
     * @return {boolean}
     */
    isStopped: function()
    {
        return this.runningStatus == ServiceWorkerAgent.ServiceWorkerVersionRunningStatus.Stopped;
    },

    /**
     * @return {boolean}
     */
    isStarting: function()
    {
        return this.runningStatus == ServiceWorkerAgent.ServiceWorkerVersionRunningStatus.Starting;
    },

    /**
     * @return {boolean}
     */
    isRunning: function()
    {
        return this.runningStatus == ServiceWorkerAgent.ServiceWorkerVersionRunningStatus.Running;
    },

    /**
     * @return {boolean}
     */
    isStopping: function()
    {
        return this.runningStatus == ServiceWorkerAgent.ServiceWorkerVersionRunningStatus.Stopping;
    },

    /**
     * @return {boolean}
     */
    isNew: function()
    {
        return this.status == ServiceWorkerAgent.ServiceWorkerVersionStatus.New;
    },

    /**
     * @return {boolean}
     */
    isInstalling: function()
    {
        return this.status == ServiceWorkerAgent.ServiceWorkerVersionStatus.Installing;
    },

    /**
     * @return {boolean}
     */
    isInstalled: function()
    {
        return this.status == ServiceWorkerAgent.ServiceWorkerVersionStatus.Installed;
    },

    /**
     * @return {boolean}
     */
    isActivating: function()
    {
        return this.status == ServiceWorkerAgent.ServiceWorkerVersionStatus.Activating;
    },

    /**
     * @return {boolean}
     */
    isActivated: function()
    {
        return this.status == ServiceWorkerAgent.ServiceWorkerVersionStatus.Activated;
    },

    /**
     * @return {boolean}
     */
    isRedundant: function()
    {
        return this.status == ServiceWorkerAgent.ServiceWorkerVersionStatus.Redundant;
    },

    /**
     * @return {string}
     */
    mode: function()
    {
        if (this.isNew() || this.isInstalling())
            return WebInspector.ServiceWorkerVersion.Modes.Installing;
        else if (this.isInstalled())
            return WebInspector.ServiceWorkerVersion.Modes.Waiting;
        else if (this.isActivating() || this.isActivated())
            return WebInspector.ServiceWorkerVersion.Modes.Active;
        return WebInspector.ServiceWorkerVersion.Modes.Redundant;
    },

    /**
     * @param {!ServiceWorkerAgent.ServiceWorkerErrorMessage} payload
     */
    _addError: function(payload)
    {
        this.errorMessages.push(new WebInspector.ServiceWorkerErrorMessage(payload));
    }
}

/**
* @constructor
* @param {!ServiceWorkerAgent.ServiceWorkerRegistration} payload
*/
WebInspector.ServiceWorkerRegistration = function(payload)
{
   this._update(payload);
   /** @type {!Map.<string, !WebInspector.ServiceWorkerVersion>} */
   this.versions = new Map();
   this._deleting = false;
}

WebInspector.ServiceWorkerRegistration.prototype = {
    /**
     * @param {!ServiceWorkerAgent.ServiceWorkerRegistration} payload
     */
    _update: function(payload)
    {
        this.id = payload.registrationId;
        this.scopeURL = payload.scopeURL;
        this.isDeleted = payload.isDeleted;
        this.forceUpdateOnPageLoad = payload.forceUpdateOnPageLoad;
    },

    /**
     * @param {!ServiceWorkerAgent.ServiceWorkerVersion} payload
     * @return {!WebInspector.ServiceWorkerVersion}
     */
    _updateVersion: function(payload)
    {
        var version = this.versions.get(payload.versionId);
        if (!version) {
            version = new WebInspector.ServiceWorkerVersion(this, payload);
            this.versions.set(payload.versionId, version);
            return version;
        }
        version._update(payload);
        return version;
    },

    /**
     * @param {!ServiceWorkerAgent.ServiceWorkerErrorMessage} payload
     */
    _addError: function(payload)
    {
        var version = this.versions.get(payload.versionId);
        if (version)
            version._addError(payload);
    },

    /**
     * @return {boolean}
     */
    _isRedundant: function()
    {
        for (var version of this.versions.values()) {
            if (!version.isStoppedAndRedundant())
                return false;
        }
        return true;
    },

    /**
     * @return {boolean}
     */
    _hasErrorLog: function()
    {
        for (var version of this.versions.values()) {
            if (version.errorMessages.length)
                return true;
        }
        return false;
    },

    /**
     * @return {boolean}
     */
    _shouldBeRemoved: function()
    {
        return this._isRedundant() && (!this._hasErrorLog() || this._deleting);
    }
}
;/* TracingManager.js */
/*
 * Copyright 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/**
 * @interface
 */
WebInspector.TracingManagerClient = function()
{
}

WebInspector.TracingManagerClient.prototype = {
    tracingStarted: function() { },
    /**
     * @param {!Array.<!WebInspector.TracingManager.EventPayload>} events
     */
    traceEventsCollected: function(events) { },
    tracingComplete: function() { },
    /**
     * @param {number} usage
     */
    tracingBufferUsage: function(usage) { },
    /**
     * @param {number} progress
     */
    eventsRetrievalProgress: function(progress) { }
}

/**
 * @constructor
 * @param {!WebInspector.Target} target
 */
WebInspector.TracingManager = function(target)
{
    this._target = target;
    target.registerTracingDispatcher(new WebInspector.TracingDispatcher(this));

    /** @type {?WebInspector.TracingManagerClient} */
    this._activeClient = null;
    this._eventBufferSize = 0;
    this._eventsRetrieved = 0;
}

/** @typedef {!{
        cat: string,
        pid: number,
        tid: number,
        ts: number,
        ph: string,
        name: string,
        args: !Object,
        dur: number,
        id: string,
        bind_id: string,
        s: string
    }}
 */
WebInspector.TracingManager.EventPayload;

WebInspector.TracingManager.TransferMode = {
    ReportEvents: "ReportEvents",
    ReturnAsStream: "ReturnAsStream"
};

WebInspector.TracingManager.prototype = {
    /**
     * @return {?WebInspector.Target}
     */
    target: function()
    {
        return this._target;
    },

    /**
     * @param {number=} usage
     * @param {number=} eventCount
     * @param {number=} percentFull
     */
    _bufferUsage: function(usage, eventCount, percentFull)
    {
        this._eventBufferSize = eventCount;
        this._activeClient.tracingBufferUsage(usage || percentFull || 0);
    },

    /**
     * @param {!Array.<!WebInspector.TracingManager.EventPayload>} events
     */
    _eventsCollected: function(events)
    {
        this._activeClient.traceEventsCollected(events);
        this._eventsRetrieved += events.length;
        if (!this._eventBufferSize)
            return;
        if (this._eventsRetrieved > this._eventBufferSize)
            this._eventsRetrieved = this._eventBufferSize;
        this._activeClient.eventsRetrievalProgress(this._eventsRetrieved / this._eventBufferSize);
    },

    _tracingComplete: function()
    {
        this._eventBufferSize = 0;
        this._eventsRetrieved = 0;
        this._activeClient.tracingComplete();
        this._activeClient = null;
        this._finishing = false;
    },

    /**
     * @param {!WebInspector.TracingManagerClient} client
     * @param {string} categoryFilter
     * @param {string} options
     * @param {function(?string)=} callback
     */
    start: function(client, categoryFilter, options, callback)
    {
        if (this._activeClient)
            throw new Error("Tracing is already started");
        var bufferUsageReportingIntervalMs = 500;
        this._activeClient = client;
        this._target.tracingAgent().start(categoryFilter, options, bufferUsageReportingIntervalMs, WebInspector.TracingManager.TransferMode.ReportEvents, callback);
        this._activeClient.tracingStarted();
    },

    stop: function()
    {
        if (!this._activeClient)
            throw new Error("Tracing is not started");
        if (this._finishing)
            throw new Error("Tracing is already being stopped");
        this._finishing = true;
        this._target.tracingAgent().end();
    }
}

/**
 * @constructor
 * @implements {TracingAgent.Dispatcher}
 * @param {!WebInspector.TracingManager} tracingManager
 */
WebInspector.TracingDispatcher = function(tracingManager)
{
    this._tracingManager = tracingManager;
}

WebInspector.TracingDispatcher.prototype = {
    /**
     * @override
     * @param {number=} usage
     * @param {number=} eventCount
     * @param {number=} percentFull
     */
    bufferUsage: function(usage, eventCount, percentFull)
    {
        this._tracingManager._bufferUsage(usage, eventCount, percentFull);
    },

    /**
     * @override
     * @param {!Array.<!WebInspector.TracingManager.EventPayload>} data
     */
    dataCollected: function(data)
    {
        this._tracingManager._eventsCollected(data);
    },

    /**
     * @override
     */
    tracingComplete: function()
    {
        this._tracingManager._tracingComplete();
    }
}
;/* TracingModel.js */
/*
 * Copyright 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/**
 * @constructor
 * @param {!WebInspector.BackingStorage} backingStorage
 */
WebInspector.TracingModel = function(backingStorage)
{
    this.reset();
    // Set backing storage after reset so that we do not perform
    // an extra reset of backing storage -- this is not free.
    this._backingStorage = backingStorage;
}

/**
 * @enum {string}
 */
WebInspector.TracingModel.Phase = {
    Begin: "B",
    End: "E",
    Complete: "X",
    Instant: "I",
    AsyncBegin: "S",
    AsyncStepInto: "T",
    AsyncStepPast: "p",
    AsyncEnd: "F",
    NestableAsyncBegin: "b",
    NestableAsyncEnd: "e",
    NestableAsyncInstant: "n",
    FlowBegin: "s",
    FlowStep: "t",
    FlowEnd: "f",
    Metadata: "M",
    Counter: "C",
    Sample: "P",
    CreateObject: "N",
    SnapshotObject: "O",
    DeleteObject: "D"
};

WebInspector.TracingModel.MetadataEvent = {
    ProcessSortIndex: "process_sort_index",
    ProcessName: "process_name",
    ThreadSortIndex: "thread_sort_index",
    ThreadName: "thread_name"
}

WebInspector.TracingModel.TopLevelEventCategory = "toplevel";
WebInspector.TracingModel.DevToolsMetadataEventCategory = "disabled-by-default-devtools.timeline";
WebInspector.TracingModel.DevToolsTimelineEventCategory = "disabled-by-default-devtools.timeline";

WebInspector.TracingModel.FrameLifecycleEventCategory = "cc,devtools";

WebInspector.TracingModel._nestableAsyncEventsString =
    WebInspector.TracingModel.Phase.NestableAsyncBegin +
    WebInspector.TracingModel.Phase.NestableAsyncEnd +
    WebInspector.TracingModel.Phase.NestableAsyncInstant;

WebInspector.TracingModel._legacyAsyncEventsString =
    WebInspector.TracingModel.Phase.AsyncBegin +
    WebInspector.TracingModel.Phase.AsyncEnd +
    WebInspector.TracingModel.Phase.AsyncStepInto +
    WebInspector.TracingModel.Phase.AsyncStepPast;

WebInspector.TracingModel._flowEventsString =
    WebInspector.TracingModel.Phase.FlowBegin +
    WebInspector.TracingModel.Phase.FlowStep +
    WebInspector.TracingModel.Phase.FlowEnd;

WebInspector.TracingModel._asyncEventsString = WebInspector.TracingModel._nestableAsyncEventsString + WebInspector.TracingModel._legacyAsyncEventsString;

/**
 * @param {string} phase
 * @return {boolean}
 */
WebInspector.TracingModel.isNestableAsyncPhase = function(phase)
{
    return WebInspector.TracingModel._nestableAsyncEventsString.indexOf(phase) >= 0;
}

/**
 * @param {string} phase
 * @return {boolean}
 */
WebInspector.TracingModel.isAsyncBeginPhase = function(phase)
{
    return phase === WebInspector.TracingModel.Phase.AsyncBegin || phase === WebInspector.TracingModel.Phase.NestableAsyncBegin;
}

/**
 * @param {string} phase
 * @return {boolean}
 */
WebInspector.TracingModel.isAsyncPhase = function(phase)
{
    return WebInspector.TracingModel._asyncEventsString.indexOf(phase) >= 0;
}

/**
 * @param {string} phase
 * @return {boolean}
 */
WebInspector.TracingModel.isFlowPhase = function(phase)
{
    return WebInspector.TracingModel._flowEventsString.indexOf(phase) >= 0;
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @return {boolean}
 */
WebInspector.TracingModel.isTopLevelEvent = function(event)
{
    return event.hasCategory(WebInspector.TracingModel.TopLevelEventCategory) ||
        event.hasCategory(WebInspector.TracingModel.DevToolsMetadataEventCategory) && event.name === "Program"; // Older timelines may have this instead of toplevel.
}

/**
 * @interface
 */
WebInspector.BackingStorage = function()
{
}

WebInspector.BackingStorage.prototype = {
    /**
     * @param {string} string
     */
    appendString: function(string) { },

    /**
     * @param {string} string
     * @return {function():!Promise.<?string>}
     */
    appendAccessibleString: function(string) { },

    finishWriting: function() { },

    reset: function() { },
}


WebInspector.TracingModel.prototype = {
    /**
     * @return {!Array.<!WebInspector.TracingModel.Event>}
     */
    devToolsMetadataEvents: function()
    {
        return this._devToolsMetadataEvents;
    },

    /**
     * @param {!Array.<!WebInspector.TracingManager.EventPayload>} events
     */
    setEventsForTest: function(events)
    {
        this.reset();
        this.addEvents(events);
        this.tracingComplete();
    },

    /**
     * @param {!Array.<!WebInspector.TracingManager.EventPayload>} events
     */
    addEvents: function(events)
    {
        for (var i = 0; i < events.length; ++i)
            this._addEvent(events[i]);
    },

    tracingComplete: function()
    {
        this._processPendingAsyncEvents();
        this._backingStorage.finishWriting();
        for (var process of Object.values(this._processById)) {
            for (var thread of Object.values(process._threads))
                thread.tracingComplete();
        }
    },

    reset: function()
    {
        /** @type {!Object.<(number|string), !WebInspector.TracingModel.Process>} */
        this._processById = {};
        this._processByName = new Map();
        this._minimumRecordTime = 0;
        this._maximumRecordTime = 0;
        this._devToolsMetadataEvents = [];
        if (this._backingStorage)
            this._backingStorage.reset();
        this._appendDelimiter = false;
        /** @type {!Array<!WebInspector.TracingModel.Event>} */
        this._asyncEvents = [];
        /** @type {!Map<string, !WebInspector.TracingModel.AsyncEvent>} */
        this._openAsyncEvents = new Map();
        /** @type {!Map<string, !Array<!WebInspector.TracingModel.AsyncEvent>>} */
        this._openNestableAsyncEvents = new Map();
        /** @type {!Map<string, !Set<string>>} */
        this._parsedCategories = new Map();
    },

    /**
      * @param {!WebInspector.TracingManager.EventPayload} payload
      */
    _addEvent: function(payload)
    {
        var process = this._processById[payload.pid];
        if (!process) {
            process = new WebInspector.TracingModel.Process(this, payload.pid);
            this._processById[payload.pid] = process;
        }

        var eventsDelimiter = ",\n";
        if (this._appendDelimiter)
            this._backingStorage.appendString(eventsDelimiter);
        this._appendDelimiter = true;
        var stringPayload = JSON.stringify(payload);
        var isAccessible = payload.ph === WebInspector.TracingModel.Phase.SnapshotObject;
        var backingStorage = null;
        var keepStringsLessThan = 10000;
        if (isAccessible && stringPayload.length > keepStringsLessThan)
            backingStorage = this._backingStorage.appendAccessibleString(stringPayload);
        else
            this._backingStorage.appendString(stringPayload);

        var timestamp = payload.ts / 1000;
        // We do allow records for unrelated threads to arrive out-of-order,
        // so there's a chance we're getting records from the past.
        if (timestamp && (!this._minimumRecordTime || timestamp < this._minimumRecordTime))
            this._minimumRecordTime = timestamp;
        var endTimeStamp = (payload.ts + (payload.dur || 0)) / 1000;
        this._maximumRecordTime = Math.max(this._maximumRecordTime, endTimeStamp);
        var event = process._addEvent(payload);
        if (!event)
            return;
        // Build async event when we've got events from all threads & processes, so we can sort them and process in the
        // chronological order. However, also add individual async events to the thread flow (above), so we can easily
        // display them on the same chart as other events, should we choose so.
        if (WebInspector.TracingModel.isAsyncPhase(payload.ph))
            this._asyncEvents.push(event);
        event._setBackingStorage(backingStorage);
        if (event.hasCategory(WebInspector.TracingModel.DevToolsMetadataEventCategory))
            this._devToolsMetadataEvents.push(event);

        if (payload.ph !== WebInspector.TracingModel.Phase.Metadata)
            return;

        switch (payload.name) {
        case WebInspector.TracingModel.MetadataEvent.ProcessSortIndex:
            process._setSortIndex(payload.args["sort_index"]);
            break;
        case WebInspector.TracingModel.MetadataEvent.ProcessName:
            var processName = payload.args["name"];
            process._setName(processName);
            this._processByName.set(processName, process);
            break;
        case WebInspector.TracingModel.MetadataEvent.ThreadSortIndex:
            process.threadById(payload.tid)._setSortIndex(payload.args["sort_index"]);
            break;
        case WebInspector.TracingModel.MetadataEvent.ThreadName:
            process.threadById(payload.tid)._setName(payload.args["name"]);
            break;
        }
    },

    /**
     * @return {number}
     */
    minimumRecordTime: function()
    {
        return this._minimumRecordTime;
    },

    /**
     * @return {number}
     */
    maximumRecordTime: function()
    {
        return this._maximumRecordTime;
    },

    /**
     * @return {!Array.<!WebInspector.TracingModel.Process>}
     */
    sortedProcesses: function()
    {
        return WebInspector.TracingModel.NamedObject._sort(Object.values(this._processById));
    },

    /**
     * @param {string} name
     * @return {?WebInspector.TracingModel.Process}
     */
    processByName: function(name)
    {
        return this._processByName.get(name);
    },

    /**
     * @param {string} processName
     * @param {string} threadName
     * @return {?WebInspector.TracingModel.Thread}
     */
    threadByName: function(processName, threadName)
    {
        var process = this.processByName(processName);
        return process && process.threadByName(threadName);
    },

    _processPendingAsyncEvents: function()
    {
        this._asyncEvents.sort(WebInspector.TracingModel.Event.compareStartTime);
        for (var i = 0; i < this._asyncEvents.length; ++i) {
            var event = this._asyncEvents[i];
            if (WebInspector.TracingModel.isNestableAsyncPhase(event.phase))
                this._addNestableAsyncEvent(event);
            else
                this._addAsyncEvent(event);
        }
        this._asyncEvents = [];
        this._closeOpenAsyncEvents();
    },

    _closeOpenAsyncEvents: function()
    {
        for (var event of this._openAsyncEvents.values()) {
            event.setEndTime(this._maximumRecordTime);
            // FIXME: remove this once we figure a better way to convert async console
            // events to sync [waterfall] timeline records.
            event.steps[0].setEndTime(this._maximumRecordTime);
        }
        this._openAsyncEvents.clear();

        for (var eventStack of this._openNestableAsyncEvents.values()) {
            while (eventStack.length)
                eventStack.pop().setEndTime(this._maximumRecordTime);
        }
        this._openNestableAsyncEvents.clear();
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     */
    _addNestableAsyncEvent: function(event)
    {
        var phase = WebInspector.TracingModel.Phase;
        var key = event.categoriesString + "." + event.id;
        var openEventsStack = this._openNestableAsyncEvents.get(key);

        switch (event.phase) {
        case phase.NestableAsyncBegin:
            if (!openEventsStack) {
                openEventsStack = [];
                this._openNestableAsyncEvents.set(key, openEventsStack);
            }
            var asyncEvent = new WebInspector.TracingModel.AsyncEvent(event);
            openEventsStack.push(asyncEvent);
            event.thread._addAsyncEvent(asyncEvent);
            break;

        case phase.NestableAsyncInstant:
            if (openEventsStack && openEventsStack.length)
                openEventsStack.peekLast()._addStep(event);
            break;

        case phase.NestableAsyncEnd:
            if (!openEventsStack || !openEventsStack.length)
                break;
            var top = openEventsStack.pop();
            if (top.name !== event.name) {
                console.error("Begin/end event mismatch for nestable async event, " + top.name + " vs. " + event.name);
                break;
            }
            top._addStep(event);
        }
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     */
    _addAsyncEvent: function(event)
    {
        var phase = WebInspector.TracingModel.Phase;
        var key = event.categoriesString + "." + event.name + "." + event.id;
        var asyncEvent = this._openAsyncEvents.get(key);

        if (event.phase === phase.AsyncBegin) {
            if (asyncEvent) {
                console.error("Event " + event.name + " has already been started");
                return;
            }
            asyncEvent = new WebInspector.TracingModel.AsyncEvent(event);
            this._openAsyncEvents.set(key, asyncEvent);
            event.thread._addAsyncEvent(asyncEvent);
            return;
        }
        if (!asyncEvent) {
            // Quietly ignore stray async events, we're probably too late for the start.
            return;
        }
        if (event.phase === phase.AsyncEnd) {
            asyncEvent._addStep(event);
            this._openAsyncEvents.delete(key);
            return;
        }
        if (event.phase === phase.AsyncStepInto || event.phase === phase.AsyncStepPast) {
            var lastStep = asyncEvent.steps.peekLast();
            if (lastStep.phase !== phase.AsyncBegin && lastStep.phase !== event.phase) {
                console.assert(false, "Async event step phase mismatch: " + lastStep.phase + " at " + lastStep.startTime + " vs. " + event.phase + " at " + event.startTime);
                return;
            }
            asyncEvent._addStep(event);
            return;
        }
        console.assert(false, "Invalid async event phase");
    },

    /**
     * @param {string} str
     * @return {!Set<string>}
     */
    _parsedCategoriesForString: function(str)
    {
        var parsedCategories = this._parsedCategories.get(str);
        if (!parsedCategories) {
            parsedCategories = new Set(str.split(","));
            this._parsedCategories.set(str, parsedCategories);
        }
        return parsedCategories;
    }
}

/**
 * @constructor
 * @param {string} categories
 * @param {string} name
 * @param {!WebInspector.TracingModel.Phase} phase
 * @param {number} startTime
 * @param {!WebInspector.TracingModel.Thread} thread
 */
WebInspector.TracingModel.Event = function(categories, name, phase, startTime, thread)
{
    /** @type {string} */
    this.categoriesString = categories;
    /** @type {!Set<string>} */
    this._parsedCategories = thread._model._parsedCategoriesForString(categories);
    /** @type {string} */
    this.name = name;
    /** @type {!WebInspector.TracingModel.Phase} */
    this.phase = phase;
    /** @type {number} */
    this.startTime = startTime;
    /** @type {!WebInspector.TracingModel.Thread} */
    this.thread = thread;
    /** @type {!Object} */
    this.args = {};

    /** @type {?string} */
    this.warning = null;
    /** @type {?WebInspector.TracingModel.Event} */
    this.initiator = null;
    /** @type {?Array.<!RuntimeAgent.CallFrame>} */
    this.stackTrace = null;
    /** @type {?Element} */
    this.previewElement = null;
    /** @type {?string} */
    this.url = null;
    /** @type {number} */
    this.backendNodeId = 0;

    /** @type {number} */
    this.selfTime = 0;
}

/**
 * @param {!WebInspector.TracingManager.EventPayload} payload
 * @param {!WebInspector.TracingModel.Thread} thread
 * @return {!WebInspector.TracingModel.Event}
 */
WebInspector.TracingModel.Event.fromPayload = function(payload, thread)
{
    var event = new WebInspector.TracingModel.Event(payload.cat, payload.name, /** @type {!WebInspector.TracingModel.Phase} */ (payload.ph), payload.ts / 1000, thread);
    if (payload.args)
        event.addArgs(payload.args);
    else
        console.error("Missing mandatory event argument 'args' at " + payload.ts / 1000);
    if (typeof payload.dur === "number")
        event.setEndTime((payload.ts + payload.dur) / 1000);
    if (payload.id)
        event.id = payload.id;
    if (payload.bind_id)
        event.bind_id = payload.bind_id;

    return event;
}

WebInspector.TracingModel.Event.prototype = {
    /**
     * @param {string} categoryName
     * @return {boolean}
     */
    hasCategory: function(categoryName)
    {
        return this._parsedCategories.has(categoryName);
    },

    /**
     * @param {number} endTime
     */
    setEndTime: function(endTime)
    {
        if (endTime < this.startTime) {
            console.assert(false, "Event out of order: " + this.name);
            return;
        }
        this.endTime = endTime;
        this.duration = endTime - this.startTime;
    },

    /**
     * @param {!Object} args
     */
    addArgs: function(args)
    {
        // Shallow copy args to avoid modifying original payload which may be saved to file.
        for (var name in args) {
            if (name in this.args)
                console.error("Same argument name (" + name +  ") is used for begin and end phases of " + this.name);
            this.args[name] = args[name];
        }
    },

    /**
     * @param {!WebInspector.TracingModel.Event} endEvent
     */
    _complete: function(endEvent)
    {
        if (endEvent.args)
            this.addArgs(endEvent.args);
        else
            console.error("Missing mandatory event argument 'args' at " + endEvent.startTime);
        this.setEndTime(endEvent.startTime);
    },

    /**
     * @param {?function():!Promise.<?string>} backingStorage
     */
    _setBackingStorage: function(backingStorage)
    {
    }
}

/**
 * @param {!WebInspector.TracingModel.Event} a
 * @param {!WebInspector.TracingModel.Event} b
 * @return {number}
 */
WebInspector.TracingModel.Event.compareStartTime = function (a, b)
{
    return a.startTime - b.startTime;
}

/**
 * @param {!WebInspector.TracingModel.Event} a
 * @param {!WebInspector.TracingModel.Event} b
 * @return {number}
 */
WebInspector.TracingModel.Event.compareStartAndEndTime = function (a, b)
{
    return a.startTime - b.startTime || (b.endTime != undefined && a.endTime !== undefined && b.endTime - a.endTime) || 0;
}

/**
 * @param {!WebInspector.TracingModel.Event} a
 * @param {!WebInspector.TracingModel.Event} b
 * @return {number}
 */
WebInspector.TracingModel.Event.orderedCompareStartTime = function (a, b)
{
    // Array.mergeOrdered coalesces objects if comparator returns 0.
    // To change this behavior this comparator return -1 in the case events
    // startTime's are equal, so both events got placed into the result array.
    return a.startTime - b.startTime || a.ordinal - b.ordinal || -1;
}

/**
 * @constructor
 * @extends {WebInspector.TracingModel.Event}
 * @param {string} category
 * @param {string} name
 * @param {number} startTime
 * @param {!WebInspector.TracingModel.Thread} thread
 */
WebInspector.TracingModel.ObjectSnapshot = function(category, name, startTime, thread)
{
    WebInspector.TracingModel.Event.call(this, category, name, WebInspector.TracingModel.Phase.SnapshotObject, startTime, thread);
}

/**
 * @param {!WebInspector.TracingManager.EventPayload} payload
 * @param {!WebInspector.TracingModel.Thread} thread
 * @return {!WebInspector.TracingModel.ObjectSnapshot}
 */
WebInspector.TracingModel.ObjectSnapshot.fromPayload = function(payload, thread)
{
    var snapshot = new WebInspector.TracingModel.ObjectSnapshot(payload.cat, payload.name, payload.ts / 1000, thread);
    if (payload.id)
        snapshot.id = payload.id;
    if (!payload.args || !payload.args["snapshot"]) {
        console.error("Missing mandatory 'snapshot' argument at " + payload.ts / 1000);
        return snapshot;
    }
    if (payload.args)
        snapshot.addArgs(payload.args);
    return snapshot;
}

WebInspector.TracingModel.ObjectSnapshot.prototype = {
    /**
     * @param {function(?)} callback
     */
    requestObject: function(callback)
    {
        var snapshot = this.args["snapshot"];
        if (snapshot) {
            callback(snapshot);
            return;
        }
        this._backingStorage().then(onRead, callback.bind(null, null));
        /**
         * @param {?string} result
         */
        function onRead(result)
        {
            if (!result) {
                callback(null);
                return;
            }
            try {
                var payload = JSON.parse(result);
                callback(payload["args"]["snapshot"]);
            } catch (e) {
                WebInspector.console.error("Malformed event data in backing storage");
                callback(null);
            }
        }
    },

    /**
     * @return {!Promise<?>}
     */
    objectPromise: function()
    {
        if (!this._objectPromise)
            this._objectPromise = new Promise(this.requestObject.bind(this));
        return this._objectPromise;
    },

    /**
     * @override
     * @param {?function():!Promise.<?>} backingStorage
     */
    _setBackingStorage: function(backingStorage)
    {
        if (!backingStorage)
            return;
        this._backingStorage = backingStorage;
        this.args = {};
    },

    __proto__: WebInspector.TracingModel.Event.prototype
}

/**
 * @constructor
 * @param {!WebInspector.TracingModel.Event} startEvent
 * @extends {WebInspector.TracingModel.Event}
 */
WebInspector.TracingModel.AsyncEvent = function(startEvent)
{
    WebInspector.TracingModel.Event.call(this, startEvent.categoriesString, startEvent.name, startEvent.phase, startEvent.startTime, startEvent.thread)
    this.addArgs(startEvent.args);
    this.steps = [startEvent];
}

WebInspector.TracingModel.AsyncEvent.prototype = {
    /**
     * @param {!WebInspector.TracingModel.Event} event
     */
    _addStep: function(event)
    {
        this.steps.push(event)
        if (event.phase === WebInspector.TracingModel.Phase.AsyncEnd || event.phase === WebInspector.TracingModel.Phase.NestableAsyncEnd) {
            this.setEndTime(event.startTime);
            // FIXME: ideally, we shouldn't do this, but this makes the logic of converting
            // async console events to sync ones much simpler.
            this.steps[0].setEndTime(event.startTime);
        }
    },

    __proto__: WebInspector.TracingModel.Event.prototype
}

/**
 * @constructor
 */
WebInspector.TracingModel.NamedObject = function()
{
}

WebInspector.TracingModel.NamedObject.prototype =
{
    /**
     * @param {string} name
     */
    _setName: function(name)
    {
        this._name = name;
    },

    /**
     * @return {string}
     */
    name: function()
    {
        return this._name;
    },

    /**
     * @param {number} sortIndex
     */
    _setSortIndex: function(sortIndex)
    {
        this._sortIndex = sortIndex;
    },
}

/**
 * @param {!Array.<!WebInspector.TracingModel.NamedObject>} array
 */
WebInspector.TracingModel.NamedObject._sort = function(array)
{
    /**
     * @param {!WebInspector.TracingModel.NamedObject} a
     * @param {!WebInspector.TracingModel.NamedObject} b
     */
    function comparator(a, b)
    {
        return a._sortIndex !== b._sortIndex ? a._sortIndex - b._sortIndex : a.name().localeCompare(b.name());
    }
    return array.sort(comparator);
}

/**
 * @constructor
 * @extends {WebInspector.TracingModel.NamedObject}
 * @param {!WebInspector.TracingModel} model
 * @param {number} id
 */
WebInspector.TracingModel.Process = function(model, id)
{
    WebInspector.TracingModel.NamedObject.call(this);
    this._setName("Process " + id);
    this._id = id;
    /** @type {!Object.<number, !WebInspector.TracingModel.Thread>} */
    this._threads = {};
    this._threadByName = new Map();
    this._model = model;
}

WebInspector.TracingModel.Process.prototype = {
    /**
     * @return {number}
     */
    id: function()
    {
        return this._id;
    },

    /**
     * @param {number} id
     * @return {!WebInspector.TracingModel.Thread}
     */
    threadById: function(id)
    {
        var thread = this._threads[id];
        if (!thread) {
            thread = new WebInspector.TracingModel.Thread(this, id);
            this._threads[id] = thread;
        }
        return thread;
    },

    /**
     * @param {string} name
     * @return {?WebInspector.TracingModel.Thread}
     */
    threadByName: function(name)
    {
        return this._threadByName.get(name) || null;
    },

    /**
     * @param {string} name
     * @param {!WebInspector.TracingModel.Thread} thread
     */
    _setThreadByName: function(name, thread)
    {
        this._threadByName.set(name, thread);
    },

    /**
     * @param {!WebInspector.TracingManager.EventPayload} payload
     * @return {?WebInspector.TracingModel.Event} event
     */
    _addEvent: function(payload)
    {
        return this.threadById(payload.tid)._addEvent(payload);
    },

    /**
     * @return {!Array.<!WebInspector.TracingModel.Thread>}
     */
    sortedThreads: function()
    {
        return WebInspector.TracingModel.NamedObject._sort(Object.values(this._threads));
    },

    __proto__: WebInspector.TracingModel.NamedObject.prototype
}

/**
 * @constructor
 * @extends {WebInspector.TracingModel.NamedObject}
 * @param {!WebInspector.TracingModel.Process} process
 * @param {number} id
 */
WebInspector.TracingModel.Thread = function(process, id)
{
    WebInspector.TracingModel.NamedObject.call(this);
    this._process = process;
    this._setName("Thread " + id);
    this._events = [];
    this._asyncEvents = [];
    this._id = id;
    this._model = process._model;
}

WebInspector.TracingModel.Thread.prototype = {
    tracingComplete: function()
    {
        this._asyncEvents.stableSort(WebInspector.TracingModel.Event.compareStartAndEndTime);
        this._events.stableSort(WebInspector.TracingModel.Event.compareStartTime);
        var phases = WebInspector.TracingModel.Phase;
        var stack = [];
        for (var i = 0; i < this._events.length; ++i) {
            var e = this._events[i];
            e.ordinal = i;
            switch (e.phase) {
            case phases.End:
                this._events[i] = null;  // Mark for removal.
                // Quietly ignore unbalanced close events, they're legit (we could have missed start one).
                if (!stack.length)
                    continue;
                var top = stack.pop();
                if (top.name !== e.name || top.categoriesString !== e.categoriesString)
                    console.error("B/E events mismatch at " + top.startTime + " (" + top.name + ") vs. " + e.startTime + " (" + e.name + ")");
                else
                    top._complete(e);
                break;
            case phases.Begin:
                stack.push(e);
                break;
            }
        }
        this._events.remove(null, false);
    },

    /**
     * @param {!WebInspector.TracingManager.EventPayload} payload
     * @return {?WebInspector.TracingModel.Event} event
     */
    _addEvent: function(payload)
    {
        var event = payload.ph === WebInspector.TracingModel.Phase.SnapshotObject
            ? WebInspector.TracingModel.ObjectSnapshot.fromPayload(payload, this)
            : WebInspector.TracingModel.Event.fromPayload(payload, this);
        if (WebInspector.TracingModel.isTopLevelEvent(event)) {
            // Discard nested "top-level" events.
            if (this._lastTopLevelEvent && this._lastTopLevelEvent.endTime > event.startTime)
                return null;
            this._lastTopLevelEvent = event;
        }
        this._events.push(event);
        return event;
    },

    /**
     * @param {!WebInspector.TracingModel.AsyncEvent} asyncEvent
     */
    _addAsyncEvent: function(asyncEvent)
    {
        this._asyncEvents.push(asyncEvent);
    },

    /**
     * @override
     * @param {string} name
     */
    _setName: function(name)
    {
        WebInspector.TracingModel.NamedObject.prototype._setName.call(this, name);
        this._process._setThreadByName(name, this);
    },

    /**
     * @return {number}
     */
    id: function()
    {
        return this._id;
    },

    /**
     * @return {!WebInspector.TracingModel.Process}
     */
    process: function()
    {
        return this._process;
    },

    /**
     * @return {!Array.<!WebInspector.TracingModel.Event>}
     */
    events: function()
    {
        return this._events;
    },

    /**
     * @return {!Array.<!WebInspector.TracingModel.AsyncEvent>}
     */
    asyncEvents: function()
    {
        return this._asyncEvents;
    },

    __proto__: WebInspector.TracingModel.NamedObject.prototype
}
;/* WorkerManager.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!WebInspector.Target} target
 */
WebInspector.WorkerManager = function(target)
{
    WebInspector.SDKObject.call(this, target);
    target.registerWorkerDispatcher(new WebInspector.WorkerDispatcher(this));
    this._lastAnonymousTargetId = 0;
    /** @type {!Map.<string, !WebInspector.WorkerConnection>} */
    this._connections = new Map();

    /** @type {!Map.<string, !WebInspector.Target>} */
    this._targetsByWorkerId = new Map();

    WebInspector.targetManager.addEventListener(WebInspector.TargetManager.Events.SuspendStateChanged, this._onSuspendStateChanged, this);
    this._onSuspendStateChanged();
    this.enable();
}

WebInspector.WorkerManager.prototype = {
    enable: function()
    {
        if (this._enabled)
            return;
        this._enabled = true;

        this.target().workerAgent().enable();
        this.target().resourceTreeModel.addEventListener(WebInspector.TargetManager.Events.MainFrameNavigated, this._mainFrameNavigated, this);
    },

    disable: function()
    {
        if (!this._enabled)
            return;
        this._enabled = false;
        this._reset();
        this.target().workerAgent().disable();
        this.target().resourceTreeModel.removeEventListener(WebInspector.TargetManager.Events.MainFrameNavigated, this._mainFrameNavigated, this);
    },

    dispose: function()
    {
        this._reset();
    },

    _reset: function()
    {
        for (var connection of this._connections.values())
            connection._close();
        this._connections.clear();
        this._targetsByWorkerId.clear();
    },

    _onSuspendStateChanged: function()
    {
        var suspended = WebInspector.targetManager.allTargetsSuspended();
        this.target().workerAgent().setAutoconnectToWorkers(!suspended);
    },

    /**
     * @param {string} workerId
     * @param {string} url
     * @param {boolean} inspectorConnected
     */
    _workerCreated: function(workerId, url, inspectorConnected)
    {
        var connection = new WebInspector.WorkerConnection(this, workerId, inspectorConnected, onConnectionReady.bind(this));
        this._connections.set(workerId, connection);

        /**
         * @param {!InspectorBackendClass.Connection} connection
         * @this {WebInspector.WorkerManager}
         */
        function onConnectionReady(connection)
        {
            var parsedURL = url.asParsedURL();
            var workerName = parsedURL ? parsedURL.lastPathComponentWithFragment() : "#" + (++this._lastAnonymousTargetId);
            var target = WebInspector.targetManager.createTarget(workerName, WebInspector.Target.Type.DedicatedWorker, connection, this.target());
            this._targetsByWorkerId.set(workerId, target);

            if (inspectorConnected)
                target.runtimeAgent().isRunRequired(pauseInDebuggerAndRunIfRequired.bind(null, target));
        }

        /**
         * @param {!WebInspector.Target} target
         * @param {?Protocol.Error} error
         * @param {boolean} required
         */
        function pauseInDebuggerAndRunIfRequired(target, error, required)
        {
            // Only pause new worker if debugging SW - we are going through the
            // pause on start checkbox.
            var mainIsServiceWorker = WebInspector.targetManager.mainTarget().isServiceWorker();
            if (mainIsServiceWorker && required)
                target.debuggerAgent().pause();
            target.runtimeAgent().run();
        }
    },

    /**
     * @param {string} workerId
     */
    _workerTerminated: function(workerId)
    {
        var connection = this._connections.get(workerId);
        if (connection)
            connection._close();
        this._connections.delete(workerId);
        this._targetsByWorkerId.delete(workerId);
    },

    /**
     * @param {string} workerId
     * @param {string} message
     */
    _dispatchMessageFromWorker: function(workerId, message)
    {
        var connection = this._connections.get(workerId);
        if (connection)
            connection.dispatch(message);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _mainFrameNavigated: function(event)
    {
        this._reset();
    },

    /**
     * @param {string} workerId
     * @return {?WebInspector.Target}
     */
    targetByWorkerId: function(workerId)
    {
        return this._targetsByWorkerId.get(workerId) || null;
    },

    __proto__: WebInspector.SDKObject.prototype
}

/**
 * @constructor
 * @implements {WorkerAgent.Dispatcher}
 */
WebInspector.WorkerDispatcher = function(workerManager)
{
    this._workerManager = workerManager;
}

WebInspector.WorkerDispatcher.prototype = {
    /**
     * @override
     * @param {string} workerId
     * @param {string} url
     * @param {boolean} inspectorConnected
     */
    workerCreated: function(workerId, url, inspectorConnected)
    {
        this._workerManager._workerCreated(workerId, url, inspectorConnected);
    },

    /**
     * @override
     * @param {string} workerId
     */
    workerTerminated: function(workerId)
    {
        this._workerManager._workerTerminated(workerId);
    },

    /**
     * @override
     * @param {string} workerId
     * @param {string} message
     */
    dispatchMessageFromWorker: function(workerId, message)
    {
        this._workerManager._dispatchMessageFromWorker(workerId, message);
    }
}

/**
 * @constructor
 * @extends {InspectorBackendClass.Connection}
 * @param {!WebInspector.WorkerManager} workerManager
 * @param {string} workerId
 * @param {boolean} inspectorConnected
 * @param {function(!InspectorBackendClass.Connection)} onConnectionReady
 */
WebInspector.WorkerConnection = function(workerManager, workerId, inspectorConnected, onConnectionReady)
{
    InspectorBackendClass.Connection.call(this);
    //FIXME: remove resourceTreeModel and others from worker targets
    this.suppressErrorsForDomains(["Worker", "Page", "CSS", "DOM", "DOMStorage", "Database", "Network", "IndexedDB"]);
    this._agent = workerManager.target().workerAgent();
    this._workerId = workerId;


    if (!inspectorConnected)
        this._agent.connectToWorker(workerId, onConnectionReady.bind(null, this));
    else
        onConnectionReady.call(null, this);
}

WebInspector.WorkerConnection.prototype = {
    /**
     * @override
     * @param {!Object} messageObject
     */
    sendMessage: function(messageObject)
    {
        this._agent.sendMessageToWorker(this._workerId, JSON.stringify(messageObject));
    },

    _close: function()
    {
        this.connectionClosed("worker_terminated");
    },

    __proto__: InspectorBackendClass.Connection.prototype
}
;/* RuntimeModel.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKModel}
 * @param {!WebInspector.Target} target
 */
WebInspector.RuntimeModel = function(target)
{
    WebInspector.SDKModel.call(this, WebInspector.RuntimeModel, target);

    this._agent = target.runtimeAgent();
    this.target().registerRuntimeDispatcher(new WebInspector.RuntimeDispatcher(this));
    if (target.hasJSContext())
        this._agent.enable();
    /**
     * @type {!Object.<number, !WebInspector.ExecutionContext>}
     */
    this._executionContextById = {};

    if (WebInspector.moduleSetting("customFormatters").get())
        this._agent.setCustomObjectFormatterEnabled(true);

    WebInspector.moduleSetting("customFormatters").addChangeListener(this._customFormattersStateChanged.bind(this));
}

WebInspector.RuntimeModel.Events = {
    ExecutionContextCreated: "ExecutionContextCreated",
    ExecutionContextDestroyed: "ExecutionContextDestroyed",
}

WebInspector.RuntimeModel._privateScript = "private script";

WebInspector.RuntimeModel.prototype = {

    /**
     * @return {!Array.<!WebInspector.ExecutionContext>}
     */
    executionContexts: function()
    {
        return Object.values(this._executionContextById);
    },

    /**
     * @param {!RuntimeAgent.ExecutionContextId} id
     * @return {?WebInspector.ExecutionContext}
     */
    executionContext: function(id)
    {
        return this._executionContextById[id] || null;
    },

    /**
     * @param {!RuntimeAgent.ExecutionContextDescription} context
     */
    _executionContextCreated: function(context)
    {
        // The private script context should be hidden behind an experiment.
        if (context.name == WebInspector.RuntimeModel._privateScript && !context.origin && !Runtime.experiments.isEnabled("privateScriptInspection")) {
            return;
        }
        var executionContext = new WebInspector.ExecutionContext(this.target(), context.id, context.name, context.origin, !context.type, context.frameId);
        this._executionContextById[executionContext.id] = executionContext;
        this.dispatchEventToListeners(WebInspector.RuntimeModel.Events.ExecutionContextCreated, executionContext);
    },

    /**
     * @param {number} executionContextId
     */
    _executionContextDestroyed: function(executionContextId)
    {
        var executionContext = this._executionContextById[executionContextId];
        if (!executionContext)
            return;
        delete this._executionContextById[executionContextId];
        this.dispatchEventToListeners(WebInspector.RuntimeModel.Events.ExecutionContextDestroyed, executionContext);
    },

    _executionContextsCleared: function()
    {
        var contexts = this.executionContexts();
        this._executionContextById = {};
        for (var  i = 0; i < contexts.length; ++i)
            this.dispatchEventToListeners(WebInspector.RuntimeModel.Events.ExecutionContextDestroyed, contexts[i]);
    },

    /**
     * @param {!RuntimeAgent.RemoteObject} payload
     * @return {!WebInspector.RemoteObject}
     */
    createRemoteObject: function(payload)
    {
        console.assert(typeof payload === "object", "Remote object payload should only be an object");
        return new WebInspector.RemoteObjectImpl(this.target(), payload.objectId, payload.type, payload.subtype, payload.value, payload.description, payload.preview, payload.customPreview);
    },

    /**
     * @param {!RuntimeAgent.RemoteObject} payload
     * @param {!WebInspector.ScopeRef} scopeRef
     * @return {!WebInspector.RemoteObject}
     */
    createScopeRemoteObject: function(payload, scopeRef)
    {
        return new WebInspector.ScopeRemoteObject(this.target(), payload.objectId, scopeRef, payload.type, payload.subtype, payload.value, payload.description, payload.preview);
    },

    /**
     * @param {number|string|boolean} value
     * @return {!WebInspector.RemoteObject}
     */
    createRemoteObjectFromPrimitiveValue: function(value)
    {
        return new WebInspector.RemoteObjectImpl(this.target(), undefined, typeof value, undefined, value);
    },

    /**
     * @param {string} name
     * @param {number|string|boolean} value
     * @return {!WebInspector.RemoteObjectProperty}
     */
    createRemotePropertyFromPrimitiveValue: function(name, value)
    {
        return new WebInspector.RemoteObjectProperty(name, this.createRemoteObjectFromPrimitiveValue(value));
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _customFormattersStateChanged: function(event)
    {
        var enabled = /** @type {boolean} */ (event.data);
        this._agent.setCustomObjectFormatterEnabled(enabled);
    },

    /**
     * @param {string} expression
     * @param {string} sourceURL
     * @param {boolean} persistScript
     * @param {number} executionContextId
     * @param {function(!RuntimeAgent.ScriptId=, ?RuntimeAgent.ExceptionDetails=)=} callback
     */
    compileScript: function(expression, sourceURL, persistScript, executionContextId, callback)
    {
        this._agent.compileScript(expression, sourceURL, persistScript, executionContextId, innerCallback);

        /**
         * @param {?Protocol.Error} error
         * @param {!RuntimeAgent.ScriptId=} scriptId
         * @param {?RuntimeAgent.ExceptionDetails=} exceptionDetails
         */
        function innerCallback(error, scriptId, exceptionDetails)
        {
            if (error) {
                console.error(error);
                return;
            }
            if (callback)
                callback(scriptId, exceptionDetails);
        }
    },

    /**
     * @param {!RuntimeAgent.ScriptId} scriptId
     * @param {number} executionContextId
     * @param {string=} objectGroup
     * @param {boolean=} doNotPauseOnExceptionsAndMuteConsole
     * @param {boolean=} includeCommandLineAPI
     * @param {function(?RuntimeAgent.RemoteObject, ?RuntimeAgent.ExceptionDetails=)=} callback
     */
    runScript: function(scriptId, executionContextId, objectGroup, doNotPauseOnExceptionsAndMuteConsole, includeCommandLineAPI, callback)
    {
        this._agent.runScript(scriptId, executionContextId, objectGroup, doNotPauseOnExceptionsAndMuteConsole, includeCommandLineAPI, innerCallback);

        /**
         * @param {?Protocol.Error} error
         * @param {?RuntimeAgent.RemoteObject} result
         * @param {?RuntimeAgent.ExceptionDetails=} exceptionDetails
         */
        function innerCallback(error, result, exceptionDetails)
        {
            if (error) {
                console.error(error);
                return;
            }
            if (callback)
                callback(result, exceptionDetails);
        }
    },

    __proto__: WebInspector.SDKModel.prototype
}

/**
 * @constructor
 * @implements {RuntimeAgent.Dispatcher}
 * @param {!WebInspector.RuntimeModel} runtimeModel
 */
WebInspector.RuntimeDispatcher = function(runtimeModel)
{
    this._runtimeModel = runtimeModel;
}

WebInspector.RuntimeDispatcher.prototype = {
    /**
     * @override
     * @param {!RuntimeAgent.ExecutionContextDescription} context
     */
    executionContextCreated: function(context)
    {
        this._runtimeModel._executionContextCreated(context);
    },

    /**
     * @override
     * @param {!RuntimeAgent.ExecutionContextId} executionContextId
     */
    executionContextDestroyed: function(executionContextId)
    {
        this._runtimeModel._executionContextDestroyed(executionContextId);
    },

    /**
     * @override
     */
    executionContextsCleared: function()
    {
        this._runtimeModel._executionContextsCleared();
    }

}

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!WebInspector.Target} target
 * @param {number} id
 * @param {string} name
 * @param {string} origin
 * @param {boolean} isPageContext
 * @param {string=} frameId
 */
WebInspector.ExecutionContext = function(target, id, name, origin, isPageContext, frameId)
{
    WebInspector.SDKObject.call(this, target);
    this.id = id;
    this.name = name;
    this.origin = origin;
    this.isMainWorldContext = isPageContext;
    this.runtimeModel = target.runtimeModel;
    this.debuggerModel = WebInspector.DebuggerModel.fromTarget(target);
    this.frameId = frameId;
}

/**
 * @param {!WebInspector.ExecutionContext} a
 * @param {!WebInspector.ExecutionContext} b
 * @return {number}
 */
WebInspector.ExecutionContext.comparator = function(a, b)
{
    /**
     * @param {!WebInspector.Target} target
     * @return {number}
     */
    function targetWeight(target)
    {
        if (target.isPage())
            return 3;
        if (target.isDedicatedWorker())
            return 2;
        return 1;
    }

    var weightDiff = targetWeight(a.target()) - targetWeight(b.target());
    if (weightDiff)
        return -weightDiff;

    var frameIdDiff = String.hashCode(a.frameId) - String.hashCode(b.frameId);
    if (frameIdDiff)
        return frameIdDiff;

    // Main world context should always go first.
    if (a.isMainWorldContext)
        return -1;
    if (b.isMainWorldContext)
        return +1;
    return a.name.localeCompare(b.name);
}

WebInspector.ExecutionContext.prototype = {
    /**
     * @param {string} expression
     * @param {string} objectGroup
     * @param {boolean} includeCommandLineAPI
     * @param {boolean} doNotPauseOnExceptionsAndMuteConsole
     * @param {boolean} returnByValue
     * @param {boolean} generatePreview
     * @param {function(?WebInspector.RemoteObject, boolean, ?RuntimeAgent.RemoteObject=, ?RuntimeAgent.ExceptionDetails=)} callback
     */
    evaluate: function(expression, objectGroup, includeCommandLineAPI, doNotPauseOnExceptionsAndMuteConsole, returnByValue, generatePreview, callback)
    {
        // FIXME: It will be moved to separate ExecutionContext.
        if (this.debuggerModel.selectedCallFrame()) {
            this.debuggerModel.evaluateOnSelectedCallFrame(expression, objectGroup, includeCommandLineAPI, doNotPauseOnExceptionsAndMuteConsole, returnByValue, generatePreview, callback);
            return;
        }
        this._evaluateGlobal.apply(this, arguments);
    },

    /**
     * @param {string} objectGroup
     * @param {boolean} returnByValue
     * @param {boolean} generatePreview
     * @param {function(?WebInspector.RemoteObject, boolean, ?RuntimeAgent.RemoteObject=, ?RuntimeAgent.ExceptionDetails=)} callback
     */
    globalObject: function(objectGroup, returnByValue, generatePreview, callback)
    {
        this._evaluateGlobal("this", objectGroup, false, true, returnByValue, generatePreview, callback);
    },

    /**
     * @param {string} expression
     * @param {string} objectGroup
     * @param {boolean} includeCommandLineAPI
     * @param {boolean} doNotPauseOnExceptionsAndMuteConsole
     * @param {boolean} returnByValue
     * @param {boolean} generatePreview
     * @param {function(?WebInspector.RemoteObject, boolean, ?RuntimeAgent.RemoteObject=, ?RuntimeAgent.ExceptionDetails=)} callback
     */
    _evaluateGlobal: function(expression, objectGroup, includeCommandLineAPI, doNotPauseOnExceptionsAndMuteConsole, returnByValue, generatePreview, callback)
    {
        if (!expression) {
            // There is no expression, so the completion should happen against global properties.
            expression = "this";
        }

        /**
         * @this {WebInspector.ExecutionContext}
         * @param {?Protocol.Error} error
         * @param {!RuntimeAgent.RemoteObject} result
         * @param {boolean=} wasThrown
         * @param {?RuntimeAgent.ExceptionDetails=} exceptionDetails
         */
        function evalCallback(error, result, wasThrown, exceptionDetails)
        {
            if (error) {
                console.error(error);
                callback(null, false);
                return;
            }

            if (returnByValue)
                callback(null, !!wasThrown, wasThrown ? null : result, exceptionDetails);
            else
                callback(this.runtimeModel.createRemoteObject(result), !!wasThrown, undefined, exceptionDetails);
        }
        this.target().runtimeAgent().evaluate(expression, objectGroup, includeCommandLineAPI, doNotPauseOnExceptionsAndMuteConsole, this.id, returnByValue, generatePreview, evalCallback.bind(this));
    },

    /**
     * @param {string} expressionString
     * @param {string} text
     * @param {number} cursorOffset
     * @param {string} prefix
     * @param {boolean} force
     * @param {function(!Array.<string>, number=)} completionsReadyCallback
     */
    completionsForExpression: function(expressionString, text, cursorOffset, prefix, force, completionsReadyCallback)
    {
        var lastIndex = expressionString.length - 1;

        var dotNotation = (expressionString[lastIndex] === ".");
        var bracketNotation = (expressionString[lastIndex] === "[");

        if (dotNotation || bracketNotation)
            expressionString = expressionString.substr(0, lastIndex);

        if (expressionString && parseInt(expressionString, 10) == expressionString) {
            // User is entering float value, do not suggest anything.
            completionsReadyCallback([]);
            return;
        }

        if (!prefix && !expressionString && !force) {
            completionsReadyCallback([]);
            return;
        }

        if (!expressionString && this.debuggerModel.selectedCallFrame())
            this.debuggerModel.selectedCallFrame().variableNames(receivedPropertyNames.bind(this));
        else
            this.evaluate(expressionString, "completion", true, true, false, false, evaluated.bind(this));

        /**
         * @this {WebInspector.ExecutionContext}
         */
        function evaluated(result, wasThrown)
        {
            if (!result || wasThrown) {
                completionsReadyCallback([]);
                return;
            }

            /**
             * @param {string=} type
             * @suppressReceiverCheck
             * @this {WebInspector.ExecutionContext}
             */
            function getCompletions(type)
            {
                var object;
                if (type === "string")
                    object = new String("");
                else if (type === "number")
                    object = new Number(0);
                else if (type === "boolean")
                    object = new Boolean(false);
                else
                    object = this;

                var resultSet = {};
                for (var o = object; o; o = o.__proto__) {
                    try {
                        if (type === "array" && o === object && ArrayBuffer.isView(o) && o.length > 9999)
                            continue;
                        var names = Object.getOwnPropertyNames(o);
                        var isArray = Array.isArray(o);
                        for (var i = 0; i < names.length; ++i) {
                            // Skip array elements indexes.
                            if (isArray && /^[0-9]/.test(names[i]))
                                continue;
                            resultSet[names[i]] = true;
                        }
                    } catch (e) {
                    }
                }
                return resultSet;
            }

            if (result.type === "object" || result.type === "function")
                result.callFunctionJSON(getCompletions, [WebInspector.RemoteObject.toCallArgument(result.subtype)], receivedPropertyNames.bind(this));
            else if (result.type === "string" || result.type === "number" || result.type === "boolean")
                this.evaluate("(" + getCompletions + ")(\"" + result.type + "\")", "completion", false, true, true, false, receivedPropertyNamesFromEval.bind(this));
        }

        /**
         * @param {?WebInspector.RemoteObject} notRelevant
         * @param {boolean} wasThrown
         * @param {?RuntimeAgent.RemoteObject=} result
         * @this {WebInspector.ExecutionContext}
         */
        function receivedPropertyNamesFromEval(notRelevant, wasThrown, result)
        {
            if (result && !wasThrown)
                receivedPropertyNames.call(this, result.value);
            else
                completionsReadyCallback([]);
        }

        /**
         * @this {WebInspector.ExecutionContext}
         */
        function receivedPropertyNames(propertyNames)
        {
            this.target().runtimeAgent().releaseObjectGroup("completion");
            if (!propertyNames) {
                completionsReadyCallback([]);
                return;
            }
            var includeCommandLineAPI = (!dotNotation && !bracketNotation);
            if (includeCommandLineAPI) {
                const commandLineAPI = ["dir", "dirxml", "keys", "values", "profile", "profileEnd", "monitorEvents", "unmonitorEvents", "inspect", "copy", "clear",
                    "getEventListeners", "debug", "undebug", "monitor", "unmonitor", "table", "$", "$$", "$x"];
                for (var i = 0; i < commandLineAPI.length; ++i)
                    propertyNames[commandLineAPI[i]] = true;
            }
            this._reportCompletions(completionsReadyCallback, dotNotation, bracketNotation, expressionString, prefix, Object.keys(propertyNames));
        }
    },

    /**
     * @param {function(!Array.<string>, number=)} completionsReadyCallback
     * @param {boolean} dotNotation
     * @param {boolean} bracketNotation
     * @param {string} expressionString
     * @param {string} prefix
     * @param {!Array.<string>} properties
     */
    _reportCompletions: function(completionsReadyCallback, dotNotation, bracketNotation, expressionString, prefix, properties) {
        if (bracketNotation) {
            if (prefix.length && prefix[0] === "'")
                var quoteUsed = "'";
            else
                var quoteUsed = "\"";
        }

        var results = [];

        if (!expressionString) {
            const keywords = ["break", "case", "catch", "continue", "default", "delete", "do", "else", "finally", "for", "function", "if", "in",
                              "instanceof", "new", "return", "switch", "this", "throw", "try", "typeof", "var", "void", "while", "with"];
            properties = properties.concat(keywords);
        }

        properties.sort();

        for (var i = 0; i < properties.length; ++i) {
            var property = properties[i];

            // Assume that all non-ASCII characters are letters and thus can be used as part of identifier.
            if (dotNotation && !/^[a-zA-Z_$\u008F-\uFFFF][a-zA-Z0-9_$\u008F-\uFFFF]*$/.test(property))
                continue;

            if (bracketNotation) {
                if (!/^[0-9]+$/.test(property))
                    property = quoteUsed + property.escapeCharacters(quoteUsed + "\\") + quoteUsed;
                property += "]";
            }

            if (property.length < prefix.length)
                continue;
            if (prefix.length && !property.startsWith(prefix))
                continue;

            // Substitute actual newlines with newline characters. @see crbug.com/498421
            results.push(property.split("\n").join("\\n"));
        }
        completionsReadyCallback(results);
    },

    __proto__: WebInspector.SDKObject.prototype
}

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!WebInspector.Target} target
 * @param {string} type
 * @param {boolean} useCapture
 * @param {?WebInspector.RemoteObject} handler
 * @param {?WebInspector.RemoteObject} originalHandler
 * @param {!WebInspector.DebuggerModel.Location} location
 * @param {?WebInspector.RemoteObject} removeFunction
 * @param {string=} listenerType
 */
WebInspector.EventListener = function(target, type, useCapture, handler, originalHandler, location, removeFunction, listenerType)
{
    WebInspector.SDKObject.call(this, target);
    this._type = type;
    this._useCapture = useCapture;
    this._handler = handler;
    this._originalHandler = originalHandler || handler;
    this._location = location;
    this._sourceURL = location.script().contentURL();
    this._removeFunction = removeFunction;
    this._listenerType = listenerType || "normal";
}

WebInspector.EventListener.prototype = {
    /**
     * @return {string}
     */
    type: function()
    {
        return this._type;
    },

    /**
     * @return {boolean}
     */
    useCapture: function()
    {
        return this._useCapture;
    },

    /**
     * @return {?WebInspector.RemoteObject}
     */
    handler: function()
    {
        return this._handler;
    },

    /**
     * @return {!WebInspector.DebuggerModel.Location}
     */
    location: function()
    {
        return this._location;
    },

    /**
     * @return {string}
     */
    sourceURL: function()
    {
        return this._sourceURL;
    },

    /**
     * @return {?WebInspector.RemoteObject}
     */
    originalHandler: function()
    {
        return this._originalHandler;
    },

    /**
     * @return {?WebInspector.RemoteObject}
     */
    removeFunction: function()
    {
        return this._removeFunction;
    },

    /**
     * @return {!Promise<undefined>}
     */
    remove: function()
    {
        if (!this._removeFunction)
            return Promise.resolve();
        return new Promise(promiseConstructor.bind(this));

        /**
         * @param {function()} success
         * @this {WebInspector.EventListener}
         */
        function promiseConstructor(success)
        {
            this._removeFunction.callFunction(callCustomRemove, [
                WebInspector.RemoteObject.toCallArgument(this._removeFunction),
                WebInspector.RemoteObject.toCallArgument(this._type),
                WebInspector.RemoteObject.toCallArgument(this._originalHandler),
                WebInspector.RemoteObject.toCallArgument(this._useCapture)
            ], success);

            /**
             * @param {function(string, function(), boolean)} func
             * @param {string} type
             * @param {function()} listener
             * @param {boolean} useCapture
             */
            function callCustomRemove(func, type, listener, useCapture)
            {
                func.call(null, type, listener, useCapture);
            }
        }
    },

    /**
     * @return {string}
     */
    listenerType: function()
    {
        return this._listenerType;
    },

    /**
     * @param {string} listenerType
     */
    setListenerType: function(listenerType)
    {
        this._listenerType = listenerType;
    },

    __proto__: WebInspector.SDKObject.prototype
}
;/* Script.js */
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @implements {WebInspector.ContentProvider}
 * @param {!WebInspector.DebuggerModel} debuggerModel
 * @param {string} scriptId
 * @param {string} sourceURL
 * @param {number} startLine
 * @param {number} startColumn
 * @param {number} endLine
 * @param {number} endColumn
 * @param {!RuntimeAgent.ExecutionContextId} executionContextId
 * @param {boolean} isContentScript
 * @param {boolean} isInternalScript
 * @param {boolean} isLiveEdit
 * @param {string=} sourceMapURL
 * @param {boolean=} hasSourceURL
 */
WebInspector.Script = function(debuggerModel, scriptId, sourceURL, startLine, startColumn, endLine, endColumn, executionContextId, isContentScript, isInternalScript, isLiveEdit, sourceMapURL, hasSourceURL)
{
    WebInspector.SDKObject.call(this, debuggerModel.target());
    this.debuggerModel = debuggerModel;
    this.scriptId = scriptId;
    this.sourceURL = sourceURL;
    this.lineOffset = startLine;
    this.columnOffset = startColumn;
    this.endLine = endLine;
    this.endColumn = endColumn;
    this._executionContextId = executionContextId;
    this._isContentScript = isContentScript;
    this._isInternalScript = isInternalScript;
    this._isLiveEdit = isLiveEdit;
    this.sourceMapURL = sourceMapURL;
    this.hasSourceURL = hasSourceURL;
}

WebInspector.Script.Events = {
    ScriptEdited: "ScriptEdited",
    SourceMapURLAdded: "SourceMapURLAdded"
}

WebInspector.Script.sourceURLRegex = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;

/**
 * @param {string} source
 * @return {string}
 */
WebInspector.Script._trimSourceURLComment = function(source)
{
    var sourceURLIndex = source.lastIndexOf("//# sourceURL=");
    if (sourceURLIndex === -1) {
        sourceURLIndex = source.lastIndexOf("//@ sourceURL=");
        if (sourceURLIndex === -1)
            return source;
    }
    var sourceURLLineIndex = source.lastIndexOf("\n", sourceURLIndex);
    if (sourceURLLineIndex === -1)
        return source;
    var sourceURLLine = source.substr(sourceURLLineIndex + 1).split("\n", 1)[0];
    if (sourceURLLine.search(WebInspector.Script.sourceURLRegex) === -1)
        return source;
    return source.substr(0, sourceURLLineIndex) + source.substr(sourceURLLineIndex + sourceURLLine.length + 1);
}


WebInspector.Script.prototype = {
    /**
     * @return {boolean}
     */
    isContentScript: function()
    {
        return this._isContentScript;
    },

    /**
     * @return {boolean}
     */
    isInternalScript: function()
    {
        return this._isInternalScript;
    },

    /**
     * @return {?WebInspector.ExecutionContext}
     */
    executionContext: function()
    {
        return this.target().runtimeModel.executionContext(this._executionContextId);
    },

    /**
     * @return {boolean}
     */
    isLiveEdit: function()
    {
        return this._isLiveEdit;
    },

    /**
     * @override
     * @return {string}
     */
    contentURL: function()
    {
        return this.sourceURL;
    },

    /**
     * @override
     * @return {!WebInspector.ResourceType}
     */
    contentType: function()
    {
        return WebInspector.resourceTypes.Script;
    },

    /**
     * @override
     * @return {!Promise<?string>}
     */
    requestContent: function()
    {
        if (this._source)
            return Promise.resolve(this._source);
        if (!this.scriptId)
            return Promise.resolve(/** @type {?string} */(""));

        var callback;
        var promise = new Promise(fulfill => callback = fulfill);
        this.target().debuggerAgent().getScriptSource(this.scriptId, didGetScriptSource.bind(this));
        return promise;

        /**
         * @this {WebInspector.Script}
         * @param {?Protocol.Error} error
         * @param {string} source
         */
        function didGetScriptSource(error, source)
        {
            this._source = WebInspector.Script._trimSourceURLComment(error ? "" : source);
            callback(this._source);
        }
    },

    /**
     * @override
     * @param {string} query
     * @param {boolean} caseSensitive
     * @param {boolean} isRegex
     * @param {function(!Array.<!DebuggerAgent.SearchMatch>)} callback
     */
    searchInContent: function(query, caseSensitive, isRegex, callback)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {!Array.<!DebuggerAgent.SearchMatch>} searchMatches
         */
        function innerCallback(error, searchMatches)
        {
            if (error) {
                console.error(error);
                callback([]);
                return;
            }
            var result = [];
            for (var i = 0; i < searchMatches.length; ++i) {
                var searchMatch = new WebInspector.ContentProvider.SearchMatch(searchMatches[i].lineNumber, searchMatches[i].lineContent);
                result.push(searchMatch);
            }
            callback(result || []);
        }

        if (this.scriptId) {
            // Script failed to parse.
            this.target().debuggerAgent().searchInContent(this.scriptId, query, caseSensitive, isRegex, innerCallback);
        } else {
            callback([]);
        }
    },

    /**
     * @param {string} source
     * @return {string}
     */
    _appendSourceURLCommentIfNeeded: function(source)
    {
        if (!this.hasSourceURL)
            return source;
        return source + "\n //# sourceURL=" + this.sourceURL;
    },

    /**
     * @param {string} newSource
     * @param {function(?Protocol.Error, !DebuggerAgent.SetScriptSourceError=, !Array.<!DebuggerAgent.CallFrame>=, !DebuggerAgent.StackTrace=, boolean=)} callback
     */
    editSource: function(newSource, callback)
    {
        /**
         * @this {WebInspector.Script}
         * @param {?Protocol.Error} error
         * @param {!Array.<!DebuggerAgent.CallFrame>=} callFrames
         * @param {boolean=} stackChanged
         * @param {!DebuggerAgent.StackTrace=} asyncStackTrace
         * @param {!DebuggerAgent.SetScriptSourceError=} compileError
         */
        function didEditScriptSource(error, callFrames, stackChanged, asyncStackTrace, compileError)
        {
            if (!error && !compileError)
                this._source = newSource;
            var needsStepIn = !!stackChanged;
            callback(error, compileError, callFrames, asyncStackTrace, needsStepIn);
        }

        newSource = WebInspector.Script._trimSourceURLComment(newSource);
        // We append correct sourceURL to script for consistency only. It's not actually needed for things to work correctly.
        newSource = this._appendSourceURLCommentIfNeeded(newSource);

        if (this.scriptId)
            this.target().debuggerAgent().setScriptSource(this.scriptId, newSource, undefined, didEditScriptSource.bind(this));
        else
            callback("Script failed to parse");
    },

    /**
     * @param {number} lineNumber
     * @param {number=} columnNumber
     * @return {!WebInspector.DebuggerModel.Location}
     */
    rawLocation: function(lineNumber, columnNumber)
    {
        return new WebInspector.DebuggerModel.Location(this.debuggerModel, this.scriptId, lineNumber, columnNumber || 0);
    },

    /**
     * @return {boolean}
     */
    isInlineScript: function()
    {
        var startsAtZero = !this.lineOffset && !this.columnOffset;
        return !!this.sourceURL && !startsAtZero;
    },

    /**
     * @param {string} sourceMapURL
     */
    addSourceMapURL: function(sourceMapURL)
    {
        if (this.sourceMapURL)
            return;
        this.sourceMapURL = sourceMapURL;
        this.dispatchEventToListeners(WebInspector.Script.Events.SourceMapURLAdded, this.sourceMapURL);
    },

    /**
     * @return {boolean}
     */
    isAnonymousScript: function()
    {
        return !this.sourceURL;
    },

    /**
     * @return {boolean}
     */
    isInlineScriptWithSourceURL: function()
    {
        return !!this.hasSourceURL && this.isInlineScript();
    },

    /**
     * @param {!Array<!DebuggerAgent.ScriptPosition>} positions
     * @return {!Promise<boolean>}
     */
    setBlackboxedRanges: function(positions)
    {
        return new Promise(setBlackboxedRanges.bind(this));

        /**
         * @param {function(?)} fulfill
         * @param {function(*)} reject
         * @this {WebInspector.Script}
         */
        function setBlackboxedRanges(fulfill, reject)
        {
            this.target().debuggerAgent().setBlackboxedRanges(this.scriptId, positions, callback);
            /**
             * @param {?Protocol.Error} error
             */
            function callback(error)
            {
                if (error)
                    console.error(error);
                fulfill(!error);
            }
        }
    },

    __proto__: WebInspector.SDKObject.prototype
}
;/* ServiceWorkerCacheModel.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Invariant: This model can only be constructed on a ServiceWorker target.
 * @constructor
 * @extends {WebInspector.SDKModel}
 */
WebInspector.ServiceWorkerCacheModel = function(target)
{
    WebInspector.SDKModel.call(this, WebInspector.ServiceWorkerCacheModel, target);

    /** @type {!Map<string, !WebInspector.ServiceWorkerCacheModel.Cache>} */
    this._caches = new Map();

    this._agent = target.cacheStorageAgent();

    /** @type {boolean} */
    this._enabled = false;
}

WebInspector.ServiceWorkerCacheModel.EventTypes = {
    CacheAdded: "CacheAdded",
    CacheRemoved: "CacheRemoved"
}

WebInspector.ServiceWorkerCacheModel.prototype = {
    enable: function()
    {
        if (this._enabled)
            return;

        this.target().resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.SecurityOriginAdded, this._securityOriginAdded, this);
        this.target().resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.SecurityOriginRemoved, this._securityOriginRemoved, this);

        var securityOrigins = this.target().resourceTreeModel.securityOrigins();
        for (var i = 0; i < securityOrigins.length; ++i)
            this._addOrigin(securityOrigins[i]);
        this._enabled = true;
    },

    refreshCacheNames: function()
    {
        var securityOrigins = this.target().resourceTreeModel.securityOrigins();
        for (var securityOrigin of securityOrigins)
            this._loadCacheNames(securityOrigin);
    },

    /**
     * @param {!WebInspector.ServiceWorkerCacheModel.Cache} cache
     */
    deleteCache: function(cache)
    {
        /**
         * @this {WebInspector.ServiceWorkerCacheModel}
         */
        function callback(error)
        {
            if (error) {
                console.error("ServiceWorkerCacheAgent error deleting cache ", cache.toString(), ": ", error);
                return;
            }
            this._caches.delete(cache.cacheId);
            this._cacheRemoved(cache);
        }
        this._agent.deleteCache(cache.cacheId, callback.bind(this));
    },

    /**
     * @param {!WebInspector.ServiceWorkerCacheModel.Cache} cache
     * @param {string} request
     * @param {function()} callback
     */
    deleteCacheEntry: function(cache, request, callback)
    {

        /**
         * @param {?Protocol.Error} error
         */
        function myCallback(error)
        {
            if (error) {
                WebInspector.console.error(WebInspector.UIString("ServiceWorkerCacheAgent error deleting cache entry %s in cache: %s", cache.toString(), error));
                return;
            }
            callback();
        }
        this._agent.deleteEntry(cache.cacheId, request, myCallback);
    },

    /**
     * @param {!WebInspector.ServiceWorkerCacheModel.Cache} cache
     * @param {number} skipCount
     * @param {number} pageSize
     * @param {function(!Array.<!WebInspector.ServiceWorkerCacheModel.Entry>, boolean)} callback
     */
    loadCacheData: function(cache, skipCount, pageSize, callback)
    {
        this._requestEntries(cache, skipCount, pageSize, callback);
    },

    /**
     * @return {!Array.<!WebInspector.ServiceWorkerCacheModel.Cache>}
     */
    caches: function()
    {
        var caches = new Array();
        for (var cache of this._caches.values())
            caches.push(cache);
        return caches;
    },

    dispose: function()
    {
        for (var cache of this._caches.values())
            this._cacheRemoved(cache);
        this._caches.clear();
        if (this._enabled) {
            this.target().resourceTreeModel.removeEventListener(WebInspector.ResourceTreeModel.EventTypes.SecurityOriginAdded, this._securityOriginAdded, this);
            this.target().resourceTreeModel.removeEventListener(WebInspector.ResourceTreeModel.EventTypes.SecurityOriginRemoved, this._securityOriginRemoved, this);
        }
    },

    _addOrigin: function(securityOrigin)
    {
        this._loadCacheNames(securityOrigin);
    },

    /**
     * @param {string} securityOrigin
     */
    _removeOrigin: function(securityOrigin)
    {
        for (var opaqueId of this._caches.keys()) {
            var cache = this._caches.get(opaqueId);
            if (cache.securityOrigin == securityOrigin) {
                this._caches.delete(opaqueId);
                this._cacheRemoved(cache);
            }
        }
    },

    /**
     * @param {string} securityOrigin
     */
    _loadCacheNames: function(securityOrigin)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {!Array.<!WebInspector.ServiceWorkerCacheModel.Cache>} caches
         * @this {WebInspector.ServiceWorkerCacheModel}
         */
        function callback(error, caches)
        {
            if (error) {
                console.error("ServiceWorkerCacheAgent error while loading caches: ", error);
                return;
            }
            this._updateCacheNames(securityOrigin, caches);
        }
        this._agent.requestCacheNames(securityOrigin, callback.bind(this));
    },

    /**
     * @param {string} securityOrigin
     * @param {!Array} cachesJson
     */
    _updateCacheNames: function(securityOrigin, cachesJson)
    {
        /**
         * @param {!WebInspector.ServiceWorkerCacheModel.Cache} cache
         * @this {WebInspector.ServiceWorkerCacheModel}
         */
        function deleteAndSaveOldCaches(cache)
        {
            if (cache.securityOrigin == securityOrigin && !updatingCachesIds.has(cache.cacheId)) {
                oldCaches.set(cache.cacheId, cache);
                this._caches.delete(cache.cacheId);
            }
        }

        /** @type {!Set<string>} */
        var updatingCachesIds = new Set();
        /** @type {!Map<string, !WebInspector.ServiceWorkerCacheModel.Cache>} */
        var newCaches = new Map();
        /** @type {!Map<string, !WebInspector.ServiceWorkerCacheModel.Cache>} */
        var oldCaches = new Map();

        for (var cacheJson of cachesJson) {
            var cache = new WebInspector.ServiceWorkerCacheModel.Cache(cacheJson.securityOrigin, cacheJson.cacheName, cacheJson.cacheId);
            updatingCachesIds.add(cache.cacheId);
            if (this._caches.has(cache.cacheId))
                continue;
            newCaches.set(cache.cacheId, cache);
            this._caches.set(cache.cacheId, cache);
        }
        this._caches.forEach(deleteAndSaveOldCaches, this);
        newCaches.forEach(this._cacheAdded, this);
        oldCaches.forEach(this._cacheRemoved, this);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _securityOriginAdded: function(event)
    {
        var securityOrigin = /** @type {string} */ (event.data);
        this._addOrigin(securityOrigin);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _securityOriginRemoved: function(event)
    {
        var securityOrigin = /** @type {string} */ (event.data);
        this._removeOrigin(securityOrigin);
    },

    /**
     * @param {!WebInspector.ServiceWorkerCacheModel.Cache} cache
     */
    _cacheAdded: function(cache)
    {
        this.dispatchEventToListeners(WebInspector.ServiceWorkerCacheModel.EventTypes.CacheAdded, cache);
    },

    /**
     * @param {!WebInspector.ServiceWorkerCacheModel.Cache} cache
     */
    _cacheRemoved: function(cache)
    {
        this.dispatchEventToListeners(WebInspector.ServiceWorkerCacheModel.EventTypes.CacheRemoved, cache);
    },

    /**
     * @param {!WebInspector.ServiceWorkerCacheModel.Cache} cache
     * @param {number} skipCount
     * @param {number} pageSize
     * @param {function(!Array.<!WebInspector.ServiceWorkerCacheModel.Entry>, boolean)} callback
     */
    _requestEntries: function(cache, skipCount, pageSize, callback)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {!Array.<!WebInspector.ServiceWorkerCacheModel.Entry>} dataEntries
         * @param {boolean} hasMore
         */
        function innerCallback(error, dataEntries, hasMore)
        {
            if (error) {
                console.error("ServiceWorkerCacheAgent error while requesting entries: ", error);
                return;
            }
            var entries = [];
            for (var i = 0; i < dataEntries.length; ++i) {
                entries.push(new WebInspector.ServiceWorkerCacheModel.Entry(dataEntries[i].request, dataEntries[i].response));
            }
            callback(entries, hasMore);
        }
        this._agent.requestEntries(cache.cacheId, skipCount, pageSize, innerCallback);
    },

    __proto__: WebInspector.SDKModel.prototype
}

/**
 * @constructor
 * @param {string} request
 * @param {string} response
 */
WebInspector.ServiceWorkerCacheModel.Entry = function(request, response)
{
    this.request = request;
    this.response = response;
}

/**
 * @constructor
 * @param {string} securityOrigin
 * @param {string} cacheName
 * @param {string} cacheId
 */
WebInspector.ServiceWorkerCacheModel.Cache = function(securityOrigin, cacheName, cacheId)
{
    this.securityOrigin = securityOrigin;
    this.cacheName = cacheName;
    this.cacheId = cacheId;
}

WebInspector.ServiceWorkerCacheModel.Cache.prototype = {
    /**
     * @param {!WebInspector.ServiceWorkerCacheModel.Cache} cache
     * @return {boolean}
     */
    equals: function(cache)
    {
        return this.cacheId == cache.cacheId;
    },

    /**
     * @override
     * @return {string}
     */
    toString: function()
    {
        return this.securityOrigin + this.cacheName;
    }
}


WebInspector.ServiceWorkerCacheModel._symbol = Symbol("CacheStorageModel");
/**
 * @param {!WebInspector.Target} target
 * @return {!WebInspector.ServiceWorkerCacheModel}
 */
WebInspector.ServiceWorkerCacheModel.fromTarget = function(target)
{
    if (!target[WebInspector.ServiceWorkerCacheModel._symbol])
        target[WebInspector.ServiceWorkerCacheModel._symbol] = new WebInspector.ServiceWorkerCacheModel(target);

    return target[WebInspector.ServiceWorkerCacheModel._symbol];
};/* RemoteObject.js */
/*
 * Copyright (C) 2009 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

 /**
 * @typedef {{object: ?WebInspector.RemoteObject, wasThrown: (boolean|undefined)}}
 */
WebInspector.CallFunctionResult;

/**
 * This may not be an interface due to "instanceof WebInspector.RemoteObject" checks in the code.
 *
 * @constructor
 */
WebInspector.RemoteObject = function() { }

WebInspector.RemoteObject.prototype = {

    /**
     * @return {?RuntimeAgent.CustomPreview}
     */
    customPreview: function()
    {
        return null;
    },

    /** @return {string} */
    get type()
    {
        throw "Not implemented";
    },

    /** @return {string|undefined} */
    get subtype()
    {
        throw "Not implemented";
    },

    /** @return {string|undefined} */
    get description()
    {
        throw "Not implemented";
    },

    /** @return {boolean} */
    get hasChildren()
    {
        throw "Not implemented";
    },

    /**
     * @return {number}
     */
    arrayLength: function()
    {
        throw "Not implemented";
    },

    /**
     * @param {function(?Array.<!WebInspector.RemoteObjectProperty>, ?Array.<!WebInspector.RemoteObjectProperty>)} callback
     */
    getOwnProperties: function(callback)
    {
        throw "Not implemented";
    },

    /**
     * @return {!Promise<!{properties: ?Array.<!WebInspector.RemoteObjectProperty>, internalProperties: ?Array.<!WebInspector.RemoteObjectProperty>}>}
     */
    getOwnPropertiesPromise: function()
    {
        return new Promise(promiseConstructor.bind(this));

        /**
         * @param {function(!{properties: ?Array.<!WebInspector.RemoteObjectProperty>, internalProperties: ?Array.<!WebInspector.RemoteObjectProperty>})} success
         * @this {WebInspector.RemoteObject}
         */
        function promiseConstructor(success)
        {
            this.getOwnProperties(getOwnPropertiesCallback.bind(null, success));
        }

        /**
         * @param {function(!{properties: ?Array.<!WebInspector.RemoteObjectProperty>, internalProperties: ?Array.<!WebInspector.RemoteObjectProperty>})} callback
         * @param {?Array.<!WebInspector.RemoteObjectProperty>} properties
         * @param {?Array.<!WebInspector.RemoteObjectProperty>} internalProperties
         */
        function getOwnPropertiesCallback(callback, properties, internalProperties)
        {
            callback({
                properties: properties,
                internalProperties: internalProperties
            });
        }
    },

    /**
     * @param {boolean} accessorPropertiesOnly
     * @param {function(?Array<!WebInspector.RemoteObjectProperty>, ?Array<!WebInspector.RemoteObjectProperty>)} callback
     */
    getAllProperties: function(accessorPropertiesOnly, callback)
    {
        throw "Not implemented";
    },

    /**
     * @param {boolean} accessorPropertiesOnly
     * @return {!Promise<!{properties: ?Array<!WebInspector.RemoteObjectProperty>, internalProperties: ?Array<!WebInspector.RemoteObjectProperty>}>}
     */
    getAllPropertiesPromise: function(accessorPropertiesOnly)
    {
        return new Promise(promiseConstructor.bind(this));

        /**
         * @param {function(!{properties: ?Array<!WebInspector.RemoteObjectProperty>, internalProperties: ?Array.<!WebInspector.RemoteObjectProperty>})} success
         * @this {WebInspector.RemoteObject}
         */
        function promiseConstructor(success)
        {
            this.getAllProperties(accessorPropertiesOnly, getAllPropertiesCallback.bind(null, success));
        }

        /**
         * @param {function(!{properties: ?Array<!WebInspector.RemoteObjectProperty>, internalProperties: ?Array<!WebInspector.RemoteObjectProperty>})} callback
         * @param {?Array<!WebInspector.RemoteObjectProperty>} properties
         * @param {?Array<!WebInspector.RemoteObjectProperty>} internalProperties
         */
        function getAllPropertiesCallback(callback, properties, internalProperties)
        {
            callback({
                properties: properties,
                internalProperties: internalProperties
            });
        }
    },

    /**
     * @return {!Promise<?Array<!WebInspector.EventListener>>}
     */
    eventListeners: function()
    {
        throw "Not implemented";
    },

    /**
     * @param {!RuntimeAgent.CallArgument} name
     * @param {function(string=)} callback
     */
    deleteProperty: function(name, callback)
    {
        throw "Not implemented";
    },

    /**
     * @param {function(this:Object, ...)} functionDeclaration
     * @param {!Array<!RuntimeAgent.CallArgument>=} args
     * @param {function(?WebInspector.RemoteObject, boolean=)=} callback
     */
    callFunction: function(functionDeclaration, args, callback)
    {
        throw "Not implemented";
    },

    /**
     * @param {function(this:Object, ...)} functionDeclaration
     * @param {!Array<!RuntimeAgent.CallArgument>=} args
     * @return {!Promise<!WebInspector.CallFunctionResult>}
     */
    callFunctionPromise: function(functionDeclaration, args)
    {
        return new Promise(promiseConstructor.bind(this));

        /**
         * @param {function(!WebInspector.CallFunctionResult)} success
         * @this {WebInspector.RemoteObject}
         */
        function promiseConstructor(success)
        {
            this.callFunction(functionDeclaration, args, callFunctionCallback.bind(null, success));
        }

        /**
         * @param {function(!WebInspector.CallFunctionResult)} callback
         * @param {?WebInspector.RemoteObject} object
         * @param {boolean=} wasThrown
         */
        function callFunctionCallback(callback, object, wasThrown)
        {
            callback({
                object: object,
                wasThrown: wasThrown
            });
        }
    },

    /**
     * @param {function(this:Object, ...)} functionDeclaration
     * @param {!Array<!RuntimeAgent.CallArgument>|undefined} args
     * @param {function(*)} callback
     */
    callFunctionJSON: function(functionDeclaration, args, callback)
    {
        throw "Not implemented";
    },

    /**
     * @param {function(this:Object, ...):T} functionDeclaration
     * @param {!Array<!RuntimeAgent.CallArgument>|undefined} args
     * @return {!Promise<T>}
     * @template T
     */
    callFunctionJSONPromise: function(functionDeclaration, args)
    {
        return new Promise(promiseConstructor.bind(this));

        /**
         * @this {WebInspector.RemoteObject}
         */
         function promiseConstructor(success)
         {
            this.callFunctionJSON(functionDeclaration, args, success);
         }
    },

    /**
     * @return {!WebInspector.Target}
     */
    target: function()
    {
        throw new Error("Target-less object");
    },

    /**
     * @return {?WebInspector.DebuggerModel}
     */
    debuggerModel: function()
    {
        throw new Error("DebuggerModel-less object");
    },

    /**
     * @return {boolean}
     */
    isNode: function()
    {
        return false;
    },

    /**
     * @param {function(?WebInspector.DebuggerModel.FunctionDetails)} callback
     */
    functionDetails: function(callback)
    {
        callback(null);
    },

    /**
     * @return {!Promise<?WebInspector.DebuggerModel.FunctionDetails>}
     */
    functionDetailsPromise: function()
    {
        return new Promise(promiseConstructor.bind(this));

        /**
         * @param {function(?WebInspector.DebuggerModel.FunctionDetails)} success
         * @this {WebInspector.RemoteObject}
         */
        function promiseConstructor(success)
        {
            this.functionDetails(success);
        }
    },

    /**
     * @param {function(?WebInspector.DebuggerModel.GeneratorObjectDetails)} callback
     */
    generatorObjectDetails: function(callback)
    {
        callback(null);
    },

    /**
     * @param {function(?Array<!DebuggerAgent.CollectionEntry>)} callback
     */
    collectionEntries: function(callback)
    {
        callback(null);
    }
}

/**
 * @param {*} value
 * @return {!WebInspector.RemoteObject}
 */
WebInspector.RemoteObject.fromLocalObject = function(value)
{
    return new WebInspector.LocalJSONObject(value);
}

/**
 * @param {!WebInspector.RemoteObject} remoteObject
 * @return {string}
 */
WebInspector.RemoteObject.type = function(remoteObject)
{
    if (remoteObject === null)
        return "null";

    var type = typeof remoteObject;
    if (type !== "object" && type !== "function")
        return type;

    return remoteObject.type;
}

/**
 * @param {!WebInspector.RemoteObject|!RuntimeAgent.RemoteObject|!RuntimeAgent.ObjectPreview} object
 * @return {number}
 */
WebInspector.RemoteObject.arrayLength = function(object)
{
    if (object.subtype !== "array")
        return 0;
    var matches = object.description.match(/\[([0-9]+)\]/);
    if (!matches)
        return 0;
    return parseInt(matches[1], 10);
}

/**
 * @param {!RuntimeAgent.RemoteObject|!WebInspector.RemoteObject|number|string|boolean|undefined|null} object
 * @return {!RuntimeAgent.CallArgument}
 */
WebInspector.RemoteObject.toCallArgument = function(object)
{
    var type = typeof object;
    var value = object;
    var objectId = undefined;
    var description = String(object);

    if (type === "number" && value === 0 && 1 / value < 0)
        description = "-0";

    switch (type) {
    case "number":
    case "string":
    case "boolean":
    case "undefined":
        break;
    default:
        if (object) {
            type = object.type;
            value = object.value;
            objectId = object.objectId;
            description = object.description;
        }
        break;
    }

    // Handle special numbers: NaN, Infinity, -Infinity, -0.
    if (type === "number") {
        switch (description) {
        case "NaN":
        case "Infinity":
        case "-Infinity":
        case "-0":
            value = description;
            break;
        }
    }

    return {
        value: value,
        objectId: objectId,
        type: /** @type {!RuntimeAgent.CallArgumentType.<string>} */ (type)
    };
}

/**
 * @constructor
 * @extends {WebInspector.RemoteObject}
 * @param {!WebInspector.Target} target
 * @param {string|undefined} objectId
 * @param {string} type
 * @param {string|undefined} subtype
 * @param {*} value
 * @param {string=} description
 * @param {!RuntimeAgent.ObjectPreview=} preview
 * @param {!RuntimeAgent.CustomPreview=} customPreview
 */
WebInspector.RemoteObjectImpl = function(target, objectId, type, subtype, value, description, preview, customPreview)
{
    WebInspector.RemoteObject.call(this);

    this._target = target;
    this._runtimeAgent = target.runtimeAgent();
    this._debuggerModel = WebInspector.DebuggerModel.fromTarget(target);

    this._type = type;
    this._subtype = subtype;
    if (objectId) {
        // handle
        this._objectId = objectId;
        this._description = description;
        this._hasChildren = (type !== "symbol");
        this._preview = preview;
    } else {
        // Primitive or null object.
        this._description = description || (value + "");
        this._hasChildren = false;
        // Handle special numbers: NaN, Infinity, -Infinity, -0.
        if (type === "number" && typeof value !== "number")
            this.value = Number(value);
        else
            this.value = value;
    }
    this._customPreview = customPreview || null;
}

WebInspector.RemoteObjectImpl.prototype = {

    /**
     * @override
     * @return {?RuntimeAgent.CustomPreview}
     */
    customPreview: function()
    {
        return this._customPreview;
    },

    /** @return {!RuntimeAgent.RemoteObjectId} */
    get objectId()
    {
        return this._objectId;
    },

    /**
     * @override
     * @return {string}
     */
    get type()
    {
        return this._type;
    },

    /**
     * @override
     * @return {string|undefined}
     */
    get subtype()
    {
        return this._subtype;
    },

    /**
     * @override
     * @return {string|undefined}
     */
    get description()
    {
        return this._description;
    },

    /**
     * @override
     * @return {boolean}
     */
    get hasChildren()
    {
        return this._hasChildren;
    },

    /**
     * @return {!RuntimeAgent.ObjectPreview|undefined}
     */
    get preview()
    {
        return this._preview;
    },

    /**
     * @override
     * @param {function(?Array.<!WebInspector.RemoteObjectProperty>, ?Array.<!WebInspector.RemoteObjectProperty>)} callback
     */
    getOwnProperties: function(callback)
    {
        this.doGetProperties(true, false, false, callback);
    },

    /**
     * @override
     * @param {boolean} accessorPropertiesOnly
     * @param {function(?Array.<!WebInspector.RemoteObjectProperty>, ?Array.<!WebInspector.RemoteObjectProperty>)} callback
     */
    getAllProperties: function(accessorPropertiesOnly, callback)
    {
        this.doGetProperties(false, accessorPropertiesOnly, false, callback);
    },

    /**
     * @override
     * @return {!Promise<?Array<!WebInspector.EventListener>>}
     */
    eventListeners: function()
    {
        return new Promise(eventListeners.bind(this));
        /**
         * @param {function(?)} fulfill
         * @param {function(*)} reject
         * @this {WebInspector.RemoteObject}
         */
        function eventListeners(fulfill, reject)
        {
            if (!this.target().isPage()) {
                // TODO(kozyatinskiy): figure out how this should work for |window| when there is no DOMDebugger.
                fulfill([]);
                return;
            }

            if (!this._objectId) {
                reject(null);
                return;
            }

            /** @type {?WebInspector.RemoteObject} */
            var removeFunction = null;

            this.callFunctionPromise(nodeRemoveEventListener).then(storeRemoveFunction.bind(this));

            /**
             * @param {!WebInspector.CallFunctionResult} result
             * @this {WebInspector.RemoteObject}
             */
            function storeRemoveFunction(result)
            {
                if (!result.wasThrown && result.object)
                    removeFunction = result.object;
                this.target().domdebuggerAgent().getEventListeners(this._objectId, mycallback.bind(this));
            }

            /**
             * @this {!WebInspector.RemoteObject}
             * @param {?Protocol.Error} error
             * @param {!Array<!DOMDebuggerAgent.EventListener>} payloads
             */
            function mycallback(error, payloads)
            {
                if (error) {
                    reject(null);
                    return;
                }
                fulfill(payloads.map(createEventListener.bind(this)));
            }

            /**
             * @suppressReceiverCheck
             * @this {Node}
             * @return {function(this:Node, string, function(), boolean=): undefined}
             */
            function nodeRemoveEventListener()
            {
                return removeEventListenerWrapper.bind(this);
                /**
                 * @param {string} type
                 * @param {function()} handler
                 * @param {boolean=} useCapture
                 * @this {Node}
                 */
                function removeEventListenerWrapper(type, handler, useCapture)
                {
                    this.removeEventListener(type, handler, useCapture);
                    if (this["on" + type])
                        this["on" + type] = null;
                }
            }

            /**
             * @this {!WebInspector.RemoteObject}
             * @param {!DOMDebuggerAgent.EventListener} payload
             */
            function createEventListener(payload)
            {
                return new WebInspector.EventListener(this._target,
                                                      payload.type,
                                                      payload.useCapture,
                                                      payload.handler ? this.target().runtimeModel.createRemoteObject(payload.handler) : null,
                                                      payload.originalHandler ? this.target().runtimeModel.createRemoteObject(payload.originalHandler) : null,
                                                      WebInspector.DebuggerModel.Location.fromPayload(this._debuggerModel, payload.location),
                                                      removeFunction);
            }
        }
    },

    /**
     * @param {!Array.<string>} propertyPath
     * @param {function(?WebInspector.RemoteObject, boolean=)} callback
     */
    getProperty: function(propertyPath, callback)
    {
        /**
         * @param {string} arrayStr
         * @suppressReceiverCheck
         * @this {Object}
         */
        function remoteFunction(arrayStr)
        {
            var result = this;
            var properties = JSON.parse(arrayStr);
            for (var i = 0, n = properties.length; i < n; ++i)
                result = result[properties[i]];
            return result;
        }

        var args = [{ value: JSON.stringify(propertyPath) }];
        this.callFunction(remoteFunction, args, callback);
    },

    /**
     * @param {boolean} ownProperties
     * @param {boolean} accessorPropertiesOnly
     * @param {boolean} generatePreview
     * @param {function(?Array.<!WebInspector.RemoteObjectProperty>, ?Array.<!WebInspector.RemoteObjectProperty>)} callback
     */
    doGetProperties: function(ownProperties, accessorPropertiesOnly, generatePreview, callback)
    {
        if (!this._objectId) {
            callback(null, null);
            return;
        }

        /**
         * @param {?Protocol.Error} error
         * @param {!Array.<!RuntimeAgent.PropertyDescriptor>} properties
         * @param {!Array.<!RuntimeAgent.InternalPropertyDescriptor>=} internalProperties
         * @param {?RuntimeAgent.ExceptionDetails=} exceptionDetails
         * @this {WebInspector.RemoteObjectImpl}
         */
        function remoteObjectBinder(error, properties, internalProperties, exceptionDetails)
        {
            if (error) {
                callback(null, null);
                return;
            }
            if (exceptionDetails) {
                var msg = new WebInspector.ConsoleMessage(this._target, WebInspector.ConsoleMessage.MessageSource.JS, WebInspector.ConsoleMessage.MessageLevel.Error, exceptionDetails.text);
                this._target.consoleModel.addMessage(msg);
                callback(null, null);
                return;
            }
            var result = [];
            for (var i = 0; properties && i < properties.length; ++i) {
                var property = properties[i];
                var propertyValue = property.value ? this._target.runtimeModel.createRemoteObject(property.value) : null;
                var propertySymbol = property.symbol ? this._target.runtimeModel.createRemoteObject(property.symbol) : null;
                var remoteProperty = new WebInspector.RemoteObjectProperty(property.name, propertyValue,
                        !!property.enumerable, !!property.writable, !!property.isOwn, !!property.wasThrown, propertySymbol);

                if (typeof property.value === "undefined") {
                    if (property.get && property.get.type !== "undefined")
                        remoteProperty.getter = this._target.runtimeModel.createRemoteObject(property.get);
                    if (property.set && property.set.type !== "undefined")
                        remoteProperty.setter = this._target.runtimeModel.createRemoteObject(property.set);
                }

                result.push(remoteProperty);
            }
            var internalPropertiesResult = null;
            if (internalProperties) {
                internalPropertiesResult = [];
                for (var i = 0; i < internalProperties.length; i++) {
                    var property = internalProperties[i];
                    if (!property.value)
                        continue;
                    var propertyValue = this._target.runtimeModel.createRemoteObject(property.value);
                    internalPropertiesResult.push(new WebInspector.RemoteObjectProperty(property.name, propertyValue, true, false));
                }
            }
            callback(result, internalPropertiesResult);
        }
        this._runtimeAgent.getProperties(this._objectId, ownProperties, accessorPropertiesOnly, generatePreview, remoteObjectBinder.bind(this));
    },

    /**
     * @param {string|!RuntimeAgent.CallArgument} name
     * @param {string} value
     * @param {function(string=)} callback
     */
    setPropertyValue: function(name, value, callback)
    {
        if (!this._objectId) {
            callback("Can't set a property of non-object.");
            return;
        }

        this._runtimeAgent.invoke_evaluate({expression:value, doNotPauseOnExceptionsAndMuteConsole:true}, evaluatedCallback.bind(this));

        /**
         * @param {?Protocol.Error} error
         * @param {!RuntimeAgent.RemoteObject} result
         * @param {boolean=} wasThrown
         * @this {WebInspector.RemoteObject}
         */
        function evaluatedCallback(error, result, wasThrown)
        {
            if (error || wasThrown) {
                callback(error || result.description);
                return;
            }

            if (typeof name === "string")
                name = WebInspector.RemoteObject.toCallArgument(name);

            this.doSetObjectPropertyValue(result, name, callback);

            if (result.objectId)
                this._runtimeAgent.releaseObject(result.objectId);
        }
    },

    /**
     * @param {!RuntimeAgent.RemoteObject} result
     * @param {!RuntimeAgent.CallArgument} name
     * @param {function(string=)} callback
     */
    doSetObjectPropertyValue: function(result, name, callback)
    {
        // This assignment may be for a regular (data) property, and for an accessor property (with getter/setter).
        // Note the sensitive matter about accessor property: the property may be physically defined in some proto object,
        // but logically it is bound to the object in question. JavaScript passes this object to getters/setters, not the object
        // where property was defined; so do we.
        var setPropertyValueFunction = "function(a, b) { this[a] = b; }";

        var argv = [name, WebInspector.RemoteObject.toCallArgument(result)];
        this._runtimeAgent.callFunctionOn(this._objectId, setPropertyValueFunction, argv, true, undefined, undefined, propertySetCallback);

        /**
         * @param {?Protocol.Error} error
         * @param {!RuntimeAgent.RemoteObject} result
         * @param {boolean=} wasThrown
         */
        function propertySetCallback(error, result, wasThrown)
        {
            if (error || wasThrown) {
                callback(error || result.description);
                return;
            }
            callback();
        }
    },

    /**
     * @override
     * @param {!RuntimeAgent.CallArgument} name
     * @param {function(string=)} callback
     */
    deleteProperty: function(name, callback)
    {
        if (!this._objectId) {
            callback("Can't delete a property of non-object.");
            return;
        }

        var deletePropertyFunction = "function(a) { delete this[a]; return !(a in this); }";
        this._runtimeAgent.callFunctionOn(this._objectId, deletePropertyFunction, [name], true, undefined, undefined, deletePropertyCallback);

        /**
         * @param {?Protocol.Error} error
         * @param {!RuntimeAgent.RemoteObject} result
         * @param {boolean=} wasThrown
         */
        function deletePropertyCallback(error, result, wasThrown)
        {
            if (error || wasThrown) {
                callback(error || result.description);
                return;
            }
            if (!result.value)
                callback("Failed to delete property.");
            else
                callback();
        }
    },

    /**
     * @override
     * @param {function(this:Object, ...)} functionDeclaration
     * @param {!Array.<!RuntimeAgent.CallArgument>=} args
     * @param {function(?WebInspector.RemoteObject, boolean=)=} callback
     */
    callFunction: function(functionDeclaration, args, callback)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {!RuntimeAgent.RemoteObject} result
         * @param {boolean=} wasThrown
         * @this {WebInspector.RemoteObjectImpl}
         */
        function mycallback(error, result, wasThrown)
        {
            if (!callback)
                return;
            if (error)
                callback(null, false);
            else
                callback(this.target().runtimeModel.createRemoteObject(result), wasThrown);
        }

        this._runtimeAgent.callFunctionOn(this._objectId, functionDeclaration.toString(), args, true, undefined, undefined, mycallback.bind(this));
    },

    /**
     * @override
     * @param {function(this:Object)} functionDeclaration
     * @param {!Array.<!RuntimeAgent.CallArgument>|undefined} args
     * @param {function(*)} callback
     */
    callFunctionJSON: function(functionDeclaration, args, callback)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {!RuntimeAgent.RemoteObject} result
         * @param {boolean=} wasThrown
         */
        function mycallback(error, result, wasThrown)
        {
            callback((error || wasThrown) ? null : result.value);
        }

        this._runtimeAgent.callFunctionOn(this._objectId, functionDeclaration.toString(), args, true, true, false, mycallback);
    },

    release: function()
    {
        if (!this._objectId)
            return;
        this._runtimeAgent.releaseObject(this._objectId);
    },

    /**
     * @override
     * @return {number}
     */
    arrayLength: function()
    {
        return WebInspector.RemoteObject.arrayLength(this);
    },

    /**
     * @override
     * @return {!WebInspector.Target}
     */
    target: function()
    {
        return this._target;
    },

    /**
     * @override
     * @return {?WebInspector.DebuggerModel}
     */
    debuggerModel: function()
    {
        return this._debuggerModel;
    },

    /**
     * @override
     * @return {boolean}
     */
    isNode: function()
    {
        return !!this._objectId && this.type === "object" && this.subtype === "node";
    },

    /**
     * @override
     * @param {function(?WebInspector.DebuggerModel.FunctionDetails)} callback
     */
    functionDetails: function(callback)
    {
        this._debuggerModel.functionDetails(this, callback);
    },

    /**
     * @override
     * @param {function(?WebInspector.DebuggerModel.GeneratorObjectDetails)} callback
     */
    generatorObjectDetails: function(callback)
    {
        this._debuggerModel.generatorObjectDetails(this, callback);
    },

    /**
     * @override
     * @param {function(?Array.<!DebuggerAgent.CollectionEntry>)} callback
     */
    collectionEntries: function(callback)
    {
        if (!this._objectId) {
            callback(null);
            return;
        }
        this._debuggerModel.getCollectionEntries(this._objectId, callback);
    },

    __proto__: WebInspector.RemoteObject.prototype
};


/**
 * @param {!WebInspector.RemoteObject} object
 * @param {function(?Array.<!WebInspector.RemoteObjectProperty>, ?Array.<!WebInspector.RemoteObjectProperty>)} callback
 */
WebInspector.RemoteObject.loadFromObjectPerProto = function(object, callback)
{
    // Combines 2 asynch calls. Doesn't rely on call-back orders (some calls may be loop-back).
    var savedOwnProperties;
    var savedAccessorProperties;
    var savedInternalProperties;
    var resultCounter = 2;

    function processCallback()
    {
        if (--resultCounter)
            return;
        if (savedOwnProperties && savedAccessorProperties) {
            var combinedList = savedAccessorProperties.slice(0);
            for (var i = 0; i < savedOwnProperties.length; i++) {
                var property = savedOwnProperties[i];
                if (!property.isAccessorProperty())
                    combinedList.push(property);
            }
            return callback(combinedList, savedInternalProperties ? savedInternalProperties : null);
        } else {
            callback(null, null);
        }
    }

    /**
     * @param {?Array.<!WebInspector.RemoteObjectProperty>} properties
     * @param {?Array.<!WebInspector.RemoteObjectProperty>} internalProperties
     */
    function allAccessorPropertiesCallback(properties, internalProperties)
    {
        savedAccessorProperties = properties;
        processCallback();
    }

    /**
     * @param {?Array.<!WebInspector.RemoteObjectProperty>} properties
     * @param {?Array.<!WebInspector.RemoteObjectProperty>} internalProperties
     */
    function ownPropertiesCallback(properties, internalProperties)
    {
        savedOwnProperties = properties;
        savedInternalProperties = internalProperties;
        processCallback();
    }

    object.getAllProperties(true, allAccessorPropertiesCallback);
    object.getOwnProperties(ownPropertiesCallback);
};


/**
 * @constructor
 * @extends {WebInspector.RemoteObjectImpl}
 * @param {!WebInspector.Target} target
 * @param {string|undefined} objectId
 * @param {!WebInspector.ScopeRef} scopeRef
 * @param {string} type
 * @param {string|undefined} subtype
 * @param {*} value
 * @param {string=} description
 * @param {!RuntimeAgent.ObjectPreview=} preview
 */
WebInspector.ScopeRemoteObject = function(target, objectId, scopeRef, type, subtype, value, description, preview)
{
    WebInspector.RemoteObjectImpl.call(this, target, objectId, type, subtype, value, description, preview);
    this._scopeRef = scopeRef;
    this._savedScopeProperties = undefined;
};

WebInspector.ScopeRemoteObject.prototype = {
    /**
     * @override
     * @param {boolean} ownProperties
     * @param {boolean} accessorPropertiesOnly
     * @param {boolean} generatePreview
     * @param {function(?Array.<!WebInspector.RemoteObjectProperty>, ?Array.<!WebInspector.RemoteObjectProperty>)} callback
     */
    doGetProperties: function(ownProperties, accessorPropertiesOnly, generatePreview, callback)
    {
        if (accessorPropertiesOnly) {
            callback([], []);
            return;
        }

        if (this._savedScopeProperties) {
            // No need to reload scope variables, as the remote object never
            // changes its properties. If variable is updated, the properties
            // array is patched locally.
            callback(this._savedScopeProperties.slice(), []);
            return;
        }

        /**
         * @param {?Array.<!WebInspector.RemoteObjectProperty>} properties
         * @param {?Array.<!WebInspector.RemoteObjectProperty>} internalProperties
         * @this {WebInspector.ScopeRemoteObject}
         */
        function wrappedCallback(properties, internalProperties)
        {
            if (this._scopeRef && Array.isArray(properties))
                this._savedScopeProperties = properties.slice();
            callback(properties, internalProperties);
        }

        // Scope objects always fetch preview.
        generatePreview = true;

        WebInspector.RemoteObjectImpl.prototype.doGetProperties.call(this, ownProperties, accessorPropertiesOnly, generatePreview, wrappedCallback.bind(this));
    },

    /**
     * @override
     * @param {!RuntimeAgent.RemoteObject} result
     * @param {!RuntimeAgent.CallArgument} name
     * @param {function(string=)} callback
     */
    doSetObjectPropertyValue: function(result, name, callback)
    {
        this._debuggerModel.setVariableValue(this._scopeRef.number, /** @type {string} */ (name.value), WebInspector.RemoteObject.toCallArgument(result), this._scopeRef.callFrameId, this._scopeRef.functionId, setVariableValueCallback.bind(this));

        /**
         * @param {string=} error
         * @this {WebInspector.ScopeRemoteObject}
         */
        function setVariableValueCallback(error)
        {
            if (error) {
                callback(error);
                return;
            }
            if (this._savedScopeProperties) {
                for (var i = 0; i < this._savedScopeProperties.length; i++) {
                    if (this._savedScopeProperties[i].name === name)
                        this._savedScopeProperties[i].value = this._target.runtimeModel.createRemoteObject(result);
                }
            }
            callback();
        }
    },

    __proto__: WebInspector.RemoteObjectImpl.prototype
};

/**
 * Either callFrameId or functionId (exactly one) must be defined.
 * @constructor
 * @param {number} number
 * @param {string=} callFrameId
 * @param {string=} functionId
 */
WebInspector.ScopeRef = function(number, callFrameId, functionId)
{
    this.number = number;
    this.callFrameId = callFrameId;
    this.functionId = functionId;
}

/**
 * @constructor
 * @param {string} name
 * @param {?WebInspector.RemoteObject} value
 * @param {boolean=} enumerable
 * @param {boolean=} writable
 * @param {boolean=} isOwn
 * @param {boolean=} wasThrown
 * @param {boolean=} synthetic
 * @param {?WebInspector.RemoteObject=} symbol
 */
WebInspector.RemoteObjectProperty = function(name, value, enumerable, writable, isOwn, wasThrown, symbol, synthetic)
{
    this.name = name;
    if (value !== null)
        this.value = value;
    this.enumerable = typeof enumerable !== "undefined" ? enumerable : true;
    this.writable = typeof writable !== "undefined" ? writable : true;
    this.isOwn = !!isOwn;
    this.wasThrown = !!wasThrown;
    if (symbol)
        this.symbol = symbol;
    this.synthetic = !!synthetic;
}

WebInspector.RemoteObjectProperty.prototype = {
    /**
     * @return {boolean}
     */
    isAccessorProperty: function()
    {
        return !!(this.getter || this.setter);
    }
};

// Below is a wrapper around a local object that implements the RemoteObject interface,
// which can be used by the UI code (primarily ObjectPropertiesSection).
// Note that only JSON-compliant objects are currently supported, as there's no provision
// for traversing prototypes, extracting class names via constructor, handling properties
// or functions.

/**
 * @constructor
 * @extends {WebInspector.RemoteObject}
 * @param {*} value
 */
WebInspector.LocalJSONObject = function(value)
{
    WebInspector.RemoteObject.call(this);
    this._value = value;
}

WebInspector.LocalJSONObject.prototype = {
    /**
     * @override
     * @return {string}
     */
    get description()
    {
        if (this._cachedDescription)
            return this._cachedDescription;

        /**
         * @param {!WebInspector.RemoteObjectProperty} property
         * @return {string}
         * @this {WebInspector.LocalJSONObject}
         */
        function formatArrayItem(property)
        {
            return this._formatValue(property.value);
        }

        /**
         * @param {!WebInspector.RemoteObjectProperty} property
         * @return {string}
         * @this {WebInspector.LocalJSONObject}
         */
        function formatObjectItem(property)
        {
            var name = property.name;
            if (/^\s|\s$|^$|\n/.test(name))
                name = "\"" + name.replace(/\n/g, "\u21B5") + "\"";
            return name + ": " + this._formatValue(property.value);
        }

        if (this.type === "object") {
            switch (this.subtype) {
            case "array":
                this._cachedDescription = this._concatenate("[", "]", formatArrayItem.bind(this));
                break;
            case "date":
                this._cachedDescription = "" + this._value;
                break;
            case "null":
                this._cachedDescription = "null";
                break;
            default:
                this._cachedDescription = this._concatenate("{", "}", formatObjectItem.bind(this));
            }
        } else {
            this._cachedDescription = String(this._value);
        }

        return this._cachedDescription;
    },

    /**
     * @param {?WebInspector.RemoteObject} value
     * @return {string}
     */
    _formatValue: function(value)
    {
        if (!value)
            return "undefined";
        var description = value.description || "";
        if (value.type === "string")
            return "\"" + description.replace(/\n/g, "\u21B5") + "\"";
        return description;
    },

    /**
     * @param {string} prefix
     * @param {string} suffix
     * @param {function(!WebInspector.RemoteObjectProperty)} formatProperty
     * @return {string}
     */
    _concatenate: function(prefix, suffix, formatProperty)
    {
        var previewChars = 100;

        var buffer = prefix;
        var children = this._children();
        for (var i = 0; i < children.length; ++i) {
            var itemDescription = formatProperty(children[i]);
            if (buffer.length + itemDescription.length > previewChars) {
                buffer += ",\u2026";
                break;
            }
            if (i)
                buffer += ", ";
            buffer += itemDescription;
        }
        buffer += suffix;
        return buffer;
    },

    /**
     * @override
     * @return {string}
     */
    get type()
    {
        return typeof this._value;
    },

    /**
     * @override
     * @return {string|undefined}
     */
    get subtype()
    {
        if (this._value === null)
            return "null";

        if (Array.isArray(this._value))
            return "array";

        if (this._value instanceof Date)
            return "date";

        return undefined;
    },

    /**
     * @override
     * @return {boolean}
     */
    get hasChildren()
    {
        if ((typeof this._value !== "object") || (this._value === null))
            return false;
        return !!Object.keys(/** @type {!Object} */ (this._value)).length;
    },

    /**
     * @override
     * @param {function(?Array.<!WebInspector.RemoteObjectProperty>, ?Array.<!WebInspector.RemoteObjectProperty>)} callback
     */
    getOwnProperties: function(callback)
    {
        callback(this._children(), null);
    },

    /**
     * @override
     * @param {boolean} accessorPropertiesOnly
     * @param {function(?Array.<!WebInspector.RemoteObjectProperty>, ?Array.<!WebInspector.RemoteObjectProperty>)} callback
     */
    getAllProperties: function(accessorPropertiesOnly, callback)
    {
        if (accessorPropertiesOnly)
            callback([], null);
        else
            callback(this._children(), null);
    },

    /**
     * @return {!Array.<!WebInspector.RemoteObjectProperty>}
     */
    _children: function()
    {
        if (!this.hasChildren)
            return [];
        var value = /** @type {!Object} */ (this._value);

        /**
         * @param {string} propName
         * @return {!WebInspector.RemoteObjectProperty}
         */
        function buildProperty(propName)
        {
            var propValue = value[propName];
            if (!(propValue instanceof WebInspector.RemoteObject))
                propValue = WebInspector.RemoteObject.fromLocalObject(propValue);
            return new WebInspector.RemoteObjectProperty(propName, propValue);
        }
        if (!this._cachedChildren)
            this._cachedChildren = Object.keys(value).map(buildProperty);
        return this._cachedChildren;
    },

    /**
     * @return {boolean}
     */
    isError: function()
    {
        return false;
    },

    /**
     * @override
     * @return {number}
     */
    arrayLength: function()
    {
        return Array.isArray(this._value) ? this._value.length : 0;
    },

    /**
     * @override
     * @param {function(this:Object, ...)} functionDeclaration
     * @param {!Array.<!RuntimeAgent.CallArgument>=} args
     * @param {function(?WebInspector.RemoteObject, boolean=)=} callback
     */
    callFunction: function(functionDeclaration, args, callback)
    {
        var target = /** @type {?Object} */ (this._value);
        var rawArgs = args ? args.map(function(arg) { return arg.value; }) : [];

        var result;
        var wasThrown = false;
        try {
            result = functionDeclaration.apply(target, rawArgs);
        } catch (e) {
            wasThrown = true;
        }

        if (!callback)
            return;
        callback(WebInspector.RemoteObject.fromLocalObject(result), wasThrown);
    },

    /**
     * @override
     * @param {function(this:Object)} functionDeclaration
     * @param {!Array.<!RuntimeAgent.CallArgument>|undefined} args
     * @param {function(*)} callback
     */
    callFunctionJSON: function(functionDeclaration, args, callback)
    {
        var target = /** @type {?Object} */ (this._value);
        var rawArgs = args ? args.map(function(arg) { return arg.value; }) : [];

        var result;
        try {
            result = functionDeclaration.apply(target, rawArgs);
        } catch (e) {
            result = null;
        }

        callback(result);
    },

    __proto__: WebInspector.RemoteObject.prototype
}

/**
 * @constructor
 * @param {!WebInspector.RemoteObject} object
 */
WebInspector.RemoteArray = function(object)
{
    this._object = object;
};

/**
 * @param {?WebInspector.RemoteObject} object
 * @return {!WebInspector.RemoteArray}
 */
WebInspector.RemoteArray.objectAsArray = function(object)
{
    if (!object || object.type !== "object" || object.subtype !== "array")
        throw new Error("Object is empty or not an array");
    return new WebInspector.RemoteArray(object);
}

/**
 * @param {!Array<!WebInspector.RemoteObject>} objects
 * @return {!Promise<!WebInspector.RemoteArray>}
 */
WebInspector.RemoteArray.createFromRemoteObjects = function(objects)
{
    if (!objects.length)
        throw new Error("Input array is empty");
    var objectArguments = [];
    for (var i = 0; i < objects.length; ++i)
        objectArguments.push(WebInspector.RemoteObject.toCallArgument(objects[i]))
    return objects[0].callFunctionPromise(createArray, objectArguments).then(returnRemoteArray);

    /**
     * @return {!Array<*>}
     */
    function createArray()
    {
        if (arguments.length > 1)
            return new Array(arguments);
        return [arguments[0]];
    }

    /**
     * @param {!WebInspector.CallFunctionResult} result
     * @return {!WebInspector.RemoteArray}
     */
    function returnRemoteArray(result)
    {
        if (result.wasThrown || !result.object)
            throw new Error("Call function throws exceptions or returns empty value");
        return WebInspector.RemoteArray.objectAsArray(result.object);
    }
}

WebInspector.RemoteArray.prototype = {
    /**
     * @param {number} index
     * @return {!Promise<!WebInspector.RemoteObject>}
     */
    at: function(index)
    {
        if (index < 0 || index > this._object.arrayLength())
            throw new Error("Out of range");
        return this._object.callFunctionPromise(at, [WebInspector.RemoteObject.toCallArgument(index)]).then(assertCallFunctionResult);

        /**
         * @suppressReceiverCheck
         * @param {number} index
         * @return {*}
         * @this {!Object}
         */
        function at(index)
        {
            return this[index];
        }

        /**
         * @param {!WebInspector.CallFunctionResult} result
         * @return {!WebInspector.RemoteObject}
         */
        function assertCallFunctionResult(result)
        {
            if (result.wasThrown || !result.object)
                throw new Error("Exception in callFunction or result value is empty");
            return result.object;
        }
    },

    /**
     * @return {number}
     */
    length: function()
    {
        return this._object.arrayLength();
    },

    /**
     * @param {function(!WebInspector.RemoteObject):!Promise<T>} func
     * @return {!Promise<!Array<T>>}
     * @template T
     */
    map: function(func)
    {
        var promises = [];
        for (var i = 0; i < this.length(); ++i)
            promises.push(this.at(i).then(func));
        return Promise.all(promises);
    },

    /**
     * @return {!WebInspector.RemoteObject}
     */
    object: function()
    {
        return this._object;
    }
}

/**
 * @constructor
 * @param {!WebInspector.RemoteObject} object
 */
WebInspector.RemoteFunction = function(object)
{
    this._object = object;
}

/**
 * @param {?WebInspector.RemoteObject} object
 * @return {!WebInspector.RemoteFunction}
 */
WebInspector.RemoteFunction.objectAsFunction = function(object)
{
    if (!object || object.type !== "function")
        throw new Error("Object is empty or not a function");
    return new WebInspector.RemoteFunction(object);
}

WebInspector.RemoteFunction.prototype = {
    /**
     * @return {!Promise<!WebInspector.RemoteObject>}
     */
    targetFunction: function()
    {
        return this._object.getOwnPropertiesPromise().then(targetFunction.bind(this));

        /**
         * @param {!{properties: ?Array<!WebInspector.RemoteObjectProperty>, internalProperties: ?Array<!WebInspector.RemoteObjectProperty>}} ownProperties
         * @return {!WebInspector.RemoteObject}
         * @this {WebInspector.RemoteFunction}
         */
        function targetFunction(ownProperties)
        {
            if (!ownProperties.internalProperties)
                return this._object;
            var internalProperties = ownProperties.internalProperties;
            for (var property of internalProperties) {
                if (property.name === "[[TargetFunction]]")
                    return property.value;
            }
            return this._object;
        }
    },

    /**
     * @return {!Promise<?WebInspector.DebuggerModel.FunctionDetails>}
     */
    targetFunctionDetails: function()
    {
        return this.targetFunction().then(functionDetails.bind(this));

        /**
         * @param {!WebInspector.RemoteObject} targetFunction
         * @return {!Promise<?WebInspector.DebuggerModel.FunctionDetails>}
         * @this {WebInspector.RemoteFunction}
         */
        function functionDetails(targetFunction)
        {
            var boundReleaseFunctionDetails = releaseTargetFunction.bind(null, this._object !== targetFunction ? targetFunction : null);
            return targetFunction.functionDetailsPromise().then(boundReleaseFunctionDetails);
        }

        /**
         * @param {?WebInspector.RemoteObject} targetFunction
         * @param {?WebInspector.DebuggerModel.FunctionDetails} functionDetails
         * @return {?WebInspector.DebuggerModel.FunctionDetails}
         */
        function releaseTargetFunction(targetFunction, functionDetails)
        {
            if (targetFunction)
                targetFunction.release();
            return functionDetails;
        }
    },

    /**
     * @return {!WebInspector.RemoteObject}
     */
    object: function()
    {
        return this._object;
    }
}

/**
 * @constructor
 * @extends {WebInspector.LocalJSONObject}
 * @param {*} value
 */
WebInspector.MapEntryLocalJSONObject = function(value)
{
    WebInspector.LocalJSONObject.call(this, value);
}

WebInspector.MapEntryLocalJSONObject.prototype = {
    /**
     * @override
     * @return {string}
     */
    get description()
    {
        if (!this._cachedDescription) {
            var children = this._children();
            this._cachedDescription = "{" + this._formatValue(children[0].value) + " => " + this._formatValue(children[1].value) + "}";
        }
        return this._cachedDescription;
    },

    __proto__: WebInspector.LocalJSONObject.prototype
}
;/* Resource.js */
/*
 * Copyright (C) 2007, 2008 Apple Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @implements {WebInspector.ContentProvider}
 * @param {!WebInspector.Target} target
 * @param {?WebInspector.NetworkRequest} request
 * @param {string} url
 * @param {string} documentURL
 * @param {!PageAgent.FrameId} frameId
 * @param {!NetworkAgent.LoaderId} loaderId
 * @param {!WebInspector.ResourceType} type
 * @param {string} mimeType
 * @param {boolean=} isHidden
 */
WebInspector.Resource = function(target, request, url, documentURL, frameId, loaderId, type, mimeType, isHidden)
{
    WebInspector.SDKObject.call(this, target);
    this._request = request;
    this.url = url;
    this._documentURL = documentURL;
    this._frameId = frameId;
    this._loaderId = loaderId;
    this._type = type || WebInspector.resourceTypes.Other;
    this._mimeType = mimeType;
    this._isHidden = isHidden;

    /** @type {?string} */ this._content;
    /** @type {boolean} */ this._contentEncoded;
    this._pendingContentCallbacks = [];
    if (this._request && !this._request.finished)
        this._request.addEventListener(WebInspector.NetworkRequest.Events.FinishedLoading, this._requestFinished, this);
}

/**
 * @param {?string} content
 * @param {string} mimeType
 * @param {boolean} contentEncoded
 * @param {?string=} charset
 * @return {?string}
 */
WebInspector.Resource.contentAsDataURL = function(content, mimeType, contentEncoded, charset)
{
    const maxDataUrlSize = 1024 * 1024;
    if (content === null || content.length > maxDataUrlSize)
        return null;

    return "data:" + mimeType + (charset ? ";charset=" + charset : "") + (contentEncoded ? ";base64" : "") + "," + content;
}

/**
 * @param {string} url
 * @param {string} mimeType
 * @param {!WebInspector.ContentProvider} contentProvider
 * @param {!Element} image
 */
WebInspector.Resource.populateImageSource = function(url, mimeType, contentProvider, image)
{
    /**
     * @param {?string} content
     */
    function onResourceContent(content)
    {
        var imageSrc = WebInspector.Resource.contentAsDataURL(content, mimeType, true);
        if (imageSrc === null)
            imageSrc = url;
        image.src = imageSrc;
    }

    contentProvider.requestContent().then(onResourceContent);
}

WebInspector.Resource.prototype = {
    /**
     * @return {?WebInspector.NetworkRequest}
     */
    get request()
    {
        return this._request;
    },

    /**
     * @return {string}
     */
    get url()
    {
        return this._url;
    },

    set url(x)
    {
        this._url = x;
        this._parsedURL = new WebInspector.ParsedURL(x);
    },

    get parsedURL()
    {
        return this._parsedURL;
    },

    /**
     * @return {string}
     */
    get documentURL()
    {
        return this._documentURL;
    },

    /**
     * @return {!PageAgent.FrameId}
     */
    get frameId()
    {
        return this._frameId;
    },

    /**
     * @return {!NetworkAgent.LoaderId}
     */
    get loaderId()
    {
        return this._loaderId;
    },

    /**
     * @return {string}
     */
    get displayName()
    {
        return this._parsedURL.displayName;
    },

    /**
     * @return {!WebInspector.ResourceType}
     */
    resourceType: function()
    {
        return this._request ? this._request.resourceType() : this._type;
    },

    /**
     * @return {string}
     */
    get mimeType()
    {
        return this._request ? this._request.mimeType : this._mimeType;
    },

    /**
     * @return {?string}
     */
    get content()
    {
        return this._content;
    },

    /**
     * @return {boolean}
     */
    get contentEncoded()
    {
        return this._contentEncoded;
    },

    /**
     * @override
     * @return {string}
     */
    contentURL: function()
    {
        return this._url;
    },

    /**
     * @override
     * @return {!WebInspector.ResourceType}
     */
    contentType: function()
    {
        if (this.resourceType() === WebInspector.resourceTypes.Document && this.mimeType.indexOf("javascript") !== -1)
            return WebInspector.resourceTypes.Script;
        return this.resourceType();
    },

    /**
     * @override
     * @return {!Promise<?string>}
     */
    requestContent: function()
    {
        if (typeof this._content !== "undefined")
            return Promise.resolve(this._content);

        var callback;
        var promise = new Promise(fulfill => callback = fulfill);
        this._pendingContentCallbacks.push(callback);
        if (!this._request || this._request.finished)
            this._innerRequestContent();
        return promise;
    },

    /**
     * @return {string}
     */
    canonicalMimeType: function()
    {
        return this.contentType().canonicalMimeType() || this.mimeType;
    },

    /**
     * @override
     * @param {string} query
     * @param {boolean} caseSensitive
     * @param {boolean} isRegex
     * @param {function(!Array.<!WebInspector.ContentProvider.SearchMatch>)} callback
     */
    searchInContent: function(query, caseSensitive, isRegex, callback)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {!Array.<!DebuggerAgent.SearchMatch>} searchMatches
         */
        function callbackWrapper(error, searchMatches)
        {
            callback(searchMatches || []);
        }

        if (this.frameId)
            this.target().pageAgent().searchInResource(this.frameId, this.url, query, caseSensitive, isRegex, callbackWrapper);
        else
            callback([]);
    },

    /**
     * @param {!Element} image
     */
    populateImageSource: function(image)
    {
        WebInspector.Resource.populateImageSource(this._url, this._mimeType, this, image);
    },

    _requestFinished: function()
    {
        this._request.removeEventListener(WebInspector.NetworkRequest.Events.FinishedLoading, this._requestFinished, this);
        if (this._pendingContentCallbacks.length)
            this._innerRequestContent();
    },


    _innerRequestContent: function()
    {
        if (this._contentRequested)
            return;
        this._contentRequested = true;

        /**
         * @param {?Protocol.Error} error
         * @param {?string} content
         * @param {boolean} contentEncoded
         * @this {WebInspector.Resource}
         */
        function contentLoaded(error, content, contentEncoded)
        {
            if (error || content === null) {
                replyWithContent.call(this, null, false);
                return;
            }
            replyWithContent.call(this, content, contentEncoded);
        }

        /**
         * @param {?string} content
         * @param {boolean} contentEncoded
         * @this {WebInspector.Resource}
         */
        function replyWithContent(content, contentEncoded)
        {
            this._content = content;
            this._contentEncoded = contentEncoded;
            var callbacks = this._pendingContentCallbacks.slice();
            for (var i = 0; i < callbacks.length; ++i)
                callbacks[i](this._content);
            this._pendingContentCallbacks.length = 0;
            delete this._contentRequested;
        }

        /**
         * @param {?Protocol.Error} error
         * @param {string} content
         * @param {boolean} contentEncoded
         * @this {WebInspector.Resource}
         */
        function resourceContentLoaded(error, content, contentEncoded)
        {
            contentLoaded.call(this, error, content, contentEncoded);
        }

        if (this.request) {
            this.request.requestContent().then(requestContentLoaded.bind(this));
            return;
        }

        /**
         * @param {?string} content
         * @this {WebInspector.Resource}
         */
        function requestContentLoaded(content)
        {
            contentLoaded.call(this, null, content, this.request.contentEncoded);
        }

        this.target().pageAgent().getResourceContent(this.frameId, this.url, resourceContentLoaded.bind(this));
    },

    /**
     * @return {boolean}
     */
    isHidden: function()
    {
        return !!this._isHidden;
    },


    /**
     * @return {boolean}
     */
    hasTextContent: function()
    {
        if (this._type.isTextType())
            return true;
        if (this._type === WebInspector.resourceTypes.Other)
            return !!this._content && !this._contentEncoded;
        return false;
    },

    __proto__: WebInspector.SDKObject.prototype
}

;/* ResourceTreeModel.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKModel}
 * @param {!WebInspector.Target} target
 */
WebInspector.ResourceTreeModel = function(target)
{
    WebInspector.SDKModel.call(this, WebInspector.ResourceTreeModel, target);

    target.networkManager.addEventListener(WebInspector.NetworkManager.EventTypes.RequestFinished, this._onRequestFinished, this);
    target.networkManager.addEventListener(WebInspector.NetworkManager.EventTypes.RequestUpdateDropped, this._onRequestUpdateDropped, this);

    this._agent = target.pageAgent();
    this._agent.enable();

    this._fetchResourceTree();

    target.registerPageDispatcher(new WebInspector.PageDispatcher(this));

    this._securityOriginFrameCount = {};
    this._inspectedPageURL = "";
    this._pendingReloadOptions = null;
    this._reloadSuspensionCount = 0;
}

WebInspector.ResourceTreeModel.EventTypes = {
    FrameAdded: "FrameAdded",
    FrameNavigated: "FrameNavigated",
    FrameDetached: "FrameDetached",
    FrameResized: "FrameResized",
    FrameWillNavigate: "FrameWillNavigate",
    MainFrameNavigated: "MainFrameNavigated",
    ResourceAdded: "ResourceAdded",
    WillLoadCachedResources: "WillLoadCachedResources",
    CachedResourcesLoaded: "CachedResourcesLoaded",
    DOMContentLoaded: "DOMContentLoaded",
    Load: "Load",
    PageReloadRequested: "PageReloadRequested",
    WillReloadPage: "WillReloadPage",
    InspectedURLChanged: "InspectedURLChanged",
    SecurityOriginAdded: "SecurityOriginAdded",
    SecurityOriginRemoved: "SecurityOriginRemoved",
    ScreencastFrame: "ScreencastFrame",
    ScreencastVisibilityChanged: "ScreencastVisibilityChanged",
    ColorPicked: "ColorPicked"
}


/**
 * @return {!Array.<!WebInspector.ResourceTreeFrame>}
 */
WebInspector.ResourceTreeModel.frames = function()
{
    var result = [];
    for (var target of WebInspector.targetManager.targets())
        result = result.concat(Object.values(target.resourceTreeModel._frames));
    return result;
}

/**
 * @param {string} url
 * @return {?WebInspector.Resource}
 */
WebInspector.ResourceTreeModel.resourceForURL = function(url)
{
    for (var target of WebInspector.targetManager.targets()) {
        var mainFrame = target.resourceTreeModel.mainFrame;
        var result = mainFrame ? mainFrame.resourceForURL(url) : null;
        if (result)
            return result;
    }
    return null;
}

WebInspector.ResourceTreeModel.prototype = {
    _fetchResourceTree: function()
    {
        /** @type {!Object.<string, !WebInspector.ResourceTreeFrame>} */
        this._frames = {};
        this._cachedResourcesProcessed = false;
        this._agent.getResourceTree(this._processCachedResources.bind(this));
    },

    _processCachedResources: function(error, mainFramePayload)
    {
        if (error) {
            this._cachedResourcesProcessed = true;
            this.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.CachedResourcesLoaded);
            return;
        }

        this.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.WillLoadCachedResources);
        this._inspectedPageURL = mainFramePayload.frame.url;

        // Do not process SW resources.
        if (this.target().isPage())
            this._addFramesRecursively(null, mainFramePayload);
        else
            this._addSecurityOrigin(mainFramePayload.frame.securityOrigin);

        this._dispatchInspectedURLChanged();
        this._cachedResourcesProcessed = true;
        this.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.CachedResourcesLoaded);
    },

    /**
     * @return {string}
     */
    inspectedPageURL: function()
    {
        return this._inspectedPageURL;
    },

    /**
     * @return {string}
     */
    inspectedPageDomain: function()
    {
        var parsedURL = this._inspectedPageURL ? this._inspectedPageURL.asParsedURL() : null;
        return parsedURL ? parsedURL.host : "";
    },

    /**
     * @return {boolean}
     */
    cachedResourcesLoaded: function()
    {
        return this._cachedResourcesProcessed;
    },

    _dispatchInspectedURLChanged: function()
    {
        InspectorFrontendHost.inspectedURLChanged(this._inspectedPageURL);
        this.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.InspectedURLChanged, this._inspectedPageURL);
    },

    /**
     * @param {!WebInspector.ResourceTreeFrame} frame
     * @param {boolean=} aboutToNavigate
     */
    _addFrame: function(frame, aboutToNavigate)
    {
        this._frames[frame.id] = frame;
        if (frame.isMainFrame())
            this.mainFrame = frame;
        this.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.FrameAdded, frame);
        if (!aboutToNavigate)
            this._addSecurityOrigin(frame.securityOrigin);
    },

    /**
     * @param {string} securityOrigin
     */
    _addSecurityOrigin: function(securityOrigin)
    {
        if (!this._securityOriginFrameCount[securityOrigin]) {
            this._securityOriginFrameCount[securityOrigin] = 1;
            this.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.SecurityOriginAdded, securityOrigin);
            return;
        }
        this._securityOriginFrameCount[securityOrigin] += 1;
    },

    /**
     * @param {string|undefined} securityOrigin
     */
    _removeSecurityOrigin: function(securityOrigin)
    {
        if (typeof securityOrigin === "undefined")
            return;
        if (this._securityOriginFrameCount[securityOrigin] === 1) {
            delete this._securityOriginFrameCount[securityOrigin];
            this.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.SecurityOriginRemoved, securityOrigin);
            return;
        }
        this._securityOriginFrameCount[securityOrigin] -= 1;
    },

    /**
     * @return {!Array.<string>}
     */
    securityOrigins: function()
    {
        return Object.keys(this._securityOriginFrameCount);
    },

    /**
     * @param {!WebInspector.ResourceTreeFrame} mainFrame
     */
    _handleMainFrameDetached: function(mainFrame)
    {
        /**
         * @param {!WebInspector.ResourceTreeFrame} frame
         * @this {WebInspector.ResourceTreeModel}
         */
        function removeOriginForFrame(frame)
        {
            for (var i = 0; i < frame.childFrames.length; ++i)
                removeOriginForFrame.call(this, frame.childFrames[i]);
            if (!frame.isMainFrame())
                this._removeSecurityOrigin(frame.securityOrigin);
        }
        removeOriginForFrame.call(this, mainFrame);
    },

    /**
     * @param {!PageAgent.FrameId} frameId
     * @param {?PageAgent.FrameId} parentFrameId
     * @return {?WebInspector.ResourceTreeFrame}
     */
    _frameAttached: function(frameId, parentFrameId)
    {
        // Do nothing unless cached resource tree is processed - it will overwrite everything.
        if (!this._cachedResourcesProcessed && parentFrameId)
            return null;
        if (this._frames[frameId])
            return null;

        var parentFrame = parentFrameId ? this._frames[parentFrameId] : null;
        var frame = new WebInspector.ResourceTreeFrame(this, parentFrame, frameId);
        if (frame.isMainFrame() && this.mainFrame) {
            this._handleMainFrameDetached(this.mainFrame);
            // Navigation to the new backend process.
            this._frameDetached(this.mainFrame.id);
        }
        this._addFrame(frame, true);
        return frame;
    },

    /**
     * @param {!PageAgent.Frame} framePayload
     */
    _frameNavigated: function(framePayload)
    {
        // Do nothing unless cached resource tree is processed - it will overwrite everything.
        if (!this._cachedResourcesProcessed && framePayload.parentId)
            return;
        var frame = this._frames[framePayload.id];
        if (!frame) {
            // Simulate missed "frameAttached" for a main frame navigation to the new backend process.
            console.assert(!framePayload.parentId, "Main frame shouldn't have parent frame id.");
            frame = this._frameAttached(framePayload.id, framePayload.parentId || "");
            console.assert(frame);
        }

        this.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.FrameWillNavigate, frame);

        this._removeSecurityOrigin(frame.securityOrigin);
        frame._navigate(framePayload);
        var addedOrigin = frame.securityOrigin;

        if (frame.isMainFrame())
            this._inspectedPageURL = frame.url;

        this.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.FrameNavigated, frame);
        if (frame.isMainFrame())
            this.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.MainFrameNavigated, frame);
        if (addedOrigin)
            this._addSecurityOrigin(addedOrigin);

        // Fill frame with retained resources (the ones loaded using new loader).
        var resources = frame.resources();
        for (var i = 0; i < resources.length; ++i)
            this.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.ResourceAdded, resources[i]);

        if (frame.isMainFrame())
            this._dispatchInspectedURLChanged();
    },

    /**
     * @param {!PageAgent.FrameId} frameId
     */
    _frameDetached: function(frameId)
    {
        // Do nothing unless cached resource tree is processed - it will overwrite everything.
        if (!this._cachedResourcesProcessed)
            return;

        var frame = this._frames[frameId];
        if (!frame)
            return;

        this._removeSecurityOrigin(frame.securityOrigin);
        if (frame.parentFrame)
            frame.parentFrame._removeChildFrame(frame);
        else
            frame._remove();
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onRequestFinished: function(event)
    {
        if (!this._cachedResourcesProcessed)
            return;

        var request = /** @type {!WebInspector.NetworkRequest} */ (event.data);
        if (request.failed || request.resourceType() === WebInspector.resourceTypes.XHR)
            return;

        var frame = this._frames[request.frameId];
        if (frame)
            frame._addRequest(request);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onRequestUpdateDropped: function(event)
    {
        if (!this._cachedResourcesProcessed)
            return;

        var frameId = event.data.frameId;
        var frame = this._frames[frameId];
        if (!frame)
            return;

        var url = event.data.url;
        if (frame._resourcesMap[url])
            return;

        var resource = new WebInspector.Resource(this.target(), null, url, frame.url, frameId, event.data.loaderId, WebInspector.resourceTypes[event.data.resourceType], event.data.mimeType);
        frame.addResource(resource);
    },

    /**
     * @param {!PageAgent.FrameId} frameId
     * @return {!WebInspector.ResourceTreeFrame}
     */
    frameForId: function(frameId)
    {
        return this._frames[frameId];
    },

    /**
     * @param {function(!WebInspector.Resource)} callback
     * @return {boolean}
     */
    forAllResources: function(callback)
    {
        if (this.mainFrame)
            return this.mainFrame._callForFrameResources(callback);
        return false;
    },

    /**
     * @return {!Array.<!WebInspector.ResourceTreeFrame>}
     */
    frames: function()
    {
        return Object.values(this._frames);
    },

    /**
     * @param {string} url
     * @return {?WebInspector.Resource}
     */
    resourceForURL: function(url)
    {
        // Workers call into this with no frames available.
        return this.mainFrame ? this.mainFrame.resourceForURL(url) : null;
    },

    /**
     * @param {?WebInspector.ResourceTreeFrame} parentFrame
     * @param {!PageAgent.FrameResourceTree} frameTreePayload
     */
    _addFramesRecursively: function(parentFrame, frameTreePayload)
    {
        var framePayload = frameTreePayload.frame;
        var frame = new WebInspector.ResourceTreeFrame(this, parentFrame, framePayload.id, framePayload);
        this._addFrame(frame);

        var frameResource = this._createResourceFromFramePayload(framePayload, framePayload.url, WebInspector.resourceTypes.Document, framePayload.mimeType);
        if (frame.isMainFrame())
            this._inspectedPageURL = frameResource.url;
        frame.addResource(frameResource);

        for (var i = 0; frameTreePayload.childFrames && i < frameTreePayload.childFrames.length; ++i)
            this._addFramesRecursively(frame, frameTreePayload.childFrames[i]);

        for (var i = 0; i < frameTreePayload.resources.length; ++i) {
            var subresource = frameTreePayload.resources[i];
            var resource = this._createResourceFromFramePayload(framePayload, subresource.url, WebInspector.resourceTypes[subresource.type], subresource.mimeType);
            frame.addResource(resource);
        }
    },

    /**
     * @param {!PageAgent.Frame} frame
     * @param {string} url
     * @param {!WebInspector.ResourceType} type
     * @param {string} mimeType
     * @return {!WebInspector.Resource}
     */
    _createResourceFromFramePayload: function(frame, url, type, mimeType)
    {
        return new WebInspector.Resource(this.target(), null, url, frame.url, frame.id, frame.loaderId, type, mimeType);
    },

    suspendReload: function()
    {
        this._reloadSuspensionCount++;
    },

    resumeReload: function()
    {
        this._reloadSuspensionCount--;
        console.assert(this._reloadSuspensionCount >= 0, "Unbalanced call to ResourceTreeModel.resumeReload()");
        if (!this._reloadSuspensionCount && this._pendingReloadOptions)
            this.reloadPage.apply(this, this._pendingReloadOptions);
    },

    /**
     * @param {boolean=} ignoreCache
     * @param {string=} scriptToEvaluateOnLoad
     */
    reloadPage: function(ignoreCache, scriptToEvaluateOnLoad)
    {
        // Only dispatch PageReloadRequested upon first reload request to simplify client logic.
        if (!this._pendingReloadOptions)
            this.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.PageReloadRequested);
        if (this._reloadSuspensionCount) {
            this._pendingReloadOptions = [ignoreCache, scriptToEvaluateOnLoad];
            return;
        }
        this._pendingReloadOptions = null;
        this.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.WillReloadPage);
        this._agent.reload(ignoreCache, scriptToEvaluateOnLoad);
    },

    __proto__: WebInspector.SDKModel.prototype
}

/**
 * @constructor
 * @param {!WebInspector.ResourceTreeModel} model
 * @param {?WebInspector.ResourceTreeFrame} parentFrame
 * @param {!PageAgent.FrameId} frameId
 * @param {!PageAgent.Frame=} payload
 */
WebInspector.ResourceTreeFrame = function(model, parentFrame, frameId, payload)
{
    this._model = model;
    this._parentFrame = parentFrame;
    this._id = frameId;
    this._url = "";

    if (payload) {
        this._loaderId = payload.loaderId;
        this._name = payload.name;
        this._url = payload.url;
        this._securityOrigin = payload.securityOrigin;
        this._mimeType = payload.mimeType;
    }

    /**
     * @type {!Array.<!WebInspector.ResourceTreeFrame>}
     */
    this._childFrames = [];

    /**
     * @type {!Object.<string, !WebInspector.Resource>}
     */
    this._resourcesMap = {};

    if (this._parentFrame)
        this._parentFrame._childFrames.push(this);
}

/**
 * @param {!WebInspector.Script} script
 * @return {?WebInspector.ResourceTreeFrame}
 */
WebInspector.ResourceTreeFrame.fromScript = function(script)
{
    var executionContext = script.executionContext();
    if (!executionContext || !executionContext.frameId)
        return null;
    return script.target().resourceTreeModel.frameForId(executionContext.frameId);
}

/**
 * @param {!WebInspector.CSSStyleSheetHeader} header
 * @return {?WebInspector.ResourceTreeFrame}
 */
WebInspector.ResourceTreeFrame.fromStyleSheet = function(header)
{
    return header.target().resourceTreeModel.frameForId(header.frameId);
}

/**
 * @param {!WebInspector.Resource} resource
 * @return {?WebInspector.ResourceTreeFrame}
 */
WebInspector.ResourceTreeFrame.fromResource = function(resource)
{
    return resource.target().resourceTreeModel.frameForId(resource.frameId);
}

WebInspector.ResourceTreeFrame.prototype = {
    /**
     * @return {!WebInspector.Target}
     */
    target: function()
    {
        return this._model.target();
    },

    /**
     * @return {string}
     */
    get id()
    {
        return this._id;
    },

    /**
     * @return {string}
     */
    get name()
    {
        return this._name || "";
    },

    /**
     * @return {string}
     */
    get url()
    {
        return this._url;
    },

    /**
     * @return {string}
     */
    get securityOrigin()
    {
        return this._securityOrigin;
    },

    /**
     * @return {string}
     */
    get loaderId()
    {
        return this._loaderId;
    },

    /**
     * @return {?WebInspector.ResourceTreeFrame}
     */
    get parentFrame()
    {
        return this._parentFrame;
    },

    /**
     * @return {!Array.<!WebInspector.ResourceTreeFrame>}
     */
    get childFrames()
    {
        return this._childFrames;
    },

    /**
     * @return {boolean}
     */
    isMainFrame: function()
    {
        return !this._parentFrame;
    },

    /**
     * @param {!PageAgent.Frame} framePayload
     */
    _navigate: function(framePayload)
    {
        this._loaderId = framePayload.loaderId;
        this._name = framePayload.name;
        this._url = framePayload.url;
        this._securityOrigin = framePayload.securityOrigin;
        this._mimeType = framePayload.mimeType;

        var mainResource = this._resourcesMap[this._url];
        this._resourcesMap = {};
        this._removeChildFrames();
        if (mainResource && mainResource.loaderId === this._loaderId)
            this.addResource(mainResource);
    },

    /**
     * @return {!WebInspector.Resource}
     */
    get mainResource()
    {
        return this._resourcesMap[this._url];
    },

    /**
     * @param {!WebInspector.ResourceTreeFrame} frame
     */
    _removeChildFrame: function(frame)
    {
        this._childFrames.remove(frame);
        frame._remove();
    },

    _removeChildFrames: function()
    {
        var frames = this._childFrames;
        this._childFrames = [];
        for (var i = 0; i < frames.length; ++i)
            frames[i]._remove();
    },

    _remove: function()
    {
        this._removeChildFrames();
        delete this._model._frames[this.id];
        this._model.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.FrameDetached, this);
    },

    /**
     * @param {!WebInspector.Resource} resource
     */
    addResource: function(resource)
    {
        if (this._resourcesMap[resource.url] === resource) {
            // Already in the tree, we just got an extra update.
            return;
        }
        this._resourcesMap[resource.url] = resource;
        this._model.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.ResourceAdded, resource);
    },

    /**
     * @param {!WebInspector.NetworkRequest} request
     * @return {!WebInspector.Resource}
     */
    _addRequest: function(request)
    {
        var resource = this._resourcesMap[request.url];
        if (resource && resource.request === request) {
            // Already in the tree, we just got an extra update.
            return resource;
        }
        resource = new WebInspector.Resource(this.target(), request, request.url, request.documentURL, request.frameId, request.loaderId, request.resourceType(), request.mimeType);
        this._resourcesMap[resource.url] = resource;
        this._model.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.ResourceAdded, resource);
        return resource;
    },

    /**
     * @return {!Array.<!WebInspector.Resource>}
     */
    resources: function()
    {
        var result = [];
        for (var url in this._resourcesMap)
            result.push(this._resourcesMap[url]);
        return result;
    },

    /**
     * @param {string} url
     * @return {?WebInspector.Resource}
     */
    resourceForURL: function(url)
    {
        var result;
        function filter(resource)
        {
            if (resource.url === url) {
                result = resource;
                return true;
            }
        }
        this._callForFrameResources(filter);
        return result || null;
    },

    /**
     * @param {function(!WebInspector.Resource)} callback
     * @return {boolean}
     */
    _callForFrameResources: function(callback)
    {
        for (var url in this._resourcesMap) {
            if (callback(this._resourcesMap[url]))
                return true;
        }

        for (var i = 0; i < this._childFrames.length; ++i) {
            if (this._childFrames[i]._callForFrameResources(callback))
                return true;
        }
        return false;
    },

    /**
     * @return {string}
     */
    displayName: function()
    {
        if (!this._parentFrame)
            return WebInspector.UIString("top");
        var subtitle = new WebInspector.ParsedURL(this._url).displayName;
        if (subtitle) {
            if (!this._name)
                return subtitle;
            return this._name + " (" + subtitle + ")";
        }
        return WebInspector.UIString("<iframe>");
    }
}

/**
 * @constructor
 * @implements {PageAgent.Dispatcher}
 */
WebInspector.PageDispatcher = function(resourceTreeModel)
{
    this._resourceTreeModel = resourceTreeModel;
}

WebInspector.PageDispatcher.prototype = {
    /**
     * @override
     * @param {number} time
     */
    domContentEventFired: function(time)
    {
        this._resourceTreeModel.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.DOMContentLoaded, time);
    },

    /**
     * @override
     * @param {number} time
     */
    loadEventFired: function(time)
    {
        this._resourceTreeModel.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.Load, time);
    },

    /**
     * @override
     * @param {!PageAgent.FrameId} frameId
     * @param {!PageAgent.FrameId} parentFrameId
     */
    frameAttached: function(frameId, parentFrameId)
    {
        this._resourceTreeModel._frameAttached(frameId, parentFrameId);
    },

    /**
     * @override
     * @param {!PageAgent.Frame} frame
     */
    frameNavigated: function(frame)
    {
        this._resourceTreeModel._frameNavigated(frame);
    },

    /**
     * @override
     * @param {!PageAgent.FrameId} frameId
     */
    frameDetached: function(frameId)
    {
        this._resourceTreeModel._frameDetached(frameId);
    },

    /**
     * @override
     * @param {!PageAgent.FrameId} frameId
     */
    frameStartedLoading: function(frameId)
    {
    },

    /**
     * @override
     * @param {!PageAgent.FrameId} frameId
     */
    frameStoppedLoading: function(frameId)
    {
    },

    /**
     * @override
     * @param {!PageAgent.FrameId} frameId
     * @param {number} delay
     */
    frameScheduledNavigation: function(frameId, delay)
    {
    },

    /**
     * @override
     * @param {!PageAgent.FrameId} frameId
     */
    frameClearedScheduledNavigation: function(frameId)
    {
    },

    /**
     * @override
     */
    frameResized: function()
    {
        this._resourceTreeModel.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.FrameResized, null);
    },

    /**
     * @override
     * @param {string} message
     * @param {string} dialogType
     */
    javascriptDialogOpening: function(message, dialogType)
    {
    },

    /**
     * @override
     * @param {boolean} result
     */
    javascriptDialogClosed: function(result)
    {
    },

    /**
     * @override
     * @param {string} data
     * @param {!PageAgent.ScreencastFrameMetadata=} metadata
     * @param {number=} sessionId
     */
    screencastFrame: function(data, metadata, sessionId)
    {
        this._resourceTreeModel._agent.screencastFrameAck(sessionId);
        this._resourceTreeModel.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.ScreencastFrame, { data: data, metadata: metadata });
    },

    /**
     * @override
     * @param {boolean} visible
     */
    screencastVisibilityChanged: function(visible)
    {
        this._resourceTreeModel.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.ScreencastVisibilityChanged, { visible: visible });
    },

    /**
     * @override
     * @param {!DOMAgent.RGBA} color
     */
    colorPicked: function(color)
    {
        this._resourceTreeModel.dispatchEventToListeners(WebInspector.ResourceTreeModel.EventTypes.ColorPicked, color);
    },

    /**
     * @override
     */
    interstitialShown: function()
    {
        // Frontend is not interested in interstitials.
    },

    /**
     * @override
     */
    interstitialHidden: function()
    {
        // Frontend is not interested in interstitials.
    }
}
;/* SourceMap.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 */
function SourceMapV3()
{
    /** @type {number} */ this.version;
    /** @type {string|undefined} */ this.file;
    /** @type {!Array.<string>} */ this.sources;
    /** @type {!Array.<!SourceMapV3.Section>|undefined} */ this.sections;
    /** @type {string} */ this.mappings;
    /** @type {string|undefined} */ this.sourceRoot;
}

/**
 * @constructor
 */
SourceMapV3.Section = function()
{
    /** @type {!SourceMapV3} */ this.map;
    /** @type {!SourceMapV3.Offset} */ this.offset;
}

/**
 * @constructor
 */
SourceMapV3.Offset = function()
{
    /** @type {number} */ this.line;
    /** @type {number} */ this.column;
}

/**
 * Implements Source Map V3 model. See https://github.com/google/closure-compiler/wiki/Source-Maps
 * for format description.
 * @constructor
 * @param {string} compiledURL
 * @param {string} sourceMappingURL
 * @param {!SourceMapV3} payload
 */
WebInspector.SourceMap = function(compiledURL, sourceMappingURL, payload)
{
    if (!WebInspector.SourceMap.prototype._base64Map) {
        const base64Digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        WebInspector.SourceMap.prototype._base64Map = {};
        for (var i = 0; i < base64Digits.length; ++i)
            WebInspector.SourceMap.prototype._base64Map[base64Digits.charAt(i)] = i;
    }

    this._compiledURL = compiledURL;
    this._sourceMappingURL = sourceMappingURL;
    this._reverseMappingsBySourceURL = new Map();
    this._mappings = [];
    this._sources = {};
    this._sourceContentByURL = {};
    this._parseMappingPayload(payload);
}

/**
 * @param {string} sourceMapURL
 * @param {string} compiledURL
 * @param {function(?WebInspector.SourceMap)} callback
 * @this {WebInspector.SourceMap}
 */
WebInspector.SourceMap.load = function(sourceMapURL, compiledURL, callback)
{
    WebInspector.multitargetNetworkManager.loadResource(sourceMapURL, contentLoaded);

    /**
     * @param {number} statusCode
     * @param {!Object.<string, string>} headers
     * @param {string} content
     */
    function contentLoaded(statusCode, headers, content)
    {
        if (!content || statusCode >= 400) {
            callback(null);
            return;
        }

        if (content.slice(0, 3) === ")]}")
            content = content.substring(content.indexOf('\n'));
        try {
            var payload = /** @type {!SourceMapV3} */ (JSON.parse(content));
            var baseURL = sourceMapURL.startsWith("data:") ? compiledURL : sourceMapURL;
            callback(new WebInspector.SourceMap(compiledURL, baseURL, payload));
        } catch(e) {
            console.error(e);
            WebInspector.console.error("Failed to parse SourceMap: " + sourceMapURL);
            callback(null);
        }
    }
}

WebInspector.SourceMap.prototype = {
    /**
     * @return {string}
     */
    compiledURL: function()
    {
        return this._compiledURL;
    },

    /**
     * @return {string}
     */
    url: function()
    {
        return this._sourceMappingURL;
    },

   /**
     * @return {!Array.<string>}
     */
    sources: function()
    {
        return Object.keys(this._sources);
    },

    /**
     * @param {string} sourceURL
     * @return {string|undefined}
     */
    sourceContent: function(sourceURL)
    {
        return this._sourceContentByURL[sourceURL];
    },

    /**
     * @param {string} sourceURL
     * @param {!WebInspector.ResourceType} contentType
     * @return {!WebInspector.ContentProvider}
     */
    sourceContentProvider: function(sourceURL, contentType)
    {
        var sourceContent = this.sourceContent(sourceURL);
        if (sourceContent)
            return new WebInspector.StaticContentProvider(contentType, sourceContent);
        return new WebInspector.CompilerSourceMappingContentProvider(sourceURL, contentType);
    },

    /**
     * @param {!SourceMapV3} mappingPayload
     */
    _parseMappingPayload: function(mappingPayload)
    {
        if (mappingPayload.sections)
            this._parseSections(mappingPayload.sections);
        else
            this._parseMap(mappingPayload, 0, 0);
    },

    /**
     * @param {!Array.<!SourceMapV3.Section>} sections
     */
    _parseSections: function(sections)
    {
        for (var i = 0; i < sections.length; ++i) {
            var section = sections[i];
            this._parseMap(section.map, section.offset.line, section.offset.column);
        }
    },

    /**
     * @param {number} lineNumber in compiled resource
     * @param {number} columnNumber in compiled resource
     * @return {?WebInspector.SourceMap.Entry}
     */
    findEntry: function(lineNumber, columnNumber)
    {
        var first = 0;
        var count = this._mappings.length;
        while (count > 1) {
          var step = count >> 1;
          var middle = first + step;
          var mapping = this._mappings[middle];
          if (lineNumber < mapping.lineNumber || (lineNumber === mapping.lineNumber && columnNumber < mapping.columnNumber))
              count = step;
          else {
              first = middle;
              count -= step;
          }
        }
        var entry = this._mappings[first];
        if (!first && entry && (lineNumber < entry.lineNumber || (lineNumber === entry.lineNumber && columnNumber < entry.columnNumber)))
            return null;
        return entry;
    },

    /**
     * @param {string} sourceURL
     * @param {number} lineNumber
     * @return {?WebInspector.SourceMap.Entry}
     */
    firstSourceLineMapping: function(sourceURL, lineNumber)
    {
        var mappings = this._reversedMappings(sourceURL);
        var index = mappings.lowerBound(lineNumber, lineComparator);
        if (index >= mappings.length || mappings[index].sourceLineNumber !== lineNumber)
            return null;
        return mappings[index];

        /**
         * @param {number} lineNumber
         * @param {!WebInspector.SourceMap.Entry} mapping
         * @return {number}
         */
        function lineComparator(lineNumber, mapping)
        {
            return lineNumber - mapping.sourceLineNumber;
        }
    },

    /**
     * @return {!Array<!WebInspector.SourceMap.Entry>}
     */
    mappings: function()
    {
        return this._mappings;
    },

    /**
     * @param {string} sourceURL
     * @return {!Array.<!WebInspector.SourceMap.Entry>}
     */
    _reversedMappings: function(sourceURL)
    {
        var mappings = this._reverseMappingsBySourceURL.get(sourceURL);
        if (!mappings)
            return [];
        if (!mappings._sorted) {
            mappings.sort(sourceMappingComparator);
            mappings._sorted = true;
        }
        return mappings;

        /**
         * @param {!WebInspector.SourceMap.Entry} a
         * @param {!WebInspector.SourceMap.Entry} b
         * @return {number}
         */
        function sourceMappingComparator(a, b)
        {
            if (a.sourceLineNumber !== b.sourceLineNumber)
                return a.sourceLineNumber - b.sourceLineNumber;
            return a.sourceColumnNumber - b.sourceColumnNumber;
        }
    },

    /**
     * @param {!SourceMapV3} map
     * @param {number} lineNumber
     * @param {number} columnNumber
     */
    _parseMap: function(map, lineNumber, columnNumber)
    {
        var sourceIndex = 0;
        var sourceLineNumber = 0;
        var sourceColumnNumber = 0;
        var nameIndex = 0;

        var sources = [];
        var sourceRoot = map.sourceRoot || "";
        if (sourceRoot && !sourceRoot.endsWith("/"))
            sourceRoot += "/";
        for (var i = 0; i < map.sources.length; ++i) {
            var href = sourceRoot + map.sources[i];
            var url = WebInspector.ParsedURL.completeURL(this._sourceMappingURL, href) || href;
            var hasSource = map.sourcesContent && map.sourcesContent[i];
            if (url === this._compiledURL && hasSource)
                url += WebInspector.UIString(" [sm]");
            sources.push(url);
            this._sources[url] = true;

            if (hasSource)
                this._sourceContentByURL[url] = map.sourcesContent[i];
        }

        var stringCharIterator = new WebInspector.SourceMap.StringCharIterator(map.mappings);
        var sourceURL = sources[sourceIndex];

        while (true) {
            if (stringCharIterator.peek() === ",")
                stringCharIterator.next();
            else {
                while (stringCharIterator.peek() === ";") {
                    lineNumber += 1;
                    columnNumber = 0;
                    stringCharIterator.next();
                }
                if (!stringCharIterator.hasNext())
                    break;
            }

            columnNumber += this._decodeVLQ(stringCharIterator);
            if (!stringCharIterator.hasNext() || this._isSeparator(stringCharIterator.peek())) {
                this._mappings.push(new WebInspector.SourceMap.Entry(lineNumber, columnNumber));
                continue;
            }

            var sourceIndexDelta = this._decodeVLQ(stringCharIterator);
            if (sourceIndexDelta) {
                sourceIndex += sourceIndexDelta;
                sourceURL = sources[sourceIndex];
            }
            sourceLineNumber += this._decodeVLQ(stringCharIterator);
            sourceColumnNumber += this._decodeVLQ(stringCharIterator);
            if (!this._isSeparator(stringCharIterator.peek()))
                nameIndex += this._decodeVLQ(stringCharIterator);

            this._mappings.push(new WebInspector.SourceMap.Entry(lineNumber, columnNumber, sourceURL, sourceLineNumber, sourceColumnNumber));
        }

        for (var i = 0; i < this._mappings.length; ++i) {
            var mapping = this._mappings[i];
            var url = mapping.sourceURL;
            if (!url)
                continue;
            if (!this._reverseMappingsBySourceURL.has(url))
                this._reverseMappingsBySourceURL.set(url, []);
            var reverseMappings = this._reverseMappingsBySourceURL.get(url);
            reverseMappings.push(mapping);
        }
    },

    /**
     * @param {string} char
     * @return {boolean}
     */
    _isSeparator: function(char)
    {
        return char === "," || char === ";";
    },

    /**
     * @param {!WebInspector.SourceMap.StringCharIterator} stringCharIterator
     * @return {number}
     */
    _decodeVLQ: function(stringCharIterator)
    {
        // Read unsigned value.
        var result = 0;
        var shift = 0;
        do {
            var digit = this._base64Map[stringCharIterator.next()];
            result += (digit & this._VLQ_BASE_MASK) << shift;
            shift += this._VLQ_BASE_SHIFT;
        } while (digit & this._VLQ_CONTINUATION_MASK);

        // Fix the sign.
        var negative = result & 1;
        result >>= 1;
        return negative ? -result : result;
    },

    _VLQ_BASE_SHIFT: 5,
    _VLQ_BASE_MASK: (1 << 5) - 1,
    _VLQ_CONTINUATION_MASK: 1 << 5
}

/**
 * @constructor
 * @param {string} string
 */
WebInspector.SourceMap.StringCharIterator = function(string)
{
    this._string = string;
    this._position = 0;
}

WebInspector.SourceMap.StringCharIterator.prototype = {
    /**
     * @return {string}
     */
    next: function()
    {
        return this._string.charAt(this._position++);
    },

    /**
     * @return {string}
     */
    peek: function()
    {
        return this._string.charAt(this._position);
    },

    /**
     * @return {boolean}
     */
    hasNext: function()
    {
        return this._position < this._string.length;
    }
}

/**
 * @constructor
 * @param {number} lineNumber
 * @param {number} columnNumber
 * @param {string=} sourceURL
 * @param {number=} sourceLineNumber
 * @param {number=} sourceColumnNumber
 */
WebInspector.SourceMap.Entry = function(lineNumber, columnNumber, sourceURL, sourceLineNumber, sourceColumnNumber)
{
    this.lineNumber = lineNumber;
    this.columnNumber = columnNumber;
    this.sourceURL = sourceURL;
    this.sourceLineNumber = sourceLineNumber;
    this.sourceColumnNumber = sourceColumnNumber;
}
;/* NetworkManager.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKModel}
 * @param {!WebInspector.Target} target
 */
WebInspector.NetworkManager = function(target)
{
    WebInspector.SDKModel.call(this, WebInspector.NetworkManager, target);
    this._dispatcher = new WebInspector.NetworkDispatcher(this);
    this._target = target;
    this._networkAgent = target.networkAgent();
    target.registerNetworkDispatcher(this._dispatcher);
    if (WebInspector.moduleSetting("cacheDisabled").get())
        this._networkAgent.setCacheDisabled(true);
    if (WebInspector.moduleSetting("monitoringXHREnabled").get())
        this._networkAgent.setMonitoringXHREnabled(true);
    this._networkAgent.enable();

    /** @type {!Map<!NetworkAgent.CertificateId, !Promise<!NetworkAgent.CertificateDetails>>} */
    this._certificateDetailsCache = new Map();

    WebInspector.moduleSetting("cacheDisabled").addChangeListener(this._cacheDisabledSettingChanged, this);
}

WebInspector.NetworkManager.EventTypes = {
    RequestStarted: "RequestStarted",
    RequestUpdated: "RequestUpdated",
    RequestFinished: "RequestFinished",
    RequestUpdateDropped: "RequestUpdateDropped",
    ResponseReceived: "ResponseReceived"
}

WebInspector.NetworkManager._MIMETypes = {
    "text/html":                   {"document": true},
    "text/xml":                    {"document": true},
    "text/plain":                  {"document": true},
    "application/xhtml+xml":       {"document": true},
    "image/svg+xml":               {"document": true},
    "text/css":                    {"stylesheet": true},
    "text/xsl":                    {"stylesheet": true},
    "text/vtt":                    {"texttrack": true},
}

/** @typedef {{download: number, upload: number, latency: number, title: string}} */
WebInspector.NetworkManager.Conditions;
/** @type {!WebInspector.NetworkManager.Conditions} */
WebInspector.NetworkManager.NoThrottlingConditions = {title: WebInspector.UIString("No throttling"), download: -1, upload: -1, latency: 0};

WebInspector.NetworkManager.prototype = {
    /**
     * @param {string} url
     * @return {!WebInspector.NetworkRequest}
     */
    inflightRequestForURL: function(url)
    {
        return this._dispatcher._inflightRequestsByURL[url];
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _cacheDisabledSettingChanged: function(event)
    {
        var enabled = /** @type {boolean} */ (event.data);
        this._networkAgent.setCacheDisabled(enabled);
    },

    dispose: function()
    {
        WebInspector.moduleSetting("cacheDisabled").removeChangeListener(this._cacheDisabledSettingChanged, this);
    },

    /**
     * @param {!NetworkAgent.CertificateId} certificateId
     * @return {!Promise<!NetworkAgent.CertificateDetails>}
     */
    certificateDetailsPromise: function(certificateId)
    {
        var cachedPromise = this._certificateDetailsCache.get(certificateId);
        if (cachedPromise)
            return cachedPromise;

        /**
         * @this {WebInspector.NetworkManager}
         * @param {function(?NetworkAgent.CertificateDetails)} resolve
         * @param {function()} reject
         */
        function executor(resolve, reject) {
            /**
             * @param {?Protocol.Error} error
             * @param {?NetworkAgent.CertificateDetails} certificateDetails
             */
            function innerCallback(error, certificateDetails)
            {
                if (error) {
                    console.error("Unable to get certificate details from the browser (for certificate ID ", certificateId, "): ", error);
                    reject();
                } else {
                    resolve(certificateDetails);
                }
            }
            this._networkAgent.getCertificateDetails(certificateId, innerCallback);
        }

        var promise = new Promise(executor.bind(this));

        this._certificateDetailsCache.set(certificateId, promise);
        return promise;
    },

    __proto__: WebInspector.SDKModel.prototype
}

/**
 * @constructor
 * @implements {NetworkAgent.Dispatcher}
 */
WebInspector.NetworkDispatcher = function(manager)
{
    this._manager = manager;
    this._inflightRequestsById = {};
    this._inflightRequestsByURL = {};
}

WebInspector.NetworkDispatcher.prototype = {
    /**
     * @param {!NetworkAgent.Headers} headersMap
     * @return {!Array.<!WebInspector.NetworkRequest.NameValue>}
     */
    _headersMapToHeadersArray: function(headersMap)
    {
        var result = [];
        for (var name in headersMap) {
            var values = headersMap[name].split("\n");
            for (var i = 0; i < values.length; ++i)
                result.push({name: name, value: values[i]});
        }
        return result;
    },

    /**
     * @param {!WebInspector.NetworkRequest} networkRequest
     * @param {!NetworkAgent.Request} request
     */
    _updateNetworkRequestWithRequest: function(networkRequest, request)
    {
        networkRequest.requestMethod = request.method;
        networkRequest.setRequestHeaders(this._headersMapToHeadersArray(request.headers));
        networkRequest.requestFormData = request.postData;
        networkRequest.setInitialPriority(request.initialPriority);
        networkRequest.mixedContentType = request.mixedContentType || NetworkAgent.RequestMixedContentType.None;
    },

    /**
     * @param {!WebInspector.NetworkRequest} networkRequest
     * @param {!NetworkAgent.Response=} response
     */
    _updateNetworkRequestWithResponse: function(networkRequest, response)
    {
        if (response.url && networkRequest.url !== response.url)
            networkRequest.url = response.url;
        networkRequest.mimeType = response.mimeType;
        networkRequest.statusCode = response.status;
        networkRequest.statusText = response.statusText;
        networkRequest.responseHeaders = this._headersMapToHeadersArray(response.headers);
        if (response.encodedDataLength >= 0)
            networkRequest.setTransferSize(response.encodedDataLength);
        if (response.headersText)
            networkRequest.responseHeadersText = response.headersText;
        if (response.requestHeaders) {
            networkRequest.setRequestHeaders(this._headersMapToHeadersArray(response.requestHeaders));
            networkRequest.setRequestHeadersText(response.requestHeadersText || "");
        }

        networkRequest.connectionReused = response.connectionReused;
        networkRequest.connectionId = String(response.connectionId);
        if (response.remoteIPAddress)
            networkRequest.setRemoteAddress(response.remoteIPAddress, response.remotePort || -1);

        if (response.fromServiceWorker)
            networkRequest.fetchedViaServiceWorker = true;

        if (response.fromDiskCache)
            networkRequest.setFromDiskCache();
        networkRequest.timing = response.timing;

        networkRequest.protocol = response.protocol;

        networkRequest.setSecurityState(response.securityState);

        if (!this._mimeTypeIsConsistentWithType(networkRequest)) {
            var consoleModel = this._manager._target.consoleModel;
            consoleModel.addMessage(new WebInspector.ConsoleMessage(consoleModel.target(), WebInspector.ConsoleMessage.MessageSource.Network,
                WebInspector.ConsoleMessage.MessageLevel.Log,
                WebInspector.UIString("Resource interpreted as %s but transferred with MIME type %s: \"%s\".", networkRequest.resourceType().title(), networkRequest.mimeType, networkRequest.url),
                WebInspector.ConsoleMessage.MessageType.Log,
                "",
                0,
                0,
                networkRequest.requestId));
        }

        if (response.securityDetails)
            networkRequest.setSecurityDetails(response.securityDetails);
    },

    /**
     * @param {!WebInspector.NetworkRequest} networkRequest
     * @return {boolean}
     */
    _mimeTypeIsConsistentWithType: function(networkRequest)
    {
        // If status is an error, content is likely to be of an inconsistent type,
        // as it's going to be an error message. We do not want to emit a warning
        // for this, though, as this will already be reported as resource loading failure.
        // Also, if a URL like http://localhost/wiki/load.php?debug=true&lang=en produces text/css and gets reloaded,
        // it is 304 Not Modified and its guessed mime-type is text/php, which is wrong.
        // Don't check for mime-types in 304-resources.
        if (networkRequest.hasErrorStatusCode() || networkRequest.statusCode === 304 || networkRequest.statusCode === 204)
            return true;

        var resourceType = networkRequest.resourceType();
        if (resourceType !== WebInspector.resourceTypes.Stylesheet &&
            resourceType !== WebInspector.resourceTypes.Document &&
            resourceType !== WebInspector.resourceTypes.TextTrack) {
            return true;
        }

        if (!networkRequest.mimeType)
            return true; // Might be not known for cached resources with null responses.

        if (networkRequest.mimeType in WebInspector.NetworkManager._MIMETypes)
            return resourceType.name() in WebInspector.NetworkManager._MIMETypes[networkRequest.mimeType];

        return false;
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!PageAgent.FrameId} frameId
     * @param {!NetworkAgent.LoaderId} loaderId
     * @param {string} documentURL
     * @param {!NetworkAgent.Request} request
     * @param {!NetworkAgent.Timestamp} time
     * @param {!NetworkAgent.Timestamp} wallTime
     * @param {!NetworkAgent.Initiator} initiator
     * @param {!NetworkAgent.Response=} redirectResponse
     * @param {!PageAgent.ResourceType=} resourceType
     */
    requestWillBeSent: function(requestId, frameId, loaderId, documentURL, request, time, wallTime, initiator, redirectResponse, resourceType)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (networkRequest) {
            // FIXME: move this check to the backend.
            if (!redirectResponse)
                return;
            this.responseReceived(requestId, frameId, loaderId, time, PageAgent.ResourceType.Other, redirectResponse);
            networkRequest = this._appendRedirect(requestId, time, request.url);
        } else
            networkRequest = this._createNetworkRequest(requestId, frameId, loaderId, request.url, documentURL, initiator);
        networkRequest.hasNetworkData = true;
        this._updateNetworkRequestWithRequest(networkRequest, request);
        networkRequest.setIssueTime(time, wallTime);
        networkRequest.setResourceType(WebInspector.resourceTypes[resourceType]);

        this._startNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     */
    requestServedFromCache: function(requestId)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.setFromMemoryCache();
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!PageAgent.FrameId} frameId
     * @param {!NetworkAgent.LoaderId} loaderId
     * @param {!NetworkAgent.Timestamp} time
     * @param {!PageAgent.ResourceType} resourceType
     * @param {!NetworkAgent.Response} response
     */
    responseReceived: function(requestId, frameId, loaderId, time, resourceType, response)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest) {
            // We missed the requestWillBeSent.
            var eventData = {};
            eventData.url = response.url;
            eventData.frameId = frameId;
            eventData.loaderId = loaderId;
            eventData.resourceType = resourceType;
            eventData.mimeType = response.mimeType;
            this._manager.dispatchEventToListeners(WebInspector.NetworkManager.EventTypes.RequestUpdateDropped, eventData);
            return;
        }

        networkRequest.responseReceivedTime = time;
        networkRequest.setResourceType(WebInspector.resourceTypes[resourceType]);

        this._updateNetworkRequestWithResponse(networkRequest, response);

        this._updateNetworkRequest(networkRequest);
        this._manager.dispatchEventToListeners(WebInspector.NetworkManager.EventTypes.ResponseReceived, networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {number} dataLength
     * @param {number} encodedDataLength
     */
    dataReceived: function(requestId, time, dataLength, encodedDataLength)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.resourceSize += dataLength;
        if (encodedDataLength != -1)
            networkRequest.increaseTransferSize(encodedDataLength);
        networkRequest.endTime = time;

        this._updateNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} finishTime
     * @param {number} encodedDataLength
     */
    loadingFinished: function(requestId, finishTime, encodedDataLength)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;
        this._finishNetworkRequest(networkRequest, finishTime, encodedDataLength);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {!PageAgent.ResourceType} resourceType
     * @param {string} localizedDescription
     * @param {boolean=} canceled
     * @param {!NetworkAgent.BlockedReason=} blockedReason
     */
    loadingFailed: function(requestId, time, resourceType, localizedDescription, canceled, blockedReason)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.failed = true;
        networkRequest.setResourceType(WebInspector.resourceTypes[resourceType]);
        networkRequest.canceled = canceled;
        if (blockedReason) {
            networkRequest.setBlockedReason(blockedReason);
            if (blockedReason === NetworkAgent.BlockedReason.Inspector) {
                var consoleModel = this._manager._target.consoleModel;
                consoleModel.addMessage(new WebInspector.ConsoleMessage(consoleModel.target(), WebInspector.ConsoleMessage.MessageSource.Network,
                    WebInspector.ConsoleMessage.MessageLevel.Warning,
                    WebInspector.UIString("Request was blocked by DevTools: \"%s\".", networkRequest.url),
                    WebInspector.ConsoleMessage.MessageType.Log,
                    "",
                    0,
                    0,
                    networkRequest.requestId));
            }
        }
        networkRequest.localizedFailDescription = localizedDescription;
        this._finishNetworkRequest(networkRequest, time, -1);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {string} requestURL
     */
    webSocketCreated: function(requestId, requestURL)
    {
        // FIXME: WebSocket MUST have initiator info.
        var networkRequest = new WebInspector.NetworkRequest(this._manager._target, requestId, requestURL, "", "", "", null);
        networkRequest.setResourceType(WebInspector.resourceTypes.WebSocket);
        this._startNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {!NetworkAgent.Timestamp} wallTime
     * @param {!NetworkAgent.WebSocketRequest} request
     */
    webSocketWillSendHandshakeRequest: function(requestId, time, wallTime, request)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.requestMethod = "GET";
        networkRequest.setRequestHeaders(this._headersMapToHeadersArray(request.headers));
        networkRequest.setIssueTime(time, wallTime);

        this._updateNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {!NetworkAgent.WebSocketResponse} response
     */
    webSocketHandshakeResponseReceived: function(requestId, time, response)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.statusCode = response.status;
        networkRequest.statusText = response.statusText;
        networkRequest.responseHeaders = this._headersMapToHeadersArray(response.headers);
        networkRequest.responseHeadersText = response.headersText;
        if (response.requestHeaders)
            networkRequest.setRequestHeaders(this._headersMapToHeadersArray(response.requestHeaders));
        if (response.requestHeadersText)
            networkRequest.setRequestHeadersText(response.requestHeadersText);
        networkRequest.responseReceivedTime = time;
        networkRequest.protocol = "websocket";

        this._updateNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {!NetworkAgent.WebSocketFrame} response
     */
    webSocketFrameReceived: function(requestId, time, response)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.addFrame(response, time);
        networkRequest.responseReceivedTime = time;

        this._updateNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {!NetworkAgent.WebSocketFrame} response
     */
    webSocketFrameSent: function(requestId, time, response)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.addFrame(response, time, true);
        networkRequest.responseReceivedTime = time;

        this._updateNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {string} errorMessage
     */
    webSocketFrameError: function(requestId, time, errorMessage)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.addFrameError(errorMessage, time);
        networkRequest.responseReceivedTime = time;

        this._updateNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     */
    webSocketClosed: function(requestId, time)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;
        this._finishNetworkRequest(networkRequest, time, -1);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {string} eventName
     * @param {string} eventId
     * @param {string} data
     */
    eventSourceMessageReceived: function(requestId, time, eventName, eventId, data)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;
        networkRequest.addEventSourceMessage(time, eventName, eventId, data);
    },

    /**
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {string} redirectURL
     * @return {!WebInspector.NetworkRequest}
     */
    _appendRedirect: function(requestId, time, redirectURL)
    {
        var originalNetworkRequest = this._inflightRequestsById[requestId];
        var previousRedirects = originalNetworkRequest.redirects || [];
        originalNetworkRequest.requestId = requestId + ":redirected." + previousRedirects.length;
        delete originalNetworkRequest.redirects;
        if (previousRedirects.length > 0)
            originalNetworkRequest.redirectSource = previousRedirects[previousRedirects.length - 1];
        this._finishNetworkRequest(originalNetworkRequest, time, -1);
        var newNetworkRequest = this._createNetworkRequest(requestId, originalNetworkRequest.frameId, originalNetworkRequest.loaderId,
             redirectURL, originalNetworkRequest.documentURL, originalNetworkRequest.initiator());
        newNetworkRequest.redirects = previousRedirects.concat(originalNetworkRequest);
        return newNetworkRequest;
    },

    /**
     * @param {!WebInspector.NetworkRequest} networkRequest
     */
    _startNetworkRequest: function(networkRequest)
    {
        this._inflightRequestsById[networkRequest.requestId] = networkRequest;
        this._inflightRequestsByURL[networkRequest.url] = networkRequest;
        this._dispatchEventToListeners(WebInspector.NetworkManager.EventTypes.RequestStarted, networkRequest);
    },

    /**
     * @param {!WebInspector.NetworkRequest} networkRequest
     */
    _updateNetworkRequest: function(networkRequest)
    {
        this._dispatchEventToListeners(WebInspector.NetworkManager.EventTypes.RequestUpdated, networkRequest);
    },

    /**
     * @param {!WebInspector.NetworkRequest} networkRequest
     * @param {!NetworkAgent.Timestamp} finishTime
     * @param {number} encodedDataLength
     */
    _finishNetworkRequest: function(networkRequest, finishTime, encodedDataLength)
    {
        networkRequest.endTime = finishTime;
        networkRequest.finished = true;
        if (encodedDataLength >= 0)
            networkRequest.setTransferSize(encodedDataLength);
        this._dispatchEventToListeners(WebInspector.NetworkManager.EventTypes.RequestFinished, networkRequest);
        delete this._inflightRequestsById[networkRequest.requestId];
        delete this._inflightRequestsByURL[networkRequest.url];
    },

    /**
     * @param {string} eventType
     * @param {!WebInspector.NetworkRequest} networkRequest
     */
    _dispatchEventToListeners: function(eventType, networkRequest)
    {
        this._manager.dispatchEventToListeners(eventType, networkRequest);
    },

    /**
     * @param {!NetworkAgent.RequestId} requestId
     * @param {string} frameId
     * @param {!NetworkAgent.LoaderId} loaderId
     * @param {string} url
     * @param {string} documentURL
     * @param {?NetworkAgent.Initiator} initiator
     */
    _createNetworkRequest: function(requestId, frameId, loaderId, url, documentURL, initiator)
    {
        return new WebInspector.NetworkRequest(this._manager._target, requestId, url, documentURL, frameId, loaderId, initiator);
    }
}


/**
 * @constructor
 * @extends {WebInspector.Object}
 * @implements {WebInspector.TargetManager.Observer}
 */
WebInspector.MultitargetNetworkManager = function()
{
    WebInspector.Object.call(this);
    WebInspector.targetManager.observeTargets(this);

    /** @type {!Set<string>} */
    this._blockedURLs = new Set();
    this._blockedSetting = WebInspector.moduleSetting("blockedURLs");
    this._blockedSetting.addChangeListener(this._updateBlockedURLs, this);
    this._blockedSetting.set([]);
    this._updateBlockedURLs();

    this._userAgentOverride = "";
    /** @type {!Set<!Protocol.NetworkAgent>} */
    this._agentsCapableOfEmulation = new Set();
    /** @type {!WebInspector.NetworkManager.Conditions} */
    this._networkConditions = WebInspector.NetworkManager.NoThrottlingConditions;
}

WebInspector.MultitargetNetworkManager.Events = {
    ConditionsChanged: "ConditionsChanged",
    UserAgentChanged: "UserAgentChanged"
}

WebInspector.MultitargetNetworkManager.prototype = {
    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target)
    {
        var networkAgent = target.networkAgent();
        if (this._extraHeaders)
            networkAgent.setExtraHTTPHeaders(this._extraHeaders);
        if (this._currentUserAgent())
            networkAgent.setUserAgentOverride(this._currentUserAgent());
        for (var url of this._blockedURLs)
            networkAgent.addBlockedURL(url);

        networkAgent.canEmulateNetworkConditions(callback.bind(this));

        /**
         * @this {WebInspector.MultitargetNetworkManager}
         */
        function callback(error, canEmulate)
        {
            if (error || !canEmulate)
                return;
            this._agentsCapableOfEmulation.add(networkAgent);
            if (this.isThrottling())
                this._updateNetworkConditions(networkAgent);
        }
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target)
    {
        this._agentsCapableOfEmulation.delete(target.networkAgent());
    },

    /**
     * @return {boolean}
     */
    isThrottling: function()
    {
        return this._networkConditions.download >= 0 || this._networkConditions.upload >= 0 || this._networkConditions.latency > 0;
    },

    /**
     * @return {boolean}
     */
    isOffline: function()
    {
        return !this._networkConditions.download && !this._networkConditions.upload;
    },

    /**
     * @param {!WebInspector.NetworkManager.Conditions} conditions
     */
    setNetworkConditions: function(conditions)
    {
        this._networkConditions = conditions;
        for (var agent of this._agentsCapableOfEmulation)
            this._updateNetworkConditions(agent);
        this.dispatchEventToListeners(WebInspector.MultitargetNetworkManager.Events.ConditionsChanged);
    },

    /**
     * @return {!WebInspector.NetworkManager.Conditions}
     */
    networkConditions: function()
    {
        return this._networkConditions;
    },

    /**
     * @param {!Protocol.NetworkAgent} networkAgent
     */
    _updateNetworkConditions: function(networkAgent)
    {
        var conditions = this._networkConditions;
        if (!this.isThrottling()) {
            networkAgent.emulateNetworkConditions(false, 0, 0, 0);
        } else {
            networkAgent.emulateNetworkConditions(this.isOffline(), conditions.latency, conditions.download < 0 ? 0 : conditions.download, conditions.upload < 0 ? 0 : conditions.upload);
        }
    },

    /**
     * @param {!NetworkAgent.Headers} headers
     */
    setExtraHTTPHeaders: function(headers)
    {
        this._extraHeaders = headers;
        for (var target of WebInspector.targetManager.targets())
            target.networkAgent().setExtraHTTPHeaders(this._extraHeaders);
    },

    /**
     * @return {string}
     */
    _currentUserAgent: function()
    {
        return this._customUserAgent ? this._customUserAgent : this._userAgentOverride;
    },

    _updateUserAgentOverride: function()
    {
        var userAgent = this._currentUserAgent();
        WebInspector.ResourceLoader.targetUserAgent = userAgent;
        for (var target of WebInspector.targetManager.targets())
            target.networkAgent().setUserAgentOverride(userAgent);
    },

    /**
     * @param {string} userAgent
     */
    setUserAgentOverride: function(userAgent)
    {
        if (this._userAgentOverride === userAgent)
            return;
        this._userAgentOverride = userAgent;
        if (!this._customUserAgent)
            this._updateUserAgentOverride();
        this.dispatchEventToListeners(WebInspector.MultitargetNetworkManager.Events.UserAgentChanged);
    },

    /**
     * @return {string}
     */
    userAgentOverride: function()
    {
        return this._userAgentOverride;
    },

    /**
     * @param {string} userAgent
     */
    setCustomUserAgentOverride: function(userAgent)
    {
        this._customUserAgent = userAgent;
        this._updateUserAgentOverride();
    },

    _updateBlockedURLs: function()
    {
        var blocked = this._blockedSetting.get();
        for (var url of blocked) {
            if (!this._blockedURLs.has(url))
                this._addBlockedURL(url);
        }
        for (var url of this._blockedURLs) {
            if (blocked.indexOf(url) === -1)
                this._removeBlockedURL(url);
        }
    },

    /**
     * @param {string} url
     */
    _addBlockedURL: function(url)
    {
        this._blockedURLs.add(url);
        for (var target of WebInspector.targetManager.targets())
            target.networkAgent().addBlockedURL(url);
    },

    /**
     * @param {string} url
     */
    _removeBlockedURL: function(url)
    {
        this._blockedURLs.delete(url);
        for (var target of WebInspector.targetManager.targets())
            target.networkAgent().removeBlockedURL(url);
    },

    clearBrowserCache: function()
    {
        for (var target of WebInspector.targetManager.targets())
            target.networkAgent().clearBrowserCache();
    },

    clearBrowserCookies: function()
    {
        for (var target of WebInspector.targetManager.targets())
            target.networkAgent().clearBrowserCookies();
    },

    /**
     * @param {!NetworkAgent.CertificateId} certificateId
     */
    showCertificateViewer: function(certificateId)
    {
        var target = WebInspector.targetManager.mainTarget();
        if (target)
            target.networkAgent().showCertificateViewer(certificateId);
    },

    /**
     * @param {string} url
     * @param {function(number, !Object.<string, string>, string)} callback
     */
    loadResource: function(url, callback)
    {
        var headers = {};

        var currentUserAgent = this._currentUserAgent();
        if (currentUserAgent)
            headers["User-Agent"] = currentUserAgent;

        if (WebInspector.moduleSetting("cacheDisabled").get())
            headers["Cache-Control"] = "no-cache";

        WebInspector.ResourceLoader.load(url, headers, callback);
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @type {!WebInspector.MultitargetNetworkManager}
 */
WebInspector.multitargetNetworkManager;
;/* NetworkRequest.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @implements {WebInspector.ContentProvider}
 * @param {!NetworkAgent.RequestId} requestId
 * @param {!WebInspector.Target} target
 * @param {string} url
 * @param {string} documentURL
 * @param {!PageAgent.FrameId} frameId
 * @param {!NetworkAgent.LoaderId} loaderId
 * @param {?NetworkAgent.Initiator} initiator
 */
WebInspector.NetworkRequest = function(target, requestId, url, documentURL, frameId, loaderId, initiator)
{
    WebInspector.SDKObject.call(this, target);

    this._requestId = requestId;
    this.url = url;
    this._documentURL = documentURL;
    this._frameId = frameId;
    this._loaderId = loaderId;
    /** @type {?NetworkAgent.Initiator} */
    this._initiator = initiator;
    this._issueTime = -1;
    this._startTime = -1;
    this._endTime = -1;
    /** @type {!NetworkAgent.BlockedReason|undefined} */
    this._blockedReason = undefined;

    this.statusCode = 0;
    this.statusText = "";
    this.requestMethod = "";
    this.requestTime = 0;
    this.protocol = "";
    /** @type {!NetworkAgent.RequestMixedContentType} */
    this.mixedContentType = NetworkAgent.RequestMixedContentType.None;

    /** @type {?NetworkAgent.ResourcePriority} */
    this._initialPriority = null;

    /** @type {!WebInspector.ResourceType} */
    this._resourceType = WebInspector.resourceTypes.Other;
    this._contentEncoded = false;
    this._pendingContentCallbacks = [];
    /** @type {!Array.<!WebInspector.NetworkRequest.WebSocketFrame>} */
    this._frames = [];
    /** @type {!Array.<!WebInspector.NetworkRequest.EventSourceMessage>} */
    this._eventSourceMessages = [];

    this._responseHeaderValues = {};

    this._remoteAddress = "";

    /** @type {!SecurityAgent.SecurityState} */
    this._securityState = SecurityAgent.SecurityState.Unknown;
    /** @type {?NetworkAgent.SecurityDetails} */
    this._securityDetails = null;

    /** @type {string} */
    this.connectionId = "0";
}

WebInspector.NetworkRequest.Events = {
    FinishedLoading: "FinishedLoading",
    TimingChanged: "TimingChanged",
    RemoteAddressChanged: "RemoteAddressChanged",
    RequestHeadersChanged: "RequestHeadersChanged",
    ResponseHeadersChanged: "ResponseHeadersChanged",
    WebsocketFrameAdded: "WebsocketFrameAdded",
    EventSourceMessageAdded: "EventSourceMessageAdded",
}

/** @enum {string} */
WebInspector.NetworkRequest.InitiatorType = {
    Other: "other",
    Parser: "parser",
    Redirect: "redirect",
    Script: "script"
}

/** @typedef {!{name: string, value: string}} */
WebInspector.NetworkRequest.NameValue;

/** @enum {string} */
WebInspector.NetworkRequest.WebSocketFrameType = {
    Send: "send",
    Receive: "receive",
    Error: "error"
}

/** @typedef {!{type: WebInspector.NetworkRequest.WebSocketFrameType, time: number, text: string, opCode: number, mask: boolean}} */
WebInspector.NetworkRequest.WebSocketFrame;

/** @typedef {!{time: number, eventName: string, eventId: string, data: string}} */
WebInspector.NetworkRequest.EventSourceMessage;

WebInspector.NetworkRequest.prototype = {
    /**
     * @param {!WebInspector.NetworkRequest} other
     * @return {number}
     */
    indentityCompare: function(other)
    {
        if (this._requestId > other._requestId)
            return 1;
        if (this._requestId < other._requestId)
            return -1;
        return 0;
    },

    /**
     * @return {!NetworkAgent.RequestId}
     */
    get requestId()
    {
        return this._requestId;
    },

    set requestId(requestId)
    {
        this._requestId = requestId;
    },

    /**
     * @return {string}
     */
    get url()
    {
        return this._url;
    },

    set url(x)
    {
        if (this._url === x)
            return;

        this._url = x;
        this._parsedURL = new WebInspector.ParsedURL(x);
        delete this._queryString;
        delete this._parsedQueryParameters;
        delete this._name;
        delete this._path;
    },

    /**
     * @return {string}
     */
    get documentURL()
    {
        return this._documentURL;
    },

    get parsedURL()
    {
        return this._parsedURL;
    },

    /**
     * @return {!PageAgent.FrameId}
     */
    get frameId()
    {
        return this._frameId;
    },

    /**
     * @return {!NetworkAgent.LoaderId}
     */
    get loaderId()
    {
        return this._loaderId;
    },

    /**
     * @param {string} ip
     * @param {number} port
     */
    setRemoteAddress: function(ip, port)
    {
        if (ip.indexOf(":") !== -1)
            ip = "[" + ip + "]";
        this._remoteAddress = ip + ":" + port;
        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.RemoteAddressChanged, this);
    },

    /**
     * @return {string}
     */
    remoteAddress: function()
    {
        return this._remoteAddress;
    },

    /**
     * @return {!SecurityAgent.SecurityState}
     */
    securityState: function()
    {
        return this._securityState;
    },

    /**
     * @param {!SecurityAgent.SecurityState} securityState
     */
    setSecurityState: function(securityState)
    {
        this._securityState = securityState;
    },

    /**
     * @return {?NetworkAgent.SecurityDetails}
     */
    securityDetails: function()
    {
        return this._securityDetails;
    },

    /**
     * @param {!NetworkAgent.SecurityDetails} securityDetails
     */
    setSecurityDetails: function(securityDetails)
    {
        this._securityDetails = securityDetails;
    },

    /**
     * @return {number}
     */
    get startTime()
    {
        return this._startTime || -1;
    },

    /**
     * @param {number} monotonicTime
     * @param {number} wallTime
     */
    setIssueTime: function(monotonicTime, wallTime)
    {
        this._issueTime = monotonicTime;
        this._wallIssueTime = wallTime;
        this._startTime = monotonicTime;
    },

    /**
     * @return {number}
     */
    issueTime: function()
    {
        return this._issueTime;
    },

    /**
     * @param {number} monotonicTime
     * @return {number}
     */
    pseudoWallTime: function(monotonicTime)
    {
        return this._wallIssueTime ? this._wallIssueTime - this._issueTime + monotonicTime : monotonicTime;
    },

    /**
     * @return {number}
     */
    get responseReceivedTime()
    {
        return this._responseReceivedTime || -1;
    },

    set responseReceivedTime(x)
    {
        this._responseReceivedTime = x;
    },

    /**
     * @return {number}
     */
    get endTime()
    {
        return this._endTime || -1;
    },

    set endTime(x)
    {
        if (this.timing && this.timing.requestTime) {
            // Check against accurate responseReceivedTime.
            this._endTime = Math.max(x, this.responseReceivedTime);
        } else {
            // Prefer endTime since it might be from the network stack.
            this._endTime = x;
            if (this._responseReceivedTime > x)
                this._responseReceivedTime = x;
        }
        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.TimingChanged, this);
    },

    /**
     * @return {number}
     */
    get duration()
    {
        if (this._endTime === -1 || this._startTime === -1)
            return -1;
        return this._endTime - this._startTime;
    },

    /**
     * @return {number}
     */
    get latency()
    {
        if (this._responseReceivedTime === -1 || this._startTime === -1)
            return -1;
        return this._responseReceivedTime - this._startTime;
    },

    /**
     * @return {number}
     */
    get resourceSize()
    {
        return this._resourceSize || 0;
    },

    set resourceSize(x)
    {
        this._resourceSize = x;
    },

    /**
     * @return {number}
     */
    get transferSize()
    {
        return this._transferSize || 0;
    },

    /**
     * @param {number} x
     */
    increaseTransferSize: function(x)
    {
        this._transferSize = (this._transferSize || 0) + x;
    },

    /**
     * @param {number} x
     */
    setTransferSize: function(x)
    {
        this._transferSize = x;
    },

    /**
     * @return {boolean}
     */
    get finished()
    {
        return this._finished;
    },

    set finished(x)
    {
        if (this._finished === x)
            return;

        this._finished = x;

        if (x) {
            this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.FinishedLoading, this);
            if (this._pendingContentCallbacks.length)
                this._innerRequestContent();
        }
    },

    /**
     * @return {boolean}
     */
    get failed()
    {
        return this._failed;
    },

    set failed(x)
    {
        this._failed = x;
    },

    /**
     * @return {boolean}
     */
    get canceled()
    {
        return this._canceled;
    },

    set canceled(x)
    {
        this._canceled = x;
    },

    /**
     * @return {!NetworkAgent.BlockedReason|undefined}
     */
    blockedReason: function()
    {
        return this._blockedReason;
    },

    /**
     * @param {!NetworkAgent.BlockedReason} reason
     */
    setBlockedReason: function(reason)
    {
        this._blockedReason = reason;
    },

    /**
     * @return {boolean}
     */
    wasBlocked: function()
    {
        return !!this._blockedReason;
    },

    /**
     * @return {boolean}
     */
    cached: function()
    {
        return (!!this._fromMemoryCache || !!this._fromDiskCache) && !this._transferSize;
    },

    setFromMemoryCache: function()
    {
        this._fromMemoryCache = true;
        delete this._timing;
    },

    setFromDiskCache: function()
    {
        this._fromDiskCache = true;
    },

    /**
     * @return {boolean}
     */
    get fetchedViaServiceWorker()
    {
        return this._fetchedViaServiceWorker;
    },

    set fetchedViaServiceWorker(x)
    {
        this._fetchedViaServiceWorker = x;
    },

    /**
     * @return {!NetworkAgent.ResourceTiming|undefined}
     */
    get timing()
    {
        return this._timing;
    },

    set timing(x)
    {
        if (x && !this._fromMemoryCache) {
            // Take startTime and responseReceivedTime from timing data for better accuracy.
            // Timing's requestTime is a baseline in seconds, rest of the numbers there are ticks in millis.
            this._startTime = x.requestTime;
            this._responseReceivedTime = x.requestTime + x.receiveHeadersEnd / 1000.0;

            this._timing = x;
            this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.TimingChanged, this);
        }
    },

    /**
     * @return {string}
     */
    get mimeType()
    {
        return this._mimeType;
    },

    set mimeType(x)
    {
        this._mimeType = x;
    },

    /**
     * @return {string}
     */
    get displayName()
    {
        return this._parsedURL.displayName;
    },

    /**
     * @return {string}
     */
    name: function()
    {
        if (this._name)
            return this._name;
        this._parseNameAndPathFromURL();
        return this._name;
    },

    /**
     * @return {string}
     */
    path: function()
    {
        if (this._path)
            return this._path;
        this._parseNameAndPathFromURL();
        return this._path;
    },

    _parseNameAndPathFromURL: function()
    {
        if (this._parsedURL.isDataURL()) {
            this._name = this._parsedURL.dataURLDisplayName();
            this._path = "";
        } else if (this._parsedURL.isAboutBlank()) {
            this._name = this._parsedURL.url;
            this._path = "";
        } else {
            this._path = this._parsedURL.host + this._parsedURL.folderPathComponents;
            this._path = this._path.trimURL(this.target().resourceTreeModel.inspectedPageDomain());
            if (this._parsedURL.lastPathComponent || this._parsedURL.queryParams)
                this._name = this._parsedURL.lastPathComponent + (this._parsedURL.queryParams ? "?" + this._parsedURL.queryParams : "");
            else if (this._parsedURL.folderPathComponents) {
                this._name = this._parsedURL.folderPathComponents.substring(this._parsedURL.folderPathComponents.lastIndexOf("/") + 1) + "/";
                this._path = this._path.substring(0, this._path.lastIndexOf("/"));
            } else {
                this._name = this._parsedURL.host;
                this._path = "";
            }
        }
    },

    /**
     * @return {string}
     */
    get folder()
    {
        var path = this._parsedURL.path;
        var indexOfQuery = path.indexOf("?");
        if (indexOfQuery !== -1)
            path = path.substring(0, indexOfQuery);
        var lastSlashIndex = path.lastIndexOf("/");
        return lastSlashIndex !== -1 ? path.substring(0, lastSlashIndex) : "";
    },

    /**
     * @return {!WebInspector.ResourceType}
     */
    resourceType: function()
    {
        return this._resourceType;
    },

    /**
     * @param {!WebInspector.ResourceType} resourceType
     */
    setResourceType: function(resourceType)
    {
        this._resourceType = resourceType;
    },

    /**
     * @return {string}
     */
    get domain()
    {
        return this._parsedURL.host;
    },

    /**
     * @return {string}
     */
    get scheme()
    {
        return this._parsedURL.scheme;
    },

    /**
     * @return {?WebInspector.NetworkRequest}
     */
    get redirectSource()
    {
        if (this.redirects && this.redirects.length > 0)
            return this.redirects[this.redirects.length - 1];
        return this._redirectSource;
    },

    set redirectSource(x)
    {
        this._redirectSource = x;
        delete this._initiatorInfo;
    },

    /**
     * @return {!Array.<!WebInspector.NetworkRequest.NameValue>}
     */
    requestHeaders: function()
    {
        return this._requestHeaders || [];
    },

    /**
     * @param {!Array.<!WebInspector.NetworkRequest.NameValue>} headers
     */
    setRequestHeaders: function(headers)
    {
        this._requestHeaders = headers;
        delete this._requestCookies;

        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.RequestHeadersChanged);
    },

    /**
     * @return {string|undefined}
     */
    requestHeadersText: function()
    {
        return this._requestHeadersText;
    },

    /**
     * @param {string} text
     */
    setRequestHeadersText: function(text)
    {
        this._requestHeadersText = text;

        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.RequestHeadersChanged);
    },

    /**
     * @param {string} headerName
     * @return {string|undefined}
     */
    requestHeaderValue: function(headerName)
    {
        return this._headerValue(this.requestHeaders(), headerName);
    },

    /**
     * @return {!Array.<!WebInspector.Cookie>}
     */
    get requestCookies()
    {
        if (!this._requestCookies)
            this._requestCookies = WebInspector.CookieParser.parseCookie(this.target(), this.requestHeaderValue("Cookie"));
        return this._requestCookies;
    },

    /**
     * @return {string|undefined}
     */
    get requestFormData()
    {
        return this._requestFormData;
    },

    set requestFormData(x)
    {
        this._requestFormData = x;
        delete this._parsedFormParameters;
    },

    /**
     * @return {string}
     */
    requestHttpVersion: function()
    {
        var headersText = this.requestHeadersText();
        if (!headersText)
            return this.requestHeaderValue("version") || this.requestHeaderValue(":version") || "unknown";
        var firstLine = headersText.split(/\r\n/)[0];
        var match = firstLine.match(/(HTTP\/\d+\.\d+)$/);
        return match ? match[1] : "HTTP/0.9";
    },

    /**
     * @return {!Array.<!WebInspector.NetworkRequest.NameValue>}
     */
    get responseHeaders()
    {
        return this._responseHeaders || [];
    },

    set responseHeaders(x)
    {
        this._responseHeaders = x;
        delete this._sortedResponseHeaders;
        delete this._responseCookies;
        this._responseHeaderValues = {};

        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.ResponseHeadersChanged);
    },

    /**
     * @return {string}
     */
    get responseHeadersText()
    {
        return this._responseHeadersText;
    },

    set responseHeadersText(x)
    {
        this._responseHeadersText = x;

        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.ResponseHeadersChanged);
    },

    /**
     * @return {!Array.<!WebInspector.NetworkRequest.NameValue>}
     */
    get sortedResponseHeaders()
    {
        if (this._sortedResponseHeaders !== undefined)
            return this._sortedResponseHeaders;

        this._sortedResponseHeaders = this.responseHeaders.slice();
        this._sortedResponseHeaders.sort(function(a, b) { return a.name.toLowerCase().compareTo(b.name.toLowerCase()); });
        return this._sortedResponseHeaders;
    },

    /**
     * @param {string} headerName
     * @return {string|undefined}
     */
    responseHeaderValue: function(headerName)
    {
        var value = this._responseHeaderValues[headerName];
        if (value === undefined) {
            value = this._headerValue(this.responseHeaders, headerName);
            this._responseHeaderValues[headerName] = (value !== undefined) ? value : null;
        }
        return (value !== null) ? value : undefined;
    },

    /**
     * @return {!Array.<!WebInspector.Cookie>}
     */
    get responseCookies()
    {
        if (!this._responseCookies)
            this._responseCookies = WebInspector.CookieParser.parseSetCookie(this.target(), this.responseHeaderValue("Set-Cookie"));
        return this._responseCookies;
    },

    /**
     * @return {?string}
     */
    queryString: function()
    {
        if (this._queryString !== undefined)
            return this._queryString;

        var queryString = null;
        var url = this.url;
        var questionMarkPosition = url.indexOf("?");
        if (questionMarkPosition !== -1) {
            queryString = url.substring(questionMarkPosition + 1);
            var hashSignPosition = queryString.indexOf("#");
            if (hashSignPosition !== -1)
                queryString = queryString.substring(0, hashSignPosition);
        }
        this._queryString = queryString;
        return this._queryString;
    },

    /**
     * @return {?Array.<!WebInspector.NetworkRequest.NameValue>}
     */
    get queryParameters()
    {
        if (this._parsedQueryParameters)
            return this._parsedQueryParameters;
        var queryString = this.queryString();
        if (!queryString)
            return null;
        this._parsedQueryParameters = this._parseParameters(queryString);
        return this._parsedQueryParameters;
    },

    /**
     * @return {?Array.<!WebInspector.NetworkRequest.NameValue>}
     */
    get formParameters()
    {
        if (this._parsedFormParameters)
            return this._parsedFormParameters;
        if (!this.requestFormData)
            return null;
        var requestContentType = this.requestContentType();
        if (!requestContentType || !requestContentType.match(/^application\/x-www-form-urlencoded\s*(;.*)?$/i))
            return null;
        this._parsedFormParameters = this._parseParameters(this.requestFormData);
        return this._parsedFormParameters;
    },

    /**
     * @return {string}
     */
    responseHttpVersion: function()
    {
        var headersText = this._responseHeadersText;
        if (!headersText)
            return this.responseHeaderValue("version") || this.responseHeaderValue(":version") || "unknown";
        var firstLine = headersText.split(/\r\n/)[0];
        var match = firstLine.match(/^(HTTP\/\d+\.\d+)/);
        return match ? match[1] : "HTTP/0.9";
    },

    /**
     * @param {string} queryString
     * @return {!Array.<!WebInspector.NetworkRequest.NameValue>}
     */
    _parseParameters: function(queryString)
    {
        function parseNameValue(pair)
        {
            var position = pair.indexOf("=");
            if (position === -1)
                return {name: pair, value: ""};
            else
                return {name: pair.substring(0, position), value: pair.substring(position + 1)};
        }
        return queryString.split("&").map(parseNameValue);
    },

    /**
     * @param {!Array.<!WebInspector.NetworkRequest.NameValue>} headers
     * @param {string} headerName
     * @return {string|undefined}
     */
    _headerValue: function(headers, headerName)
    {
        headerName = headerName.toLowerCase();

        var values = [];
        for (var i = 0; i < headers.length; ++i) {
            if (headers[i].name.toLowerCase() === headerName)
                values.push(headers[i].value);
        }
        if (!values.length)
            return undefined;
        // Set-Cookie values should be separated by '\n', not comma, otherwise cookies could not be parsed.
        if (headerName === "set-cookie")
            return values.join("\n");
        return values.join(", ");
    },

    /**
     * @return {?string|undefined}
     */
    get content()
    {
        return this._content;
    },

    /**
     * @return {?Protocol.Error|undefined}
     */
    contentError: function()
    {
        return this._contentError;
    },

    /**
     * @return {boolean}
     */
    get contentEncoded()
    {
        return this._contentEncoded;
    },

    /**
     * @override
     * @return {string}
     */
    contentURL: function()
    {
        return this._url;
    },

    /**
     * @override
     * @return {!WebInspector.ResourceType}
     */
    contentType: function()
    {
        return this._resourceType;
    },

    /**
     * @override
     * @return {!Promise<?string>}
     */
    requestContent: function()
    {
        // We do not support content retrieval for WebSockets at the moment.
        // Since WebSockets are potentially long-living, fail requests immediately
        // to prevent caller blocking until resource is marked as finished.
        if (this._resourceType === WebInspector.resourceTypes.WebSocket)
            return Promise.resolve(/** @type {?string} */(null));
        if (typeof this._content !== "undefined")
            return Promise.resolve(/** @type {?string} */(this.content || null));
        var callback;
        var promise = new Promise(fulfill => callback = fulfill);
        this._pendingContentCallbacks.push(callback);
        if (this.finished)
            this._innerRequestContent();
        return promise;
    },

    /**
     * @override
     * @param {string} query
     * @param {boolean} caseSensitive
     * @param {boolean} isRegex
     * @param {function(!Array.<!WebInspector.ContentProvider.SearchMatch>)} callback
     */
    searchInContent: function(query, caseSensitive, isRegex, callback)
    {
        callback([]);
    },

    /**
     * @return {boolean}
     */
    isHttpFamily: function()
    {
        return !!this.url.match(/^https?:/i);
    },

    /**
     * @return {string|undefined}
     */
    requestContentType: function()
    {
        return this.requestHeaderValue("Content-Type");
    },

    /**
     * @return {boolean}
     */
    hasErrorStatusCode: function()
    {
        return this.statusCode >= 400;
    },

    /**
     * @param {!NetworkAgent.ResourcePriority} priority
     */
    setInitialPriority: function(priority)
    {
        this._initialPriority = priority;
    },

    /**
     * @return {?NetworkAgent.ResourcePriority}
     */
    initialPriority: function()
    {
        return this._initialPriority;
    },

    /**
     * @param {!Element} image
     */
    populateImageSource: function(image)
    {
        WebInspector.Resource.populateImageSource(this._url, this._mimeType, this, image);
    },

    /**
     * @return {?string}
     */
    asDataURL: function()
    {
        var content = this._content;
        var charset = null;
        if (!this._contentEncoded) {
            content = content.toBase64();
            charset = "utf-8";
        }
        return WebInspector.Resource.contentAsDataURL(content, this.mimeType, true, charset);
    },

    _innerRequestContent: function()
    {
        if (this._contentRequested)
            return;
        this._contentRequested = true;

        /**
         * @param {?Protocol.Error} error
         * @param {string} content
         * @param {boolean} contentEncoded
         * @this {WebInspector.NetworkRequest}
         */
        function onResourceContent(error, content, contentEncoded)
        {
            this._content = error ? null : content;
            this._contentError = error;
            this._contentEncoded = contentEncoded;
            var callbacks = this._pendingContentCallbacks.slice();
            for (var i = 0; i < callbacks.length; ++i)
                callbacks[i](this._content);
            this._pendingContentCallbacks.length = 0;
            delete this._contentRequested;
        }
        this.target().networkAgent().getResponseBody(this._requestId, onResourceContent.bind(this));
    },

    /**
     * @return {?NetworkAgent.Initiator}
     */
    initiator: function()
    {
        return this._initiator;
    },

    /**
     * @return {!{type: !WebInspector.NetworkRequest.InitiatorType, url: string, lineNumber: number, columnNumber: number, scriptId: ?string}}
     */
    initiatorInfo: function()
    {
        if (this._initiatorInfo)
            return this._initiatorInfo;

        var type = WebInspector.NetworkRequest.InitiatorType.Other;
        var url = "";
        var lineNumber = -Infinity;
        var columnNumber = -Infinity;
        var scriptId = null;
        var initiator = this._initiator;

        if (this.redirectSource) {
            type = WebInspector.NetworkRequest.InitiatorType.Redirect;
            url = this.redirectSource.url;
        } else if (initiator) {
            if (initiator.type === NetworkAgent.InitiatorType.Parser) {
                type = WebInspector.NetworkRequest.InitiatorType.Parser;
                url = initiator.url ? initiator.url : url;
                lineNumber = initiator.lineNumber ? initiator.lineNumber : lineNumber;
            } else if (initiator.type === NetworkAgent.InitiatorType.Script) {
                for (var stack = initiator.stack; stack; stack = stack.parent) {
                    var topFrame = stack.callFrames.length ? stack.callFrames[0] : null;
                    if (!topFrame)
                        continue;
                    type = WebInspector.NetworkRequest.InitiatorType.Script;
                    url = topFrame.url || WebInspector.UIString("<anonymous>");
                    lineNumber = topFrame.lineNumber;
                    columnNumber = topFrame.columnNumber;
                    scriptId = topFrame.scriptId;
                    break;
                }
            }
        }

        this._initiatorInfo = {type: type, url: url, lineNumber: lineNumber, columnNumber: columnNumber, scriptId: scriptId};
        return this._initiatorInfo;
    },

    /**
     * @return {?WebInspector.NetworkRequest}
     */
    initiatorRequest: function()
    {
        if (this._initiatorRequest === undefined)
            this._initiatorRequest = this.target().networkLog.requestForURL(this.initiatorInfo().url);
        return this._initiatorRequest;
    },

    /**
     * @return {!Set<!WebInspector.NetworkRequest>}
     */
    initiatorChain: function()
    {
        if (this._initiatorChain)
            return this._initiatorChain;
        this._initiatorChain = new Set();
        var request = this;
        while (request) {
            this._initiatorChain.add(request);
            request = request.initiatorRequest();
        }
        return this._initiatorChain;
    },

    /**
     * @return {!Array.<!WebInspector.NetworkRequest.WebSocketFrame>}
     */
    frames: function()
    {
        return this._frames;
    },

    /**
     * @param {string} errorMessage
     * @param {number} time
     */
    addFrameError: function(errorMessage, time)
    {
        this._addFrame({ type: WebInspector.NetworkRequest.WebSocketFrameType.Error, text: errorMessage, time: this.pseudoWallTime(time), opCode: -1, mask: false });
    },

    /**
     * @param {!NetworkAgent.WebSocketFrame} response
     * @param {number} time
     * @param {boolean} sent
     */
    addFrame: function(response, time, sent)
    {
        var type = sent ? WebInspector.NetworkRequest.WebSocketFrameType.Send : WebInspector.NetworkRequest.WebSocketFrameType.Receive;
        this._addFrame({ type: type, text: response.payloadData, time: this.pseudoWallTime(time), opCode: response.opcode, mask: response.mask });
    },

    /**
     * @param {!WebInspector.NetworkRequest.WebSocketFrame} frame
     */
    _addFrame: function(frame)
    {
        this._frames.push(frame);
        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.WebsocketFrameAdded, frame);
    },

    /**
     * @return {!Array.<!WebInspector.NetworkRequest.EventSourceMessage>}
     */
    eventSourceMessages: function()
    {
        return this._eventSourceMessages;
    },

    /**
     * @param {number} time
     * @param {string} eventName
     * @param {string} eventId
     * @param {string} data
     */
    addEventSourceMessage: function(time, eventName, eventId, data)
    {
        var message = {time: this.pseudoWallTime(time), eventName: eventName, eventId: eventId, data: data};
        this._eventSourceMessages.push(message);
        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.EventSourceMessageAdded, message);
    },

    replayXHR: function()
    {
        this.target().networkAgent().replayXHR(this.requestId);
    },

    __proto__: WebInspector.SDKObject.prototype
}
;/* PaintProfiler.js */
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @typedef {!{x: number, y: number, picture: string}}
 */
WebInspector.PictureFragment;

/**
 * @constructor
 * @param {!WebInspector.Target} target
 * @param {string} snapshotId
 */
WebInspector.PaintProfilerSnapshot = function(target, snapshotId)
{
    this._target = target;
    this._id = snapshotId;
}

/**
 * @param {!WebInspector.Target} target
 * @param {!Array.<!WebInspector.PictureFragment>} fragments
 * @param {function(?WebInspector.PaintProfilerSnapshot)} callback
 */
WebInspector.PaintProfilerSnapshot.loadFromFragments = function(target, fragments, callback)
{
    var wrappedCallback = InspectorBackend.wrapClientCallback(callback, "LayerTreeAgent.loadSnapshot(): ", WebInspector.PaintProfilerSnapshot.bind(null, target));
    target.layerTreeAgent().loadSnapshot(fragments, wrappedCallback);
}

/**
 * @param {!WebInspector.Target} target
 * @param {string} encodedPicture
 * @param {function(?WebInspector.PaintProfilerSnapshot)} callback
 */
WebInspector.PaintProfilerSnapshot.load = function(target, encodedPicture, callback)
{
    var fragment = {
        x: 0,
        y: 0,
        picture: encodedPicture
    };
    WebInspector.PaintProfilerSnapshot.loadFromFragments(target, [fragment], callback);
}

/**
 * @param {!Array.<!WebInspector.RawPaintProfilerLogItem>} log
 * @return {!Array.<!WebInspector.PaintProfilerLogItem>}
 */
WebInspector.PaintProfilerSnapshot._processAnnotations = function(log)
{
    var result = [];
    /** @type {!Array.<!Object.<string, string>>} */
    var commentGroupStack = [];

    for (var i = 0; i < log.length; ++i) {
        var method = log[i].method;
        switch (method) {
        case "beginCommentGroup":
            commentGroupStack.push({});
            break;
        case "addComment":
            var group = commentGroupStack.peekLast();
            if (!group) {
                console.assert(false, "Stray comment without a group");
                break;
            }
            var key = String(log[i].params["key"]);
            var value = String(log[i].params["value"]);
            if (!key || typeof value === "undefined") {
                console.assert(false, "Missing key or value in addComment() params");
                break;
            }
            if (key in group) {
                console.assert(false, "Duplicate key in comment group");
                break;
            }
            group[key] = value;
            break;
        case "endCommentGroup":
            if (!commentGroupStack.length)
                console.assert(false, "Unbalanced commentGroupEnd call");
            else
                commentGroupStack.pop();
            break;
        default:
            result.push(new WebInspector.PaintProfilerLogItem(log[i], i, commentGroupStack.peekLast()));
        }
    }
    return result;
}

WebInspector.PaintProfilerSnapshot.prototype = {
    dispose: function()
    {
        this._target.layerTreeAgent().releaseSnapshot(this._id);
    },

    /**
     * @return {!WebInspector.Target}
     */
    target: function()
    {
        return this._target;
    },

    /**
     * @param {?number} firstStep
     * @param {?number} lastStep
     * @param {?number} scale
     * @param {function(string=)} callback
     */
    requestImage: function(firstStep, lastStep, scale, callback)
    {
        var wrappedCallback = InspectorBackend.wrapClientCallback(callback, "LayerTreeAgent.replaySnapshot(): ");
        this._target.layerTreeAgent().replaySnapshot(this._id, firstStep || undefined, lastStep || undefined, scale || 1.0, wrappedCallback);
    },

    /**
     * @param {?DOMAgent.Rect} clipRect
     * @param {function(!Array.<!LayerTreeAgent.PaintProfile>=)} callback
     */
    profile: function(clipRect, callback)
    {
        var wrappedCallback = InspectorBackend.wrapClientCallback(callback, "LayerTreeAgent.profileSnapshot(): ");
        this._target.layerTreeAgent().profileSnapshot(this._id, 5, 1, clipRect || undefined, wrappedCallback);
    },

    /**
     * @param {function(!Array.<!WebInspector.PaintProfilerLogItem>=)} callback
     */
    commandLog: function(callback)
    {
        /**
         * @param {?string} error
         * @param {!Array.<!WebInspector.RawPaintProfilerLogItem>} log
         */
        function callbackWrapper(error, log)
        {
            if (error) {
                console.error("LayerTreeAgent.snapshotCommandLog(): " + error);
                callback();
                return;
            }
            callback(WebInspector.PaintProfilerSnapshot._processAnnotations(log));
        }

        this._target.layerTreeAgent().snapshotCommandLog(this._id, callbackWrapper);
    }
};

/**
 * @typedef {!{method: string, params: ?Array.<!Object.<string, *>>}}
 */
WebInspector.RawPaintProfilerLogItem;

/**
 * @constructor
 * @param {!WebInspector.RawPaintProfilerLogItem} rawEntry
 * @param {number} commandIndex
 * @param {!Object.<string, string>=} annotations
 */
WebInspector.PaintProfilerLogItem = function(rawEntry, commandIndex, annotations)
{
    this.method = rawEntry.method;
    this.params = rawEntry.params;
    this.annotations = annotations;
    this.commandIndex = commandIndex;
}

WebInspector.PaintProfilerLogItem.prototype = {
    /**
     * @return {number}
     */
    nodeId: function()
    {
        if (!this.annotations)
            return 0;
        var inspectorId = this.annotations["INSPECTOR_ID"];
        return Number(inspectorId);
    }
}
;/* HeapProfilerModel.js */
/**
 * @constructor
 * @extends {WebInspector.SDKModel}
 * @param {!WebInspector.Target} target
 */
WebInspector.HeapProfilerModel = function(target)
{
    WebInspector.SDKModel.call(this, WebInspector.HeapProfilerModel, target);
    target.registerHeapProfilerDispatcher(new WebInspector.HeapProfilerDispatcher(this));
    this._enabled = false;
    this._heapProfilerAgent = target.heapProfilerAgent();
}

WebInspector.HeapProfilerModel.Events = {
    HeapStatsUpdate: "HeapStatsUpdate",
    LastSeenObjectId: "LastSeenObjectId",
    AddHeapSnapshotChunk: "AddHeapSnapshotChunk",
    ReportHeapSnapshotProgress: "ReportHeapSnapshotProgress",
    ResetProfiles: "ResetProfiles"
}

WebInspector.HeapProfilerModel.prototype = {

    enable: function()
    {
        if (this._enabled)
            return;

        this._enabled = true;
        this._heapProfilerAgent.enable();
    },

    /**
     * @param {!Array.<number>} samples
     */
    heapStatsUpdate: function(samples)
    {
        this.dispatchEventToListeners(WebInspector.HeapProfilerModel.Events.HeapStatsUpdate, samples);
    },

    /**
     * @param {number} lastSeenObjectId
     * @param {number} timestamp
     */
    lastSeenObjectId: function(lastSeenObjectId, timestamp)
    {
        this.dispatchEventToListeners(WebInspector.HeapProfilerModel.Events.LastSeenObjectId ,{lastSeenObjectId: lastSeenObjectId, timestamp: timestamp});
    },

    /**
     * @param {string} chunk
     */
    addHeapSnapshotChunk: function(chunk)
    {
        this.dispatchEventToListeners(WebInspector.HeapProfilerModel.Events.AddHeapSnapshotChunk, chunk);
    },

    /**
     * @param {number} done
     * @param {number} total
     * @param {boolean=} finished
     */
    reportHeapSnapshotProgress: function(done, total, finished)
    {
        this.dispatchEventToListeners(WebInspector.HeapProfilerModel.Events.ReportHeapSnapshotProgress, {done: done, total: total, finished: finished});
    },

    resetProfiles: function()
    {
        this.dispatchEventToListeners(WebInspector.HeapProfilerModel.Events.ResetProfiles);
    },

    __proto__: WebInspector.SDKModel.prototype
}


/**
 * @constructor
 * @implements {HeapProfilerAgent.Dispatcher}
 */
WebInspector.HeapProfilerDispatcher = function(model)
{
    this._heapProfilerModel = model;
}

WebInspector.HeapProfilerDispatcher.prototype = {
    /**
     * @override
     * @param {!Array.<number>} samples
     */
    heapStatsUpdate: function(samples)
    {
        this._heapProfilerModel.heapStatsUpdate(samples);
    },

    /**
     * @override
     * @param {number} lastSeenObjectId
     * @param {number} timestamp
     */
    lastSeenObjectId: function(lastSeenObjectId, timestamp)
    {
        this._heapProfilerModel.lastSeenObjectId(lastSeenObjectId, timestamp);
    },

    /**
     * @override
     * @param {string} chunk
     */
    addHeapSnapshotChunk: function(chunk)
    {
        this._heapProfilerModel.addHeapSnapshotChunk(chunk);
    },

    /**
     * @override
     * @param {number} done
     * @param {number} total
     * @param {boolean=} finished
     */
    reportHeapSnapshotProgress: function(done, total, finished)
    {
        this._heapProfilerModel.reportHeapSnapshotProgress(done, total, finished);
    },

    /**
     * @override
     */
    resetProfiles: function()
    {
        this._heapProfilerModel.resetProfiles();
    }
};/* ../SupportedCSSProperties.js */
WebInspector.CSSMetadata.initializeWithSupportedProperties([{"name": "color"}, {"name": "direction"}, {"name": "font-family"}, {"name": "font-kerning"}, {"name": "font-size"}, {"name": "font-size-adjust"}, {"name": "font-stretch"}, {"name": "font-style"}, {"name": "font-variant"}, {"name": "font-variant-ligatures"}, {"name": "font-weight"}, {"name": "font-feature-settings"}, {"name": "-webkit-font-smoothing"}, {"name": "-webkit-locale"}, {"name": "text-orientation"}, {"name": "-webkit-text-orientation"}, {"name": "writing-mode"}, {"name": "-webkit-writing-mode"}, {"name": "text-rendering"}, {"name": "zoom"}, {"name": "align-content"}, {"name": "align-items"}, {"name": "alignment-baseline"}, {"name": "align-self"}, {"name": "animation-delay"}, {"name": "animation-direction"}, {"name": "animation-duration"}, {"name": "animation-fill-mode"}, {"name": "animation-iteration-count"}, {"name": "animation-name"}, {"name": "animation-play-state"}, {"name": "animation-timing-function"}, {"name": "backdrop-filter"}, {"name": "backface-visibility"}, {"name": "background-attachment"}, {"name": "background-blend-mode"}, {"name": "background-clip"}, {"name": "background-color"}, {"name": "background-image"}, {"name": "background-origin"}, {"name": "background-position-x"}, {"name": "background-position-y"}, {"name": "background-repeat-x"}, {"name": "background-repeat-y"}, {"name": "background-size"}, {"name": "baseline-shift"}, {"name": "border-bottom-color"}, {"name": "border-bottom-left-radius"}, {"name": "border-bottom-right-radius"}, {"name": "border-bottom-style"}, {"name": "border-bottom-width"}, {"name": "border-collapse"}, {"name": "border-image-outset"}, {"name": "border-image-repeat"}, {"name": "border-image-slice"}, {"name": "border-image-source"}, {"name": "border-image-width"}, {"name": "border-left-color"}, {"name": "border-left-style"}, {"name": "border-left-width"}, {"name": "border-right-color"}, {"name": "border-right-style"}, {"name": "border-right-width"}, {"name": "border-top-color"}, {"name": "border-top-left-radius"}, {"name": "border-top-right-radius"}, {"name": "border-top-style"}, {"name": "border-top-width"}, {"name": "bottom"}, {"name": "box-shadow"}, {"name": "box-sizing"}, {"name": "break-after"}, {"name": "break-before"}, {"name": "break-inside"}, {"name": "buffered-rendering"}, {"name": "caption-side"}, {"name": "clear"}, {"name": "clip"}, {"name": "clip-path"}, {"name": "clip-rule"}, {"name": "color-interpolation"}, {"name": "color-interpolation-filters"}, {"name": "color-rendering"}, {"name": "column-fill"}, {"name": "contain"}, {"name": "content"}, {"name": "counter-increment"}, {"name": "counter-reset"}, {"name": "cursor"}, {"name": "cx"}, {"name": "cy"}, {"name": "d"}, {"name": "display"}, {"name": "dominant-baseline"}, {"name": "empty-cells"}, {"name": "fill"}, {"name": "fill-opacity"}, {"name": "fill-rule"}, {"name": "filter"}, {"name": "flex-basis"}, {"name": "flex-direction"}, {"name": "flex-grow"}, {"name": "flex-shrink"}, {"name": "flex-wrap"}, {"name": "float"}, {"name": "flood-color"}, {"name": "flood-opacity"}, {"name": "grid-auto-columns"}, {"name": "grid-auto-flow"}, {"name": "grid-auto-rows"}, {"name": "grid-column-end"}, {"name": "grid-column-gap"}, {"name": "grid-column-start"}, {"name": "grid-row-end"}, {"name": "grid-row-gap"}, {"name": "grid-row-start"}, {"name": "grid-template-areas"}, {"name": "grid-template-columns"}, {"name": "grid-template-rows"}, {"name": "height"}, {"name": "image-rendering"}, {"name": "image-orientation"}, {"name": "isolation"}, {"name": "justify-content"}, {"name": "justify-items"}, {"name": "justify-self"}, {"name": "left"}, {"name": "letter-spacing"}, {"name": "lighting-color"}, {"name": "line-height"}, {"name": "list-style-image"}, {"name": "list-style-position"}, {"name": "list-style-type"}, {"name": "margin-bottom"}, {"name": "margin-left"}, {"name": "margin-right"}, {"name": "margin-top"}, {"name": "marker-end"}, {"name": "marker-mid"}, {"name": "marker-start"}, {"name": "mask"}, {"name": "mask-source-type"}, {"name": "mask-type"}, {"name": "max-height"}, {"name": "max-width"}, {"name": "min-height"}, {"name": "min-width"}, {"name": "mix-blend-mode"}, {"name": "motion-offset"}, {"name": "motion-path"}, {"name": "motion-rotation"}, {"name": "object-fit"}, {"name": "object-position"}, {"name": "opacity"}, {"name": "order"}, {"name": "orphans"}, {"name": "outline-color"}, {"name": "outline-offset"}, {"name": "outline-style"}, {"name": "outline-width"}, {"name": "overflow-wrap"}, {"name": "overflow-x"}, {"name": "overflow-y"}, {"name": "padding-bottom"}, {"name": "padding-left"}, {"name": "padding-right"}, {"name": "padding-top"}, {"name": "paint-order"}, {"name": "perspective"}, {"name": "perspective-origin"}, {"name": "pointer-events"}, {"name": "position"}, {"name": "quotes"}, {"name": "resize"}, {"name": "right"}, {"name": "r"}, {"name": "rx"}, {"name": "ry"}, {"name": "scroll-behavior"}, {"name": "scroll-snap-type"}, {"name": "scroll-snap-points-x"}, {"name": "scroll-snap-points-y"}, {"name": "scroll-snap-destination"}, {"name": "scroll-snap-coordinate"}, {"name": "shape-image-threshold"}, {"name": "shape-margin"}, {"name": "shape-outside"}, {"name": "shape-rendering"}, {"name": "size"}, {"name": "snap-height"}, {"name": "speak"}, {"name": "stop-color"}, {"name": "stop-opacity"}, {"name": "stroke"}, {"name": "stroke-dasharray"}, {"name": "stroke-dashoffset"}, {"name": "stroke-linecap"}, {"name": "stroke-linejoin"}, {"name": "stroke-miterlimit"}, {"name": "stroke-opacity"}, {"name": "stroke-width"}, {"name": "table-layout"}, {"name": "tab-size"}, {"name": "text-align"}, {"name": "text-align-last"}, {"name": "text-anchor"}, {"name": "text-combine-upright"}, {"longhands": ["text-decoration-line", "text-decoration-style", "text-decoration-color"], "name": "text-decoration"}, {"name": "text-decoration-color"}, {"name": "text-decoration-line"}, {"name": "text-decoration-style"}, {"name": "text-indent"}, {"name": "text-justify"}, {"name": "text-overflow"}, {"name": "text-shadow"}, {"name": "text-transform"}, {"name": "text-underline-position"}, {"name": "top"}, {"name": "touch-action"}, {"name": "transform"}, {"name": "transform-origin"}, {"name": "transform-style"}, {"name": "translate"}, {"name": "rotate"}, {"name": "scale"}, {"name": "transition-delay"}, {"name": "transition-duration"}, {"name": "transition-property"}, {"name": "transition-timing-function"}, {"name": "unicode-bidi"}, {"name": "vector-effect"}, {"name": "vertical-align"}, {"name": "visibility"}, {"name": "x"}, {"name": "y"}, {"name": "-webkit-appearance"}, {"name": "-webkit-app-region"}, {"name": "-webkit-background-clip"}, {"name": "-webkit-background-composite"}, {"name": "-webkit-background-origin"}, {"name": "-webkit-border-horizontal-spacing"}, {"name": "-webkit-border-image"}, {"name": "-webkit-border-vertical-spacing"}, {"name": "-webkit-box-align"}, {"name": "-webkit-box-decoration-break"}, {"name": "-webkit-box-direction"}, {"name": "-webkit-box-flex"}, {"name": "-webkit-box-flex-group"}, {"name": "-webkit-box-lines"}, {"name": "-webkit-box-ordinal-group"}, {"name": "-webkit-box-orient"}, {"name": "-webkit-box-pack"}, {"name": "-webkit-box-reflect"}, {"name": "-webkit-clip-path"}, {"name": "column-count"}, {"name": "column-gap"}, {"name": "column-rule-color"}, {"name": "column-rule-style"}, {"name": "column-rule-width"}, {"name": "column-span"}, {"name": "column-width"}, {"name": "-webkit-filter"}, {"name": "-webkit-highlight"}, {"name": "-webkit-hyphenate-character"}, {"name": "-webkit-line-break"}, {"name": "-webkit-line-clamp"}, {"name": "-webkit-margin-after-collapse"}, {"name": "-webkit-margin-before-collapse"}, {"name": "-webkit-margin-bottom-collapse"}, {"name": "-webkit-margin-top-collapse"}, {"name": "-webkit-mask-box-image-outset"}, {"name": "-webkit-mask-box-image-repeat"}, {"name": "-webkit-mask-box-image-slice"}, {"name": "-webkit-mask-box-image-source"}, {"name": "-webkit-mask-box-image-width"}, {"name": "-webkit-mask-clip"}, {"name": "-webkit-mask-composite"}, {"name": "-webkit-mask-image"}, {"name": "-webkit-mask-origin"}, {"name": "-webkit-mask-position-x"}, {"name": "-webkit-mask-position-y"}, {"name": "-webkit-mask-repeat-x"}, {"name": "-webkit-mask-repeat-y"}, {"name": "-webkit-mask-size"}, {"name": "-webkit-perspective-origin-x"}, {"name": "-webkit-perspective-origin-y"}, {"name": "-webkit-print-color-adjust"}, {"name": "-webkit-rtl-ordering"}, {"name": "-webkit-ruby-position"}, {"name": "-webkit-tap-highlight-color"}, {"name": "-webkit-text-combine"}, {"name": "-webkit-text-emphasis-color"}, {"name": "-webkit-text-emphasis-position"}, {"name": "-webkit-text-emphasis-style"}, {"name": "-webkit-text-fill-color"}, {"name": "-webkit-text-security"}, {"name": "-webkit-text-stroke-color"}, {"name": "-webkit-text-stroke-width"}, {"name": "-webkit-transform-origin-x"}, {"name": "-webkit-transform-origin-y"}, {"name": "-webkit-transform-origin-z"}, {"name": "-webkit-user-drag"}, {"name": "-webkit-user-modify"}, {"name": "-webkit-user-select"}, {"name": "white-space"}, {"name": "widows"}, {"name": "width"}, {"name": "will-change"}, {"name": "word-break"}, {"name": "word-spacing"}, {"name": "word-wrap"}, {"name": "z-index"}, {"name": "-webkit-border-end-color"}, {"name": "-webkit-border-end-style"}, {"name": "-webkit-border-end-width"}, {"name": "-webkit-border-start-color"}, {"name": "-webkit-border-start-style"}, {"name": "-webkit-border-start-width"}, {"name": "-webkit-border-before-color"}, {"name": "-webkit-border-before-style"}, {"name": "-webkit-border-before-width"}, {"name": "-webkit-border-after-color"}, {"name": "-webkit-border-after-style"}, {"name": "-webkit-border-after-width"}, {"name": "-webkit-margin-end"}, {"name": "-webkit-margin-start"}, {"name": "-webkit-margin-before"}, {"name": "-webkit-margin-after"}, {"name": "-webkit-padding-end"}, {"name": "-webkit-padding-start"}, {"name": "-webkit-padding-before"}, {"name": "-webkit-padding-after"}, {"name": "-webkit-logical-width"}, {"name": "-webkit-logical-height"}, {"name": "-webkit-min-logical-width"}, {"name": "-webkit-min-logical-height"}, {"name": "-webkit-max-logical-width"}, {"name": "-webkit-max-logical-height"}, {"name": "all"}, {"name": "font-display"}, {"name": "max-zoom"}, {"name": "min-zoom"}, {"name": "orientation"}, {"name": "page"}, {"name": "src"}, {"name": "unicode-range"}, {"name": "user-zoom"}, {"name": "-webkit-font-size-delta"}, {"name": "-webkit-text-decorations-in-effect"}, {"longhands": ["animation-name", "animation-duration", "animation-timing-function", "animation-delay", "animation-iteration-count", "animation-direction", "animation-fill-mode", "animation-play-state"], "name": "animation"}, {"longhands": ["background-image", "background-position-x", "background-position-y", "background-size", "background-repeat-x", "background-repeat-y", "background-attachment", "background-origin", "background-clip", "background-color"], "name": "background"}, {"longhands": ["background-position-x", "background-position-y"], "name": "background-position"}, {"longhands": ["background-repeat-x", "background-repeat-y"], "name": "background-repeat"}, {"longhands": ["border-top-color", "border-top-style", "border-top-width", "border-right-color", "border-right-style", "border-right-width", "border-bottom-color", "border-bottom-style", "border-bottom-width", "border-left-color", "border-left-style", "border-left-width", "border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat"], "name": "border"}, {"longhands": ["border-bottom-width", "border-bottom-style", "border-bottom-color"], "name": "border-bottom"}, {"longhands": ["border-top-color", "border-right-color", "border-bottom-color", "border-left-color"], "name": "border-color"}, {"longhands": ["border-image-source", "border-image-slice", "border-image-width", "border-image-outset", "border-image-repeat"], "name": "border-image"}, {"longhands": ["border-left-width", "border-left-style", "border-left-color"], "name": "border-left"}, {"longhands": ["border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius"], "name": "border-radius"}, {"longhands": ["border-right-width", "border-right-style", "border-right-color"], "name": "border-right"}, {"longhands": ["-webkit-border-horizontal-spacing", "-webkit-border-vertical-spacing"], "name": "border-spacing"}, {"longhands": ["border-top-style", "border-right-style", "border-bottom-style", "border-left-style"], "name": "border-style"}, {"longhands": ["border-top-width", "border-top-style", "border-top-color"], "name": "border-top"}, {"longhands": ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"], "name": "border-width"}, {"longhands": ["flex-grow", "flex-shrink", "flex-basis"], "name": "flex"}, {"longhands": ["flex-direction", "flex-wrap"], "name": "flex-flow"}, {"longhands": ["font-style", "font-variant", "font-weight", "font-stretch", "font-size", "line-height", "font-family"], "name": "font"}, {"longhands": ["grid-template-columns", "grid-template-rows", "grid-template-areas", "grid-auto-flow", "grid-auto-columns", "grid-auto-rows", "grid-column-gap", "grid-row-gap"], "name": "grid"}, {"longhands": ["grid-row-start", "grid-column-start", "grid-row-end", "grid-column-end"], "name": "grid-area"}, {"longhands": ["grid-column-start", "grid-column-end"], "name": "grid-column"}, {"longhands": ["grid-row-gap", "grid-column-gap"], "name": "grid-gap"}, {"longhands": ["grid-row-start", "grid-row-end"], "name": "grid-row"}, {"longhands": ["grid-template-columns", "grid-template-rows", "grid-template-areas"], "name": "grid-template"}, {"longhands": ["list-style-type", "list-style-position", "list-style-image"], "name": "list-style"}, {"longhands": ["margin-top", "margin-right", "margin-bottom", "margin-left"], "name": "margin"}, {"longhands": ["marker-start", "marker-mid", "marker-end"], "name": "marker"}, {"longhands": ["motion-path", "motion-offset", "motion-rotation"], "name": "motion"}, {"longhands": ["outline-color", "outline-style", "outline-width"], "name": "outline"}, {"longhands": ["overflow-x", "overflow-y"], "name": "overflow"}, {"longhands": ["padding-top", "padding-right", "padding-bottom", "padding-left"], "name": "padding"}, {"longhands": ["break-after"], "name": "page-break-after"}, {"longhands": ["break-before"], "name": "page-break-before"}, {"longhands": ["break-inside"], "name": "page-break-inside"}, {"longhands": ["transition-property", "transition-duration", "transition-timing-function", "transition-delay"], "name": "transition"}, {"longhands": ["-webkit-border-after-width", "-webkit-border-after-style", "-webkit-border-after-color"], "name": "-webkit-border-after"}, {"longhands": ["-webkit-border-before-width", "-webkit-border-before-style", "-webkit-border-before-color"], "name": "-webkit-border-before"}, {"longhands": ["-webkit-border-end-width", "-webkit-border-end-style", "-webkit-border-end-color"], "name": "-webkit-border-end"}, {"longhands": ["-webkit-border-start-width", "-webkit-border-start-style", "-webkit-border-start-color"], "name": "-webkit-border-start"}, {"longhands": ["break-after"], "name": "-webkit-column-break-after"}, {"longhands": ["break-before"], "name": "-webkit-column-break-before"}, {"longhands": ["break-inside"], "name": "-webkit-column-break-inside"}, {"longhands": ["column-rule-width", "column-rule-style", "column-rule-color"], "name": "column-rule"}, {"longhands": ["column-width", "column-count"], "name": "columns"}, {"longhands": ["-webkit-margin-before-collapse", "-webkit-margin-after-collapse"], "name": "-webkit-margin-collapse"}, {"longhands": ["-webkit-mask-image", "-webkit-mask-position-x", "-webkit-mask-position-y", "-webkit-mask-size", "-webkit-mask-repeat-x", "-webkit-mask-repeat-y", "-webkit-mask-origin", "-webkit-mask-clip"], "name": "-webkit-mask"}, {"longhands": ["-webkit-mask-box-image-source", "-webkit-mask-box-image-slice", "-webkit-mask-box-image-width", "-webkit-mask-box-image-outset", "-webkit-mask-box-image-repeat"], "name": "-webkit-mask-box-image"}, {"longhands": ["-webkit-mask-position-x", "-webkit-mask-position-y"], "name": "-webkit-mask-position"}, {"longhands": ["-webkit-mask-repeat-x", "-webkit-mask-repeat-y"], "name": "-webkit-mask-repeat"}, {"longhands": ["-webkit-text-emphasis-style", "-webkit-text-emphasis-color"], "name": "-webkit-text-emphasis"}, {"longhands": ["-webkit-text-stroke-width", "-webkit-text-stroke-color"], "name": "-webkit-text-stroke"}]);;
/* Module workspace */
/* FileManager.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Object}
 */
WebInspector.FileManager = function()
{
    this._savedURLsSetting = WebInspector.settings.createLocalSetting("savedURLs", {});

    /** @type {!Object.<string, ?function(boolean)>} */
    this._saveCallbacks = {};
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.SavedURL, this._savedURL, this);
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.CanceledSaveURL, this._canceledSaveURL, this);
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.AppendedToURL, this._appendedToURL, this);
}

WebInspector.FileManager.EventTypes = {
    SavedURL: "SavedURL",
    AppendedToURL: "AppendedToURL"
}

WebInspector.FileManager.prototype = {
    /**
     * @param {string} url
     * @param {string} content
     * @param {boolean} forceSaveAs
     * @param {function(boolean)=} callback
     */
    save: function(url, content, forceSaveAs, callback)
    {
        // Remove this url from the saved URLs while it is being saved.
        var savedURLs = this._savedURLsSetting.get();
        delete savedURLs[url];
        this._savedURLsSetting.set(savedURLs);
        this._saveCallbacks[url] = callback || null;
        InspectorFrontendHost.save(url, content, forceSaveAs);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _savedURL: function(event)
    {
        var url = /** @type {string} */ (event.data);
        var savedURLs = this._savedURLsSetting.get();
        savedURLs[url] = true;
        this._savedURLsSetting.set(savedURLs);
        this.dispatchEventToListeners(WebInspector.FileManager.EventTypes.SavedURL, url);
        this._invokeSaveCallback(url, true);
    },

    /**
     * @param {string} url
     * @param {boolean} accepted
     */
    _invokeSaveCallback: function(url, accepted)
    {
        var callback = this._saveCallbacks[url];
        delete this._saveCallbacks[url];
        if (callback)
            callback(accepted);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _canceledSaveURL: function(event)
    {
        var url = /** @type {string} */ (event.data);
        this._invokeSaveCallback(url, false);
    },

    /**
     * @param {string} url
     * @return {boolean}
     */
    isURLSaved: function(url)
    {
        var savedURLs = this._savedURLsSetting.get();
        return savedURLs[url];
    },

    /**
     * @param {string} url
     * @param {string} content
     */
    append: function(url, content)
    {
        InspectorFrontendHost.append(url, content);
    },

    /**
     * @param {string} url
     */
    close: function(url)
    {
        // Currently a no-op.
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _appendedToURL: function(event)
    {
        var url = /** @type {string} */ (event.data);
        this.dispatchEventToListeners(WebInspector.FileManager.EventTypes.AppendedToURL, url);
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @type {?WebInspector.FileManager}
 */
WebInspector.fileManager = null;
;/* FileSystemMapping.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Object}
 */
WebInspector.FileSystemMapping = function()
{
    WebInspector.Object.call(this);
    this._fileSystemMappingSetting = WebInspector.settings.createLocalSetting("fileSystemMapping", {});
    /** @type {!Object.<string, !Array.<!WebInspector.FileSystemMapping.Entry>>} */
    this._fileSystemMappings = {};
    this._loadFromSettings();
}

WebInspector.FileSystemMapping.Events = {
    FileMappingAdded: "FileMappingAdded",
    FileMappingRemoved: "FileMappingRemoved"
}

WebInspector.FileSystemMapping.prototype = {
    _loadFromSettings: function()
    {
        var savedMapping = this._fileSystemMappingSetting.get();
        this._fileSystemMappings = {};
        for (var fileSystemPath in savedMapping) {
            var savedFileSystemMappings = savedMapping[fileSystemPath];
            fileSystemPath = WebInspector.IsolatedFileSystemManager.normalizePath(fileSystemPath);
            this._fileSystemMappings[fileSystemPath] = [];
            var fileSystemMappings = this._fileSystemMappings[fileSystemPath];

            for (var i = 0; i < savedFileSystemMappings.length; ++i) {
                var savedEntry = savedFileSystemMappings[i];
                var entry = new WebInspector.FileSystemMapping.Entry(fileSystemPath, savedEntry.urlPrefix, savedEntry.pathPrefix, true);
                fileSystemMappings.push(entry);
            }
        }

        this._rebuildIndexes();
    },

    _saveToSettings: function()
    {
        var setting = {};
        for (var fileSystemPath in this._fileSystemMappings) {
            setting[fileSystemPath] = [];
            var entries = this._fileSystemMappings[fileSystemPath];
            for (var entry of entries) {
                if (entry.configurable)
                    setting[fileSystemPath].push(entry);
            }
        }
        this._fileSystemMappingSetting.set(setting);
    },

    _rebuildIndexes: function()
    {
        // We are building an index here to search for the longest url prefix match faster.
        this._mappingForURLPrefix = {};
        this._urlPrefixes = [];
        for (var fileSystemPath in this._fileSystemMappings) {
            var fileSystemMapping = this._fileSystemMappings[fileSystemPath];
            for (var i = 0; i < fileSystemMapping.length; ++i) {
                var entry = fileSystemMapping[i];
                // Resolve conflict in favor of configurable mapping.
                if (this._mappingForURLPrefix[entry.urlPrefix] && !entry.configurable)
                    continue;
                this._mappingForURLPrefix[entry.urlPrefix] = entry;
                if (this._urlPrefixes.indexOf(entry.urlPrefix) === -1)
                    this._urlPrefixes.push(entry.urlPrefix);
            }
        }
        this._urlPrefixes.sort();
    },

    /**
     * @param {string} fileSystemPath
     */
    addFileSystem: function(fileSystemPath)
    {
        if (this._fileSystemMappings[fileSystemPath])
            return;

        this._fileSystemMappings[fileSystemPath] = [];
        this._saveToSettings();
    },

    /**
     * @param {string} fileSystemPath
     */
    removeFileSystem: function(fileSystemPath)
    {
        if (!this._fileSystemMappings[fileSystemPath])
            return;
        delete this._fileSystemMappings[fileSystemPath];
        this._rebuildIndexes();
        this._saveToSettings();
    },

    /**
     * @param {string} fileSystemPath
     * @param {string} urlPrefix
     * @param {string} pathPrefix
     */
    addFileMapping: function(fileSystemPath, urlPrefix, pathPrefix)
    {
        if (!urlPrefix.endsWith("/"))
            urlPrefix += "/";
        if (!pathPrefix.endsWith("/"))
            pathPrefix += "/";
        if (!pathPrefix.startsWith("/"))
            pathPrefix = "/" + pathPrefix;
        this._innerAddFileMapping(fileSystemPath, urlPrefix, pathPrefix, true);
        this._saveToSettings();
    },

    /**
     * @param {string} fileSystemPath
     * @param {string} urlPrefix
     * @param {string} pathPrefix
     */
    addNonConfigurableFileMapping: function(fileSystemPath, urlPrefix, pathPrefix)
    {
        this._innerAddFileMapping(fileSystemPath, urlPrefix, pathPrefix, false);
    },

    /**
     * @param {string} fileSystemPath
     * @param {string} urlPrefix
     * @param {string} pathPrefix
     * @param {boolean} configurable
     */
    _innerAddFileMapping: function(fileSystemPath, urlPrefix, pathPrefix, configurable)
    {
        var entry = new WebInspector.FileSystemMapping.Entry(fileSystemPath, urlPrefix, pathPrefix, configurable);
        this._fileSystemMappings[fileSystemPath].push(entry);
        this._rebuildIndexes();
        this.dispatchEventToListeners(WebInspector.FileSystemMapping.Events.FileMappingAdded, entry);
    },

    /**
     * @param {string} fileSystemPath
     * @param {string} urlPrefix
     * @param {string} pathPrefix
     */
    removeFileMapping: function(fileSystemPath, urlPrefix, pathPrefix)
    {
        var entry = this._configurableMappingEntryForPathPrefix(fileSystemPath, pathPrefix);
        if (!entry)
            return;
        this._fileSystemMappings[fileSystemPath].remove(entry);
        this._rebuildIndexes();
        this._saveToSettings();
        this.dispatchEventToListeners(WebInspector.FileSystemMapping.Events.FileMappingRemoved, entry);
    },

    /**
     * @param {string} url
     * @return {?WebInspector.FileSystemMapping.Entry}
     */
    _mappingEntryForURL: function(url)
    {
        for (var i = this._urlPrefixes.length - 1; i >= 0; --i) {
            var urlPrefix = this._urlPrefixes[i];
            if (url.startsWith(urlPrefix))
                return this._mappingForURLPrefix[urlPrefix];
        }
        return null;
    },

    /**
     * @param {string} fileSystemPath
     * @param {string} filePath
     * @return {?WebInspector.FileSystemMapping.Entry}
     */
    _mappingEntryForPath: function(fileSystemPath, filePath)
    {
        var entries = this._fileSystemMappings[fileSystemPath];
        if (!entries)
            return null;

        var entry = null;
        for (var i = 0; i < entries.length; ++i) {
            var pathPrefix = entries[i].pathPrefix;
            if (entry && entry.configurable && !entries[i].configurable)
                continue;
            // We are looking for the longest pathPrefix match.
            if (entry && entry.pathPrefix.length > pathPrefix.length)
                continue;
            if (filePath.startsWith(pathPrefix))
                entry = entries[i];
        }
        return entry;
    },

    /**
     * @param {string} fileSystemPath
     * @param {string} pathPrefix
     * @return {?WebInspector.FileSystemMapping.Entry}
     */
    _configurableMappingEntryForPathPrefix: function(fileSystemPath, pathPrefix)
    {
        var entries = this._fileSystemMappings[fileSystemPath];
        for (var i = 0; i < entries.length; ++i) {
            if (entries[i].configurable && pathPrefix === entries[i].pathPrefix)
                return entries[i];
        }
        return null;
    },

    /**
     * @param {string} fileSystemPath
     * @return {!Array.<!WebInspector.FileSystemMapping.Entry>}
     */
    mappingEntries: function(fileSystemPath)
    {
        return this._fileSystemMappings[fileSystemPath].slice();
    },

    /**
     * @param {string} url
     * @return {boolean}
     */
    hasMappingForNetworkURL: function(url)
    {
        return !!this._mappingEntryForURL(url);
    },

    /**
     * @param {string} url
     * @return {?{fileSystemPath: string, fileURL: string}}
     */
    fileForURL: function(url)
    {
        var entry = this._mappingEntryForURL(url);
        if (!entry)
            return null;
        var file = {};
        file.fileSystemPath = entry.fileSystemPath;
        file.fileURL = entry.fileSystemPath + entry.pathPrefix + url.substr(entry.urlPrefix.length);
        return file;
    },

    /**
     * @param {string} fileSystemPath
     * @param {string} filePath
     * @return {string}
     */
    networkURLForFileSystemURL: function(fileSystemPath, filePath)
    {
        var relativePath = filePath.substring(fileSystemPath.length);
        var entry = this._mappingEntryForPath(fileSystemPath, relativePath);
        if (!entry)
            return "";
        return entry.urlPrefix + relativePath.substring(entry.pathPrefix.length);
    },

    /**
     * @param {string} url
     */
    removeMappingForURL: function(url)
    {
        var entry = this._mappingEntryForURL(url);
        if (!entry || !entry.configurable)
            return;
        this._fileSystemMappings[entry.fileSystemPath].remove(entry);
        this._saveToSettings();
    },

    /**
     * @param {string} url
     * @param {string} fileSystemPath
     * @param {string} filePath
     */
    addMappingForResource: function(url, fileSystemPath, filePath)
    {
        var commonPathSuffixLength = 0;
        for (var i = 0; i < filePath.length; ++i) {
            var filePathCharacter = filePath[filePath.length - 1 - i];
            var urlCharacter = url[url.length - 1 - i];
            if (filePathCharacter !== urlCharacter)
                break;
            if (filePathCharacter === "/")
                commonPathSuffixLength = i;
        }
        var from = fileSystemPath.length;
        var to = filePath.length - commonPathSuffixLength;
        var pathPrefix = filePath.substring(from, to);
        var urlPrefix = url.substr(0, url.length - commonPathSuffixLength);
        if (to >= from)
            this.addFileMapping(fileSystemPath, urlPrefix, pathPrefix);
        else
            this.addFileMapping(fileSystemPath, urlPrefix + pathPrefix, "/");
    },

    resetForTesting: function()
    {
        this._fileSystemMappings = {};
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @constructor
 * @param {string} fileSystemPath
 * @param {string} urlPrefix
 * @param {string} pathPrefix
 * @param {boolean} configurable
 */
WebInspector.FileSystemMapping.Entry = function(fileSystemPath, urlPrefix, pathPrefix, configurable)
{
    this.fileSystemPath = fileSystemPath;
    this.urlPrefix = urlPrefix;
    this.pathPrefix = pathPrefix;
    this.configurable = configurable;
}

/**
 * @type {!WebInspector.FileSystemMapping}
 */
WebInspector.fileSystemMapping;
;/* IsolatedFileSystem.js */
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {!WebInspector.IsolatedFileSystemManager} manager
 * @param {string} path
 * @param {string} embedderPath
 * @param {!DOMFileSystem} domFileSystem
 */
WebInspector.IsolatedFileSystem = function(manager, path, embedderPath, domFileSystem)
{
    this._manager = manager;
    this._path = path;
    this._embedderPath = embedderPath;
    this._domFileSystem = domFileSystem;
    this._excludedFoldersSetting = WebInspector.settings.createLocalSetting("workspaceExcludedFolders", {});
    /** @type {!Set<string>} */
    this._excludedFolders = new Set(this._excludedFoldersSetting.get()[path] || []);
    /** @type {!Set<string>} */
    this._nonConfigurableExcludedFolders = new Set();
}

WebInspector.IsolatedFileSystem.ImageExtensions = new Set(["jpeg", "jpg", "svg", "gif", "webp", "png", "ico", "tiff", "tif", "bmp"]);

/**
 * @constructor
 * @param {!WebInspector.IsolatedFileSystemManager} manager
 * @param {string} path
 * @param {string} embedderPath
 * @param {string} name
 * @param {string} rootURL
 * @return {!Promise<?WebInspector.IsolatedFileSystem>}
 */
WebInspector.IsolatedFileSystem.create = function(manager, path, embedderPath, name, rootURL)
{
    return new Promise(promiseBody);

    /**
     * @param {function(?WebInspector.IsolatedFileSystem)} resolve
     * @param {function(!Error)} reject
     */
    function promiseBody(resolve, reject)
    {
        var domFileSystem = InspectorFrontendHost.isolatedFileSystem(name, rootURL);
        if (!domFileSystem) {
            resolve(null);
            return;
        }
        var fileSystem = new WebInspector.IsolatedFileSystem(manager, path, embedderPath, domFileSystem);
        fileSystem.requestFileContent(".devtools", onConfigAvailable);

        /**
         * @param {?string} projectText
         */
        function onConfigAvailable(projectText)
        {
            if (projectText) {
                try {
                    var projectObject = JSON.parse(projectText);
                    fileSystem._initializeProject(typeof projectObject === "object" ? /** @type {!Object} */ (projectObject) : null);
                } catch (e) {
                    WebInspector.console.error("Invalid project file: " + projectText);
                }
            }
            resolve(fileSystem);
        }
    }
}

/**
 * @param {!FileError} error
 * @return {string}
 */
WebInspector.IsolatedFileSystem.errorMessage = function(error)
{
    return WebInspector.UIString("File system error: %s", error.message);
}

WebInspector.IsolatedFileSystem.prototype = {
    /**
     * @return {string}
     */
    path: function()
    {
        return this._path;
    },

    /**
     * @return {string}
     */
    embedderPath: function()
    {
        return this._embedderPath;
    },

    /**
     * @param {?Object} projectObject
     */
    _initializeProject: function(projectObject)
    {
        this._projectObject = projectObject;

        var projectExcludes = this.projectProperty("excludes");
        if (Array.isArray(projectExcludes)) {
            for (var folder of /** @type {!Array<*>} */ (projectExcludes)) {
                if (typeof folder === "string")
                    this._nonConfigurableExcludedFolders.add(folder);
            }
        }
    },

    /**
     * @param {string} key
     * @return {*}
     */
    projectProperty: function(key)
    {
        return this._projectObject ? this._projectObject[key] : null;
    },

    /**
     * @param {string} path
     * @param {function(string)} fileCallback
     * @param {function()=} finishedCallback
     */
    requestFilesRecursive: function(path, fileCallback, finishedCallback)
    {
        var pendingRequests = 1;
        this._requestEntries(path, innerCallback.bind(this));

        /**
         * @param {!Array.<!FileEntry>} entries
         * @this {WebInspector.IsolatedFileSystem}
         */
        function innerCallback(entries)
        {
            for (var i = 0; i < entries.length; ++i) {
                var entry = entries[i];
                if (!entry.isDirectory) {
                    if (this._isFileExcluded(entry.fullPath))
                        continue;
                    fileCallback(entry.fullPath.substr(1));
                } else {
                    if (this._isFileExcluded(entry.fullPath + "/"))
                        continue;
                    ++pendingRequests;
                    this._requestEntries(entry.fullPath, innerCallback.bind(this));
                }
            }
            if (finishedCallback && (--pendingRequests === 0))
                finishedCallback();
        }
    },

    /**
     * @param {string} path
     * @param {?string} name
     * @param {function(?string)} callback
     */
    createFile: function(path, name, callback)
    {
        var newFileIndex = 1;
        if (!name)
            name = "NewFile";
        var nameCandidate;

        this._domFileSystem.root.getDirectory(path, null, dirEntryLoaded.bind(this), errorHandler.bind(this));

        /**
         * @param {!DirectoryEntry} dirEntry
         * @this {WebInspector.IsolatedFileSystem}
         */
        function dirEntryLoaded(dirEntry)
        {
            var nameCandidate = name;
            if (newFileIndex > 1)
                nameCandidate += newFileIndex;
            ++newFileIndex;
            dirEntry.getFile(nameCandidate, { create: true, exclusive: true }, fileCreated, fileCreationError.bind(this));

            function fileCreated(entry)
            {
                callback(entry.fullPath.substr(1));
            }

            /**
             * @this {WebInspector.IsolatedFileSystem}
             */
            function fileCreationError(error)
            {
                if (error.code === FileError.INVALID_MODIFICATION_ERR) {
                    dirEntryLoaded.call(this, dirEntry);
                    return;
                }

                var errorMessage = WebInspector.IsolatedFileSystem.errorMessage(error);
                console.error(errorMessage + " when testing if file exists '" + (this._path + "/" + path + "/" + nameCandidate) + "'");
                callback(null);
            }
        }

        /**
         * @this {WebInspector.IsolatedFileSystem}
         */
        function errorHandler(error)
        {
            var errorMessage = WebInspector.IsolatedFileSystem.errorMessage(error);
            var filePath = this._path + "/" + path;
            if (nameCandidate)
                filePath += "/" + nameCandidate;
            console.error(errorMessage + " when getting content for file '" + (filePath) + "'");
            callback(null);
        }
    },

    /**
     * @param {string} path
     */
    deleteFile: function(path)
    {
        this._domFileSystem.root.getFile(path, null, fileEntryLoaded.bind(this), errorHandler.bind(this));

        /**
         * @param {!FileEntry} fileEntry
         * @this {WebInspector.IsolatedFileSystem}
         */
        function fileEntryLoaded(fileEntry)
        {
            fileEntry.remove(fileEntryRemoved, errorHandler.bind(this));
        }

        function fileEntryRemoved()
        {
        }

        /**
         * @param {!FileError} error
         * @this {WebInspector.IsolatedFileSystem}
         */
        function errorHandler(error)
        {
            var errorMessage = WebInspector.IsolatedFileSystem.errorMessage(error);
            console.error(errorMessage + " when deleting file '" + (this._path + "/" + path) + "'");
        }
    },

    /**
     * @param {string} path
     * @param {function(?string)} callback
     */
    requestFileContent: function(path, callback)
    {
        this._domFileSystem.root.getFile(path, null, fileEntryLoaded.bind(this), errorHandler.bind(this));

        /**
         * @param {!FileEntry} entry
         * @this {WebInspector.IsolatedFileSystem}
         */
        function fileEntryLoaded(entry)
        {
            entry.file(fileLoaded, errorHandler.bind(this));
        }

        /**
         * @param {!Blob} file
         */
        function fileLoaded(file)
        {
            var reader = new FileReader();
            reader.onloadend = readerLoadEnd;
            if (WebInspector.IsolatedFileSystem.ImageExtensions.has(WebInspector.TextUtils.extension(path)))
                reader.readAsDataURL(file);
            else
                reader.readAsText(file);
        }

        /**
         * @this {!FileReader}
         */
        function readerLoadEnd()
        {
            /** @type {?string} */
            var string = null;
            try {
                string = /** @type {string} */ (this.result);
            } catch (e) {
                console.error("Can't read file: " + path + ": " + e);
            }
            callback(string);
        }

        /**
         * @this {WebInspector.IsolatedFileSystem}
         */
        function errorHandler(error)
        {
            if (error.code === FileError.NOT_FOUND_ERR) {
                callback(null);
                return;
            }

            var errorMessage = WebInspector.IsolatedFileSystem.errorMessage(error);
            console.error(errorMessage + " when getting content for file '" + (this._path + "/" + path) + "'");
            callback(null);
        }
    },

    /**
     * @param {string} path
     * @param {string} content
     * @param {function()} callback
     */
    setFileContent: function(path, content, callback)
    {
        WebInspector.userMetrics.actionTaken(WebInspector.UserMetrics.Action.FileSavedInWorkspace);
        this._domFileSystem.root.getFile(path, { create: true }, fileEntryLoaded.bind(this), errorHandler.bind(this));

        /**
         * @param {!FileEntry} entry
         * @this {WebInspector.IsolatedFileSystem}
         */
        function fileEntryLoaded(entry)
        {
            entry.createWriter(fileWriterCreated.bind(this), errorHandler.bind(this));
        }

        /**
         * @param {!FileWriter} fileWriter
         * @this {WebInspector.IsolatedFileSystem}
         */
        function fileWriterCreated(fileWriter)
        {
            fileWriter.onerror = errorHandler.bind(this);
            fileWriter.onwriteend = fileWritten;
            var blob = new Blob([content], { type: "text/plain" });
            fileWriter.write(blob);

            function fileWritten()
            {
                fileWriter.onwriteend = callback;
                fileWriter.truncate(blob.size);
            }
        }

        /**
         * @this {WebInspector.IsolatedFileSystem}
         */
        function errorHandler(error)
        {
            var errorMessage = WebInspector.IsolatedFileSystem.errorMessage(error);
            console.error(errorMessage + " when setting content for file '" + (this._path + "/" + path) + "'");
            callback();
        }
    },

    /**
     * @param {string} path
     * @param {string} newName
     * @param {function(boolean, string=)} callback
     */
    renameFile: function(path, newName, callback)
    {
        newName = newName ? newName.trim() : newName;
        if (!newName || newName.indexOf("/") !== -1) {
            callback(false);
            return;
        }
        var fileEntry;
        var dirEntry;

        this._domFileSystem.root.getFile(path, null, fileEntryLoaded.bind(this), errorHandler.bind(this));

        /**
         * @param {!FileEntry} entry
         * @this {WebInspector.IsolatedFileSystem}
         */
        function fileEntryLoaded(entry)
        {
            if (entry.name === newName) {
                callback(false);
                return;
            }

            fileEntry = entry;
            fileEntry.getParent(dirEntryLoaded.bind(this), errorHandler.bind(this));
        }

        /**
         * @param {!Entry} entry
         * @this {WebInspector.IsolatedFileSystem}
         */
        function dirEntryLoaded(entry)
        {
            dirEntry = entry;
            dirEntry.getFile(newName, null, newFileEntryLoaded, newFileEntryLoadErrorHandler.bind(this));
        }

        /**
         * @param {!FileEntry} entry
         */
        function newFileEntryLoaded(entry)
        {
            callback(false);
        }

        /**
         * @this {WebInspector.IsolatedFileSystem}
         */
        function newFileEntryLoadErrorHandler(error)
        {
            if (error.code !== FileError.NOT_FOUND_ERR) {
                callback(false);
                return;
            }
            fileEntry.moveTo(dirEntry, newName, fileRenamed, errorHandler.bind(this));
        }

        /**
         * @param {!FileEntry} entry
         */
        function fileRenamed(entry)
        {
            callback(true, entry.name);
        }

        /**
         * @this {WebInspector.IsolatedFileSystem}
         */
        function errorHandler(error)
        {
            var errorMessage = WebInspector.IsolatedFileSystem.errorMessage(error);
            console.error(errorMessage + " when renaming file '" + (this._path + "/" + path) + "' to '" + newName + "'");
            callback(false);
        }
    },

    /**
     * @param {!DirectoryEntry} dirEntry
     * @param {function(!Array.<!FileEntry>)} callback
     */
    _readDirectory: function(dirEntry, callback)
    {
        var dirReader = dirEntry.createReader();
        var entries = [];

        function innerCallback(results)
        {
            if (!results.length) {
                callback(entries.sort());
            } else {
                entries = entries.concat(toArray(results));
                dirReader.readEntries(innerCallback, errorHandler);
            }
        }

        function toArray(list)
        {
            return Array.prototype.slice.call(list || [], 0);
        }

        dirReader.readEntries(innerCallback, errorHandler);

        function errorHandler(error)
        {
            var errorMessage = WebInspector.IsolatedFileSystem.errorMessage(error);
            console.error(errorMessage + " when reading directory '" + dirEntry.fullPath + "'");
            callback([]);
        }
    },

    /**
     * @param {string} path
     * @param {function(!Array.<!FileEntry>)} callback
     */
    _requestEntries: function(path, callback)
    {
        this._domFileSystem.root.getDirectory(path, null, innerCallback.bind(this), errorHandler);

        /**
         * @param {!DirectoryEntry} dirEntry
         * @this {WebInspector.IsolatedFileSystem}
         */
        function innerCallback(dirEntry)
        {
            this._readDirectory(dirEntry, callback);
        }

        function errorHandler(error)
        {
            var errorMessage = WebInspector.IsolatedFileSystem.errorMessage(error);
            console.error(errorMessage + " when requesting entry '" + path + "'");
            callback([]);
        }
    },

    _saveExcludedFolders: function()
    {
        var settingValue = this._excludedFoldersSetting.get();
        settingValue[this._path] = Array.from(this._excludedFolders.values());
        this._excludedFoldersSetting.set(settingValue);
    },

    /**
     * @param {string} path
     */
    addExcludedFolder: function(path)
    {
        this._excludedFolders.add(path);
        this._saveExcludedFolders();
        this._manager.dispatchEventToListeners(WebInspector.IsolatedFileSystemManager.Events.ExcludedFolderAdded, path);
    },

    /**
     * @param {string} path
     */
    removeExcludedFolder: function(path)
    {
        this._excludedFolders.delete(path);
        this._saveExcludedFolders();
        this._manager.dispatchEventToListeners(WebInspector.IsolatedFileSystemManager.Events.ExcludedFolderRemoved, path);
    },

    fileSystemRemoved: function()
    {
        var settingValue = this._excludedFoldersSetting.get();
        delete settingValue[this._path];
        this._excludedFoldersSetting.set(settingValue);
    },

    /**
     * @param {string} folderPath
     * @return {boolean}
     */
    _isFileExcluded: function(folderPath)
    {
        if (this._nonConfigurableExcludedFolders.has(folderPath) || this._excludedFolders.has(folderPath))
            return true;
        var regex = this._manager.workspaceFolderExcludePatternSetting().asRegExp();
        return !!(regex && regex.test(folderPath));
    },

    /**
     * @return {!Set<string>}
     */
    excludedFolders: function()
    {
        return this._excludedFolders;
    },

    /**
     * @return {!Set<string>}
     */
    nonConfigurableExcludedFolders: function()
    {
        return this._nonConfigurableExcludedFolders;
    },


    /**
     * @param {string} query
     * @param {!WebInspector.Progress} progress
     * @param {function(!Array.<string>)} callback
     */
    searchInPath: function(query, progress, callback)
    {
        var requestId = this._manager.registerCallback(innerCallback);
        InspectorFrontendHost.searchInPath(requestId, this._embedderPath, query);

        /**
         * @param {!Array.<string>} files
         */
        function innerCallback(files)
        {
            files = files.map(embedderPath => WebInspector.IsolatedFileSystemManager.normalizePath(embedderPath));
            progress.worked(1);
            callback(files);
        }
    },

    /**
     * @param {!WebInspector.Progress} progress
     */
    indexContent: function(progress)
    {
        progress.setTotalWork(1);
        var requestId = this._manager.registerProgress(progress);
        InspectorFrontendHost.indexPath(requestId, this._embedderPath);
    }
}
;/* IsolatedFileSystemManager.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Object}
 */
WebInspector.IsolatedFileSystemManager = function()
{
    /** @type {!Object.<string, !WebInspector.IsolatedFileSystem>} */
    this._fileSystems = {};
    /** @type {!Object.<number, function(!Array.<string>)>} */
    this._callbacks = {};
    /** @type {!Object.<number, !WebInspector.Progress>} */
    this._progresses = {};

    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.FileSystemsLoaded, this._onFileSystemsLoaded, this);
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.FileSystemRemoved, this._onFileSystemRemoved, this);
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.FileSystemAdded, this._onFileSystemAdded, this);
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.FileSystemFilesChanged, this._onFileSystemFilesChanged, this);
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.IndexingTotalWorkCalculated, this._onIndexingTotalWorkCalculated, this);
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.IndexingWorked, this._onIndexingWorked, this);
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.IndexingDone, this._onIndexingDone, this);
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.SearchCompleted, this._onSearchCompleted, this);

    this._initExcludePatterSetting();
}

/** @typedef {!{fileSystemName: string, rootURL: string, fileSystemPath: string}} */
WebInspector.IsolatedFileSystemManager.FileSystem;

WebInspector.IsolatedFileSystemManager.Events = {
    FileSystemAdded: "FileSystemAdded",
    FileSystemRemoved: "FileSystemRemoved",
    FileSystemsLoaded: "FileSystemsLoaded",
    FileSystemFilesChanged: "FileSystemFilesChanged",
    ExcludedFolderAdded: "ExcludedFolderAdded",
    ExcludedFolderRemoved: "ExcludedFolderRemoved"
}

WebInspector.IsolatedFileSystemManager._lastRequestId = 0;

/**
 * @param {string} fileSystemPath
 * @return {string}
 */
WebInspector.IsolatedFileSystemManager.normalizePath = function(fileSystemPath)
{
    fileSystemPath = fileSystemPath.replace(/\\/g, "/");
    if (!fileSystemPath.startsWith("file://")) {
        if (fileSystemPath.startsWith("/"))
            fileSystemPath = "file://" + fileSystemPath;
        else
            fileSystemPath = "file:///" + fileSystemPath;
    }
    return fileSystemPath;
}

WebInspector.IsolatedFileSystemManager.prototype = {
    /**
     * @param {function()} callback
     */
    initialize: function(callback)
    {
        this._initializeCallback = callback;
        InspectorFrontendHost.requestFileSystems();
    },

    addFileSystem: function()
    {
        InspectorFrontendHost.addFileSystem("");
    },

    /**
     * @param {!WebInspector.IsolatedFileSystem} fileSystem
     */
    removeFileSystem: function(fileSystem)
    {

        InspectorFrontendHost.removeFileSystem(fileSystem.embedderPath());
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onFileSystemsLoaded: function(event)
    {
        var fileSystems = /** @type {!Array.<!WebInspector.IsolatedFileSystemManager.FileSystem>} */ (event.data);
        var promises = [];
        for (var i = 0; i < fileSystems.length; ++i)
            promises.push(this._innerAddFileSystem(fileSystems[i]));
        Promise.all(promises).then(fireFileSystemsLoaded.bind(this));

        /**
         * @this {WebInspector.IsolatedFileSystemManager}
         */
        function fireFileSystemsLoaded()
        {
            this._initializeCallback();
            delete this._initializeCallback;
            this.dispatchEventToListeners(WebInspector.IsolatedFileSystemManager.Events.FileSystemsLoaded);
        }
    },

    /**
     * @return {boolean}
     */
    fileSystemsLoaded: function()
    {
        return !this._initializeCallback;
    },

    /**
     * @param {!WebInspector.IsolatedFileSystemManager.FileSystem} fileSystem
     * @return {!Promise}
     */
    _innerAddFileSystem: function(fileSystem)
    {
        var embedderPath = fileSystem.fileSystemPath;
        var fileSystemPath = WebInspector.IsolatedFileSystemManager.normalizePath(fileSystem.fileSystemPath);
        var promise = WebInspector.IsolatedFileSystem.create(this, fileSystemPath, embedderPath, fileSystem.fileSystemName, fileSystem.rootURL);
        return promise.then(storeFileSystem.bind(this));

        /**
         * @param {?WebInspector.IsolatedFileSystem} fileSystem
         * @this {WebInspector.IsolatedFileSystemManager}
         */
        function storeFileSystem(fileSystem)
        {
            if (!fileSystem)
                return;
            this._fileSystems[fileSystemPath] = fileSystem;
            this.dispatchEventToListeners(WebInspector.IsolatedFileSystemManager.Events.FileSystemAdded, fileSystem);
        }
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onFileSystemAdded: function(event)
    {
        var errorMessage = /** @type {string} */ (event.data["errorMessage"]);
        var fileSystem = /** @type {?WebInspector.IsolatedFileSystemManager.FileSystem} */ (event.data["fileSystem"]);
        if (errorMessage)
            WebInspector.console.error(errorMessage);
        else if (fileSystem)
            this._innerAddFileSystem(fileSystem);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onFileSystemRemoved: function(event)
    {
        this._fileSystemRemoved(/** @type {string} */ (event.data));
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onFileSystemFilesChanged: function(event)
    {
        var embedderPaths = /** @type {!Array<string>} */ (event.data);
        var paths = embedderPaths.map(embedderPath => WebInspector.IsolatedFileSystemManager.normalizePath(embedderPath));
        this.dispatchEventToListeners(WebInspector.IsolatedFileSystemManager.Events.FileSystemFilesChanged, paths);
    },

    /**
     * @param {string} embedderPath
     */
    _fileSystemRemoved: function(embedderPath)
    {
        var fileSystemPath = WebInspector.IsolatedFileSystemManager.normalizePath(embedderPath);
        var isolatedFileSystem = this._fileSystems[fileSystemPath];
        delete this._fileSystems[fileSystemPath];
        if (isolatedFileSystem) {
            isolatedFileSystem.fileSystemRemoved();
            this.dispatchEventToListeners(WebInspector.IsolatedFileSystemManager.Events.FileSystemRemoved, isolatedFileSystem);
        }
    },

    /**
     * @return {!Array<string>}
     */
    fileSystemPaths: function()
    {
        return Object.keys(this._fileSystems);
    },

    /**
     * @param {string} fileSystemPath
     * @return {?WebInspector.IsolatedFileSystem}
     */
    fileSystem: function(fileSystemPath)
    {
        return this._fileSystems[fileSystemPath];
    },

    _initExcludePatterSetting: function()
    {
        var defaultCommonExcludedFolders = [
            "/\\.devtools",
            "/\\.git/",
            "/\\.sass-cache/",
            "/\\.hg/",
            "/\\.idea/",
            "/\\.svn/",
            "/\\.cache/",
            "/\\.project/"
        ];
        var defaultWinExcludedFolders = [
            "/Thumbs.db$",
            "/ehthumbs.db$",
            "/Desktop.ini$",
            "/\\$RECYCLE.BIN/"
        ];
        var defaultMacExcludedFolders = [
            "/\\.DS_Store$",
            "/\\.Trashes$",
            "/\\.Spotlight-V100$",
            "/\\.AppleDouble$",
            "/\\.LSOverride$",
            "/Icon$",
            "/\\._.*$"
        ];
        var defaultLinuxExcludedFolders = [
            "/.*~$"
        ];
        var defaultExcludedFolders = defaultCommonExcludedFolders;
        if (WebInspector.isWin())
            defaultExcludedFolders = defaultExcludedFolders.concat(defaultWinExcludedFolders);
        else if (WebInspector.isMac())
            defaultExcludedFolders = defaultExcludedFolders.concat(defaultMacExcludedFolders);
        else
            defaultExcludedFolders = defaultExcludedFolders.concat(defaultLinuxExcludedFolders);
        var defaultExcludedFoldersPattern = defaultExcludedFolders.join("|");
        this._workspaceFolderExcludePatternSetting = WebInspector.settings.createRegExpSetting("workspaceFolderExcludePattern", defaultExcludedFoldersPattern, WebInspector.isWin() ? "i" : "");
    },

    /**
     * @return {!WebInspector.Setting}
     */
    workspaceFolderExcludePatternSetting: function()
    {
        return this._workspaceFolderExcludePatternSetting;
    },

    /**
     * @param {function(!Array.<string>)} callback
     * @return {number}
     */
    registerCallback: function(callback)
    {
        var requestId = ++WebInspector.IsolatedFileSystemManager._lastRequestId;
        this._callbacks[requestId] = callback;
        return requestId;
    },

    /**
     * @param {!WebInspector.Progress} progress
     * @return {number}
     */
    registerProgress: function(progress)
    {
        var requestId = ++WebInspector.IsolatedFileSystemManager._lastRequestId;
        this._progresses[requestId] = progress;
        return requestId;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onIndexingTotalWorkCalculated: function(event)
    {
        var requestId = /** @type {number} */ (event.data["requestId"]);
        var totalWork = /** @type {number} */ (event.data["totalWork"]);

        var progress = this._progresses[requestId];
        if (!progress)
            return;
        progress.setTotalWork(totalWork);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onIndexingWorked: function(event)
    {
        var requestId = /** @type {number} */ (event.data["requestId"]);
        var worked = /** @type {number} */ (event.data["worked"]);

        var progress = this._progresses[requestId];
        if (!progress)
            return;
        progress.worked(worked);
        if (progress.isCanceled()) {
            InspectorFrontendHost.stopIndexing(requestId);
            this._onIndexingDone(event);
        }
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onIndexingDone: function(event)
    {
        var requestId = /** @type {number} */ (event.data["requestId"]);

        var progress = this._progresses[requestId];
        if (!progress)
            return;
        progress.done();
        delete this._progresses[requestId];
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onSearchCompleted: function(event)
    {
        var requestId = /** @type {number} */ (event.data["requestId"]);
        var files = /** @type {!Array.<string>} */ (event.data["files"]);

        var callback = this._callbacks[requestId];
        if (!callback)
            return;
        callback.call(null, files);
        delete this._callbacks[requestId];
    },

    dispose: function()
    {
        InspectorFrontendHost.events.removeEventListener(InspectorFrontendHostAPI.Events.IndexingTotalWorkCalculated, this._onIndexingTotalWorkCalculated, this);
        InspectorFrontendHost.events.removeEventListener(InspectorFrontendHostAPI.Events.IndexingWorked, this._onIndexingWorked, this);
        InspectorFrontendHost.events.removeEventListener(InspectorFrontendHostAPI.Events.IndexingDone, this._onIndexingDone, this);
        InspectorFrontendHost.events.removeEventListener(InspectorFrontendHostAPI.Events.SearchCompleted, this._onSearchCompleted, this);
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @type {!WebInspector.IsolatedFileSystemManager}
 */
WebInspector.isolatedFileSystemManager;
;/* SearchConfig.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @implements {WebInspector.ProjectSearchConfig}
 * @param {string} query
 * @param {boolean} ignoreCase
 * @param {boolean} isRegex
 */
WebInspector.SearchConfig = function(query, ignoreCase, isRegex)
{
    this._query = query;
    this._ignoreCase = ignoreCase;
    this._isRegex = isRegex;
    this._parse();
}

/** @typedef {!{regex: !RegExp, isNegative: boolean}} */
WebInspector.SearchConfig.RegexQuery;

/**
 * @param {{query: string, ignoreCase: boolean, isRegex: boolean}} object
 * @return {!WebInspector.SearchConfig}
 */
WebInspector.SearchConfig.fromPlainObject = function(object)
{
    return new WebInspector.SearchConfig(object.query, object.ignoreCase, object.isRegex);
}

WebInspector.SearchConfig.prototype = {
    /**
     * @override
     * @return {string}
     */
    query: function()
    {
        return this._query;
    },

    /**
     * @override
     * @return {boolean}
     */
    ignoreCase: function()
    {
        return this._ignoreCase;
    },

    /**
     * @override
     * @return {boolean}
     */
    isRegex: function()
    {
        return this._isRegex;
    },

    /**
     * @return {{query: string, ignoreCase: boolean, isRegex: boolean}}
     */
    toPlainObject: function()
    {
        return { query: this.query(), ignoreCase: this.ignoreCase(), isRegex: this.isRegex() };
    },

    _parse: function()
    {
        var filePattern = "-?f(ile)?:(([^\\\\ ]|\\\\.)+)"; // After file: prefix: any symbol except space and backslash or any symbol escaped with a backslash.
        var quotedPattern = "\"(([^\\\\\"]|\\\\.)+)\""; // Inside double quotes: any symbol except double quote and backslash or any symbol escaped with a backslash.

        // A word is a sequence of any symbols except space and backslash or any symbols escaped with a backslash, that does not start with file:.
        var unquotedWordPattern = "(\\s*(?!-?f(ile)?:)[^\\\\ ]|\\\\.)+";
        var unquotedPattern = unquotedWordPattern + "( +" + unquotedWordPattern + ")*"; // A word or several words separated by space(s).

        var pattern = "(" + filePattern + ")|(" + quotedPattern + ")|(" + unquotedPattern + ")";
        var regexp = new RegExp(pattern, "g");
        var queryParts = this._query.match(regexp) || [];

        /**
         * @type {!Array.<!WebInspector.SearchConfig.QueryTerm>}
         */
        this._fileQueries = [];

        /**
         * @type {!Array.<string>}
         */
        this._queries = [];

        for (var i = 0; i < queryParts.length; ++i) {
            var queryPart = queryParts[i];
            if (!queryPart)
                continue;
            var fileQuery = this._parseFileQuery(queryPart);
            if (fileQuery) {
                this._fileQueries.push(fileQuery);
                /** @type {!Array.<!WebInspector.SearchConfig.RegexQuery>} */
                this._fileRegexQueries = this._fileRegexQueries || [];
                this._fileRegexQueries.push({ regex: new RegExp(fileQuery.text, this.ignoreCase ? "i" : ""), isNegative: fileQuery.isNegative });
                continue;
            }
            if (this._isRegex) {
                this._queries.push(queryPart);
                continue;
            }
            if (queryPart.startsWith("\"")) {
                if (!queryPart.endsWith("\""))
                    continue;
                this._queries.push(this._parseQuotedQuery(queryPart));
                continue;
            }
            this._queries.push(this._parseUnquotedQuery(queryPart));
        }
    },

    /**
     * @override
     * @param {string} filePath
     * @return {boolean}
     */
    filePathMatchesFileQuery: function(filePath)
    {
        if (!this._fileRegexQueries)
            return true;
        for (var i = 0; i < this._fileRegexQueries.length; ++i) {
            if (!!filePath.match(this._fileRegexQueries[i].regex) === this._fileRegexQueries[i].isNegative)
                return false;
        }
        return true;
    },

    /**
     * @override
     * @return {!Array.<string>}
     */
    queries: function()
    {
        return this._queries;
    },

    _parseUnquotedQuery: function(query)
    {
        return query.replace(/\\(.)/g, "$1");
    },

    _parseQuotedQuery: function(query)
    {
        return query.substring(1, query.length - 1).replace(/\\(.)/g, "$1");
    },

    /**
     * @param {string} query
     * @return {?WebInspector.SearchConfig.QueryTerm}
     */
    _parseFileQuery: function(query)
    {
        var match = query.match(/^(-)?f(ile)?:/);
        if (!match)
            return null;
        var isNegative = !!match[1];
        query = query.substr(match[0].length);
        var result = "";
        for (var i = 0; i < query.length; ++i) {
            var char = query[i];
            if (char === "*") {
                result += ".*";
            } else if (char === "\\") {
                ++i;
                var nextChar = query[i];
                if (nextChar === " ")
                    result += " ";
            } else {
                if (String.regexSpecialCharacters().indexOf(query.charAt(i)) !== -1)
                    result += "\\";
                result += query.charAt(i);
            }
        }
        return new WebInspector.SearchConfig.QueryTerm(result, isNegative);
    }
}

/**
 * @constructor
 * @param {string} text
 * @param {boolean} isNegative
 */
WebInspector.SearchConfig.QueryTerm = function(text, isNegative)
{
    this.text = text;
    this.isNegative = isNegative;
}
;/* UISourceCode.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/**
 * @constructor
 * @extends {WebInspector.Object}
 * @implements {WebInspector.ContentProvider}
 * @param {!WebInspector.Project} project
 * @param {string} url
 * @param {!WebInspector.ResourceType} contentType
 */
WebInspector.UISourceCode = function(project, url, contentType)
{
    this._project = project;
    this._url = url;

    var pathComponents = WebInspector.ParsedURL.splitURLIntoPathComponents(url);
    this._origin = pathComponents[0];
    this._parentURL = pathComponents.slice(0, -1).join("/");
    this._name = pathComponents[pathComponents.length - 1];

    this._contentType = contentType;
    /** @type {?function(?string)} */
    this._requestContentCallback = null;
    /** @type {?Promise<?string>} */
    this._requestContentPromise = null;

    /** @type {!Array.<!WebInspector.Revision>} */
    this.history = [];
    this._hasUnsavedCommittedChanges = false;

    /** @type {!Array<!WebInspector.UISourceCode.Message>} */
    this._messages = [];
}

/**
 * @enum {string}
 */
WebInspector.UISourceCode.Events = {
    WorkingCopyChanged: "WorkingCopyChanged",
    WorkingCopyCommitted: "WorkingCopyCommitted",
    TitleChanged: "TitleChanged",
    SourceMappingChanged: "SourceMappingChanged",
    MessageAdded: "MessageAdded",
    MessageRemoved: "MessageRemoved",
}

WebInspector.UISourceCode.prototype = {
    /**
     * @return {string}
     */
    name: function()
    {
        return this._name;
    },

    /**
     * @return {string}
     */
    url: function()
    {
        return this._url;
    },

    /**
     * @return {string}
     */
    parentURL: function()
    {
        return this._parentURL;
    },

    /**
     * @return {string}
     */
    origin: function()
    {
        return this._origin;
    },

    /**
     * @return {string}
     */
    fullDisplayName: function()
    {
        var parentPath = this._parentURL.replace(/^(?:https?|file)\:\/\//, "");
        try {
            parentPath = decodeURI(parentPath);
        } catch (e) {
        }
        return parentPath + "/" + this.displayName(true);
    },

    /**
     * @param {boolean=} skipTrim
     * @return {string}
     */
    displayName: function(skipTrim)
    {
        if (!this._name)
            return WebInspector.UIString("(index)");
        var name = this._name;
        try {
            name = decodeURI(name);
        } catch (e) {
        }
        return skipTrim ? name : name.trimEnd(100);
    },

    /**
     * @return {boolean}
     */
    isFromServiceProject: function()
    {
        return WebInspector.Project.isServiceProject(this._project);
    },

    /**
     * @return {boolean}
     */
    canRename: function()
    {
        return this._project.canRename();
    },

    /**
     * @param {string} newName
     * @param {function(boolean)} callback
     */
    rename: function(newName, callback)
    {
        this._project.rename(this, newName, innerCallback.bind(this));

        /**
         * @param {boolean} success
         * @param {string=} newName
         * @param {string=} newURL
         * @param {!WebInspector.ResourceType=} newContentType
         * @this {WebInspector.UISourceCode}
         */
        function innerCallback(success, newName, newURL, newContentType)
        {
            if (success)
                this._updateName(/** @type {string} */ (newName), /** @type {string} */ (newURL), /** @type {!WebInspector.ResourceType} */ (newContentType));
            callback(success);
        }
    },

    remove: function()
    {
        this._project.deleteFile(this.url());
    },

    /**
     * @param {string} name
     * @param {string} url
     * @param {!WebInspector.ResourceType=} contentType
     */
    _updateName: function(name, url, contentType)
    {
        var oldURД = this.url();
        this._url = this._url.substring(0, this._url.length - this._name.length) + name;
        this._name = name;
        if (url)
            this._url = url;
        if (contentType)
            this._contentType = contentType;
        this.dispatchEventToListeners(WebInspector.UISourceCode.Events.TitleChanged, oldURД);
    },

    /**
     * @override
     * @return {string}
     */
    contentURL: function()
    {
        return this.url();
    },

    /**
     * @override
     * @return {!WebInspector.ResourceType}
     */
    contentType: function()
    {
        return this._contentType;
    },

    /**
     * @return {!WebInspector.Project}
     */
    project: function()
    {
        return this._project;
    },

    /**
     * @override
     * @return {!Promise<?string>}
     */
    requestContent: function()
    {
        if (this._content || this._contentLoaded)
            return Promise.resolve(this._content);
        var promise = this._requestContentPromise;
        if (!promise) {
            promise = new Promise(fulfill => this._requestContentCallback = fulfill);
            this._requestContentPromise = promise;
            this._project.requestFileContent(this, this._fireContentAvailable.bind(this));
        }
        return promise;
    },

    /**
     * @param {function()} callback
     */
    _pushCheckContentUpdatedCallback: function(callback)
    {
        if (!this._checkContentUpdatedCallbacks)
            this._checkContentUpdatedCallbacks = [];
        this._checkContentUpdatedCallbacks.push(callback);
    },

    _terminateContentCheck: function()
    {
        delete this._checkingContent;
        if (this._checkContentUpdatedCallbacks) {
            this._checkContentUpdatedCallbacks.forEach(function(callback) { callback(); });
            delete this._checkContentUpdatedCallbacks;
        }
    },

    /**
     * @param {boolean=} forceLoad
     * @param {function()=} callback
     */
    checkContentUpdated: function(forceLoad, callback)
    {
        callback = callback || function() {};
        forceLoad = forceLoad || this._forceLoadOnCheckContent;
        if (!this.contentLoaded() && !forceLoad) {
            callback();
            return;
        }

        if (!this._project.canSetFileContent()) {
            callback();
            return;
        }
        this._pushCheckContentUpdatedCallback(callback);

        if (this._checkingContent)
            return;

        this._checkingContent = true;
        this._project.requestFileContent(this, contentLoaded.bind(this));

        /**
         * @param {?string} updatedContent
         * @this {WebInspector.UISourceCode}
         */
        function contentLoaded(updatedContent)
        {
            if (updatedContent === null) {
                var workingCopy = this.workingCopy();
                this._contentCommitted("", true, false);
                this.setWorkingCopy(workingCopy);
                this._terminateContentCheck();
                return;
            }
            if (typeof this._lastAcceptedContent === "string" && this._lastAcceptedContent === updatedContent) {
                this._terminateContentCheck();
                return;
            }

            if (this._content === updatedContent) {
                delete this._lastAcceptedContent;
                this._terminateContentCheck();
                return;
            }

            if (!this.isDirty() || this._workingCopy === updatedContent) {
                this._contentCommitted(updatedContent, true, false);
                this._terminateContentCheck();
                return;
            }

            var shouldUpdate = window.confirm(WebInspector.UIString("This file was changed externally. Would you like to reload it?"));
            if (shouldUpdate)
                this._contentCommitted(updatedContent, true, false);
            else
                this._lastAcceptedContent = updatedContent;
            this._terminateContentCheck();
        }
    },

    forceLoadOnCheckContent: function()
    {
        this._forceLoadOnCheckContent = true;
    },

    /**
     * @return {!Promise<?string>}
     */
    requestOriginalContent: function()
    {
        var callback;
        var promise = new Promise(fulfill => callback = fulfill);
        this._project.requestFileContent(this, callback);
        return promise;
    },

    /**
     * @param {string} content
     */
    _commitContent: function(content)
    {
        var wasPersisted = false;
        if (this._project.canSetFileContent()) {
            this._project.setFileContent(this, content, function() { });
            wasPersisted = true;
        } else if (this._project.workspace().hasResourceContentTrackingExtensions()) {
            wasPersisted = true;
        } else if (this._url && WebInspector.fileManager.isURLSaved(this._url)) {
            WebInspector.fileManager.save(this._url, content, false, function() { });
            WebInspector.fileManager.close(this._url);
            wasPersisted = true;
        }
        this._contentCommitted(content, wasPersisted, true);
    },

    /**
     * @param {string} content
     * @param {boolean} wasPersisted
     * @param {boolean} committedByUser
     */
    _contentCommitted: function(content, wasPersisted, committedByUser)
    {
        delete this._lastAcceptedContent;
        this._content = content;
        this._contentLoaded = true;

        var lastRevision = this.history.length ? this.history[this.history.length - 1] : null;
        if (!lastRevision || lastRevision._content !== this._content) {
            var revision = new WebInspector.Revision(this, this._content, new Date());
            this.history.push(revision);
        }

        this._innerResetWorkingCopy();
        this._hasUnsavedCommittedChanges = !wasPersisted;
        this.dispatchEventToListeners(WebInspector.UISourceCode.Events.WorkingCopyCommitted);
        this._project.workspace().dispatchEventToListeners(WebInspector.Workspace.Events.WorkingCopyCommitted, { uiSourceCode: this, content: content });
        if (committedByUser)
            this._project.workspace().dispatchEventToListeners(WebInspector.Workspace.Events.WorkingCopyCommittedByUser, { uiSourceCode: this, content: content });
    },

    saveAs: function()
    {
        WebInspector.fileManager.save(this._url, this.workingCopy(), true, callback.bind(this));
        WebInspector.fileManager.close(this._url);

        /**
         * @param {boolean} accepted
         * @this {WebInspector.UISourceCode}
         */
        function callback(accepted)
        {
            if (accepted)
                this._contentCommitted(this.workingCopy(), true, true);
        }
    },

    /**
     * @return {boolean}
     */
    hasUnsavedCommittedChanges: function()
    {
        return this._hasUnsavedCommittedChanges;
    },

    /**
     * @param {string} content
     */
    addRevision: function(content)
    {
        this._commitContent(content);
    },

    /**
     * @return {!Promise}
     */
    revertToOriginal: function()
    {
        /**
         * @this {WebInspector.UISourceCode}
         * @param {?string} content
         */
        function callback(content)
        {
            if (typeof content !== "string")
                return;

            this.addRevision(content);
        }

        WebInspector.userMetrics.actionTaken(WebInspector.UserMetrics.Action.RevisionApplied);
        return this.requestOriginalContent().then(callback.bind(this));
    },

    /**
     * @param {function(!WebInspector.UISourceCode)} callback
     */
    revertAndClearHistory: function(callback)
    {
        /**
         * @this {WebInspector.UISourceCode}
         * @param {?string} content
         */
        function revert(content)
        {
            if (typeof content !== "string")
                return;

            this.addRevision(content);
            this.history = [];
            callback(this);
        }

        WebInspector.userMetrics.actionTaken(WebInspector.UserMetrics.Action.RevisionApplied);
        this.requestOriginalContent().then(revert.bind(this));
    },

    /**
     * @return {string}
     */
    workingCopy: function()
    {
        if (this._workingCopyGetter) {
            this._workingCopy = this._workingCopyGetter();
            delete this._workingCopyGetter;
        }
        if (this.isDirty())
            return this._workingCopy;
        return this._content;
    },

    resetWorkingCopy: function()
    {
        this._innerResetWorkingCopy();
        this.dispatchEventToListeners(WebInspector.UISourceCode.Events.WorkingCopyChanged);
    },

    _innerResetWorkingCopy: function()
    {
        delete this._workingCopy;
        delete this._workingCopyGetter;
    },

    /**
     * @param {string} newWorkingCopy
     */
    setWorkingCopy: function(newWorkingCopy)
    {
        this._workingCopy = newWorkingCopy;
        delete this._workingCopyGetter;
        this.dispatchEventToListeners(WebInspector.UISourceCode.Events.WorkingCopyChanged);
        this._project.workspace().dispatchEventToListeners(WebInspector.Workspace.Events.WorkingCopyChanged, { uiSourceCode: this });
    },

    setWorkingCopyGetter: function(workingCopyGetter)
    {
        this._workingCopyGetter = workingCopyGetter;
        this.dispatchEventToListeners(WebInspector.UISourceCode.Events.WorkingCopyChanged);
        this._project.workspace().dispatchEventToListeners(WebInspector.Workspace.Events.WorkingCopyChanged, { uiSourceCode: this  });
    },

    removeWorkingCopyGetter: function()
    {
        if (!this._workingCopyGetter)
            return;
        this._workingCopy = this._workingCopyGetter();
        delete this._workingCopyGetter;
    },

    commitWorkingCopy: function()
    {
        if (this.isDirty())
            this._commitContent(this.workingCopy());
    },

    /**
     * @return {boolean}
     */
    isDirty: function()
    {
        return typeof this._workingCopy !== "undefined" || typeof this._workingCopyGetter !== "undefined";
    },

    /**
     * @return {string}
     */
    extension: function()
    {
        return WebInspector.TextUtils.extension(this._name);
    },

    /**
     * @return {?string}
     */
    content: function()
    {
        return this._content;
    },

    /**
     * @override
     * @param {string} query
     * @param {boolean} caseSensitive
     * @param {boolean} isRegex
     * @param {function(!Array.<!WebInspector.ContentProvider.SearchMatch>)} callback
     */
    searchInContent: function(query, caseSensitive, isRegex, callback)
    {
        var content = this.content();
        if (content) {
            WebInspector.StaticContentProvider.searchInContent(content, query, caseSensitive, isRegex, callback);
            return;
        }

        this._project.searchInFileContent(this, query, caseSensitive, isRegex, callback);
    },

    /**
     * @param {?string} content
     */
    _fireContentAvailable: function(content)
    {
        this._contentLoaded = true;
        this._content = content;

        var callback = this._requestContentCallback;
        this._requestContentCallback = null;
        this._requestContentPromise = null;

        callback.call(null, content);
    },

    /**
     * @return {boolean}
     */
    contentLoaded: function()
    {
        return this._contentLoaded;
    },

    /**
     * @param {number} lineNumber
     * @param {number=} columnNumber
     * @return {!WebInspector.UILocation}
     */
    uiLocation: function(lineNumber, columnNumber)
    {
        if (typeof columnNumber === "undefined")
            columnNumber = 0;
        return new WebInspector.UILocation(this, lineNumber, columnNumber);
    },

    /**
     * @return {!Array<!WebInspector.UISourceCode.Message>}
     */
    messages: function()
    {
        return this._messages.slice();
    },

    /**
     * @param {!WebInspector.UISourceCode.Message.Level} level
     * @param {string} text
     * @param {number} lineNumber
     * @param {number=} columnNumber
     * @return {!WebInspector.UISourceCode.Message} message
     */
    addLineMessage: function(level, text, lineNumber, columnNumber)
    {
        return this.addMessage(level, text, new WebInspector.TextRange(lineNumber, columnNumber || 0, lineNumber, columnNumber || 0));
    },

    /**
     * @param {!WebInspector.UISourceCode.Message.Level} level
     * @param {string} text
     * @param {!WebInspector.TextRange} range
     * @return {!WebInspector.UISourceCode.Message} message
     */
    addMessage: function(level, text, range)
    {
        var message = new WebInspector.UISourceCode.Message(this, level, text, range);
        this._messages.push(message);
        this.dispatchEventToListeners(WebInspector.UISourceCode.Events.MessageAdded, message);
        return message;
    },

    /**
     * @param {!WebInspector.UISourceCode.Message} message
     */
    removeMessage: function(message)
    {
        if (this._messages.remove(message))
            this.dispatchEventToListeners(WebInspector.UISourceCode.Events.MessageRemoved, message);
    },

    removeAllMessages: function()
    {
        var messages = this._messages;
        this._messages = [];
        for (var message of messages)
            this.dispatchEventToListeners(WebInspector.UISourceCode.Events.MessageRemoved, message);
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @constructor
 * @param {!WebInspector.UISourceCode} uiSourceCode
 * @param {number} lineNumber
 * @param {number} columnNumber
 */
WebInspector.UILocation = function(uiSourceCode, lineNumber, columnNumber)
{
    this.uiSourceCode = uiSourceCode;
    this.lineNumber = lineNumber;
    this.columnNumber = columnNumber;
}

WebInspector.UILocation.prototype = {
    /**
     * @return {string}
     */
    linkText: function()
    {
        var linkText = this.uiSourceCode.displayName();
        if (typeof this.lineNumber === "number")
            linkText += ":" + (this.lineNumber + 1);
        return linkText;
    },

    /**
     * @return {string}
     */
    id: function()
    {
        return this.uiSourceCode.project().id() + ":" + this.uiSourceCode.url() + ":" + this.lineNumber + ":" + this.columnNumber;
    },

    /**
     * @return {string}
     */
    toUIString: function()
    {
        return this.uiSourceCode.url() + ":" + (this.lineNumber + 1);
    }
}

/**
 * @constructor
 * @implements {WebInspector.ContentProvider}
 * @param {!WebInspector.UISourceCode} uiSourceCode
 * @param {?string|undefined} content
 * @param {!Date} timestamp
 */
WebInspector.Revision = function(uiSourceCode, content, timestamp)
{
    this._uiSourceCode = uiSourceCode;
    this._content = content;
    this._timestamp = timestamp;
}

WebInspector.Revision.prototype = {
    /**
     * @return {!WebInspector.UISourceCode}
     */
    get uiSourceCode()
    {
        return this._uiSourceCode;
    },

    /**
     * @return {!Date}
     */
    get timestamp()
    {
        return this._timestamp;
    },

    /**
     * @return {?string}
     */
    get content()
    {
        return this._content || null;
    },

    /**
     * @return {!Promise}
     */
    revertToThis: function()
    {
        /**
         * @param {?string} content
         * @this {WebInspector.Revision}
         */
        function revert(content)
        {
            if (content && this._uiSourceCode._content !== content)
                this._uiSourceCode.addRevision(content);
        }
        WebInspector.userMetrics.actionTaken(WebInspector.UserMetrics.Action.RevisionApplied);
        return this.requestContent().then(revert.bind(this));
    },

    /**
     * @override
     * @return {string}
     */
    contentURL: function()
    {
        return this._uiSourceCode.url();
    },

    /**
     * @override
     * @return {!WebInspector.ResourceType}
     */
    contentType: function()
    {
        return this._uiSourceCode.contentType();
    },

    /**
     * @override
     * @return {!Promise<?string>}
     */
    requestContent: function()
    {
        return Promise.resolve(/** @type {?string} */(this._content || ""));
    },

    /**
     * @override
     * @param {string} query
     * @param {boolean} caseSensitive
     * @param {boolean} isRegex
     * @param {function(!Array.<!WebInspector.ContentProvider.SearchMatch>)} callback
     */
    searchInContent: function(query, caseSensitive, isRegex, callback)
    {
        callback([]);
    }
}

/**
 * @constructor
 * @param {!WebInspector.UISourceCode} uiSourceCode
 * @param {!WebInspector.UISourceCode.Message.Level} level
 * @param {string} text
 * @param {!WebInspector.TextRange} range
 */
WebInspector.UISourceCode.Message = function(uiSourceCode, level, text, range)
{
    this._uiSourceCode = uiSourceCode;
    this._level = level;
    this._text = text;
    this._range = range;
}

/**
 * @enum {string}
 */
WebInspector.UISourceCode.Message.Level = {
    Error: "Error",
    Warning: "Warning"
}

WebInspector.UISourceCode.Message.prototype = {
    /**
     * @return {!WebInspector.UISourceCode}
     */
    uiSourceCode: function()
    {
        return this._uiSourceCode;
    },

    /**
     * @return {!WebInspector.UISourceCode.Message.Level}
     */
    level: function()
    {
        return this._level;
    },

    /**
     * @return {string}
     */
    text: function()
    {
        return this._text;
    },

    /**
     * @return {!WebInspector.TextRange}
     */
    range: function() {
        return this._range;
    },

    /**
     * @return {number}
     */
    lineNumber: function()
    {
        return this._range.startLine;
    },

    /**
     * @return {(number|undefined)}
     */
    columnNumber: function()
    {
        return this._range.startColumn;
    },

    /**
     * @param {!WebInspector.UISourceCode.Message} another
     * @return {boolean}
     */
    isEqual: function(another)
    {
        return this._uiSourceCode === another._uiSourceCode && this.text() === another.text() && this.level() === another.level() && this.range().equal(another.range());
    },

    remove: function()
    {
        this._uiSourceCode.removeMessage(this);
    }
}
;/* Workspace.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @interface
 */
WebInspector.ProjectSearchConfig = function() {}

WebInspector.ProjectSearchConfig.prototype = {
    /**
     * @return {string}
     */
    query: function() { },

    /**
     * @return {boolean}
     */
    ignoreCase: function() { },

    /**
     * @return {boolean}
     */
    isRegex: function() { },

    /**
     * @return {!Array.<string>}
     */
    queries: function() { },

    /**
     * @param {string} filePath
     * @return {boolean}
     */
    filePathMatchesFileQuery: function(filePath) { }
}

/**
 * @interface
 */
WebInspector.Project = function() { }

/**
 * @param {!WebInspector.Project} project
 * @return {boolean}
 */
WebInspector.Project.isServiceProject = function(project)
{
    return project.type() === WebInspector.projectTypes.Debugger || project.type() === WebInspector.projectTypes.Formatter || project.type() === WebInspector.projectTypes.Service;
}

WebInspector.Project.prototype = {
    /**
     * @return {!WebInspector.Workspace}
     */
    workspace: function() { },

    /**
     * @return {string}
     */
    id: function() { },

    /**
     * @return {string}
     */
    type: function() { },

    /**
     * @return {string}
     */
    displayName: function() { },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {function(?string)} callback
     */
    requestFileContent: function(uiSourceCode, callback) { },

    /**
     * @return {boolean}
     */
    canSetFileContent: function() { },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {string} newContent
     * @param {function(?string)} callback
     */
    setFileContent: function(uiSourceCode, newContent, callback) { },

    /**
     * @return {boolean}
     */
    canRename: function() { },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {string} newName
     * @param {function(boolean, string=, string=, !WebInspector.ResourceType=)} callback
     */
    rename: function(uiSourceCode, newName, callback) { },

    /**
     * @param {string} path
     * @param {function()=} callback
     */
    refresh: function(path, callback) { },

    /**
     * @param {string} path
     */
    excludeFolder: function(path) { },

    /**
     * @param {string} path
     * @param {?string} name
     * @param {string} content
     * @param {function(?WebInspector.UISourceCode)} callback
     */
    createFile: function(path, name, content, callback) { },

    /**
     * @param {string} path
     */
    deleteFile: function(path) { },

    remove: function() { },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {string} query
     * @param {boolean} caseSensitive
     * @param {boolean} isRegex
     * @param {function(!Array.<!WebInspector.ContentProvider.SearchMatch>)} callback
     */
    searchInFileContent: function(uiSourceCode, query, caseSensitive, isRegex, callback) { },

    /**
     * @param {!WebInspector.ProjectSearchConfig} searchConfig
     * @param {!Array.<string>} filesMathingFileQuery
     * @param {!WebInspector.Progress} progress
     * @param {function(!Array.<string>)} callback
     */
    findFilesMatchingSearchRequest: function(searchConfig, filesMathingFileQuery, progress, callback) { },

    /**
     * @param {!WebInspector.Progress} progress
     */
    indexContent: function(progress) { },

    /**
     * @param {string} url
     * @return {?WebInspector.UISourceCode}
     */
    uiSourceCodeForURL: function(url) { },

    /**
     * @return {!Array.<!WebInspector.UISourceCode>}
     */
    uiSourceCodes: function() { }
}

/**
 * @enum {string}
 */
WebInspector.projectTypes = {
    Debugger: "debugger",
    Formatter: "formatter",
    Network: "network",
    Snippets: "snippets",
    FileSystem: "filesystem",
    ContentScripts: "contentscripts",
    Service: "service"
}

/**
 * @constructor
 * @param {!WebInspector.Workspace} workspace
 * @param {string} id
 * @param {!WebInspector.projectTypes} type
 * @param {string} displayName
 */
WebInspector.ProjectStore = function(workspace, id, type, displayName)
{
    this._workspace = workspace;
    this._id = id;
    this._type = type;
    this._displayName = displayName;

    /** @type {!Map.<string, !{uiSourceCode: !WebInspector.UISourceCode, index: number}>} */
    this._uiSourceCodesMap = new Map();
    /** @type {!Array.<!WebInspector.UISourceCode>} */
    this._uiSourceCodesList = [];

    this._project = /** @type {!WebInspector.Project} */(this);
}

WebInspector.ProjectStore.prototype = {
    /**
     * @return {string}
     */
    id: function()
    {
        return this._id;
    },

    /**
     * @return {string}
     */
    type: function()
    {
        return this._type;
    },

    /**
     * @return {string}
     */
    displayName: function()
    {
        return this._displayName;
    },

    /**
     * @return {!WebInspector.Workspace}
     */
    workspace: function()
    {
        return this._workspace;
    },

    /**
     * @param {string} url
     * @param {!WebInspector.ResourceType} contentType
     * @return {!WebInspector.UISourceCode}
     */
    createUISourceCode: function(url, contentType)
    {
        return new WebInspector.UISourceCode(this._project, url, contentType);
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {boolean=} replace
     * @return {boolean}
     */
    addUISourceCode: function(uiSourceCode, replace)
    {
        var url = uiSourceCode.url();
        if (this.uiSourceCodeForURL(url)) {
            if (replace)
                this.removeUISourceCode(url);
            else
                return false;
        }
        this._uiSourceCodesMap.set(url, {uiSourceCode: uiSourceCode, index: this._uiSourceCodesList.length});
        this._uiSourceCodesList.push(uiSourceCode);
        this._workspace.dispatchEventToListeners(WebInspector.Workspace.Events.UISourceCodeAdded, uiSourceCode);
        return true;
    },

    /**
     * @param {string} url
     */
    removeUISourceCode: function(url)
    {
        var uiSourceCode = this.uiSourceCodeForURL(url);
        if (!uiSourceCode)
            return;

        var entry = this._uiSourceCodesMap.get(url);
        var movedUISourceCode = this._uiSourceCodesList[this._uiSourceCodesList.length - 1];
        this._uiSourceCodesList[entry.index] = movedUISourceCode;
        var movedEntry = this._uiSourceCodesMap.get(movedUISourceCode.url());
        movedEntry.index = entry.index;
        this._uiSourceCodesList.splice(this._uiSourceCodesList.length - 1, 1);
        this._uiSourceCodesMap.delete(url);
        this._workspace.dispatchEventToListeners(WebInspector.Workspace.Events.UISourceCodeRemoved, entry.uiSourceCode);
    },

    removeProject: function()
    {
        this._workspace._removeProject(this._project);
        this._uiSourceCodesMap = new Map();
        this._uiSourceCodesList = [];
    },

    /**
     * @param {string} url
     * @return {?WebInspector.UISourceCode}
     */
    uiSourceCodeForURL: function(url)
    {
        var entry = this._uiSourceCodesMap.get(url);
        return entry ? entry.uiSourceCode : null;
    },

    /**
     * @return {!Array.<!WebInspector.UISourceCode>}
     */
    uiSourceCodes: function()
    {
        return this._uiSourceCodesList;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {string} newName
     */
    renameUISourceCode: function(uiSourceCode, newName)
    {
        var oldPath = uiSourceCode.url();
        var newPath = uiSourceCode.parentURL() ? uiSourceCode.parentURL() + "/" + newName : newName;
        var value = /** @type {!{uiSourceCode: !WebInspector.UISourceCode, index: number}} */ (this._uiSourceCodesMap.get(oldPath));
        this._uiSourceCodesMap.set(newPath, value);
        this._uiSourceCodesMap.delete(oldPath);
    }
}

/**
 * @constructor
 * @extends {WebInspector.Object}
 */
WebInspector.Workspace = function()
{
    /** @type {!Map<string, !WebInspector.Project>} */
    this._projects = new Map();
    this._hasResourceContentTrackingExtensions = false;
}

WebInspector.Workspace.Events = {
    UISourceCodeAdded: "UISourceCodeAdded",
    UISourceCodeRemoved: "UISourceCodeRemoved",
    WorkingCopyChanged: "WorkingCopyChanged",
    WorkingCopyCommitted: "WorkingCopyCommitted",
    WorkingCopyCommittedByUser: "WorkingCopyCommittedByUser",
    ProjectAdded: "ProjectAdded",
    ProjectRemoved: "ProjectRemoved"
}

WebInspector.Workspace.prototype = {
    /**
     * @return {!Array.<!WebInspector.UISourceCode>}
     */
    unsavedSourceCodes: function()
    {
        /**
         * @param {!WebInspector.UISourceCode} sourceCode
         * @return {boolean}
         */
        function filterUnsaved(sourceCode)
        {
            return sourceCode.isDirty();
        }

        var unsavedSourceCodes = [];
        var projects = this.projectsForType(WebInspector.projectTypes.FileSystem);
        for (var i = 0; i < projects.length; ++i)
            unsavedSourceCodes = unsavedSourceCodes.concat(projects[i].uiSourceCodes().filter(filterUnsaved));

        return unsavedSourceCodes;
    },

    /**
     * @param {string} projectId
     * @param {string} url
     * @return {?WebInspector.UISourceCode}
     */
    uiSourceCode: function(projectId, url)
    {
        var project = this._projects.get(projectId);
        return project ? project.uiSourceCodeForURL(url) : null;
    },

    /**
     * @param {string} url
     * @return {?WebInspector.UISourceCode}
     */
    uiSourceCodeForURL: function(url)
    {
        for (var project of this._projects.values()) {
            var uiSourceCode = project.uiSourceCodeForURL(url);
            if (uiSourceCode)
                return uiSourceCode;
        }
        return null;
    },

    /**
     * @param {string} type
     * @return {!Array.<!WebInspector.UISourceCode>}
     */
    uiSourceCodesForProjectType: function(type)
    {
        var result = [];
        for (var project of this._projects.values()) {
            if (project.type() === type)
                result = result.concat(project.uiSourceCodes());
        }
        return result;
    },

    /**
     * @param {!WebInspector.Project} project
     */
    addProject: function(project)
    {
        this._projects.set(project.id(), project);
        this.dispatchEventToListeners(WebInspector.Workspace.Events.ProjectAdded, project);
    },

    /**
     * @param {!WebInspector.Project} project
     */
    _removeProject: function(project)
    {
        this._projects.delete(project.id());
        this.dispatchEventToListeners(WebInspector.Workspace.Events.ProjectRemoved, project);
    },

    /**
     * @param {string} projectId
     * @return {?WebInspector.Project}
     */
    project: function(projectId)
    {
        return this._projects.get(projectId) || null;
    },

    /**
     * @return {!Array.<!WebInspector.Project>}
     */
    projects: function()
    {
        return Array.from(this._projects.values());
    },

    /**
     * @param {string} type
     * @return {!Array.<!WebInspector.Project>}
     */
    projectsForType: function(type)
    {
        function filterByType(project)
        {
            return project.type() === type;
        }
        return this.projects().filter(filterByType);
    },

    /**
     * @return {!Array.<!WebInspector.UISourceCode>}
     */
    uiSourceCodes: function()
    {
        var result = [];
        for (var project of this._projects.values())
            result = result.concat(project.uiSourceCodes());
        return result;
    },

    /**
     * @param {boolean} hasExtensions
     */
    setHasResourceContentTrackingExtensions: function(hasExtensions)
    {
        this._hasResourceContentTrackingExtensions = hasExtensions;
    },

    /**
     * @return {boolean}
     */
    hasResourceContentTrackingExtensions: function()
    {
        return this._hasResourceContentTrackingExtensions;
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @type {!WebInspector.Workspace}
 */
WebInspector.workspace;
;
/* Module bindings */
/* LiveLocation.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {function(!WebInspector.LiveLocation)} updateDelegate
 */
WebInspector.LiveLocation = function(updateDelegate)
{
    this._updateDelegate = updateDelegate;
}

WebInspector.LiveLocation.prototype = {
    update: function()
    {
        this._updateDelegate(this);
    },

    /**
     * @return {?WebInspector.UILocation}
     */
    uiLocation: function()
    {
        throw "Not implemented";
    },

    dispose: function()
    {
        // Overridden by subclasses.
    },

    /**
     * @return {boolean}
     */
    isBlackboxed: function()
    {
        throw "Not implemented";
    }
}
;/* CompilerScriptMapping.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @implements {WebInspector.DebuggerSourceMapping}
 * @param {!WebInspector.DebuggerModel} debuggerModel
 * @param {!WebInspector.Workspace} workspace
 * @param {!WebInspector.NetworkMapping} networkMapping
 * @param {!WebInspector.NetworkProject} networkProject
 * @param {!WebInspector.DebuggerWorkspaceBinding} debuggerWorkspaceBinding
 */
WebInspector.CompilerScriptMapping = function(debuggerModel, workspace, networkMapping, networkProject, debuggerWorkspaceBinding)
{
    this._target = debuggerModel.target();
    this._debuggerModel = debuggerModel;
    this._workspace = workspace;
    this._workspace.addEventListener(WebInspector.Workspace.Events.UISourceCodeAdded, this._uiSourceCodeAddedToWorkspace, this);
    this._networkMapping = networkMapping;
    this._networkProject = networkProject;
    this._debuggerWorkspaceBinding = debuggerWorkspaceBinding;

    /** @type {!Object.<string, !WebInspector.SourceMap>} */
    this._sourceMapForSourceMapURL = {};
    /** @type {!Object.<string, !Array.<function(?WebInspector.SourceMap)>>} */
    this._pendingSourceMapLoadingCallbacks = {};
    /** @type {!Object.<string, !WebInspector.SourceMap>} */
    this._sourceMapForScriptId = {};
    /** @type {!Map.<!WebInspector.SourceMap, !WebInspector.Script>} */
    this._scriptForSourceMap = new Map();
    /** @type {!Map.<string, !WebInspector.SourceMap>} */
    this._sourceMapForURL = new Map();
    /** @type {!Map.<string, !WebInspector.UISourceCode>} */
    this._stubUISourceCodes = new Map();

    this._stubProjectID = "compiler-script-project";
    this._stubProject = new WebInspector.ContentProviderBasedProject(this._workspace, this._stubProjectID, WebInspector.projectTypes.Service, "");
    debuggerModel.addEventListener(WebInspector.DebuggerModel.Events.GlobalObjectCleared, this._debuggerReset, this);
}

WebInspector.CompilerScriptMapping.StubProjectID = "compiler-script-project";

WebInspector.CompilerScriptMapping._originSymbol = Symbol("origin");

/**
 * @param {!WebInspector.UISourceCode} uiSourceCode
 * @return {?string}
 */
WebInspector.CompilerScriptMapping.uiSourceCodeOrigin = function(uiSourceCode)
{
    return uiSourceCode[WebInspector.CompilerScriptMapping._originSymbol] || null;
}

WebInspector.CompilerScriptMapping.prototype = {
    /**
     * @param {!WebInspector.DebuggerModel.Location} rawLocation
     * @return {boolean}
     */
    mapsToSourceCode: function (rawLocation) {
        var sourceMap = this._sourceMapForScriptId[rawLocation.scriptId];
        if (!sourceMap) {
            return true;
        }
        return !!sourceMap.findEntry(rawLocation.lineNumber, rawLocation.columnNumber);
    },

    /**
     * @override
     * @param {!WebInspector.DebuggerModel.Location} rawLocation
     * @return {?WebInspector.UILocation}
     */
    rawLocationToUILocation: function(rawLocation)
    {
        var debuggerModelLocation = /** @type {!WebInspector.DebuggerModel.Location} */ (rawLocation);

        var stubUISourceCode = this._stubUISourceCodes.get(debuggerModelLocation.scriptId);
        if (stubUISourceCode)
            return new WebInspector.UILocation(stubUISourceCode, rawLocation.lineNumber, rawLocation.columnNumber);

        var sourceMap = this._sourceMapForScriptId[debuggerModelLocation.scriptId];
        if (!sourceMap)
            return null;
        var lineNumber = debuggerModelLocation.lineNumber;
        var columnNumber = debuggerModelLocation.columnNumber || 0;
        var entry = sourceMap.findEntry(lineNumber, columnNumber);
        if (!entry || !entry.sourceURL)
            return null;
        var uiSourceCode = this._networkMapping.uiSourceCodeForScriptURL(/** @type {string} */ (entry.sourceURL), rawLocation.script());
        if (!uiSourceCode)
            return null;
        return uiSourceCode.uiLocation(/** @type {number} */ (entry.sourceLineNumber), /** @type {number} */ (entry.sourceColumnNumber));
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?WebInspector.DebuggerModel.Location}
     */
    uiLocationToRawLocation: function(uiSourceCode, lineNumber, columnNumber)
    {
        if (uiSourceCode.project().type() === WebInspector.projectTypes.Service)
            return null;
        var networkURL = this._networkMapping.networkURL(uiSourceCode);
        if (!networkURL)
            return null;
        var sourceMap = this._sourceMapForURL.get(networkURL);
        if (!sourceMap)
            return null;
        var script = /** @type {!WebInspector.Script} */ (this._scriptForSourceMap.get(sourceMap));
        console.assert(script);
        var entry = sourceMap.firstSourceLineMapping(networkURL, lineNumber);
        if (!entry)
            return null;
        return this._debuggerModel.createRawLocation(script, entry.lineNumber, entry.columnNumber);
    },

    /**
     * @param {!WebInspector.Script} script
     */
    addScript: function(script)
    {
        if (!script.sourceMapURL) {
            script.addEventListener(WebInspector.Script.Events.SourceMapURLAdded, this._sourceMapURLAdded.bind(this));
            return;
        }

        this._processScript(script);
    },

    /**
     * @param {!WebInspector.Script} script
     * @return {?WebInspector.SourceMap}
     */
    sourceMapForScript: function(script)
    {
        return this._sourceMapForScriptId[script.scriptId];
    },

    /**
     * @param {!WebInspector.Script} script
     */
    maybeLoadSourceMap: function(script)
    {
        if (!script.sourceMapURL)
            return;
        if (this._pendingSourceMapLoadingCallbacks[script.sourceMapURL])
            return;
        if (this._sourceMapForScriptId[script.scriptId])
            return;
        this._processScript(script);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _sourceMapURLAdded: function(event)
    {
        var script = /** @type {!WebInspector.Script} */ (event.target);
        if (!script.sourceMapURL)
            return;
        this._processScript(script);
    },

    /**
     * @param {!WebInspector.Script} script
     */
    _processScript: function(script)
    {
        if (WebInspector.blackboxManager.isBlackboxedURL(script.sourceURL, script.isContentScript()))
            return;
        // Create stub UISourceCode for the time source mapping is being loaded.
        var stubUISourceCode = this._stubProject.addContentProvider(script.sourceURL, new WebInspector.StaticContentProvider(WebInspector.resourceTypes.Script, "\n\n\n\n\n// Please wait a bit.\n// Compiled script is not shown while source map is being loaded!", script.sourceURL));
        this._stubUISourceCodes.set(script.scriptId, stubUISourceCode);

        this._debuggerWorkspaceBinding.pushSourceMapping(script, this);
        this._loadSourceMapForScript(script, this._sourceMapLoaded.bind(this, script, stubUISourceCode.url()));
    },

    /**
     * @param {!WebInspector.Script} script
     * @param {string} uiSourceCodePath
     * @param {?WebInspector.SourceMap} sourceMap
     */
    _sourceMapLoaded: function(script, uiSourceCodePath, sourceMap)
    {
        WebInspector.blackboxManager.sourceMapLoaded(script, sourceMap);

        this._stubUISourceCodes.delete(script.scriptId);
        this._stubProject.removeFile(uiSourceCodePath);

        if (!sourceMap) {
            this._debuggerWorkspaceBinding.updateLocations(script);
            return;
        }

        if (this._scriptForSourceMap.get(sourceMap)) {
            this._sourceMapForScriptId[script.scriptId] = sourceMap;
            this._debuggerWorkspaceBinding.updateLocations(script);
            return;
        }

        this._sourceMapForScriptId[script.scriptId] = sourceMap;
        this._scriptForSourceMap.set(sourceMap, script);

        var sourceURLs = sourceMap.sources();
        var missingSources = [];
        for (var i = 0; i < sourceURLs.length; ++i) {
            var sourceURL = sourceURLs[i];
            if (this._sourceMapForURL.get(sourceURL))
                continue;
            this._sourceMapForURL.set(sourceURL, sourceMap);
            var uiSourceCode = this._networkMapping.uiSourceCodeForScriptURL(sourceURL, script);
            if (!uiSourceCode && !this._networkMapping.hasMappingForNetworkURL(sourceURL)) {
                var contentProvider = sourceMap.sourceContentProvider(sourceURL, WebInspector.resourceTypes.SourceMapScript);
                uiSourceCode = this._networkProject.addFileForURL(sourceURL, contentProvider, WebInspector.ResourceTreeFrame.fromScript(script), script.isContentScript());
                uiSourceCode[WebInspector.CompilerScriptMapping._originSymbol] = script.sourceURL;
            }
            if (uiSourceCode) {
                this._bindUISourceCode(uiSourceCode);
            } else {
                if (missingSources.length < 3)
                    missingSources.push(sourceURL);
                else if (missingSources.peekLast() !== "\u2026")
                    missingSources.push("\u2026");
            }
        }
        if (missingSources.length) {
            WebInspector.console.warn(
                WebInspector.UIString("Source map %s points to the files missing from the workspace: [%s]",
                                      sourceMap.url(), missingSources.join(", ")));
        }

        this._debuggerWorkspaceBinding.updateLocations(script);
    },

    /**
     * @override
     * @return {boolean}
     */
    isIdentity: function()
    {
        return false;
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @return {boolean}
     */
    uiLineHasMapping: function(uiSourceCode, lineNumber)
    {
        var networkURL = this._networkMapping.networkURL(uiSourceCode);
        if (!networkURL)
            return true;
        var sourceMap = this._sourceMapForURL.get(networkURL);
        if (!sourceMap)
            return true;
        return !!sourceMap.firstSourceLineMapping(networkURL, lineNumber);
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     */
    _bindUISourceCode: function(uiSourceCode)
    {
        this._debuggerWorkspaceBinding.setSourceMapping(this._target, uiSourceCode, this);
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     */
    _unbindUISourceCode: function(uiSourceCode)
    {
        this._debuggerWorkspaceBinding.setSourceMapping(this._target, uiSourceCode, null);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _uiSourceCodeAddedToWorkspace: function(event)
    {
        var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (event.data);
        var networkURL = this._networkMapping.networkURL(uiSourceCode);
        if (!networkURL || !this._sourceMapForURL.get(networkURL))
            return;
        this._bindUISourceCode(uiSourceCode);
    },

    /**
     * @param {!WebInspector.Script} script
     * @param {function(?WebInspector.SourceMap)} callback
     */
    _loadSourceMapForScript: function(script, callback)
    {
        // script.sourceURL can be a random string, but is generally an absolute path -> complete it to inspected page url for
        // relative links.
        var scriptURL = WebInspector.ParsedURL.completeURL(this._target.resourceTreeModel.inspectedPageURL(), script.sourceURL);
        if (!scriptURL) {
            callback(null);
            return;
        }

        console.assert(script.sourceMapURL);
        var scriptSourceMapURL = /** @type {string} */ (script.sourceMapURL);

        var sourceMapURL = WebInspector.ParsedURL.completeURL(scriptURL, scriptSourceMapURL);
        if (!sourceMapURL) {
            callback(null);
            return;
        }

        var sourceMap = this._sourceMapForSourceMapURL[sourceMapURL];
        if (sourceMap) {
            callback(sourceMap);
            return;
        }

        var pendingCallbacks = this._pendingSourceMapLoadingCallbacks[sourceMapURL];
        if (pendingCallbacks) {
            pendingCallbacks.push(callback);
            return;
        }

        pendingCallbacks = [callback];
        this._pendingSourceMapLoadingCallbacks[sourceMapURL] = pendingCallbacks;

        WebInspector.SourceMap.load(sourceMapURL, scriptURL, sourceMapLoaded.bind(this));

        /**
         * @param {?WebInspector.SourceMap} sourceMap
         * @this {WebInspector.CompilerScriptMapping}
         */
        function sourceMapLoaded(sourceMap)
        {
            var url = /** @type {string} */ (sourceMapURL);
            var callbacks = this._pendingSourceMapLoadingCallbacks[url];
            delete this._pendingSourceMapLoadingCallbacks[url];
            if (!callbacks)
                return;
            if (sourceMap)
                this._sourceMapForSourceMapURL[url] = sourceMap;
            for (var i = 0; i < callbacks.length; ++i)
                callbacks[i](sourceMap);
        }
    },

    _debuggerReset: function()
    {
        /**
         * @param {!WebInspector.SourceMap} sourceMap
         * @this {WebInspector.CompilerScriptMapping}
         */
        function unbindSourceMapSources(sourceMap)
        {
            var script = this._scriptForSourceMap.get(sourceMap);
            if (!script)
                return;
            var sourceURLs = sourceMap.sources();
            for (var i = 0; i < sourceURLs.length; ++i) {
                var uiSourceCode = this._networkMapping.uiSourceCodeForScriptURL(sourceURLs[i], script);
                if (uiSourceCode)
                    this._unbindUISourceCode(uiSourceCode);
            }
        }

        this._sourceMapForURL.valuesArray().forEach(unbindSourceMapSources.bind(this));

        this._sourceMapForSourceMapURL = {};
        this._pendingSourceMapLoadingCallbacks = {};
        this._sourceMapForScriptId = {};
        this._scriptForSourceMap.clear();
        this._sourceMapForURL.clear();
    },

    dispose: function()
    {
        this._workspace.removeEventListener(WebInspector.Workspace.Events.UISourceCodeAdded, this._uiSourceCodeAddedToWorkspace, this);
    }
}
;/* ResourceScriptMapping.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @implements {WebInspector.DebuggerSourceMapping}
 * @param {!WebInspector.DebuggerModel} debuggerModel
 * @param {!WebInspector.Workspace} workspace
 * @param {!WebInspector.NetworkMapping} networkMapping
 * @param {!WebInspector.DebuggerWorkspaceBinding} debuggerWorkspaceBinding
 */
WebInspector.ResourceScriptMapping = function(debuggerModel, workspace, networkMapping, debuggerWorkspaceBinding)
{
    this._target = debuggerModel.target();
    this._debuggerModel = debuggerModel;
    this._workspace = workspace;
    this._workspace.addEventListener(WebInspector.Workspace.Events.UISourceCodeAdded, this._uiSourceCodeAdded, this);
    this._workspace.addEventListener(WebInspector.Workspace.Events.UISourceCodeRemoved, this._uiSourceCodeRemoved, this);
    this._networkMapping = networkMapping;
    this._debuggerWorkspaceBinding = debuggerWorkspaceBinding;
    /** @type {!Array.<!WebInspector.UISourceCode>} */
    this._boundUISourceCodes = [];

    /** @type {!Map.<!WebInspector.UISourceCode, !WebInspector.ResourceScriptFile>} */
    this._uiSourceCodeToScriptFile = new Map();

    debuggerModel.addEventListener(WebInspector.DebuggerModel.Events.GlobalObjectCleared, this._debuggerReset, this);
}

WebInspector.ResourceScriptMapping.prototype = {
    /**
     * @override
     * @param {!WebInspector.DebuggerModel.Location} rawLocation
     * @return {?WebInspector.UILocation}
     */
    rawLocationToUILocation: function(rawLocation)
    {
        var debuggerModelLocation = /** @type {!WebInspector.DebuggerModel.Location} */ (rawLocation);
        var script = debuggerModelLocation.script();
        var uiSourceCode = this._workspaceUISourceCodeForScript(script);
        if (!uiSourceCode)
            return null;
        var scriptFile = this.scriptFile(uiSourceCode);
        if (scriptFile && ((scriptFile.hasDivergedFromVM() && !scriptFile.isMergingToVM()) || scriptFile.isDivergingFromVM()))
            return null;
        var lineNumber = debuggerModelLocation.lineNumber - (script.isInlineScriptWithSourceURL() ? script.lineOffset : 0);
        var columnNumber = debuggerModelLocation.columnNumber || 0;
        if (script.isInlineScriptWithSourceURL() && !lineNumber && columnNumber)
            columnNumber -= script.columnOffset;
        return uiSourceCode.uiLocation(lineNumber, columnNumber);
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?WebInspector.DebuggerModel.Location}
     */
    uiLocationToRawLocation: function(uiSourceCode, lineNumber, columnNumber)
    {
        var scripts = this._scriptsForUISourceCode(uiSourceCode);
        console.assert(scripts.length);
        var script = scripts[0];
        if (script.isInlineScriptWithSourceURL())
            return this._debuggerModel.createRawLocation(script, lineNumber + script.lineOffset, lineNumber ? columnNumber : columnNumber + script.columnOffset);
        return this._debuggerModel.createRawLocation(script, lineNumber, columnNumber);
    },

    /**
     * @param {!WebInspector.Script} script
     */
    addScript: function(script)
    {
        if (script.isAnonymousScript())
            return;
        this._debuggerWorkspaceBinding.pushSourceMapping(script, this);

        var uiSourceCode = this._workspaceUISourceCodeForScript(script);
        if (!uiSourceCode)
            return;

        this._bindUISourceCodeToScripts(uiSourceCode, [script]);
    },

    /**
     * @override
     * @return {boolean}
     */
    isIdentity: function()
    {
        return true;
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @return {boolean}
     */
    uiLineHasMapping: function(uiSourceCode, lineNumber)
    {
        return true;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @return {?WebInspector.ResourceScriptFile}
     */
    scriptFile: function(uiSourceCode)
    {
        return this._uiSourceCodeToScriptFile.get(uiSourceCode) || null;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {?WebInspector.ResourceScriptFile} scriptFile
     */
    _setScriptFile: function(uiSourceCode, scriptFile)
    {
        if (scriptFile)
            this._uiSourceCodeToScriptFile.set(uiSourceCode, scriptFile);
        else
            this._uiSourceCodeToScriptFile.remove(uiSourceCode);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _uiSourceCodeAdded: function(event)
    {
        var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (event.data);
        if (!this._networkMapping.networkURL(uiSourceCode))
            return;
        if (uiSourceCode.isFromServiceProject())
            return;

        var scripts = this._scriptsForUISourceCode(uiSourceCode);
        if (!scripts.length)
            return;

        this._bindUISourceCodeToScripts(uiSourceCode, scripts);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _uiSourceCodeRemoved: function(event)
    {
        var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (event.data);
        if (!this._networkMapping.networkURL(uiSourceCode))
            return;
        if (uiSourceCode.isFromServiceProject())
            return;

        this._unbindUISourceCode(uiSourceCode);
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     */
    _updateLocations: function(uiSourceCode)
    {
        var scripts = this._scriptsForUISourceCode(uiSourceCode);
        if (!scripts.length)
            return;
        for (var i = 0; i < scripts.length; ++i)
            this._debuggerWorkspaceBinding.updateLocations(scripts[i]);
    },

    /**
     * @param {!WebInspector.Script} script
     * @return {?WebInspector.UISourceCode}
     */
    _workspaceUISourceCodeForScript: function(script)
    {
        if (script.isAnonymousScript())
            return null;
        return this._networkMapping.uiSourceCodeForScriptURL(script.sourceURL, script);
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @return {!Array.<!WebInspector.Script>}
     */
    _scriptsForUISourceCode: function(uiSourceCode)
    {
        var target = WebInspector.NetworkProject.targetForUISourceCode(uiSourceCode);
        if (target && target !== this._debuggerModel.target())
            return [];
        if (!this._networkMapping.networkURL(uiSourceCode))
            return [];
        return this._debuggerModel.scriptsForSourceURL(this._networkMapping.networkURL(uiSourceCode));
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {!Array.<!WebInspector.Script>} scripts
     */
    _bindUISourceCodeToScripts: function(uiSourceCode, scripts)
    {
        console.assert(scripts.length);
        // Due to different listeners order, a script file could be created just before uiSourceCode
        // for the corresponding script was created. Check that we don't create scriptFile twice.
        var boundScriptFile = this.scriptFile(uiSourceCode);
        if (boundScriptFile && boundScriptFile._hasScripts(scripts))
            return;

        var scriptFile = new WebInspector.ResourceScriptFile(this, uiSourceCode, scripts);
        this._setScriptFile(uiSourceCode, scriptFile);
        for (var i = 0; i < scripts.length; ++i)
            this._debuggerWorkspaceBinding.updateLocations(scripts[i]);
        this._debuggerWorkspaceBinding.setSourceMapping(this._target, uiSourceCode, this);
        this._boundUISourceCodes.push(uiSourceCode);
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     */
    _unbindUISourceCode: function(uiSourceCode)
    {
        var scriptFile = this.scriptFile(uiSourceCode);
        if (scriptFile) {
            scriptFile.dispose();
            this._setScriptFile(uiSourceCode, null);
        }
        this._debuggerWorkspaceBinding.setSourceMapping(this._target, uiSourceCode, null);
        this._boundUISourceCodes.remove(uiSourceCode);
    },

    _debuggerReset: function()
    {
        var sourceCodes = this._boundUISourceCodes;
        this._boundUISourceCodes = [];
        sourceCodes.forEach(this._unbindUISourceCode.bind(this));
        console.assert(!this._uiSourceCodeToScriptFile.size);
    },

    dispose: function()
    {
        this._debuggerReset();
        this._workspace.removeEventListener(WebInspector.Workspace.Events.UISourceCodeAdded, this._uiSourceCodeAdded, this);
        this._workspace.removeEventListener(WebInspector.Workspace.Events.UISourceCodeRemoved, this._uiSourceCodeRemoved, this);
    }

}

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @param {!WebInspector.ResourceScriptMapping} resourceScriptMapping
 * @param {!WebInspector.UISourceCode} uiSourceCode
 * @param {!Array.<!WebInspector.Script>} scripts
 */
WebInspector.ResourceScriptFile = function(resourceScriptMapping, uiSourceCode, scripts)
{
    console.assert(scripts.length);

    this._resourceScriptMapping = resourceScriptMapping;
    this._uiSourceCode = uiSourceCode;
    this._uiSourceCode.forceLoadOnCheckContent();

    if (this._uiSourceCode.contentType().isScript())
        this._script = scripts[0];

    this._uiSourceCode.addEventListener(WebInspector.UISourceCode.Events.WorkingCopyChanged, this._workingCopyChanged, this);
    this._uiSourceCode.addEventListener(WebInspector.UISourceCode.Events.WorkingCopyCommitted, this._workingCopyCommitted, this);
}

WebInspector.ResourceScriptFile.Events = {
    DidMergeToVM: "DidMergeToVM",
    DidDivergeFromVM: "DidDivergeFromVM",
}

WebInspector.ResourceScriptFile.prototype = {
    /**
     * @param {!Array.<!WebInspector.Script>} scripts
     * @return {boolean}
     */
    _hasScripts: function(scripts)
    {
        return this._script && this._script === scripts[0];
    },

    /**
     * @return {boolean}
     */
    _isDiverged: function()
    {
        if (this._uiSourceCode.isDirty())
            return true;
        if (!this._script)
            return false;
        if (typeof this._scriptSource === "undefined")
            return false;
        if (!this._uiSourceCode.workingCopy().startsWith(this._scriptSource.trimRight()))
            return true;
        var suffix = this._uiSourceCode.workingCopy().substr(this._scriptSource.length);
        return !!suffix.length && !suffix.match(WebInspector.Script.sourceURLRegex);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _workingCopyChanged: function(event)
    {
        this._update();
    },

    _workingCopyCommitted: function(event)
    {
        if (this._uiSourceCode.project().type() === WebInspector.projectTypes.Snippets)
            return;
        if (!this._script)
            return;
        var debuggerModel = this._resourceScriptMapping._debuggerModel;
        var source = this._uiSourceCode.workingCopy();
        debuggerModel.setScriptSource(this._script.scriptId, source, scriptSourceWasSet.bind(this));

        /**
         * @param {?string} error
         * @param {!DebuggerAgent.SetScriptSourceError=} errorData
         * @this {WebInspector.ResourceScriptFile}
         */
        function scriptSourceWasSet(error, errorData)
        {
            if (!error && !errorData)
                this._scriptSource = source;
            this._update();

            if (!error && !errorData)
                return;
            var warningLevel = WebInspector.Console.MessageLevel.Warning;
            if (!errorData) {
                WebInspector.console.addMessage(WebInspector.UIString("LiveEdit failed: %s", error), warningLevel);
                return;
            }
            if (errorData) {
                var messageText = WebInspector.UIString("LiveEdit compile failed: %s", errorData.message);
                this._uiSourceCode.addLineMessage(WebInspector.UISourceCode.Message.Level.Error, messageText, errorData.lineNumber - 1, errorData.columnNumber + 1);
            } else {
                WebInspector.console.addMessage(WebInspector.UIString("Unknown LiveEdit error: %s; %s", JSON.stringify(errorData), error), warningLevel);
            }
        }
    },

    _update: function()
    {
        if (this._isDiverged() && !this._hasDivergedFromVM)
            this._divergeFromVM();
        else if (!this._isDiverged() && this._hasDivergedFromVM)
            this._mergeToVM();
    },

    _divergeFromVM: function()
    {
        this._isDivergingFromVM = true;
        this._resourceScriptMapping._updateLocations(this._uiSourceCode);
        delete this._isDivergingFromVM;
        this._hasDivergedFromVM = true;
        this.dispatchEventToListeners(WebInspector.ResourceScriptFile.Events.DidDivergeFromVM, this._uiSourceCode);
    },

    _mergeToVM: function()
    {
        delete this._hasDivergedFromVM;
        this._isMergingToVM = true;
        this._resourceScriptMapping._updateLocations(this._uiSourceCode);
        delete this._isMergingToVM;
        this.dispatchEventToListeners(WebInspector.ResourceScriptFile.Events.DidMergeToVM, this._uiSourceCode);
    },

    /**
     * @return {boolean}
     */
    hasDivergedFromVM: function()
    {
        return this._hasDivergedFromVM;
    },

    /**
     * @return {boolean}
     */
    isDivergingFromVM: function()
    {
        return this._isDivergingFromVM;
    },

    /**
     * @return {boolean}
     */
    isMergingToVM: function()
    {
        return this._isMergingToVM;
    },

    checkMapping: function()
    {
        if (!this._script || typeof this._scriptSource !== "undefined") {
            this._mappingCheckedForTest();
            return;
        }
        this._script.requestContent().then(callback.bind(this));

        /**
         * @param {?string} source
         * @this {WebInspector.ResourceScriptFile}
         */
        function callback(source)
        {
            this._scriptSource = source;
            this._update();
            this._mappingCheckedForTest();
        }
    },

    _mappingCheckedForTest: function() { },

    /**
     * @return {?WebInspector.Target}
     */
    target: function()
    {
        if (!this._script)
            return null;
        return this._script.target();
    },

    dispose: function()
    {
        this._uiSourceCode.removeEventListener(WebInspector.UISourceCode.Events.WorkingCopyChanged, this._workingCopyChanged, this);
        this._uiSourceCode.removeEventListener(WebInspector.UISourceCode.Events.WorkingCopyCommitted, this._workingCopyCommitted, this);
    },

    /**
     * @param {string} sourceMapURL
     */
    addSourceMapURL: function(sourceMapURL)
    {
        if (!this._script)
            return;
        this._script.addSourceMapURL(sourceMapURL);
    },

    /**
     * @return {boolean}
     */
    hasSourceMapURL: function()
    {
        return this._script && !!this._script.sourceMapURL;
    },

    __proto__: WebInspector.Object.prototype
}
;/* SASSSourceMapping.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @implements {WebInspector.CSSSourceMapping}
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {!WebInspector.NetworkMapping} networkMapping
 * @param {!WebInspector.NetworkProject} networkProject
 */
WebInspector.SASSSourceMapping = function(cssModel, networkMapping, networkProject)
{
    this._cssModel = cssModel;
    this._networkProject = networkProject;
    this._reset();
    WebInspector.moduleSetting("cssSourceMapsEnabled").addChangeListener(this._toggleSourceMapSupport, this);
    this._cssModel.addEventListener(WebInspector.CSSStyleModel.Events.StyleSheetChanged, this._styleSheetChanged, this);
    cssModel.target().resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.MainFrameNavigated, this._reset, this);
    this._networkMapping = networkMapping;
}

WebInspector.SASSSourceMapping.prototype = {
    /**
     * @param {!WebInspector.Event} event
     */
    _styleSheetChanged: function(event)
    {
        var id = /** @type {!CSSAgent.StyleSheetId} */ (event.data.styleSheetId);
        var header = this._cssModel.styleSheetHeaderForId(id);
        if (!header)
            return;
        this.removeHeader(header);
        this.addHeader(header);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _toggleSourceMapSupport: function(event)
    {
        var enabled = /** @type {boolean} */ (event.data);
        var headers = this._cssModel.styleSheetHeaders();
        for (var i = 0; i < headers.length; ++i) {
            if (enabled)
                this.addHeader(headers[i]);
            else
                this.removeHeader(headers[i]);
        }
    },

    /**
     * @param {!WebInspector.CSSStyleSheetHeader} header
     */
    addHeader: function(header)
    {
        if (!header.sourceMapURL || !header.sourceURL || !WebInspector.moduleSetting("cssSourceMapsEnabled").get())
            return;
        var completeSourceMapURL = WebInspector.ParsedURL.completeURL(header.sourceURL, header.sourceMapURL);
        if (!completeSourceMapURL)
            return;
        this._loadSourceMap(completeSourceMapURL, header, sourceMapLoaded.bind(this));

        /**
         * @param {?WebInspector.SourceMap} sourceMap
         * @this {WebInspector.SASSSourceMapping}
         */
        function sourceMapLoaded(sourceMap)
        {
            if (sourceMap)
                this._sourceMapByStyleSheetURL[header.sourceURL] = sourceMap;
            else
                delete this._sourceMapByStyleSheetURL[header.sourceURL];
            WebInspector.cssWorkspaceBinding.pushSourceMapping(header, this);
        }

    },

    /**
     * @param {!WebInspector.CSSStyleSheetHeader} header
     */
    removeHeader: function(header)
    {
        if (!header.sourceURL)
            return;
        delete this._sourceMapByStyleSheetURL[header.sourceURL];
        WebInspector.cssWorkspaceBinding.updateLocations(header);
    },

    /**
     * @param {string} completeSourceMapURL
     * @param {!WebInspector.CSSStyleSheetHeader} header
     * @param {function(?WebInspector.SourceMap)} callback
     */
    _loadSourceMap: function(completeSourceMapURL, header, callback)
    {
        var sourceMap = this._sourceMapByURL[completeSourceMapURL];
        if (sourceMap) {
            callback(sourceMap);
            return;
        }

        var pendingCallbacks = this._pendingSourceMapLoadingCallbacks[completeSourceMapURL];
        if (pendingCallbacks) {
            pendingCallbacks.push(callback);
            return;
        }

        pendingCallbacks = [callback];
        this._pendingSourceMapLoadingCallbacks[completeSourceMapURL] = pendingCallbacks;

        WebInspector.SourceMap.load(completeSourceMapURL, header.sourceURL, sourceMapLoaded.bind(this));

        /**
         * @param {?WebInspector.SourceMap} sourceMap
         * @this {WebInspector.SASSSourceMapping}
         */
        function sourceMapLoaded(sourceMap)
        {
            var callbacks = this._pendingSourceMapLoadingCallbacks[completeSourceMapURL];
            delete this._pendingSourceMapLoadingCallbacks[completeSourceMapURL];

            if (sourceMap)
                this._sourceMapByURL[completeSourceMapURL] = sourceMap;
            else
                delete this._sourceMapByURL[completeSourceMapURL];

            // Then report sources.
            var sources = sourceMap ? sourceMap.sources() : [];
            for (var i = 0; i < sources.length; ++i) {
                var sassURL = sources[i];
                if (!this._networkMapping.hasMappingForNetworkURL(sassURL)) {
                    var contentProvider = sourceMap.sourceContentProvider(sassURL, WebInspector.resourceTypes.SourceMapStyleSheet);
                    this._networkProject.addFileForURL(sassURL, contentProvider, WebInspector.ResourceTreeFrame.fromStyleSheet(header));
                }
            }

            for (var i = 0; callbacks && i < callbacks.length; ++i)
                callbacks[i](sourceMap);
        }
    },

    /**
     * @override
     * @param {!WebInspector.CSSLocation} rawLocation
     * @return {?WebInspector.UILocation}
     */
    rawLocationToUILocation: function(rawLocation)
    {
        var sourceMap = this._sourceMapByStyleSheetURL[rawLocation.url];
        if (!sourceMap)
            return null;
        var entry = sourceMap.findEntry(rawLocation.lineNumber, rawLocation.columnNumber);
        if (!entry || !entry.sourceURL)
            return null;
        var uiSourceCode = this._networkMapping.uiSourceCodeForStyleURL(entry.sourceURL, rawLocation.header());
        if (!uiSourceCode)
            return null;
        return uiSourceCode.uiLocation(entry.sourceLineNumber, entry.sourceColumnNumber);
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?WebInspector.CSSLocation}
     */
    uiLocationToRawLocation: function(uiSourceCode, lineNumber, columnNumber)
    {
        return null;
    },

    /**
     * @override
     * @return {boolean}
     */
    isIdentity: function()
    {
        return false;
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @return {boolean}
     */
    uiLineHasMapping: function(uiSourceCode, lineNumber)
    {
        return true;
    },

    /**
     * @return {!WebInspector.Target}
     */
    target: function()
    {
        return this._cssModel.target();
    },

    _reset: function()
    {
        /** @type {!Object.<string, !Array.<function(?WebInspector.SourceMap)>>} */
        this._pendingSourceMapLoadingCallbacks = {};
        /** @type {!Object.<string, !WebInspector.SourceMap>} */
        this._sourceMapByURL = {};
        this._sourceMapByStyleSheetURL = {};
    }
}
;/* StylesSourceMapping.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @implements {WebInspector.CSSSourceMapping}
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {!WebInspector.Workspace} workspace
 * @param {!WebInspector.NetworkMapping} networkMapping
 */
WebInspector.StylesSourceMapping = function(cssModel, workspace, networkMapping)
{
    this._cssModel = cssModel;
    this._workspace = workspace;
    this._workspace.addEventListener(WebInspector.Workspace.Events.ProjectRemoved, this._projectRemoved, this);
    this._workspace.addEventListener(WebInspector.Workspace.Events.UISourceCodeAdded, this._uiSourceCodeAddedToWorkspace, this);
    this._workspace.addEventListener(WebInspector.Workspace.Events.UISourceCodeRemoved, this._uiSourceCodeRemoved, this);
    this._networkMapping = networkMapping;

    cssModel.target().resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.MainFrameNavigated, this._unbindAllUISourceCodes, this);

    this._cssModel.addEventListener(WebInspector.CSSStyleModel.Events.StyleSheetChanged, this._styleSheetChanged, this);
    /** @type {!Map<string, !Map<string, !Map<string, !WebInspector.CSSStyleSheetHeader>>>} */
    this._urlToHeadersByFrameId = new Map();
    /** @type {!Map.<!WebInspector.UISourceCode, !WebInspector.StyleFile>} */
    this._styleFiles = new Map();
}

WebInspector.StylesSourceMapping.ChangeUpdateTimeoutMs = 200;

WebInspector.StylesSourceMapping.prototype = {
    /**
     * @override
     * @param {!WebInspector.CSSLocation} rawLocation
     * @return {?WebInspector.UILocation}
     */
    rawLocationToUILocation: function(rawLocation)
    {
        var uiSourceCode = this._networkMapping.uiSourceCodeForStyleURL(rawLocation.url, rawLocation.header());
        if (!uiSourceCode)
            return null;
        var lineNumber = rawLocation.lineNumber;
        var columnNumber = rawLocation.columnNumber;
        var header = this._cssModel.styleSheetHeaderForId(rawLocation.styleSheetId);
        if (header && header.isInline && header.hasSourceURL) {
            lineNumber -= header.lineNumberInSource(0);
            columnNumber -= header.columnNumberInSource(lineNumber, 0);
        }
        return uiSourceCode.uiLocation(lineNumber, columnNumber);
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?WebInspector.CSSLocation}
     */
    uiLocationToRawLocation: function(uiSourceCode, lineNumber, columnNumber)
    {
        return null;
    },

    /**
     * @override
     * @return {boolean}
     */
    isIdentity: function()
    {
        return true;
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @return {boolean}
     */
    uiLineHasMapping: function(uiSourceCode, lineNumber)
    {
        return true;
    },

    /**
     * @return {!WebInspector.Target}
     */
    target: function()
    {
        return this._cssModel.target();
    },

    /**
     * @param {!WebInspector.CSSStyleSheetHeader} header
     */
    addHeader: function(header)
    {
        var url = header.resourceURL();
        if (!url)
            return;

        WebInspector.cssWorkspaceBinding.pushSourceMapping(header, this);
        var map = this._urlToHeadersByFrameId.get(url);
        if (!map) {
            map = /** @type {!Map.<string, !Map.<string, !WebInspector.CSSStyleSheetHeader>>} */ (new Map());
            this._urlToHeadersByFrameId.set(url, map);
        }
        var headersById = map.get(header.frameId);
        if (!headersById) {
            headersById = /** @type {!Map.<string, !WebInspector.CSSStyleSheetHeader>} */ (new Map());
            map.set(header.frameId, headersById);
        }
        headersById.set(header.id, header);
        var uiSourceCode = this._networkMapping.uiSourceCodeForStyleURL(url, header);
        if (uiSourceCode)
            this._bindUISourceCode(uiSourceCode, header);
    },

    /**
     * @param {!WebInspector.CSSStyleSheetHeader} header
     */
    removeHeader: function(header)
    {
        var url = header.resourceURL();
        if (!url)
            return;

        var map = this._urlToHeadersByFrameId.get(url);
        console.assert(map);
        var headersById = map.get(header.frameId);
        console.assert(headersById);
        headersById.delete(header.id);

        if (!headersById.size) {
            map.delete(header.frameId);
            if (!map.size) {
                this._urlToHeadersByFrameId.delete(url);
                var uiSourceCode = this._networkMapping.uiSourceCodeForStyleURL(url, header);
                if (uiSourceCode)
                    this._unbindUISourceCode(uiSourceCode);
            }
        }
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     */
    _unbindUISourceCode: function(uiSourceCode)
    {
        var styleFile = this._styleFiles.get(uiSourceCode);
        if (!styleFile)
            return;
        styleFile.dispose();
        this._styleFiles.delete(uiSourceCode);
    },

    _unbindAllUISourceCodes: function()
    {
        for (var styleFile of this._styleFiles.keys())
            styleFile.dispose();
        this._styleFiles.clear();
        this._urlToHeadersByFrameId = new Map();
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _uiSourceCodeAddedToWorkspace: function(event)
    {
        var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (event.data);
        var networkURL = this._networkMapping.networkURL(uiSourceCode);
        if (!networkURL || !this._urlToHeadersByFrameId.has(networkURL))
            return;
        this._bindUISourceCode(uiSourceCode, this._urlToHeadersByFrameId.get(networkURL).valuesArray()[0].valuesArray()[0]);
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {!WebInspector.CSSStyleSheetHeader} header
     */
    _bindUISourceCode: function(uiSourceCode, header)
    {
        if (this._styleFiles.get(uiSourceCode) || (header.isInline && !header.hasSourceURL))
            return;
        this._styleFiles.set(uiSourceCode, new WebInspector.StyleFile(uiSourceCode, this));
        WebInspector.cssWorkspaceBinding.updateLocations(header);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _projectRemoved: function(event)
    {
        var project = /** @type {!WebInspector.Project} */ (event.data);
        var uiSourceCodes = project.uiSourceCodes();
        for (var i = 0; i < uiSourceCodes.length; ++i)
            this._unbindUISourceCode(uiSourceCodes[i]);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _uiSourceCodeRemoved: function(event)
    {
        var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (event.data);
        this._unbindUISourceCode(uiSourceCode);
    },

    _initialize: function()
    {
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {string} content
     * @param {boolean} majorChange
     * @return {!Promise<?string>}
     */
    _setStyleContent: function(uiSourceCode, content, majorChange)
    {
        var networkURL = this._networkMapping.networkURL(uiSourceCode);
        var styleSheetIds = this._cssModel.styleSheetIdsForURL(networkURL);
        if (!styleSheetIds.length)
            return Promise.resolve(/** @type {?string} */("No stylesheet found: " + networkURL));

        this._isSettingContent = true;

        /**
         * @param {?string} error
         * @this {WebInspector.StylesSourceMapping}
         * @return {?string}
         */
        function callback(error)
        {
            delete this._isSettingContent;
            return error || null;
        }

        var promises = [];
        for (var i = 0; i < styleSheetIds.length; ++i)
            promises.push(this._cssModel.setStyleSheetText(styleSheetIds[i], content, majorChange));

        return Promise.all(promises).spread(callback.bind(this));
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _styleSheetChanged: function(event)
    {
        if (this._isSettingContent)
            return;

        this._updateStyleSheetTextSoon(event.data.styleSheetId);
    },

    /**
     * @param {!CSSAgent.StyleSheetId} styleSheetId
     */
    _updateStyleSheetTextSoon: function(styleSheetId)
    {
        if (this._updateStyleSheetTextTimer)
            clearTimeout(this._updateStyleSheetTextTimer);

        this._updateStyleSheetTextTimer = setTimeout(this._updateStyleSheetText.bind(this, styleSheetId), WebInspector.StylesSourceMapping.ChangeUpdateTimeoutMs);
    },

    /**
     * @param {!CSSAgent.StyleSheetId} styleSheetId
     */
    _updateStyleSheetText: function(styleSheetId)
    {
        if (this._updateStyleSheetTextTimer) {
            clearTimeout(this._updateStyleSheetTextTimer);
            delete this._updateStyleSheetTextTimer;
        }

        var header = this._cssModel.styleSheetHeaderForId(styleSheetId);
        if (!header)
            return;
        var styleSheetURL = header.resourceURL();
        if (!styleSheetURL)
            return;
        var uiSourceCode = this._networkMapping.uiSourceCodeForStyleURL(styleSheetURL, header);
        if (!uiSourceCode)
            return;
        header.requestContent().then(callback.bind(this, uiSourceCode));

        /**
         * @param {!WebInspector.UISourceCode} uiSourceCode
         * @param {?string} content
         * @this {WebInspector.StylesSourceMapping}
         */
        function callback(uiSourceCode, content)
        {
            var styleFile = this._styleFiles.get(uiSourceCode);
            if (styleFile)
                styleFile.addRevision(content || "");
        }
    }
}

/**
 * @constructor
 * @param {!WebInspector.UISourceCode} uiSourceCode
 * @param {!WebInspector.StylesSourceMapping} mapping
 */
WebInspector.StyleFile = function(uiSourceCode, mapping)
{
    this._uiSourceCode = uiSourceCode;
    this._mapping = mapping;
    this._uiSourceCode.addEventListener(WebInspector.UISourceCode.Events.WorkingCopyChanged, this._workingCopyChanged, this);
    this._uiSourceCode.addEventListener(WebInspector.UISourceCode.Events.WorkingCopyCommitted, this._workingCopyCommitted, this);
    this._uiSourceCode.forceLoadOnCheckContent();
    this._commitThrottler = new WebInspector.Throttler(WebInspector.StyleFile.updateTimeout);
}

WebInspector.StyleFile.updateTimeout = 200;

WebInspector.StyleFile.prototype = {
    /**
     * @param {!WebInspector.Event} event
     */
    _workingCopyCommitted: function(event)
    {
        if (this._isAddingRevision)
            return;

        this._isMajorChangePending = true;
        this._commitThrottler.schedule(this._commitIncrementalEdit.bind(this), true);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _workingCopyChanged: function(event)
    {
        if (this._isAddingRevision)
            return;

        this._commitThrottler.schedule(this._commitIncrementalEdit.bind(this), false);
    },

    _commitIncrementalEdit: function()
    {
        var promise = this._mapping._setStyleContent(this._uiSourceCode, this._uiSourceCode.workingCopy(), this._isMajorChangePending)
            .then(this._styleContentSet.bind(this))
        this._isMajorChangePending = false;
        return promise;
    },

    /**
     * @param {?string} error
     */
    _styleContentSet: function(error)
    {
        if (error)
            WebInspector.console.error(error);
    },

    /**
     * @param {string} content
     */
    addRevision: function(content)
    {
        this._isAddingRevision = true;
        this._uiSourceCode.addRevision(content);
        delete this._isAddingRevision;
    },

    dispose: function()
    {
        this._uiSourceCode.removeEventListener(WebInspector.UISourceCode.Events.WorkingCopyCommitted, this._workingCopyCommitted, this);
        this._uiSourceCode.removeEventListener(WebInspector.UISourceCode.Events.WorkingCopyChanged, this._workingCopyChanged, this);
    }
}
;/* CSSWorkspaceBinding.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @implements {WebInspector.TargetManager.Observer}
 * @param {!WebInspector.TargetManager} targetManager
 * @param {!WebInspector.Workspace} workspace
 * @param {!WebInspector.NetworkMapping} networkMapping
 */
WebInspector.CSSWorkspaceBinding = function(targetManager, workspace, networkMapping)
{
    this._workspace = workspace;
    this._networkMapping = networkMapping;

    /** @type {!Map.<!WebInspector.CSSStyleModel, !WebInspector.CSSWorkspaceBinding.TargetInfo>} */
    this._modelToTargetInfo = new Map();
    targetManager.observeTargets(this);

    targetManager.addModelListener(WebInspector.ResourceTreeModel, WebInspector.ResourceTreeModel.EventTypes.MainFrameNavigated, this._mainFrameCreatedOrNavigated, this);
}

WebInspector.CSSWorkspaceBinding.prototype = {
    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target)
    {
        var cssModel = WebInspector.CSSStyleModel.fromTarget(target);
        if (cssModel)
            this._modelToTargetInfo.set(cssModel, new WebInspector.CSSWorkspaceBinding.TargetInfo(cssModel, this._workspace, this._networkMapping));
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target)
    {
        var cssModel = WebInspector.CSSStyleModel.fromTarget(target);
        if (cssModel)
            this._modelToTargetInfo.remove(cssModel)._dispose();
    },

    /**
     * @param {!WebInspector.CSSStyleSheetHeader} header
     * @param {!WebInspector.CSSSourceMapping} mapping
     */
    pushSourceMapping: function(header, mapping)
    {
        this._ensureInfoForHeader(header)._pushSourceMapping(mapping);
    },

    /**
     * @param {!WebInspector.CSSStyleSheetHeader} header
     * @return {?WebInspector.CSSWorkspaceBinding.HeaderInfo}
     */
    _headerInfo: function(header)
    {
        var map = this._modelToTargetInfo.get(header.cssModel());
        return map._headerInfo(header.id) || null;
    },

    /**
     * @param {!WebInspector.CSSStyleSheetHeader} header
     * @return {!WebInspector.CSSWorkspaceBinding.HeaderInfo}
     */
    _ensureInfoForHeader: function(header)
    {
        var targetInfo = this._modelToTargetInfo.get(header.cssModel());
        if (!targetInfo) {
            targetInfo = new WebInspector.CSSWorkspaceBinding.TargetInfo(header.cssModel(), this._workspace, this._networkMapping);
            this._modelToTargetInfo.set(header.cssModel(), targetInfo);
        }
        return targetInfo._ensureInfoForHeader(header);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _mainFrameCreatedOrNavigated: function(event)
    {
        var target = /** @type {!WebInspector.ResourceTreeModel} */ (event.target).target();
        var cssModel = WebInspector.CSSStyleModel.fromTarget(target);
        if (cssModel)
            this._modelToTargetInfo.get(cssModel)._reset();
    },

    /**
     * @param {!WebInspector.CSSStyleSheetHeader} header
     */
    updateLocations: function(header)
    {
        var info = this._headerInfo(header);
        if (info)
            info._updateLocations();
    },

    /**
     * @param {!WebInspector.CSSLocation} rawLocation
     * @param {function(!WebInspector.LiveLocation)} updateDelegate
     * @return {!WebInspector.CSSWorkspaceBinding.LiveLocation}
     */
    createLiveLocation: function(rawLocation, updateDelegate)
    {
        var header = rawLocation.styleSheetId ? rawLocation.cssModel().styleSheetHeaderForId(rawLocation.styleSheetId) : null;
        return new WebInspector.CSSWorkspaceBinding.LiveLocation(rawLocation.cssModel(), header, rawLocation, this, updateDelegate);
    },

    /**
     * @param {!WebInspector.CSSWorkspaceBinding.LiveLocation} location
     */
    _addLiveLocation: function(location)
    {
        this._ensureInfoForHeader(location._header)._addLocation(location);
    },

    /**
     * @param {!WebInspector.CSSWorkspaceBinding.LiveLocation} location
     */
    _removeLiveLocation: function(location)
    {
        var info = this._headerInfo(location._header);
        if (info)
            info._removeLocation(location);
    },

    /**
     * @param {!WebInspector.CSSProperty} cssProperty
     * @param {boolean} forName
     * @return {?WebInspector.UILocation}
     */
    propertyUILocation: function(cssProperty, forName)
    {
        var style = cssProperty.ownerStyle;
        if (!style || !style.parentRule || !style.styleSheetId)
            return null;

        var range = cssProperty.range;
        if (!range)
            return null;

        var header = style.cssModel().styleSheetHeaderForId(style.styleSheetId);
        if (!header)
            return null;

        var line = forName ? range.startLine : range.endLine;
        // End of range is exclusive, so subtract 1 from the end offset.
        var column = forName ? range.startColumn : range.endColumn - (cssProperty.text && cssProperty.text.endsWith(";") ? 2 : 1);
        var rawLocation = new WebInspector.CSSLocation(header, header.lineNumberInSource(line), header.columnNumberInSource(line, column));
        return this.rawLocationToUILocation(rawLocation);
    },

    /**
     * @param {?WebInspector.CSSLocation} rawLocation
     * @return {?WebInspector.UILocation}
     */
    rawLocationToUILocation: function(rawLocation)
    {
        if (!rawLocation)
            return null;
        var header = rawLocation.cssModel().styleSheetHeaderForId(rawLocation.styleSheetId);
        if (!header)
            return null;
        var info = this._headerInfo(header);
        return info ? info._rawLocationToUILocation(rawLocation.lineNumber, rawLocation.columnNumber) : null;
    }
}

/**
 * @constructor
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {!WebInspector.Workspace} workspace
 * @param {!WebInspector.NetworkMapping} networkMapping
 */
WebInspector.CSSWorkspaceBinding.TargetInfo = function(cssModel, workspace, networkMapping)
{
    this._cssModel = cssModel;
    this._stylesSourceMapping = new WebInspector.StylesSourceMapping(cssModel, workspace, networkMapping);
    this._sassSourceMapping = new WebInspector.SASSSourceMapping(cssModel, networkMapping, WebInspector.NetworkProject.forTarget(cssModel.target()));

    /** @type {!Map.<string, !WebInspector.CSSWorkspaceBinding.HeaderInfo>} */
    this._headerInfoById = new Map();

    cssModel.addEventListener(WebInspector.CSSStyleModel.Events.StyleSheetAdded, this._styleSheetAdded, this);
    cssModel.addEventListener(WebInspector.CSSStyleModel.Events.StyleSheetRemoved, this._styleSheetRemoved, this);
}

WebInspector.CSSWorkspaceBinding.TargetInfo.prototype = {
    /**
     * @param {!WebInspector.Event} event
     */
    _styleSheetAdded: function(event)
    {
        var header = /** @type {!WebInspector.CSSStyleSheetHeader} */ (event.data);
        this._stylesSourceMapping.addHeader(header);
        this._sassSourceMapping.addHeader(header);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _styleSheetRemoved: function(event)
    {
        var header = /** @type {!WebInspector.CSSStyleSheetHeader} */ (event.data);
        this._stylesSourceMapping.removeHeader(header);
        this._sassSourceMapping.removeHeader(header);
        this._headerInfoById.remove(header.id);
    },

    /**
     * @param {!CSSAgent.StyleSheetId} id
     */
    _headerInfo: function(id)
    {
        return this._headerInfoById.get(id);
    },

    _ensureInfoForHeader: function(header)
    {
        var info = this._headerInfoById.get(header.id);
        if (!info) {
            info = new WebInspector.CSSWorkspaceBinding.HeaderInfo(header);
            this._headerInfoById.set(header.id, info);
        }
        return info;
    },

    _dispose: function()
    {
        this._reset();
        this._cssModel.removeEventListener(WebInspector.CSSStyleModel.Events.StyleSheetAdded, this._styleSheetAdded, this);
        this._cssModel.removeEventListener(WebInspector.CSSStyleModel.Events.StyleSheetRemoved, this._styleSheetRemoved, this);
    },

    _reset: function()
    {
        this._headerInfoById.clear();
    }
}

/**
 * @constructor
 * @param {!WebInspector.CSSStyleSheetHeader} header
 */
WebInspector.CSSWorkspaceBinding.HeaderInfo = function(header)
{
    this._header = header;

    /** @type {!Array.<!WebInspector.CSSSourceMapping>} */
    this._sourceMappings = [];

    /** @type {!Set.<!WebInspector.LiveLocation>} */
    this._locations = new Set();
}

WebInspector.CSSWorkspaceBinding.HeaderInfo.prototype = {
    /**
     * @param {!WebInspector.LiveLocation} location
     */
    _addLocation: function(location)
    {
        this._locations.add(location);
        location.update();
    },

    /**
     * @param {!WebInspector.LiveLocation} location
     */
    _removeLocation: function(location)
    {
        this._locations.delete(location);
    },

    _updateLocations: function()
    {
        var items = this._locations.valuesArray();
        for (var i = 0; i < items.length; ++i)
            items[i].update();
    },

    /**
     * @param {number} lineNumber
     * @param {number=} columnNumber
     * @return {?WebInspector.UILocation}
     */
    _rawLocationToUILocation: function(lineNumber, columnNumber)
    {
        var uiLocation = null;
        var rawLocation = new WebInspector.CSSLocation(this._header, lineNumber, columnNumber);
        for (var i = this._sourceMappings.length - 1; !uiLocation && i >= 0; --i)
            uiLocation = this._sourceMappings[i].rawLocationToUILocation(rawLocation);
        return uiLocation;
    },

    /**
     * @param {!WebInspector.CSSSourceMapping} sourceMapping
     */
    _pushSourceMapping: function(sourceMapping)
    {
        if (this._sourceMappings.indexOf(sourceMapping) !== -1)
            return;
        this._sourceMappings.push(sourceMapping);
        this._updateLocations();
    }
}

/**
 * @constructor
 * @extends {WebInspector.LiveLocation}
 * @param {!WebInspector.CSSStyleModel} cssModel
 * @param {?WebInspector.CSSStyleSheetHeader} header
 * @param {!WebInspector.CSSLocation} rawLocation
 * @param {!WebInspector.CSSWorkspaceBinding} binding
 * @param {function(!WebInspector.LiveLocation)} updateDelegate
 */
WebInspector.CSSWorkspaceBinding.LiveLocation = function(cssModel, header, rawLocation, binding, updateDelegate)
{
    WebInspector.LiveLocation.call(this, updateDelegate);
    this._cssModel = cssModel;
    this._rawLocation = rawLocation;
    this._binding = binding;
    if (!header)
        this._clearStyleSheet();
    else
        this._setStyleSheet(header);
}

WebInspector.CSSWorkspaceBinding.LiveLocation.prototype = {
    /**
     * @param {!WebInspector.Event} event
     */
    _styleSheetAdded: function(event)
    {
        console.assert(!this._header);
        var header = /** @type {!WebInspector.CSSStyleSheetHeader} */ (event.data);
        if (header.sourceURL && header.sourceURL === this._rawLocation.url)
            this._setStyleSheet(header);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _styleSheetRemoved: function(event)
    {
        console.assert(this._header);
        var header = /** @type {!WebInspector.CSSStyleSheetHeader} */ (event.data);
        if (this._header !== header)
            return;
        this._binding._removeLiveLocation(this);
        this._clearStyleSheet();
    },

    /**
     * @param {!WebInspector.CSSStyleSheetHeader} header
     */
    _setStyleSheet: function(header)
    {
        this._header = header;
        this._binding._addLiveLocation(this);
        this._cssModel.removeEventListener(WebInspector.CSSStyleModel.Events.StyleSheetAdded, this._styleSheetAdded, this);
        this._cssModel.addEventListener(WebInspector.CSSStyleModel.Events.StyleSheetRemoved, this._styleSheetRemoved, this);
    },

    _clearStyleSheet: function()
    {
        delete this._header;
        this._cssModel.removeEventListener(WebInspector.CSSStyleModel.Events.StyleSheetRemoved, this._styleSheetRemoved, this);
        this._cssModel.addEventListener(WebInspector.CSSStyleModel.Events.StyleSheetAdded, this._styleSheetAdded, this);
    },

    /**
     * @override
     * @return {?WebInspector.UILocation}
     */
    uiLocation: function()
    {
        var cssLocation = this._rawLocation;
        if (this._header) {
            var headerInfo = this._binding._headerInfo(this._header);
            return headerInfo._rawLocationToUILocation(cssLocation.lineNumber, cssLocation.columnNumber);
        }
        var uiSourceCode = this._binding._networkMapping.uiSourceCodeForStyleURL(cssLocation.url, cssLocation.header());
        if (!uiSourceCode)
            return null;
        return uiSourceCode.uiLocation(cssLocation.lineNumber, cssLocation.columnNumber);
    },

    dispose: function()
    {
        WebInspector.LiveLocation.prototype.dispose.call(this);
        if (this._header)
            this._binding._removeLiveLocation(this);
        this._cssModel.removeEventListener(WebInspector.CSSStyleModel.Events.StyleSheetAdded, this._styleSheetAdded, this);
        this._cssModel.removeEventListener(WebInspector.CSSStyleModel.Events.StyleSheetRemoved, this._styleSheetRemoved, this);
    },

    /**
     * @override
     * @return {boolean}
     */
    isBlackboxed: function()
    {
        return false;
    },

    __proto__: WebInspector.LiveLocation.prototype
}

/**
 * @interface
 */
WebInspector.CSSSourceMapping = function()
{
}

WebInspector.CSSSourceMapping.prototype = {
    /**
     * @param {!WebInspector.CSSLocation} rawLocation
     * @return {?WebInspector.UILocation}
     */
    rawLocationToUILocation: function(rawLocation) { },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?WebInspector.CSSLocation}
     */
    uiLocationToRawLocation: function(uiSourceCode, lineNumber, columnNumber) { },

    /**
     * @return {boolean}
     */
    isIdentity: function() { },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @return {boolean}
     */
    uiLineHasMapping: function(uiSourceCode, lineNumber) { }
}

/**
 * @type {!WebInspector.CSSWorkspaceBinding}
 */
WebInspector.cssWorkspaceBinding;
;/* DebuggerWorkspaceBinding.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @implements {WebInspector.TargetManager.Observer}
 * @param {!WebInspector.TargetManager} targetManager
 * @param {!WebInspector.Workspace} workspace
 * @param {!WebInspector.NetworkMapping} networkMapping
 */
WebInspector.DebuggerWorkspaceBinding = function(targetManager, workspace, networkMapping)
{
    this._workspace = workspace;
    this._networkMapping = networkMapping;

    // FIXME: Migrate from _targetToData to _debuggerModelToData.
    /** @type {!Map.<!WebInspector.Target, !WebInspector.DebuggerWorkspaceBinding.TargetData>} */
    this._targetToData = new Map();
    targetManager.observeTargets(this);

    targetManager.addModelListener(WebInspector.DebuggerModel, WebInspector.DebuggerModel.Events.GlobalObjectCleared, this._globalObjectCleared, this);
    targetManager.addModelListener(WebInspector.DebuggerModel, WebInspector.DebuggerModel.Events.BeforeDebuggerPaused, this._beforeDebuggerPaused, this);
    targetManager.addModelListener(WebInspector.DebuggerModel, WebInspector.DebuggerModel.Events.DebuggerResumed, this._debuggerResumed, this);
    workspace.addEventListener(WebInspector.Workspace.Events.UISourceCodeRemoved, this._uiSourceCodeRemoved, this);
    workspace.addEventListener(WebInspector.Workspace.Events.ProjectRemoved, this._projectRemoved, this);
}

WebInspector.DebuggerWorkspaceBinding.prototype = {
    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target)
    {
        var debuggerModel = WebInspector.DebuggerModel.fromTarget(target);
        if (debuggerModel)
            this._targetToData.set(target, new WebInspector.DebuggerWorkspaceBinding.TargetData(debuggerModel, this));
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target)
    {
        if (!WebInspector.DebuggerModel.fromTarget(target))
            return;
        var targetData = this._targetToData.get(target);
        targetData._dispose();
        this._targetToData.remove(target);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _uiSourceCodeRemoved: function(event)
    {
        var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (event.data);
        var targetDatas = this._targetToData.valuesArray();
        for (var i = 0; i < targetDatas.length; ++i)
            targetDatas[i]._uiSourceCodeRemoved(uiSourceCode);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _projectRemoved: function(event)
    {
        var project = /** @type {!WebInspector.Project} */ (event.data);
        var targetDatas = this._targetToData.valuesArray();
        var uiSourceCodes = project.uiSourceCodes();
        for (var i = 0; i < targetDatas.length; ++i) {
            for (var j = 0; j < uiSourceCodes.length; ++j)
                targetDatas[i]._uiSourceCodeRemoved(uiSourceCodes[j]);
        }
    },

    /**
     * @param {!WebInspector.Script} script
     * @param {!WebInspector.DebuggerSourceMapping} sourceMapping
     */
    pushSourceMapping: function(script, sourceMapping)
    {
        var info = this._ensureInfoForScript(script);
        info._pushSourceMapping(sourceMapping);
    },

    /**
     * @param {!WebInspector.Script} script
     * @return {!WebInspector.DebuggerSourceMapping}
     */
    popSourceMapping: function(script)
    {
        var info = this._infoForScript(script.target(), script.scriptId);
        console.assert(info);
        return info._popSourceMapping();
    },

    /**
     * @param {!WebInspector.Target} target
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {?WebInspector.DebuggerSourceMapping} sourceMapping
     */
    setSourceMapping: function(target, uiSourceCode, sourceMapping)
    {
        var data = this._targetToData.get(target);
        if (data)
            data._setSourceMapping(uiSourceCode, sourceMapping);
    },

    /**
     * @param {!WebInspector.Script} script
     */
    updateLocations: function(script)
    {
        var info = this._infoForScript(script.target(), script.scriptId);
        if (info)
            info._updateLocations();
    },

    /**
     * @param {!WebInspector.DebuggerModel.Location} rawLocation
     * @param {function(!WebInspector.LiveLocation)} updateDelegate
     * @return {!WebInspector.DebuggerWorkspaceBinding.Location}
     */
    createLiveLocation: function(rawLocation, updateDelegate)
    {
        var info = this._infoForScript(rawLocation.target(), rawLocation.scriptId);
        console.assert(info);
        var location = new WebInspector.DebuggerWorkspaceBinding.Location(info._script, rawLocation, this, updateDelegate);
        info._addLocation(location);
        return location;
    },

    /**
     * @param {!Array<!WebInspector.DebuggerModel.Location>} rawLocations
     * @param {function(!WebInspector.LiveLocation)} updateDelegate
     * @return {!WebInspector.LiveLocation}
     */
    createStackTraceTopFrameLiveLocation: function(rawLocations, updateDelegate)
    {
        console.assert(rawLocations.length);
        var location = new WebInspector.DebuggerWorkspaceBinding.StackTraceTopFrameLocation(rawLocations, this, updateDelegate);
        location.update();
        return location;
    },

    /**
     * @param {!WebInspector.DebuggerModel.CallFrame} callFrame
     * @param {function(!WebInspector.LiveLocation)} updateDelegate
     * @return {!WebInspector.DebuggerWorkspaceBinding.Location}
     */
    createCallFrameLiveLocation: function(callFrame, updateDelegate)
    {
        var target = callFrame.target();
        this._ensureInfoForScript(callFrame.script);
        var location = this.createLiveLocation(callFrame.location(), updateDelegate);
        this._registerCallFrameLiveLocation(target, location);
        return location;
    },

    /**
     * @param {!WebInspector.DebuggerModel.Location} rawLocation
     * @return {!WebInspector.UILocation}
     */
    rawLocationToUILocation: function(rawLocation)
    {
        var info = this._infoForScript(rawLocation.target(), rawLocation.scriptId);
        console.assert(info);
        return info._rawLocationToUILocation(rawLocation);
    },

    /**
     * @param {!WebInspector.Target} target
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?WebInspector.DebuggerModel.Location}
     */
    uiLocationToRawLocation: function(target, uiSourceCode, lineNumber, columnNumber)
    {
        var targetData = this._targetToData.get(target);
        return targetData ? /** @type {?WebInspector.DebuggerModel.Location} */ (targetData._uiLocationToRawLocation(uiSourceCode, lineNumber, columnNumber)) : null;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {!Array.<!WebInspector.DebuggerModel.Location>}
     */
    uiLocationToRawLocations: function(uiSourceCode, lineNumber, columnNumber)
    {
        var result = [];
        var targetDatas = this._targetToData.valuesArray();
        for (var i = 0; i < targetDatas.length; ++i) {
            var rawLocation = targetDatas[i]._uiLocationToRawLocation(uiSourceCode, lineNumber, columnNumber);
            if (rawLocation)
                result.push(rawLocation);
        }
        return result;
    },

    /**
     * @param {!WebInspector.UILocation} uiLocation
     * @return {!WebInspector.UILocation}
     */
    normalizeUILocation: function(uiLocation)
    {
        var target = WebInspector.NetworkProject.targetForUISourceCode(uiLocation.uiSourceCode);
        if (target) {
            var rawLocation = this.uiLocationToRawLocation(target, uiLocation.uiSourceCode, uiLocation.lineNumber, uiLocation.columnNumber);
            if (rawLocation)
                return this.rawLocationToUILocation(rawLocation);
        }
        return uiLocation;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @return {boolean}
     */
    uiLineHasMapping: function(uiSourceCode, lineNumber)
    {
        var targetDatas = this._targetToData.valuesArray();
        for (var i = 0; i < targetDatas.length; ++i) {
            if (!targetDatas[i]._uiLineHasMapping(uiSourceCode, lineNumber))
                return false;
        }
        return true;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {!WebInspector.Target} target
     * @return {?WebInspector.ResourceScriptFile}
     */
    scriptFile: function(uiSourceCode, target)
    {
        var targetData = this._targetToData.get(target);
        return targetData ? targetData._resourceMapping.scriptFile(uiSourceCode) : null;
    },

    /**
     * @param {!WebInspector.Script} script
     * @return {?WebInspector.SourceMap}
     */
    sourceMapForScript: function(script)
    {
        var targetData = this._targetToData.get(script.target());
        if (!targetData)
            return null;
        return targetData._compilerMapping.sourceMapForScript(script);
    },

    /**
     * @param {!WebInspector.Script} script
     */
    maybeLoadSourceMap: function(script)
    {
        var targetData = this._targetToData.get(script.target());
        if (!targetData)
            return;
        targetData._compilerMapping.maybeLoadSourceMap(script);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _globalObjectCleared: function(event)
    {
        var debuggerModel = /** @type {!WebInspector.DebuggerModel} */ (event.target);
        this._reset(debuggerModel.target());
    },

    /**
     * @param {!WebInspector.Target} target
     */
    _reset: function(target)
    {
        var targetData = this._targetToData.get(target);
        targetData.callFrameLocations.valuesArray().forEach(function(location) { location.dispose(); });
        targetData.callFrameLocations.clear();
    },

    /**
     * @param {!WebInspector.Script} script
     * @return {!WebInspector.DebuggerWorkspaceBinding.ScriptInfo}
     */
    _ensureInfoForScript: function(script)
    {
        var scriptDataMap = this._targetToData.get(script.target()).scriptDataMap;
        var info = scriptDataMap.get(script.scriptId);
        if (!info) {
            info = new WebInspector.DebuggerWorkspaceBinding.ScriptInfo(script);
            scriptDataMap.set(script.scriptId, info);
        }
        return info;
    },


    /**
     * @param {!WebInspector.Target} target
     * @param {string} scriptId
     * @return {?WebInspector.DebuggerWorkspaceBinding.ScriptInfo}
     */
    _infoForScript: function(target, scriptId)
    {
        var data = this._targetToData.get(target);
        if (!data)
            return null;
        return data.scriptDataMap.get(scriptId) || null;
    },

    /**
     * @param {!WebInspector.Target} target
     * @param {!WebInspector.DebuggerWorkspaceBinding.Location} location
     */
    _registerCallFrameLiveLocation: function(target, location)
    {
        var locations = this._targetToData.get(target).callFrameLocations;
        locations.add(location);
    },

    /**
     * @param {!WebInspector.DebuggerWorkspaceBinding.Location} location
     */
    _removeLiveLocation: function(location)
    {
        var info = this._infoForScript(location._script.target(), location._script.scriptId);
        if (info)
            info._removeLocation(location);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _debuggerResumed: function(event)
    {
        var debuggerModel = /** @type {!WebInspector.DebuggerModel} */ (event.target);
        this._reset(debuggerModel.target());
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _beforeDebuggerPaused: function(event)
    {
        var rawLocation = event.data.callFrames[0].location();
        var targetData = this._targetToData.get(rawLocation.target());
        if (!targetData._compilerMapping.mapsToSourceCode(rawLocation)) {
            event.stopPropagation();
            event.preventDefault();
        }
    }
}

/**
 * @constructor
 * @param {!WebInspector.DebuggerModel} debuggerModel
 * @param {!WebInspector.DebuggerWorkspaceBinding} debuggerWorkspaceBinding
 */
WebInspector.DebuggerWorkspaceBinding.TargetData = function(debuggerModel, debuggerWorkspaceBinding)
{
    this._target = debuggerModel.target();

    /** @type {!Map.<string, !WebInspector.DebuggerWorkspaceBinding.ScriptInfo>} */
    this.scriptDataMap = new Map();

    /** @type {!Set.<!WebInspector.DebuggerWorkspaceBinding.Location>} */
    this.callFrameLocations = new Set();

    var workspace = debuggerWorkspaceBinding._workspace;
    var networkMapping = debuggerWorkspaceBinding._networkMapping;

    this._defaultMapping = new WebInspector.DefaultScriptMapping(debuggerModel, workspace, debuggerWorkspaceBinding);
    this._resourceMapping = new WebInspector.ResourceScriptMapping(debuggerModel, workspace, networkMapping, debuggerWorkspaceBinding);
    this._compilerMapping = new WebInspector.CompilerScriptMapping(debuggerModel, workspace, networkMapping, WebInspector.NetworkProject.forTarget(this._target), debuggerWorkspaceBinding);

    /** @type {!Map.<!WebInspector.UISourceCode, !WebInspector.DebuggerSourceMapping>} */
    this._uiSourceCodeToSourceMapping = new Map();

    debuggerModel.addEventListener(WebInspector.DebuggerModel.Events.ParsedScriptSource, this._parsedScriptSource, this);
    debuggerModel.addEventListener(WebInspector.DebuggerModel.Events.FailedToParseScriptSource, this._parsedScriptSource, this);
}

WebInspector.DebuggerWorkspaceBinding.TargetData.prototype = {
    /**
     * @param {!WebInspector.Event} event
     */
    _parsedScriptSource: function(event)
    {
        var script = /** @type {!WebInspector.Script} */ (event.data);
        this._defaultMapping.addScript(script);
        this._resourceMapping.addScript(script);

        if (WebInspector.moduleSetting("jsSourceMapsEnabled").get())
            this._compilerMapping.addScript(script);
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {?WebInspector.DebuggerSourceMapping} sourceMapping
     */
    _setSourceMapping: function(uiSourceCode, sourceMapping)
    {
        if (this._uiSourceCodeToSourceMapping.get(uiSourceCode) === sourceMapping)
            return;

        if (sourceMapping)
            this._uiSourceCodeToSourceMapping.set(uiSourceCode, sourceMapping);
        else
            this._uiSourceCodeToSourceMapping.remove(uiSourceCode);

        uiSourceCode.dispatchEventToListeners(WebInspector.UISourceCode.Events.SourceMappingChanged, {target: this._target, isIdentity: sourceMapping ? sourceMapping.isIdentity() : false});
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?WebInspector.DebuggerModel.Location}
     */
    _uiLocationToRawLocation: function(uiSourceCode, lineNumber, columnNumber)
    {
        var sourceMapping = this._uiSourceCodeToSourceMapping.get(uiSourceCode);
        return sourceMapping ? sourceMapping.uiLocationToRawLocation(uiSourceCode, lineNumber, columnNumber) : null;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @return {boolean}
     */
    _uiLineHasMapping: function(uiSourceCode, lineNumber)
    {
        var sourceMapping = this._uiSourceCodeToSourceMapping.get(uiSourceCode);
        return sourceMapping ? sourceMapping.uiLineHasMapping(uiSourceCode, lineNumber) : true;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     */
    _uiSourceCodeRemoved: function(uiSourceCode)
    {
        this._uiSourceCodeToSourceMapping.remove(uiSourceCode);
    },

    _dispose: function()
    {
        this._compilerMapping.dispose();
        this._resourceMapping.dispose();
        this._defaultMapping.dispose();
        this._uiSourceCodeToSourceMapping.clear();
    }
}

/**
 * @constructor
 * @param {!WebInspector.Script} script
 */
WebInspector.DebuggerWorkspaceBinding.ScriptInfo = function(script)
{
    this._script = script;

    /** @type {!Array.<!WebInspector.DebuggerSourceMapping>} */
    this._sourceMappings = [];

    /** @type {!Set.<!WebInspector.LiveLocation>} */
    this._locations = new Set();
}

WebInspector.DebuggerWorkspaceBinding.ScriptInfo.prototype = {
    /**
     * @param {!WebInspector.DebuggerSourceMapping} sourceMapping
     */
    _pushSourceMapping: function(sourceMapping)
    {
        this._sourceMappings.push(sourceMapping);
        this._updateLocations();
    },

    /**
     * @return {!WebInspector.DebuggerSourceMapping}
     */
    _popSourceMapping: function()
    {
        var sourceMapping = this._sourceMappings.pop();
        this._updateLocations();
        return sourceMapping;
    },

    /**
     * @param {!WebInspector.LiveLocation} location
     */
    _addLocation: function(location)
    {
        this._locations.add(location);
        location.update();
    },

    /**
     * @param {!WebInspector.LiveLocation} location
     */
    _removeLocation: function(location)
    {
        this._locations.delete(location);
    },

    _updateLocations: function()
    {
        for (var location of this._locations)
            location.update();
    },

    /**
     * @param {!WebInspector.DebuggerModel.Location} rawLocation
     * @return {!WebInspector.UILocation}
     */
    _rawLocationToUILocation: function(rawLocation)
    {
        var uiLocation;
        for (var i = this._sourceMappings.length - 1; !uiLocation && i >= 0; --i)
            uiLocation = this._sourceMappings[i].rawLocationToUILocation(rawLocation);
        console.assert(uiLocation, "Script raw location cannot be mapped to any UI location.");
        return /** @type {!WebInspector.UILocation} */ (uiLocation);
    }
}


/**
 * @constructor
 * @extends {WebInspector.LiveLocation}
 * @param {!WebInspector.Script} script
 * @param {!WebInspector.DebuggerModel.Location} rawLocation
 * @param {!WebInspector.DebuggerWorkspaceBinding} binding
 * @param {function(!WebInspector.LiveLocation)} updateDelegate
 */
WebInspector.DebuggerWorkspaceBinding.Location = function(script, rawLocation, binding, updateDelegate)
{
    WebInspector.LiveLocation.call(this, updateDelegate);
    this._script = script;
    this._rawLocation = rawLocation;
    this._binding = binding;
}

WebInspector.DebuggerWorkspaceBinding.Location.prototype = {
    /**
     * @override
     * @return {!WebInspector.UILocation}
     */
    uiLocation: function()
    {
        var debuggerModelLocation = this._rawLocation;
        return this._binding.rawLocationToUILocation(debuggerModelLocation);
    },

    /**
     * @override
     */
    dispose: function()
    {
        WebInspector.LiveLocation.prototype.dispose.call(this);
        this._binding._removeLiveLocation(this);
    },

    /**
     * @override
     * @return {boolean}
     */
    isBlackboxed: function()
    {
        return WebInspector.blackboxManager.isBlackboxedRawLocation(this._rawLocation);
    },

    __proto__: WebInspector.LiveLocation.prototype
}

/**
 * @constructor
 * @extends {WebInspector.LiveLocation}
 * @param {!Array<!WebInspector.DebuggerModel.Location>} rawLocations
 * @param {!WebInspector.DebuggerWorkspaceBinding} binding
 * @param {function(!WebInspector.LiveLocation)} updateDelegate
 */
WebInspector.DebuggerWorkspaceBinding.StackTraceTopFrameLocation = function(rawLocations, binding, updateDelegate)
{
    WebInspector.LiveLocation.call(this, updateDelegate);

    this._updateScheduled = true;
    /** @type {!Array<!WebInspector.DebuggerWorkspaceBinding.Location>} */
    this._locations = [];
    for (var location of rawLocations)
        this._locations.push(binding.createLiveLocation(location, this._scheduleUpdate.bind(this)));
    this._updateLocation();
}

WebInspector.DebuggerWorkspaceBinding.StackTraceTopFrameLocation.prototype = {
    /**
     * @override
     * @return {!WebInspector.UILocation}
     */
    uiLocation: function()
    {
        return this._currentLocation().uiLocation();
    },

    /**
     * @override
     */
    dispose: function()
    {
        for (var location of this._locations)
            location.dispose();
    },

    /**
     * @override
     * @return {boolean}
     */
    isBlackboxed: function()
    {
        return this._currentLocation().isBlackboxed();
    },

    _scheduleUpdate: function()
    {
        if (!this._updateScheduled) {
            this._updateScheduled = true;
            setImmediate(this._updateLocation.bind(this));
        }
    },

    /**
     * @return {!WebInspector.DebuggerWorkspaceBinding.Location}
     */
    _currentLocation: function()
    {
        return this._locations[this._current < this._locations.length ? this._current : 0];
    },

    _updateLocation: function()
    {
        this._updateScheduled = false;
        this._current = 0;
        while (this._current < this._locations.length && this._locations[this._current].isBlackboxed())
            ++this._current;
        this.update();
    },

    __proto__: WebInspector.LiveLocation.prototype
}

/**
 * @interface
 */
WebInspector.DebuggerSourceMapping = function()
{
}

WebInspector.DebuggerSourceMapping.prototype = {
    /**
     * @param {!WebInspector.DebuggerModel.Location} rawLocation
     * @return {?WebInspector.UILocation}
     */
    rawLocationToUILocation: function(rawLocation) { },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?WebInspector.DebuggerModel.Location}
     */
    uiLocationToRawLocation: function(uiSourceCode, lineNumber, columnNumber) { },

    /**
     * @return {boolean}
     */
    isIdentity: function() { },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @return {boolean}
     */
    uiLineHasMapping: function(uiSourceCode, lineNumber) { }
}

/**
 * @type {!WebInspector.DebuggerWorkspaceBinding}
 */
WebInspector.debuggerWorkspaceBinding;
;/* BreakpointManager.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @implements {WebInspector.TargetManager.Observer}
 * @param {?WebInspector.Setting} breakpointsSetting
 * @param {!WebInspector.Workspace} workspace
 * @param {!WebInspector.NetworkMapping} networkMapping
 * @param {!WebInspector.TargetManager} targetManager
 * @param {!WebInspector.DebuggerWorkspaceBinding} debuggerWorkspaceBinding
 */
WebInspector.BreakpointManager = function(breakpointsSetting, workspace, networkMapping, targetManager, debuggerWorkspaceBinding)
{
    this._storage = new WebInspector.BreakpointManager.Storage(this, breakpointsSetting);
    this._workspace = workspace;
    this._networkMapping = networkMapping;
    this._targetManager = targetManager;
    this._debuggerWorkspaceBinding = debuggerWorkspaceBinding;

    this._breakpointsActive = true;
    this._breakpointsForUISourceCode = new Map();
    this._breakpointsForPrimaryUISourceCode = new Map();
    /** @type {!Multimap.<string, !WebInspector.BreakpointManager.Breakpoint>} */
    this._provisionalBreakpoints = new Multimap();

    this._workspace.addEventListener(WebInspector.Workspace.Events.ProjectRemoved, this._projectRemoved, this);
    this._workspace.addEventListener(WebInspector.Workspace.Events.UISourceCodeAdded, this._uiSourceCodeAdded, this);
    this._workspace.addEventListener(WebInspector.Workspace.Events.UISourceCodeRemoved, this._uiSourceCodeRemoved, this);
}

WebInspector.BreakpointManager.Events = {
    BreakpointAdded: "breakpoint-added",
    BreakpointRemoved: "breakpoint-removed",
    BreakpointsActiveStateChanged: "BreakpointsActiveStateChanged"
}

/**
 * @param {string} sourceFileId
 * @param {number} lineNumber
 * @param {number} columnNumber
 * @return {string}
 */
WebInspector.BreakpointManager._breakpointStorageId = function(sourceFileId, lineNumber, columnNumber)
{
    if (!sourceFileId)
        return "";
    return sourceFileId + ":" + lineNumber + ":" + columnNumber;
}

WebInspector.BreakpointManager.prototype = {
    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @return {string}
     */
    _sourceFileId: function(uiSourceCode)
    {
        var networkURL = this._networkMapping.networkURL(uiSourceCode)
        if (!networkURL)
            return "";
        return uiSourceCode.url();
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target)
    {
        var debuggerModel = WebInspector.DebuggerModel.fromTarget(target);
        if (debuggerModel && !this._breakpointsActive)
            debuggerModel.setBreakpointsActive(this._breakpointsActive);
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target) { },

    /**
     * @param {string} sourceFileId
     * @return {!Map.<string, !WebInspector.BreakpointManager.Breakpoint>}
     */
    _provisionalBreakpointsForSourceFileId: function(sourceFileId)
    {
        var result = new Map();
        var breakpoints = this._provisionalBreakpoints.get(sourceFileId).valuesArray();
        for (var i = 0; i < breakpoints.length; ++i)
            result.set(breakpoints[i]._breakpointStorageId(), breakpoints[i]);
        return result;
    },

    removeProvisionalBreakpointsForTest: function()
    {
        var breakpoints = this._provisionalBreakpoints.valuesArray();
        for (var i = 0; i < breakpoints.length; ++i)
            breakpoints[i].remove();
        this._provisionalBreakpoints.clear();
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     */
    _restoreBreakpoints: function(uiSourceCode)
    {
        var sourceFileId = this._sourceFileId(uiSourceCode);
        if (!sourceFileId)
            return;

        this._storage.mute();
        var breakpointItems = this._storage.breakpointItems(this._sourceFileId(uiSourceCode));
        var provisionalBreakpoints = this._provisionalBreakpointsForSourceFileId(sourceFileId);
        for (var i = 0; i < breakpointItems.length; ++i) {
            var breakpointItem = breakpointItems[i];
            var itemStorageId = WebInspector.BreakpointManager._breakpointStorageId(breakpointItem.sourceFileId, breakpointItem.lineNumber, breakpointItem.columnNumber);
            var provisionalBreakpoint = provisionalBreakpoints.get(itemStorageId);
            if (provisionalBreakpoint) {
                if (!this._breakpointsForPrimaryUISourceCode.get(uiSourceCode))
                    this._breakpointsForPrimaryUISourceCode.set(uiSourceCode, []);
                this._breakpointsForPrimaryUISourceCode.get(uiSourceCode).push(provisionalBreakpoint);
                provisionalBreakpoint._updateBreakpoint();
            } else {
                this._innerSetBreakpoint(uiSourceCode, breakpointItem.lineNumber, breakpointItem.columnNumber, breakpointItem.condition, breakpointItem.enabled);
            }
        }
        this._provisionalBreakpoints.removeAll(sourceFileId);
        this._storage.unmute();
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _uiSourceCodeAdded: function(event)
    {
        var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (event.data);
        this._restoreBreakpoints(uiSourceCode);
        if (uiSourceCode.contentType().hasScripts())
            uiSourceCode.addEventListener(WebInspector.UISourceCode.Events.SourceMappingChanged, this._uiSourceCodeMappingChanged, this);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _uiSourceCodeRemoved: function(event)
    {
        var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (event.data);
        this._removeUISourceCode(uiSourceCode);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _uiSourceCodeMappingChanged: function(event)
    {
        var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (event.target);
        var isIdentity = /** @type {boolean} */ (event.data.isIdentity);
        var target = /** @type {!WebInspector.Target} */ (event.data.target);
        if (isIdentity)
            return;
        var breakpoints = this._breakpointsForPrimaryUISourceCode.get(uiSourceCode) || [];
        for (var i = 0; i < breakpoints.length; ++i)
            breakpoints[i]._updateInDebuggerForTarget(target);
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     */
    _removeUISourceCode: function(uiSourceCode)
    {
        var breakpoints = this._breakpointsForPrimaryUISourceCode.get(uiSourceCode) || [];
        var sourceFileId = this._sourceFileId(uiSourceCode);
        for (var i = 0; i < breakpoints.length; ++i) {
            breakpoints[i]._resetLocations();
            if (breakpoints[i].enabled())
                this._provisionalBreakpoints.set(sourceFileId, breakpoints[i]);
        }
        uiSourceCode.removeEventListener(WebInspector.UISourceCode.Events.SourceMappingChanged, this._uiSourceCodeMappingChanged, this);
        this._breakpointsForPrimaryUISourceCode.remove(uiSourceCode);
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @param {string} condition
     * @param {boolean} enabled
     * @return {!WebInspector.BreakpointManager.Breakpoint}
     */
    setBreakpoint: function(uiSourceCode, lineNumber, columnNumber, condition, enabled)
    {
        var uiLocation = new WebInspector.UILocation(uiSourceCode, lineNumber, columnNumber);
        var normalizedLocation = this._debuggerWorkspaceBinding.normalizeUILocation(uiLocation);
        if (normalizedLocation.id() !== uiLocation.id()) {
            WebInspector.Revealer.reveal(normalizedLocation);
            uiLocation = normalizedLocation;
        }
        this.setBreakpointsActive(true);
        return this._innerSetBreakpoint(uiLocation.uiSourceCode, uiLocation.lineNumber, uiLocation.columnNumber, condition, enabled);
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @param {string} condition
     * @param {boolean} enabled
     * @return {!WebInspector.BreakpointManager.Breakpoint}
     */
    _innerSetBreakpoint: function(uiSourceCode, lineNumber, columnNumber, condition, enabled)
    {
        var breakpoint = this.findBreakpoint(uiSourceCode, lineNumber, columnNumber);
        if (breakpoint) {
            breakpoint._updateState(condition, enabled);
            return breakpoint;
        }
        var projectId = uiSourceCode.project().id();
        var path = uiSourceCode.url();
        var sourceFileId = this._sourceFileId(uiSourceCode);
        breakpoint = new WebInspector.BreakpointManager.Breakpoint(this, projectId, path, sourceFileId, lineNumber, columnNumber, condition, enabled);
        if (!this._breakpointsForPrimaryUISourceCode.get(uiSourceCode))
            this._breakpointsForPrimaryUISourceCode.set(uiSourceCode, []);
        this._breakpointsForPrimaryUISourceCode.get(uiSourceCode).push(breakpoint);
        return breakpoint;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?WebInspector.BreakpointManager.Breakpoint}
     */
    findBreakpoint: function(uiSourceCode, lineNumber, columnNumber)
    {
        var breakpoints = this._breakpointsForUISourceCode.get(uiSourceCode);
        var lineBreakpoints = breakpoints ? breakpoints.get(String(lineNumber)) : null;
        var columnBreakpoints = lineBreakpoints ? lineBreakpoints.get(String(columnNumber)) : null;
        return columnBreakpoints ? columnBreakpoints[0] : null;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @return {?WebInspector.BreakpointManager.Breakpoint}
     */
    findBreakpointOnLine: function(uiSourceCode, lineNumber)
    {
        var breakpoints = this._breakpointsForUISourceCode.get(uiSourceCode);
        var lineBreakpoints = breakpoints ? breakpoints.get(String(lineNumber)) : null;
        return lineBreakpoints ? lineBreakpoints.valuesArray()[0][0] : null;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @return {!Array.<!WebInspector.BreakpointManager.Breakpoint>}
     */
    breakpointsForUISourceCode: function(uiSourceCode)
    {
        var result = [];
        var uiSourceCodeBreakpoints = this._breakpointsForUISourceCode.get(uiSourceCode);
        var breakpoints = uiSourceCodeBreakpoints ? uiSourceCodeBreakpoints.valuesArray() : [];
        for (var i = 0; i < breakpoints.length; ++i) {
            var lineBreakpoints = breakpoints[i];
            var columnBreakpointArrays = lineBreakpoints ? lineBreakpoints.valuesArray() : [];
            result = result.concat.apply(result, columnBreakpointArrays);
        }
        return result;
    },

    /**
     * @return {!Array.<!WebInspector.BreakpointManager.Breakpoint>}
     */
    allBreakpoints: function()
    {
        var result = [];
        var uiSourceCodes = this._breakpointsForUISourceCode.keysArray();
        for (var i = 0; i < uiSourceCodes.length; ++i)
            result = result.concat(this.breakpointsForUISourceCode(uiSourceCodes[i]));
        return result;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @return {!Array.<!{breakpoint: !WebInspector.BreakpointManager.Breakpoint, uiLocation: !WebInspector.UILocation}>}
     */
    breakpointLocationsForUISourceCode: function(uiSourceCode)
    {
        var uiSourceCodeBreakpoints = this._breakpointsForUISourceCode.get(uiSourceCode);
        var lineNumbers = uiSourceCodeBreakpoints ? uiSourceCodeBreakpoints.keysArray() : [];
        var result = [];
        for (var i = 0; i < lineNumbers.length; ++i) {
            var lineBreakpoints = uiSourceCodeBreakpoints.get(lineNumbers[i]);
            var columnNumbers = lineBreakpoints.keysArray();
            for (var j = 0; j < columnNumbers.length; ++j) {
                var columnBreakpoints = lineBreakpoints.get(columnNumbers[j]);
                var lineNumber = parseInt(lineNumbers[i], 10);
                var columnNumber = parseInt(columnNumbers[j], 10);
                for (var k = 0; k < columnBreakpoints.length; ++k) {
                    var breakpoint = columnBreakpoints[k];
                    var uiLocation = uiSourceCode.uiLocation(lineNumber, columnNumber);
                    result.push({breakpoint: breakpoint, uiLocation: uiLocation});
                }
            }
        }
        return result;
    },

    /**
     * @return {!Array.<!{breakpoint: !WebInspector.BreakpointManager.Breakpoint, uiLocation: !WebInspector.UILocation}>}
     */
    allBreakpointLocations: function()
    {
        var result = [];
        var uiSourceCodes = this._breakpointsForUISourceCode.keysArray();
        for (var i = 0; i < uiSourceCodes.length; ++i)
            result = result.concat(this.breakpointLocationsForUISourceCode(uiSourceCodes[i]));
        return result;
    },

    /**
     * @param {boolean} toggleState
     */
    toggleAllBreakpoints: function(toggleState)
    {
        var breakpoints = this.allBreakpoints();
        for (var i = 0; i < breakpoints.length; ++i)
            breakpoints[i].setEnabled(toggleState);
    },

    removeAllBreakpoints: function()
    {
        var breakpoints = this.allBreakpoints();
        for (var i = 0; i < breakpoints.length; ++i)
            breakpoints[i].remove();
    },

    _projectRemoved: function(event)
    {
        var project = /** @type {!WebInspector.Project} */ (event.data);
        var uiSourceCodes = project.uiSourceCodes();
        for (var i = 0; i < uiSourceCodes.length; ++i)
            this._removeUISourceCode(uiSourceCodes[i]);
    },

    /**
     * @param {!WebInspector.BreakpointManager.Breakpoint} breakpoint
     * @param {boolean} removeFromStorage
     */
    _removeBreakpoint: function(breakpoint, removeFromStorage)
    {
        var uiSourceCode = breakpoint.uiSourceCode();
        var breakpoints = uiSourceCode ? this._breakpointsForPrimaryUISourceCode.get(uiSourceCode) || [] : [];
        breakpoints.remove(breakpoint);
        if (removeFromStorage)
            this._storage._removeBreakpoint(breakpoint);
        this._provisionalBreakpoints.remove(breakpoint._sourceFileId, breakpoint);
    },

    /**
     * @param {!WebInspector.BreakpointManager.Breakpoint} breakpoint
     * @param {!WebInspector.UILocation} uiLocation
     */
    _uiLocationAdded: function(breakpoint, uiLocation)
    {
        var breakpoints = this._breakpointsForUISourceCode.get(uiLocation.uiSourceCode);
        if (!breakpoints) {
            breakpoints = new Map();
            this._breakpointsForUISourceCode.set(uiLocation.uiSourceCode, breakpoints);
        }
        var lineBreakpoints = breakpoints.get(String(uiLocation.lineNumber));
        if (!lineBreakpoints) {
            lineBreakpoints = new Map();
            breakpoints.set(String(uiLocation.lineNumber), lineBreakpoints);
        }
        var columnBreakpoints = lineBreakpoints.get(String(uiLocation.columnNumber));
        if (!columnBreakpoints) {
            columnBreakpoints = [];
            lineBreakpoints.set(String(uiLocation.columnNumber), columnBreakpoints);
        }
        columnBreakpoints.push(breakpoint);
        this.dispatchEventToListeners(WebInspector.BreakpointManager.Events.BreakpointAdded, {breakpoint: breakpoint, uiLocation: uiLocation});
    },

    /**
     * @param {!WebInspector.BreakpointManager.Breakpoint} breakpoint
     * @param {!WebInspector.UILocation} uiLocation
     */
    _uiLocationRemoved: function(breakpoint, uiLocation)
    {
        var breakpoints = this._breakpointsForUISourceCode.get(uiLocation.uiSourceCode);
        if (!breakpoints)
            return;

        var lineBreakpoints = breakpoints.get(String(uiLocation.lineNumber));
        if (!lineBreakpoints)
            return;
        var columnBreakpoints = lineBreakpoints.get(String(uiLocation.columnNumber));
        if (!columnBreakpoints)
            return;
        columnBreakpoints.remove(breakpoint);
        if (!columnBreakpoints.length)
            lineBreakpoints.remove(String(uiLocation.columnNumber));
        if (!lineBreakpoints.size)
            breakpoints.remove(String(uiLocation.lineNumber));
        if (!breakpoints.size)
            this._breakpointsForUISourceCode.remove(uiLocation.uiSourceCode);
        this.dispatchEventToListeners(WebInspector.BreakpointManager.Events.BreakpointRemoved, {breakpoint: breakpoint, uiLocation: uiLocation});
    },

    /**
     * @param {boolean} active
     */
    setBreakpointsActive: function(active)
    {
        if (this._breakpointsActive === active)
            return;

        this._breakpointsActive = active;
        var debuggerModels = WebInspector.DebuggerModel.instances();
        for (var i = 0; i < debuggerModels.length; ++i)
            debuggerModels[i].setBreakpointsActive(active);

        this.dispatchEventToListeners(WebInspector.BreakpointManager.Events.BreakpointsActiveStateChanged, active);
    },

    /**
     * @return {boolean}
     */
    breakpointsActive: function()
    {
        return this._breakpointsActive;
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @constructor
 * @implements {WebInspector.TargetManager.Observer}
 * @param {!WebInspector.BreakpointManager} breakpointManager
 * @param {string} projectId
 * @param {string} path
 * @param {string} sourceFileId
 * @param {number} lineNumber
 * @param {number} columnNumber
 * @param {string} condition
 * @param {boolean} enabled
 */
WebInspector.BreakpointManager.Breakpoint = function(breakpointManager, projectId, path, sourceFileId, lineNumber, columnNumber, condition, enabled)
{
    this._breakpointManager = breakpointManager;
    this._projectId = projectId;
    this._path = path;
    this._lineNumber = lineNumber;
    this._columnNumber = columnNumber;
    this._sourceFileId = sourceFileId;

    /** @type {!Object.<string, number>} */
    this._numberOfDebuggerLocationForUILocation = {};

    // Force breakpoint update.
    /** @type {string} */ this._condition;
    /** @type {boolean} */ this._enabled;
    /** @type {boolean} */ this._isRemoved;
    /** @type {!WebInspector.UILocation|undefined} */ this._fakePrimaryLocation;

    this._currentState = null;
    /** @type {!Map.<!WebInspector.Target, !WebInspector.BreakpointManager.TargetBreakpoint>}*/
    this._targetBreakpoints = new Map();
    this._updateState(condition, enabled);
    this._breakpointManager._targetManager.observeTargets(this);
}

WebInspector.BreakpointManager.Breakpoint.prototype = {
    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target)
    {
        var debuggerModel = WebInspector.DebuggerModel.fromTarget(target);
        if (!debuggerModel)
            return;
        var networkMapping = this._breakpointManager._networkMapping;
        var debuggerWorkspaceBinding = this._breakpointManager._debuggerWorkspaceBinding;
        this._targetBreakpoints.set(target, new WebInspector.BreakpointManager.TargetBreakpoint(debuggerModel, this, networkMapping, debuggerWorkspaceBinding));
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target)
    {
        var debuggerModel = WebInspector.DebuggerModel.fromTarget(target);
        if (!debuggerModel)
            return;
        var targetBreakpoint = this._targetBreakpoints.remove(target);
        targetBreakpoint._cleanUpAfterDebuggerIsGone();
        targetBreakpoint._removeEventListeners();
    },

    /**
     * @return {string}
     */
    projectId: function()
    {
        return this._projectId;
    },

    /**
     * @return {string}
     */
    path: function()
    {
        return this._path;
    },

    /**
     * @return {number}
     */
    lineNumber: function()
    {
        return this._lineNumber;
    },

    /**
     * @return {number}
     */
    columnNumber: function()
    {
        return this._columnNumber;
    },

    /**
     * @return {?WebInspector.UISourceCode}
     */
    uiSourceCode: function()
    {
        return this._breakpointManager._workspace.uiSourceCode(this._projectId, this._path);
    },

    /**
     * @param {?WebInspector.UILocation} oldUILocation
     * @param {!WebInspector.UILocation} newUILocation
     */
    _replaceUILocation: function(oldUILocation, newUILocation)
    {
        if (this._isRemoved)
            return;

        this._removeUILocation(oldUILocation, true);
        this._removeFakeBreakpointAtPrimaryLocation();

        if (!this._numberOfDebuggerLocationForUILocation[newUILocation.id()])
            this._numberOfDebuggerLocationForUILocation[newUILocation.id()] = 0;

        if (++this._numberOfDebuggerLocationForUILocation[newUILocation.id()] === 1)
            this._breakpointManager._uiLocationAdded(this, newUILocation);
    },

    /**
     * @param {?WebInspector.UILocation} uiLocation
     * @param {boolean=} muteCreationFakeBreakpoint
     */
    _removeUILocation: function(uiLocation, muteCreationFakeBreakpoint)
    {
        if (!uiLocation || --this._numberOfDebuggerLocationForUILocation[uiLocation.id()] !== 0)
            return;

        delete this._numberOfDebuggerLocationForUILocation[uiLocation.id()];
        this._breakpointManager._uiLocationRemoved(this, uiLocation);
        if (!muteCreationFakeBreakpoint)
            this._fakeBreakpointAtPrimaryLocation();
    },

    /**
     * @return {boolean}
     */
    enabled: function()
    {
        return this._enabled;
    },

    /**
     * @param {boolean} enabled
     */
    setEnabled: function(enabled)
    {
        this._updateState(this._condition, enabled);
    },

    /**
     * @return {string}
     */
    condition: function()
    {
        return this._condition;
    },

    /**
     * @param {string} condition
     */
    setCondition: function(condition)
    {
        this._updateState(condition, this._enabled);
    },

    /**
     * @param {string} condition
     * @param {boolean} enabled
     */
    _updateState: function(condition, enabled)
    {
        if (this._enabled === enabled && this._condition === condition)
            return;
        this._enabled = enabled;
        this._condition = condition;
        this._breakpointManager._storage._updateBreakpoint(this);
        this._updateBreakpoint();
    },

    _updateBreakpoint: function()
    {
        this._removeFakeBreakpointAtPrimaryLocation();
        this._fakeBreakpointAtPrimaryLocation();
        var targetBreakpoints = this._targetBreakpoints.valuesArray();
        for (var i = 0; i < targetBreakpoints.length; ++i)
            targetBreakpoints[i]._scheduleUpdateInDebugger();
    },

    /**
     * @param {boolean=} keepInStorage
     */
    remove: function(keepInStorage)
    {

        this._isRemoved = true;
        var removeFromStorage = !keepInStorage;
        this._removeFakeBreakpointAtPrimaryLocation();
        var targetBreakpoints = this._targetBreakpoints.valuesArray();
        for (var i = 0; i < targetBreakpoints.length; ++i) {
            targetBreakpoints[i]._scheduleUpdateInDebugger();
            targetBreakpoints[i]._removeEventListeners();
        }

        this._breakpointManager._removeBreakpoint(this, removeFromStorage);
        this._breakpointManager._targetManager.unobserveTargets(this);
    },

    /**
     * @param {!WebInspector.Target} target
     */
    _updateInDebuggerForTarget: function(target)
    {
        this._targetBreakpoints.get(target)._scheduleUpdateInDebugger();
    },

    /**
     * @return {string}
     */
    _breakpointStorageId: function()
    {
        return WebInspector.BreakpointManager._breakpointStorageId(this._sourceFileId, this._lineNumber, this._columnNumber);
    },

    _fakeBreakpointAtPrimaryLocation: function()
    {
        if (this._isRemoved || !Object.isEmpty(this._numberOfDebuggerLocationForUILocation) || this._fakePrimaryLocation)
            return;

        var uiSourceCode = this._breakpointManager._workspace.uiSourceCode(this._projectId, this._path);
        if (!uiSourceCode)
            return;

        this._fakePrimaryLocation = uiSourceCode.uiLocation(this._lineNumber, this._columnNumber);
        if (this._fakePrimaryLocation)
            this._breakpointManager._uiLocationAdded(this, this._fakePrimaryLocation);
    },

    _removeFakeBreakpointAtPrimaryLocation: function()
    {
        if (this._fakePrimaryLocation) {
            this._breakpointManager._uiLocationRemoved(this, this._fakePrimaryLocation);
            delete this._fakePrimaryLocation;
        }
    },

    _resetLocations: function()
    {
        this._removeFakeBreakpointAtPrimaryLocation();
        var targetBreakpoints = this._targetBreakpoints.valuesArray();
        for (var i = 0; i < targetBreakpoints.length; ++i)
            targetBreakpoints[i]._resetLocations();
    }
}

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!WebInspector.DebuggerModel} debuggerModel
 * @param {!WebInspector.BreakpointManager.Breakpoint} breakpoint
 * @param {!WebInspector.NetworkMapping} networkMapping
 * @param {!WebInspector.DebuggerWorkspaceBinding} debuggerWorkspaceBinding
 */
WebInspector.BreakpointManager.TargetBreakpoint = function(debuggerModel, breakpoint, networkMapping, debuggerWorkspaceBinding)
{
    WebInspector.SDKObject.call(this, debuggerModel.target());
    this._debuggerModel = debuggerModel;
    this._breakpoint = breakpoint;
    this._networkMapping = networkMapping;
    this._debuggerWorkspaceBinding = debuggerWorkspaceBinding;

    /** @type {!Array.<!WebInspector.DebuggerWorkspaceBinding.Location>} */
    this._liveLocations = [];

    /** @type {!Object.<string, !WebInspector.UILocation>} */
    this._uiLocations = {};
    this._debuggerModel.addEventListener(WebInspector.DebuggerModel.Events.DebuggerWasDisabled, this._cleanUpAfterDebuggerIsGone, this);
    this._debuggerModel.addEventListener(WebInspector.DebuggerModel.Events.DebuggerWasEnabled, this._scheduleUpdateInDebugger, this);
    this._hasPendingUpdate = false;
    this._isUpdating = false;
    this._cancelCallback = false;
    this._currentState = null;
    if (this._debuggerModel.debuggerEnabled())
        this._scheduleUpdateInDebugger();
}

WebInspector.BreakpointManager.TargetBreakpoint.prototype = {

    _resetLocations: function()
    {
        var uiLocations = Object.values(this._uiLocations);
        for (var i = 0; i < uiLocations.length; ++i)
            this._breakpoint._removeUILocation(uiLocations[i]);

        this._uiLocations = {};

        for (var i = 0; i < this._liveLocations.length; ++i)
            this._liveLocations[i].dispose();
        this._liveLocations = [];
    },

    _scheduleUpdateInDebugger: function()
    {
        if (this._isUpdating) {
            this._hasPendingUpdate = true;
            return;
        }

        this._isUpdating = true;
        this._updateInDebugger(this._didUpdateInDebugger.bind(this));
    },

    _didUpdateInDebugger: function()
    {
        this._isUpdating = false;
        if (this._hasPendingUpdate) {
            this._hasPendingUpdate = false;
            this._scheduleUpdateInDebugger();
        }
    },

    /**
     * @return {boolean}
     */
    _scriptDiverged: function()
    {
        var uiSourceCode = this._breakpoint.uiSourceCode();
        if (!uiSourceCode)
            return false;
        var scriptFile = this._debuggerWorkspaceBinding.scriptFile(uiSourceCode, this.target());
        return !!scriptFile && scriptFile.hasDivergedFromVM();
    },

    /**
     * @param {function()} callback
     */
    _updateInDebugger: function(callback)
    {
        if (this.target().isDetached()) {
            this._cleanUpAfterDebuggerIsGone();
            callback();
            return;
        }

        var uiSourceCode = this._breakpoint.uiSourceCode();
        var lineNumber = this._breakpoint._lineNumber;
        var columnNumber = this._breakpoint._columnNumber;
        var condition = this._breakpoint.condition();

        var debuggerLocation = uiSourceCode ? this._debuggerWorkspaceBinding.uiLocationToRawLocation(this.target(), uiSourceCode, lineNumber, columnNumber) : null;
        var newState;
        if (this._breakpoint._isRemoved || !this._breakpoint.enabled() || this._scriptDiverged())
            newState = null;
        else if (debuggerLocation) {
            var script = debuggerLocation.script();
            if (script.sourceURL)
                newState = new WebInspector.BreakpointManager.Breakpoint.State(script.sourceURL, null, debuggerLocation.lineNumber, debuggerLocation.columnNumber, condition);
            else
                newState = new WebInspector.BreakpointManager.Breakpoint.State(null, debuggerLocation.scriptId, debuggerLocation.lineNumber, debuggerLocation.columnNumber, condition);
        } else if (this._breakpoint._currentState && this._breakpoint._currentState.url) {
            var position = this._breakpoint._currentState;
            newState = new WebInspector.BreakpointManager.Breakpoint.State(position.url, null, position.lineNumber, position.columnNumber, condition);
        } else if (uiSourceCode) {
            var networkURL = this._networkMapping.networkURL(uiSourceCode);
            if (networkURL)
                newState = new WebInspector.BreakpointManager.Breakpoint.State(networkURL, null, lineNumber, columnNumber, condition);
        }
        if (this._debuggerId && WebInspector.BreakpointManager.Breakpoint.State.equals(newState, this._currentState)) {
            callback();
            return;
        }

        this._breakpoint._currentState = newState;

        if (this._debuggerId) {
            this._resetLocations();
            this._debuggerModel.removeBreakpoint(this._debuggerId, this._didRemoveFromDebugger.bind(this, callback));
            this._scheduleUpdateInDebugger();
            this._currentState = null;
            return;
        }

        if (!newState) {
            callback();
            return;
        }

        var updateCallback = this._didSetBreakpointInDebugger.bind(this, callback);
        if (newState.url)
            this._debuggerModel.setBreakpointByURL(newState.url, newState.lineNumber, newState.columnNumber, this._breakpoint.condition(), updateCallback);
        else if (newState.scriptId)
            this._debuggerModel.setBreakpointBySourceId(/** @type {!WebInspector.DebuggerModel.Location} */ (debuggerLocation), condition, updateCallback);

        this._currentState = newState;
    },

    /**
     * @param {function()} callback
     * @param {?DebuggerAgent.BreakpointId} breakpointId
     * @param {!Array.<!WebInspector.DebuggerModel.Location>} locations
     */
    _didSetBreakpointInDebugger: function(callback, breakpointId, locations)
    {
        if (this._cancelCallback) {
            this._cancelCallback = false;
            callback();
            return;
        }

        if (!breakpointId) {
            this._breakpoint.remove(true);
            callback();
            return;
        }

        this._debuggerId = breakpointId;
        this._debuggerModel.addBreakpointListener(this._debuggerId, this._breakpointResolved, this);
        for (var i = 0; i < locations.length; ++i) {
            if (!this._addResolvedLocation(locations[i]))
                break;
        }
        callback();
    },

    /**
     * @param {function()} callback
     */
    _didRemoveFromDebugger: function(callback)
    {
        if (this._cancelCallback) {
            this._cancelCallback = false;
            callback();
            return;
        }

        this._resetLocations();
        this._debuggerModel.removeBreakpointListener(this._debuggerId, this._breakpointResolved, this);
        delete this._debuggerId;
        callback();
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _breakpointResolved: function(event)
    {
        this._addResolvedLocation(/** @type {!WebInspector.DebuggerModel.Location}*/ (event.data));
    },

    /**
     * @param {!WebInspector.DebuggerModel.Location} location
     * @param {!WebInspector.LiveLocation} liveLocation
     */
    _locationUpdated: function(location, liveLocation)
    {
        var uiLocation = liveLocation.uiLocation();
        if (!uiLocation)
            return;
        var oldUILocation = this._uiLocations[location.id()] || null;
        this._uiLocations[location.id()] = uiLocation;
        this._breakpoint._replaceUILocation(oldUILocation, uiLocation);
    },

    /**
     * @param {!WebInspector.DebuggerModel.Location} location
     * @return {boolean}
     */
    _addResolvedLocation: function(location)
    {
        var uiLocation = this._debuggerWorkspaceBinding.rawLocationToUILocation(location);
        var breakpoint = this._breakpoint._breakpointManager.findBreakpoint(uiLocation.uiSourceCode, uiLocation.lineNumber, uiLocation.columnNumber);
        if (breakpoint && breakpoint !== this._breakpoint) {
            // location clash
            this._breakpoint.remove();
            return false;
        }
        this._liveLocations.push(this._debuggerWorkspaceBinding.createLiveLocation(location, this._locationUpdated.bind(this, location)));
        return true;
    },

    _cleanUpAfterDebuggerIsGone: function()
    {
        if (this._isUpdating)
            this._cancelCallback = true;

        this._resetLocations();
        this._currentState = null;
        if (this._debuggerId)
            this._didRemoveFromDebugger(function() {});
    },

    _removeEventListeners: function()
    {
        this._debuggerModel.removeEventListener(WebInspector.DebuggerModel.Events.DebuggerWasDisabled, this._cleanUpAfterDebuggerIsGone, this);
        this._debuggerModel.removeEventListener(WebInspector.DebuggerModel.Events.DebuggerWasEnabled, this._scheduleUpdateInDebugger, this);
    },

    __proto__: WebInspector.SDKObject.prototype
}

/**
 * @constructor
 * @param {?string} url
 * @param {?string} scriptId
 * @param {number} lineNumber
 * @param {number} columnNumber
 * @param {string} condition
 */
WebInspector.BreakpointManager.Breakpoint.State = function(url, scriptId, lineNumber, columnNumber, condition)
{
    this.url = url;
    this.scriptId = scriptId;
    this.lineNumber = lineNumber;
    this.columnNumber = columnNumber;
    this.condition = condition;
}

/**
 * @param {?WebInspector.BreakpointManager.Breakpoint.State|undefined} stateA
 * @param {?WebInspector.BreakpointManager.Breakpoint.State|undefined} stateB
 * @return {boolean}
 */
WebInspector.BreakpointManager.Breakpoint.State.equals = function(stateA, stateB)
{
    if (!stateA || !stateB)
        return false;

    if (stateA.scriptId || stateB.scriptId)
        return false;

    return stateA.url === stateB.url && stateA.lineNumber === stateB.lineNumber && stateA.columnNumber === stateB.columnNumber && stateA.condition === stateB.condition;
}

/**
 * @constructor
 * @param {!WebInspector.BreakpointManager} breakpointManager
 * @param {?WebInspector.Setting} setting
 */
WebInspector.BreakpointManager.Storage = function(breakpointManager, setting)
{
    this._breakpointManager = breakpointManager;
    this._setting = setting || WebInspector.settings.createLocalSetting("breakpoints", []);
    var breakpoints = this._setting.get();
    /** @type {!Object.<string, !WebInspector.BreakpointManager.Storage.Item>} */
    this._breakpoints = {};
    for (var i = 0; i < breakpoints.length; ++i) {
        var breakpoint = /** @type {!WebInspector.BreakpointManager.Storage.Item} */ (breakpoints[i]);
        breakpoint.columnNumber = breakpoint.columnNumber || 0;
        this._breakpoints[breakpoint.sourceFileId + ":" + breakpoint.lineNumber + ":" + breakpoint.columnNumber] = breakpoint;
    }
}

WebInspector.BreakpointManager.Storage.prototype = {
    mute: function()
    {
        this._muted = true;
    },

    unmute: function()
    {
        delete this._muted;
    },

    /**
     * @param {string} sourceFileId
     * @return {!Array.<!WebInspector.BreakpointManager.Storage.Item>}
     */
    breakpointItems: function(sourceFileId)
    {
        var result = [];
        for (var id in this._breakpoints) {
            var breakpoint = this._breakpoints[id];
            if (breakpoint.sourceFileId === sourceFileId)
                result.push(breakpoint);
        }
        return result;
    },

    /**
     * @param {!WebInspector.BreakpointManager.Breakpoint} breakpoint
     */
    _updateBreakpoint: function(breakpoint)
    {
        if (this._muted || !breakpoint._breakpointStorageId())
            return;
        this._breakpoints[breakpoint._breakpointStorageId()] = new WebInspector.BreakpointManager.Storage.Item(breakpoint);
        this._save();
    },

    /**
     * @param {!WebInspector.BreakpointManager.Breakpoint} breakpoint
     */
    _removeBreakpoint: function(breakpoint)
    {
        if (this._muted)
            return;
        delete this._breakpoints[breakpoint._breakpointStorageId()];
        this._save();
    },

    _save: function()
    {
        var breakpointsArray = [];
        for (var id in this._breakpoints)
            breakpointsArray.push(this._breakpoints[id]);
        this._setting.set(breakpointsArray);
    }
}

/**
 * @constructor
 * @param {!WebInspector.BreakpointManager.Breakpoint} breakpoint
 */
WebInspector.BreakpointManager.Storage.Item = function(breakpoint)
{
    this.sourceFileId = breakpoint._sourceFileId;
    this.lineNumber = breakpoint.lineNumber();
    this.columnNumber = breakpoint.columnNumber();
    this.condition = breakpoint.condition();
    this.enabled = breakpoint.enabled();
}

/** @type {!WebInspector.BreakpointManager} */
WebInspector.breakpointManager;
;/* ContentProviderBasedProject.js */
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

 /**
 * @constructor
 * @extends {WebInspector.ProjectStore}
 * @implements {WebInspector.Project}
 * @param {!WebInspector.Workspace} workspace
 * @param {string} id
 * @param {!WebInspector.projectTypes} type
 * @param {string} displayName
 */
WebInspector.ContentProviderBasedProject = function(workspace, id, type, displayName)
{
    WebInspector.ProjectStore.call(this, workspace, id, type, displayName);
    /** @type {!Object.<string, !WebInspector.ContentProvider>} */
    this._contentProviders = {};
    workspace.addProject(this);
}

WebInspector.ContentProviderBasedProject.prototype = {
    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {function(?string)} callback
     */
    requestFileContent: function(uiSourceCode, callback)
    {
        var contentProvider = this._contentProviders[uiSourceCode.url()];
        contentProvider.requestContent().then(callback);
    },

    /**
     * @override
     * @return {boolean}
     */
    canSetFileContent: function()
    {
        return false;
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {string} newContent
     * @param {function(?string)} callback
     */
    setFileContent: function(uiSourceCode, newContent, callback)
    {
        callback(null);
    },

    /**
     * @override
     * @return {boolean}
     */
    canRename: function()
    {
        return false;
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {string} newName
     * @param {function(boolean, string=, string=, !WebInspector.ResourceType=)} callback
     */
    rename: function(uiSourceCode, newName, callback)
    {
        var path = uiSourceCode.url();
        this.performRename(path, newName, innerCallback.bind(this));

        /**
         * @param {boolean} success
         * @param {string=} newName
         * @this {WebInspector.ContentProviderBasedProject}
         */
        function innerCallback(success, newName)
        {
            if (success && newName) {
                var copyOfPath = path.split("/");
                copyOfPath[copyOfPath.length - 1] = newName;
                var newPath = copyOfPath.join("/");
                this._contentProviders[newPath] = this._contentProviders[path];
                delete this._contentProviders[path];
                this.renameUISourceCode(uiSourceCode, newName);
            }
            callback(success, newName);
        }
    },

    /**
     * @override
     * @param {string} path
     * @param {function()=} callback
     */
    refresh: function(path, callback)
    {
        if (callback)
            callback();
    },

    /**
     * @override
     * @param {string} path
     */
    excludeFolder: function(path)
    {
    },

    /**
     * @override
     * @param {string} path
     * @param {?string} name
     * @param {string} content
     * @param {function(?WebInspector.UISourceCode)} callback
     */
    createFile: function(path, name, content, callback)
    {
    },

    /**
     * @override
     * @param {string} path
     */
    deleteFile: function(path)
    {
    },

    /**
     * @override
     */
    remove: function()
    {
    },

    /**
     * @param {string} path
     * @param {string} newName
     * @param {function(boolean, string=)} callback
     */
    performRename: function(path, newName, callback)
    {
        callback(false);
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {string} query
     * @param {boolean} caseSensitive
     * @param {boolean} isRegex
     * @param {function(!Array.<!WebInspector.ContentProvider.SearchMatch>)} callback
     */
    searchInFileContent: function(uiSourceCode, query, caseSensitive, isRegex, callback)
    {
        var contentProvider = this._contentProviders[uiSourceCode.url()];
        contentProvider.searchInContent(query, caseSensitive, isRegex, callback);
    },

    /**
     * @override
     * @param {!WebInspector.ProjectSearchConfig} searchConfig
     * @param {!Array.<string>} filesMathingFileQuery
     * @param {!WebInspector.Progress} progress
     * @param {function(!Array.<string>)} callback
     */
    findFilesMatchingSearchRequest: function(searchConfig, filesMathingFileQuery, progress, callback)
    {
        var result = [];
        var paths = filesMathingFileQuery;
        var totalCount = paths.length;
        if (totalCount === 0) {
            // searchInContent should call back later.
            setTimeout(doneCallback, 0);
            return;
        }

        var barrier = new CallbackBarrier();
        progress.setTotalWork(paths.length);
        for (var i = 0; i < paths.length; ++i)
            searchInContent.call(this, paths[i], barrier.createCallback(searchInContentCallback.bind(null, paths[i])));
        barrier.callWhenDone(doneCallback);

        /**
         * @param {string} path
         * @param {function(boolean)} callback
         * @this {WebInspector.ContentProviderBasedProject}
         */
        function searchInContent(path, callback)
        {
            var queriesToRun = searchConfig.queries().slice();
            searchNextQuery.call(this);

            /**
             * @this {WebInspector.ContentProviderBasedProject}
             */
            function searchNextQuery()
            {
                if (!queriesToRun.length) {
                    callback(true);
                    return;
                }
                var query = queriesToRun.shift();
                this._contentProviders[path].searchInContent(query, !searchConfig.ignoreCase(), searchConfig.isRegex(), contentCallback.bind(this));
            }

            /**
             * @param {!Array.<!WebInspector.ContentProvider.SearchMatch>} searchMatches
             * @this {WebInspector.ContentProviderBasedProject}
             */
            function contentCallback(searchMatches)
            {
                if (!searchMatches.length) {
                    callback(false);
                    return;
                }
                searchNextQuery.call(this);
            }
        }

        /**
         * @param {string} path
         * @param {boolean} matches
         */
        function searchInContentCallback(path, matches)
        {
            if (matches)
                result.push(path);
            progress.worked(1);
        }

        function doneCallback()
        {
            callback(result);
            progress.done();
        }
    },

    /**
     * @override
     * @param {!WebInspector.Progress} progress
     */
    indexContent: function(progress)
    {
        setImmediate(progress.done.bind(progress));
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {!WebInspector.ContentProvider} contentProvider
     */
    addUISourceCodeWithProvider: function(uiSourceCode, contentProvider)
    {
        this._contentProviders[uiSourceCode.url()] = contentProvider;
        this.addUISourceCode(uiSourceCode, true);
    },

    /**
     * @param {string} url
     * @param {!WebInspector.ContentProvider} contentProvider
     * @return {!WebInspector.UISourceCode}
     */
    addContentProvider: function(url, contentProvider)
    {
        var uiSourceCode = this.createUISourceCode(url, contentProvider.contentType());
        this.addUISourceCodeWithProvider(uiSourceCode, contentProvider);
        return uiSourceCode;
    },

    /**
     * @param {string} path
     */
    removeFile: function(path)
    {
        delete this._contentProviders[path];
        this.removeUISourceCode(path);
    },

    reset: function()
    {
        this._contentProviders = {};
        this.removeProject();
        this.workspace().addProject(this);
    },

    dispose: function()
    {
        this._contentProviders = {};
        this.removeProject();
    },

    __proto__: WebInspector.ProjectStore.prototype
}
;/* DefaultScriptMapping.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @implements {WebInspector.DebuggerSourceMapping}
 * @param {!WebInspector.DebuggerModel} debuggerModel
 * @param {!WebInspector.Workspace} workspace
 * @param {!WebInspector.DebuggerWorkspaceBinding} debuggerWorkspaceBinding
 */
WebInspector.DefaultScriptMapping = function(debuggerModel, workspace, debuggerWorkspaceBinding)
{
    this._debuggerModel = debuggerModel;
    this._debuggerWorkspaceBinding = debuggerWorkspaceBinding;
    this._workspace = workspace;
    this._projectId = WebInspector.DefaultScriptMapping.projectIdForTarget(debuggerModel.target());
    this._project = new WebInspector.ContentProviderBasedProject(this._workspace, this._projectId, WebInspector.projectTypes.Debugger, "");
    debuggerModel.addEventListener(WebInspector.DebuggerModel.Events.GlobalObjectCleared, this._debuggerReset, this);
    this._debuggerReset();
}

WebInspector.DefaultScriptMapping._scriptSymbol = Symbol("symbol");

/**
 * @param {!WebInspector.UISourceCode} uiSourceCode
 * @return {?WebInspector.Script}
 */
WebInspector.DefaultScriptMapping.scriptForUISourceCode = function(uiSourceCode)
{
    return uiSourceCode[WebInspector.DefaultScriptMapping._scriptSymbol] || null;
}

WebInspector.DefaultScriptMapping.prototype = {
    /**
     * @override
     * @param {!WebInspector.DebuggerModel.Location} rawLocation
     * @return {!WebInspector.UILocation}
     */
    rawLocationToUILocation: function(rawLocation)
    {
        var debuggerModelLocation = /** @type {!WebInspector.DebuggerModel.Location} */ (rawLocation);
        var script = debuggerModelLocation.script();
        var uiSourceCode = this._uiSourceCodeForScriptId.get(script.scriptId);
        var lineNumber = debuggerModelLocation.lineNumber - (script.isInlineScriptWithSourceURL() ? script.lineOffset : 0);
        var columnNumber = debuggerModelLocation.columnNumber || 0;
        if (script.isInlineScriptWithSourceURL() && !lineNumber && columnNumber)
            columnNumber -= script.columnOffset;
        return uiSourceCode.uiLocation(lineNumber, columnNumber);
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?WebInspector.DebuggerModel.Location}
     */
    uiLocationToRawLocation: function(uiSourceCode, lineNumber, columnNumber)
    {
        var scriptId = this._scriptIdForUISourceCode.get(uiSourceCode);
        var script = this._debuggerModel.scriptForId(scriptId);
        if (script.isInlineScriptWithSourceURL())
            return this._debuggerModel.createRawLocation(script, lineNumber + script.lineOffset, lineNumber ? columnNumber : columnNumber + script.columnOffset);
        return this._debuggerModel.createRawLocation(script, lineNumber, columnNumber);
    },

    /**
     * @param {!WebInspector.Script} script
     */
    addScript: function(script)
    {

        var splitURL = WebInspector.ParsedURL.splitURLIntoPathComponents(script.sourceURL);
        var url = splitURL[splitURL.length - 1];
        url = "debugger:///VM" + script.scriptId + (url ? " " + url: "");

        var uiSourceCode = this._project.createUISourceCode(url, WebInspector.resourceTypes.Script);
        uiSourceCode[WebInspector.DefaultScriptMapping._scriptSymbol] = script;
        this._uiSourceCodeForScriptId.set(script.scriptId, uiSourceCode);
        this._scriptIdForUISourceCode.set(uiSourceCode, script.scriptId);
        this._project.addUISourceCodeWithProvider(uiSourceCode, script);

        this._debuggerWorkspaceBinding.setSourceMapping(this._debuggerModel.target(), uiSourceCode, this);
        this._debuggerWorkspaceBinding.pushSourceMapping(script, this);
    },

    /**
     * @override
     * @return {boolean}
     */
    isIdentity: function()
    {
        return true;
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {number} lineNumber
     * @return {boolean}
     */
    uiLineHasMapping: function(uiSourceCode, lineNumber)
    {
        return true;
    },

    _debuggerReset: function()
    {
        /** @type {!Map.<string, !WebInspector.UISourceCode>} */
        this._uiSourceCodeForScriptId = new Map();
        this._scriptIdForUISourceCode = new Map();
        this._project.reset();
    },

    dispose: function()
    {
        this._project.dispose();
    }
}

/**
 * @param {!WebInspector.Target} target
 * @return {string}
 */
WebInspector.DefaultScriptMapping.projectIdForTarget = function(target)
{
    return "debugger:" + target.id();
}
;/* FileSystemWorkspaceBinding.js */
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {!WebInspector.IsolatedFileSystemManager} isolatedFileSystemManager
 * @param {!WebInspector.Workspace} workspace
 */
WebInspector.FileSystemWorkspaceBinding = function(isolatedFileSystemManager, workspace)
{
    this._isolatedFileSystemManager = isolatedFileSystemManager;
    this._workspace = workspace;
    this._isolatedFileSystemManager.addEventListener(WebInspector.IsolatedFileSystemManager.Events.FileSystemAdded, this._fileSystemAdded, this);
    this._isolatedFileSystemManager.addEventListener(WebInspector.IsolatedFileSystemManager.Events.FileSystemRemoved, this._fileSystemRemoved, this);
    this._isolatedFileSystemManager.addEventListener(WebInspector.IsolatedFileSystemManager.Events.FileSystemFilesChanged, this._fileSystemFilesChanged, this);
    /** @type {!Map.<string, !WebInspector.FileSystemWorkspaceBinding.FileSystem>} */
    this._boundFileSystems = new Map();
}

WebInspector.FileSystemWorkspaceBinding._styleSheetExtensions = new Set(["css", "scss", "sass", "less"]);
WebInspector.FileSystemWorkspaceBinding._documentExtensions = new Set(["htm", "html", "asp", "aspx", "phtml", "jsp"]);
WebInspector.FileSystemWorkspaceBinding._scriptExtensions = new Set(["asp", "aspx", "c", "cc", "cljs", "coffee", "cpp", "cs", "dart", "java", "js", "jsp", "jsx", "h", "m", "mm", "py", "sh", "ts", "tsx"]);

WebInspector.FileSystemWorkspaceBinding._imageExtensions = WebInspector.IsolatedFileSystem.ImageExtensions;

/**
 * @param {string} fileSystemPath
 * @return {string}
 */
WebInspector.FileSystemWorkspaceBinding.projectId = function(fileSystemPath)
{
    return fileSystemPath;
}

/**
 * @param {!WebInspector.UISourceCode} uiSourceCode
 * @return {!Array<string>}
 */
WebInspector.FileSystemWorkspaceBinding.relativePath = function(uiSourceCode)
{
    var baseURL = /** @type {!WebInspector.FileSystemWorkspaceBinding.FileSystem}*/(uiSourceCode.project())._fileSystemBaseURL;
    return uiSourceCode.url().substring(baseURL.length).split("/");
}

/**
 * @param {!WebInspector.Project} project
 * @param {string} relativePath
 * @return {string}
 */
WebInspector.FileSystemWorkspaceBinding.completeURL = function(project, relativePath)
{
    var fsProject = /** @type {!WebInspector.FileSystemWorkspaceBinding.FileSystem}*/(project);
    return fsProject._fileSystemBaseURL + relativePath;
}

/**
 * @param {string} extension
 * @return {!WebInspector.ResourceType}
 */
WebInspector.FileSystemWorkspaceBinding._contentTypeForExtension = function(extension)
{
    if (WebInspector.FileSystemWorkspaceBinding._styleSheetExtensions.has(extension))
        return WebInspector.resourceTypes.Stylesheet;
    if (WebInspector.FileSystemWorkspaceBinding._documentExtensions.has(extension))
        return WebInspector.resourceTypes.Document;
    if (WebInspector.FileSystemWorkspaceBinding._imageExtensions.has(extension))
        return WebInspector.resourceTypes.Image;
    if (WebInspector.FileSystemWorkspaceBinding._scriptExtensions.has(extension))
        return WebInspector.resourceTypes.Script;
    return WebInspector.resourceTypes.Other;
}

WebInspector.FileSystemWorkspaceBinding.prototype = {
    /**
     * @return {!WebInspector.IsolatedFileSystemManager}
     */
    fileSystemManager: function()
    {
        return this._isolatedFileSystemManager;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _fileSystemAdded: function(event)
    {
        var fileSystem = /** @type {!WebInspector.IsolatedFileSystem} */ (event.data);
        var boundFileSystem = new WebInspector.FileSystemWorkspaceBinding.FileSystem(this, fileSystem, this._workspace);
        this._boundFileSystems.set(fileSystem.path(), boundFileSystem);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _fileSystemRemoved: function(event)
    {
        var fileSystem = /** @type {!WebInspector.IsolatedFileSystem} */ (event.data);
        var boundFileSystem = this._boundFileSystems.get(fileSystem.path());
        boundFileSystem.dispose();
        this._boundFileSystems.remove(fileSystem.path());
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _fileSystemFilesChanged: function(event)
    {
        var paths = /** @type {!Array<string>} */ (event.data);
        for (var path of paths) {
            for (var key of this._boundFileSystems.keys()) {
                if (!path.startsWith(key))
                    continue;
                this._boundFileSystems.get(key)._fileChanged(path);
            }
        }
    },

    /**
     * @param {string} projectId
     * @return {string}
     */
    fileSystemPath: function(projectId)
    {
        return projectId;
    },

    dispose: function()
    {
        this._isolatedFileSystemManager.removeEventListener(WebInspector.IsolatedFileSystemManager.Events.FileSystemAdded, this._fileSystemAdded, this);
        this._isolatedFileSystemManager.removeEventListener(WebInspector.IsolatedFileSystemManager.Events.FileSystemRemoved, this._fileSystemRemoved, this);
        this._isolatedFileSystemManager.dispose();
        for (var fileSystem of this._boundFileSystems.values()) {
            fileSystem.dispose();
            this._boundFileSystems.remove(fileSystem._fileSystem.path());
        }
    }
}

/**
 * @constructor
 * @extends {WebInspector.ProjectStore}
 * @implements {WebInspector.Project}
 * @param {!WebInspector.FileSystemWorkspaceBinding} fileSystemWorkspaceBinding
 * @param {!WebInspector.IsolatedFileSystem} isolatedFileSystem
 * @param {!WebInspector.Workspace} workspace
 */
WebInspector.FileSystemWorkspaceBinding.FileSystem = function(fileSystemWorkspaceBinding, isolatedFileSystem, workspace)
{
    this._fileSystemWorkspaceBinding = fileSystemWorkspaceBinding;
    this._fileSystem = isolatedFileSystem;
    this._fileSystemBaseURL = this._fileSystem.path() + "/";
    this._fileSystemPath = this._fileSystem.path();

    var id = WebInspector.FileSystemWorkspaceBinding.projectId(this._fileSystemPath);
    console.assert(!workspace.project(id));

    var displayName = this._fileSystemPath.substr(this._fileSystemPath.lastIndexOf("/") + 1);
    WebInspector.ProjectStore.call(this, workspace, id, WebInspector.projectTypes.FileSystem, displayName);

    workspace.addProject(this);
    this.populate();
}

WebInspector.FileSystemWorkspaceBinding.FileSystem.prototype = {
    /**
     * @return {string}
     */
    fileSystemPath: function()
    {
        return this._fileSystemPath;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @return {string}
     */
    _filePathForUISourceCode: function(uiSourceCode)
    {
        return uiSourceCode.url().substring(this._fileSystemPath.length);
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {function(?string)} callback
     */
    requestFileContent: function(uiSourceCode, callback)
    {
        var filePath = this._filePathForUISourceCode(uiSourceCode);
        var isImage = WebInspector.FileSystemWorkspaceBinding._imageExtensions.has(WebInspector.TextUtils.extension(filePath));

        this._fileSystem.requestFileContent(filePath, isImage ? base64CallbackWrapper : callback);

        /**
         * @param {?string} result
         */
        function base64CallbackWrapper(result)
        {
            if (!result) {
                callback(result);
                return;
            }
            var index = result.indexOf(",");
            callback(result.substring(index + 1));
        }
    },

    /**
     * @override
     * @return {boolean}
     */
    canSetFileContent: function()
    {
        return true;
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {string} newContent
     * @param {function(?string)} callback
     */
    setFileContent: function(uiSourceCode, newContent, callback)
    {
        var filePath = this._filePathForUISourceCode(uiSourceCode);
        this._fileSystem.setFileContent(filePath, newContent, callback.bind(this, ""));
    },

    /**
     * @override
     * @return {boolean}
     */
    canRename: function()
    {
        return true;
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {string} newName
     * @param {function(boolean, string=, string=, !WebInspector.ResourceType=)} callback
     */
    rename: function(uiSourceCode, newName, callback)
    {
        if (newName === uiSourceCode.name()) {
            callback(true, uiSourceCode.name(), uiSourceCode.url(), uiSourceCode.contentType());
            return;
        }

        var filePath = this._filePathForUISourceCode(uiSourceCode);
        this._fileSystem.renameFile(filePath, newName, innerCallback.bind(this));

        /**
         * @param {boolean} success
         * @param {string=} newName
         * @this {WebInspector.FileSystemWorkspaceBinding.FileSystem}
         */
        function innerCallback(success, newName)
        {
            if (!success || !newName) {
                callback(false, newName);
                return;
            }
            console.assert(newName);
            var slash = filePath.lastIndexOf("/");
            var parentPath = filePath.substring(0, slash);
            filePath = parentPath + "/" + newName;
            filePath = filePath.substr(1);
            var extension = this._extensionForPath(newName);
            var newURL = this._fileSystemBaseURL + filePath;
            var newContentType = WebInspector.FileSystemWorkspaceBinding._contentTypeForExtension(extension);
            this.renameUISourceCode(uiSourceCode, newName);
            callback(true, newName, newURL, newContentType);
        }
    },

    /**
     * @override
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {string} query
     * @param {boolean} caseSensitive
     * @param {boolean} isRegex
     * @param {function(!Array.<!WebInspector.ContentProvider.SearchMatch>)} callback
     */
    searchInFileContent: function(uiSourceCode, query, caseSensitive, isRegex, callback)
    {
        var filePath = this._filePathForUISourceCode(uiSourceCode);
        this._fileSystem.requestFileContent(filePath, contentCallback);

        /**
         * @param {?string} content
         */
        function contentCallback(content)
        {
            var result = [];
            if (content !== null)
                result = WebInspector.ContentProvider.performSearchInContent(content, query, caseSensitive, isRegex);
            callback(result);
        }
    },

    /**
     * @override
     * @param {!WebInspector.ProjectSearchConfig} searchConfig
     * @param {!Array.<string>} filesMathingFileQuery
     * @param {!WebInspector.Progress} progress
     * @param {function(!Array.<string>)} callback
     */
    findFilesMatchingSearchRequest: function(searchConfig, filesMathingFileQuery, progress, callback)
    {
        var result = filesMathingFileQuery;
        var queriesToRun = searchConfig.queries().slice();
        if (!queriesToRun.length)
            queriesToRun.push("");
        progress.setTotalWork(queriesToRun.length);
        searchNextQuery.call(this);

        /**
         * @this {WebInspector.FileSystemWorkspaceBinding.FileSystem}
         */
        function searchNextQuery()
        {
            if (!queriesToRun.length) {
                progress.done();
                callback(result);
                return;
            }
            var query = queriesToRun.shift();
            this._fileSystem.searchInPath(searchConfig.isRegex() ? "" : query, progress, innerCallback.bind(this));
        }

        /**
         * @param {!Array.<string>} files
         * @this {WebInspector.FileSystemWorkspaceBinding.FileSystem}
         */
        function innerCallback(files)
        {
            files = files.sort();
            progress.worked(1);
            result = result.intersectOrdered(files, String.naturalOrderComparator);
            searchNextQuery.call(this);
        }
    },

    /**
     * @override
     * @param {!WebInspector.Progress} progress
     */
    indexContent: function(progress)
    {
        this._fileSystem.indexContent(progress);
    },

    /**
     * @param {string} path
     * @return {string}
     */
    _extensionForPath: function(path)
    {
        var extensionIndex = path.lastIndexOf(".");
        if (extensionIndex === -1)
            return "";
        return path.substring(extensionIndex + 1).toLowerCase();
    },

    populate: function()
    {
        this._fileSystem.requestFilesRecursive("", this._addFile.bind(this));
    },

    /**
     * @override
     * @param {string} path
     * @param {function()=} callback
     */
    refresh: function(path, callback)
    {
        this._fileSystem.requestFilesRecursive(path, this._addFile.bind(this), callback);
    },

    /**
     * @override
     * @param {string} url
     */
    excludeFolder: function(url)
    {
        var relativeFolder = url.substring(this._fileSystemBaseURL.length);
        if (!relativeFolder.startsWith("/"))
            relativeFolder = "/" + relativeFolder;
        if (!relativeFolder.endsWith("/"))
            relativeFolder += "/";
        this._fileSystem.addExcludedFolder(relativeFolder);

        var uiSourceCodes = this.uiSourceCodes().slice();
        for (var i = 0; i < uiSourceCodes.length; ++i) {
            var uiSourceCode = uiSourceCodes[i];
            if (uiSourceCode.url().startsWith(url))
                this.removeUISourceCode(uiSourceCode.url());
        }
    },

    /**
     * @override
     * @param {string} path
     * @param {?string} name
     * @param {string} content
     * @param {function(?WebInspector.UISourceCode)} callback
     */
    createFile: function(path, name, content, callback)
    {
        this._fileSystem.createFile(path, name, innerCallback.bind(this));
        var createFilePath;

        /**
         * @param {?string} filePath
         * @this {WebInspector.FileSystemWorkspaceBinding.FileSystem}
         */
        function innerCallback(filePath)
        {
            if (!filePath) {
                callback(null);
                return;
            }
            createFilePath = filePath;
            if (!content) {
                contentSet.call(this);
                return;
            }
            this._fileSystem.setFileContent(filePath, content, contentSet.bind(this));
        }

        /**
         * @this {WebInspector.FileSystemWorkspaceBinding.FileSystem}
         */
        function contentSet()
        {
            callback(this._addFile(createFilePath));
        }
    },

    /**
     * @override
     * @param {string} path
     */
    deleteFile: function(path)
    {
        this._fileSystem.deleteFile(path);
        this.removeUISourceCode(path);
    },

    /**
     * @override
     */
    remove: function()
    {
        this._fileSystemWorkspaceBinding._isolatedFileSystemManager.removeFileSystem(this._fileSystem);
    },

    /**
     * @param {string} filePath
     * @return {!WebInspector.UISourceCode}
     */
    _addFile: function(filePath)
    {
        if (!filePath)
            console.assert(false);

        var extension = this._extensionForPath(filePath);
        var contentType = WebInspector.FileSystemWorkspaceBinding._contentTypeForExtension(extension);

        var uiSourceCode = this.createUISourceCode(this._fileSystemBaseURL + filePath, contentType);
        this.addUISourceCode(uiSourceCode);
        return uiSourceCode;
    },

    /**
     * @param {string} path
     */
    _fileChanged: function(path)
    {
        var uiSourceCode = this.uiSourceCodeForURL(path);
        if (!uiSourceCode) {
            var contentType = WebInspector.FileSystemWorkspaceBinding._contentTypeForExtension(this._extensionForPath(path));
            this.addUISourceCode(this.createUISourceCode(path, contentType));
            return;
        }
        uiSourceCode.checkContentUpdated();
    },

    dispose: function()
    {
        this.removeProject();
    },

    __proto__: WebInspector.ProjectStore.prototype
}
;/* FileUtils.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @interface
 */
WebInspector.OutputStreamDelegate = function()
{
}

WebInspector.OutputStreamDelegate.prototype = {
    onTransferStarted: function() { },

    onTransferFinished: function() { },

    /**
     * @param {!WebInspector.ChunkedReader} reader
     */
    onChunkTransferred: function(reader) { },

    /**
     * @param {!WebInspector.ChunkedReader} reader
     * @param {!Event} event
     */
    onError: function(reader, event) { },
}

/**
 * @interface
 */
WebInspector.ChunkedReader = function()
{
}

WebInspector.ChunkedReader.prototype = {
    /**
     * @return {number}
     */
    fileSize: function() { },

    /**
     * @return {number}
     */
    loadedSize: function() { },

    /**
     * @return {string}
     */
    fileName: function() { },

    cancel: function() { }
}

/**
 * @constructor
 * @implements {WebInspector.ChunkedReader}
 * @param {!File} file
 * @param {number} chunkSize
 * @param {!WebInspector.OutputStreamDelegate} delegate
 */
WebInspector.ChunkedFileReader = function(file, chunkSize, delegate)
{
    this._file = file;
    this._fileSize = file.size;
    this._loadedSize = 0;
    this._chunkSize = chunkSize;
    this._delegate = delegate;
    this._decoder = new TextDecoder();
    this._isCanceled = false;
}

WebInspector.ChunkedFileReader.prototype = {
    /**
     * @param {!WebInspector.OutputStream} output
     */
    start: function(output)
    {
        this._output = output;

        this._reader = new FileReader();
        this._reader.onload = this._onChunkLoaded.bind(this);
        this._reader.onerror = this._delegate.onError.bind(this._delegate, this);
        this._delegate.onTransferStarted();
        this._loadChunk();
    },

    /**
     * @override
     */
    cancel: function()
    {
        this._isCanceled = true;
    },

    /**
     * @override
     * @return {number}
     */
    loadedSize: function()
    {
        return this._loadedSize;
    },

    /**
     * @override
     * @return {number}
     */
    fileSize: function()
    {
        return this._fileSize;
    },

    /**
     * @override
     * @return {string}
     */
    fileName: function()
    {
        return this._file.name;
    },

    /**
     * @param {!Event} event
     */
    _onChunkLoaded: function(event)
    {
        if (this._isCanceled)
            return;

        if (event.target.readyState !== FileReader.DONE)
            return;

        var buffer = event.target.result;
        this._loadedSize += buffer.byteLength;
        var endOfFile = this._loadedSize === this._fileSize;
        var decodedString = this._decoder.decode(buffer, {stream: !endOfFile});
        this._output.write(decodedString);
        if (this._isCanceled)
            return;
        this._delegate.onChunkTransferred(this);

        if (endOfFile) {
            this._file = null;
            this._reader = null;
            this._output.close();
            this._delegate.onTransferFinished();
            return;
        }

        this._loadChunk();
    },

    _loadChunk: function()
    {
        var chunkStart = this._loadedSize;
        var chunkEnd = Math.min(this._fileSize, chunkStart + this._chunkSize);
        var nextPart = this._file.slice(chunkStart, chunkEnd);
        this._reader.readAsArrayBuffer(nextPart);
    }
}

/**
 * @param {function(!File)} callback
 * @return {!Node}
 */
WebInspector.createFileSelectorElement = function(callback)
{
    var fileSelectorElement = createElement("input");
    fileSelectorElement.type = "file";
    fileSelectorElement.style.display = "none";
    fileSelectorElement.setAttribute("tabindex", -1);
    fileSelectorElement.onchange = onChange;
    function onChange(event)
    {
        callback(fileSelectorElement.files[0]);
    };
    return fileSelectorElement;
}

/**
 * @constructor
 * @implements {WebInspector.OutputStream}
 */
WebInspector.FileOutputStream = function()
{
}

WebInspector.FileOutputStream.prototype = {
    /**
     * @param {string} fileName
     * @param {function(boolean)} callback
     */
    open: function(fileName, callback)
    {
        this._closed = false;
        this._writeCallbacks = [];
        this._fileName = fileName;

        /**
         * @param {boolean} accepted
         * @this {WebInspector.FileOutputStream}
         */
        function callbackWrapper(accepted)
        {
            if (accepted)
                WebInspector.fileManager.addEventListener(WebInspector.FileManager.EventTypes.AppendedToURL, this._onAppendDone, this);
            callback(accepted);
        }
        WebInspector.fileManager.save(this._fileName, "", true, callbackWrapper.bind(this));
    },

    /**
     * @override
     * @param {string} data
     * @param {function(!WebInspector.OutputStream)=} callback
     */
    write: function(data, callback)
    {
        this._writeCallbacks.push(callback);
        WebInspector.fileManager.append(this._fileName, data);
    },

    /**
     * @override
     */
    close: function()
    {
        this._closed = true;
        if (this._writeCallbacks.length)
            return;
        WebInspector.fileManager.removeEventListener(WebInspector.FileManager.EventTypes.AppendedToURL, this._onAppendDone, this);
        WebInspector.fileManager.close(this._fileName);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onAppendDone: function(event)
    {
        if (event.data !== this._fileName)
            return;
        var callback = this._writeCallbacks.shift();
        if (callback)
            callback(this);
        if (!this._writeCallbacks.length) {
            if (this._closed) {
                WebInspector.fileManager.removeEventListener(WebInspector.FileManager.EventTypes.AppendedToURL, this._onAppendDone, this);
                WebInspector.fileManager.close(this._fileName);
            }
        }
    }
}
;/* BlackboxManager.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {!WebInspector.DebuggerWorkspaceBinding} debuggerWorkspaceBinding
 * @param {!WebInspector.NetworkMapping} networkMapping
 */
WebInspector.BlackboxManager = function(debuggerWorkspaceBinding, networkMapping)
{
    this._debuggerWorkspaceBinding = debuggerWorkspaceBinding;
    this._networkMapping = networkMapping;

    WebInspector.targetManager.addModelListener(WebInspector.DebuggerModel, WebInspector.DebuggerModel.Events.ParsedScriptSource, this._parsedScriptSource, this);
    WebInspector.targetManager.addModelListener(WebInspector.DebuggerModel, WebInspector.DebuggerModel.Events.GlobalObjectCleared, this._globalObjectCleared, this);
    WebInspector.moduleSetting("skipStackFramesPattern").addChangeListener(this._patternChanged.bind(this));
    WebInspector.moduleSetting("skipContentScripts").addChangeListener(this._patternChanged.bind(this));

    /** @type {!Map<!WebInspector.DebuggerModel, !Map<string, !Array<!DebuggerAgent.ScriptPosition>>>} */
    this._debuggerModelData = new Map();
    /** @type {!Map<string, boolean>} */
    this._isBlackboxedURLCache = new Map();
}

WebInspector.BlackboxManager.prototype = {
    /**
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    addChangeListener: function(listener, thisObject)
    {
        WebInspector.moduleSetting("skipStackFramesPattern").addChangeListener(listener, thisObject);
    },

    /**
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    removeChangeListener: function(listener, thisObject)
    {
        WebInspector.moduleSetting("skipStackFramesPattern").removeChangeListener(listener, thisObject);
    },

    /**
     * @param {!WebInspector.DebuggerModel.Location} location
     * @return {boolean}
     */
    isBlackboxedRawLocation: function(location)
    {
        var positions = this._scriptPositions(location.script());
        if (!positions)
            return this._isBlackboxedScript(location.script());
        var index = positions.lowerBound(location, comparator);
        return !!(index % 2);

        /**
         * @param {!WebInspector.DebuggerModel.Location} a
         * @param {!DebuggerAgent.ScriptPosition} b
         * @return {number}
         */
        function comparator(a, b)
        {
            if (a.lineNumber !== b.line)
                return a.lineNumber - b.line;
            return a.columnNumber - b.column;
        }
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @return {boolean}
     */
    isBlackboxedUISourceCode: function(uiSourceCode)
    {
        var projectType = uiSourceCode.project().type();
        var isContentScript = projectType === WebInspector.projectTypes.ContentScripts;
        if (isContentScript && WebInspector.moduleSetting("skipContentScripts").get())
            return true;
        var url = this._uiSourceCodeURL(uiSourceCode);
        return url ? this.isBlackboxedURL(url) : false;
    },

    /**
     * @param {string} url
     * @param {boolean=} isContentScript
     * @return {boolean}
     */
    isBlackboxedURL: function(url, isContentScript)
    {
        if (this._isBlackboxedURLCache.has(url))
            return !!this._isBlackboxedURLCache.get(url);
        if (isContentScript && WebInspector.moduleSetting("skipContentScripts").get())
            return true;
        var regex = WebInspector.moduleSetting("skipStackFramesPattern").asRegExp();
        var isBlackboxed = regex && regex.test(url);
        this._isBlackboxedURLCache.set(url, isBlackboxed);
        return isBlackboxed;
    },

    /**
     * @param {!WebInspector.Script} script
     * @param {?WebInspector.SourceMap} sourceMap
     * @return {!Promise<undefined>}
     */
    sourceMapLoaded: function(script, sourceMap)
    {
        if (!sourceMap)
            return Promise.resolve();
        var previousScriptState = this._scriptPositions(script);
        if (!previousScriptState)
            return Promise.resolve();

        var mappings = sourceMap.mappings().slice();
        mappings.sort(mappingComparator);

        if (!mappings.length) {
            if (previousScriptState.length > 0)
                return this._setScriptState(script, []).then(this._sourceMapLoadedForTest);
            return Promise.resolve();
        }

        var currentBlackboxed = false;
        var isBlackboxed = false;
        var positions = [];
        // If content in script file begin is not mapped and one or more ranges are blackboxed then blackbox it.
        if (mappings[0].lineNumber !== 0 || mappings[0].columnNumber !== 0) {
            positions.push({ line: 0, column: 0});
            currentBlackboxed = true;
        }
        for (var mapping of mappings) {
            if (currentBlackboxed !== this.isBlackboxedURL(mapping.sourceURL)) {
                positions.push({ line: mapping.lineNumber, column: mapping.columnNumber });
                currentBlackboxed = !currentBlackboxed;
            }
            isBlackboxed = currentBlackboxed || isBlackboxed;
        }
        return this._setScriptState(script, !isBlackboxed ? [] : positions).then(this._sourceMapLoadedForTest);
        /**
         * @param {!WebInspector.SourceMap.Entry} a
         * @param {!WebInspector.SourceMap.Entry} b
         * @return {number}
         */
        function mappingComparator(a, b)
        {
            if (a.lineNumber !== b.lineNumber)
                return a.lineNumber - b.lineNumber;
            return a.columnNumber - b.columnNumber;
        }
    },

    _sourceMapLoadedForTest: function()
    {
        // This method is sniffed in tests.
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @return {?string}
     */
    _uiSourceCodeURL: function(uiSourceCode)
    {
        var networkURL = this._networkMapping.networkURL(uiSourceCode);
        var projectType = uiSourceCode.project().type();
        if (projectType === WebInspector.projectTypes.Debugger)
            return null;
        var url = projectType === WebInspector.projectTypes.Formatter ? uiSourceCode.url() : networkURL;
        return url ? url : null;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @return {boolean}
     */
    canBlackboxUISourceCode: function(uiSourceCode)
    {
        var url = this._uiSourceCodeURL(uiSourceCode);
        return url ? !!this._urlToRegExpString(url) : false;
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     */
    blackboxUISourceCode: function(uiSourceCode)
    {
        var url = this._uiSourceCodeURL(uiSourceCode);
        if (url)
            this._blackboxURL(url);
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     */
    unblackboxUISourceCode: function(uiSourceCode)
    {
        var url = this._uiSourceCodeURL(uiSourceCode);
        if (url)
            this._unblackboxURL(url);
    },

    blackboxContentScripts: function()
    {
        WebInspector.moduleSetting("skipContentScripts").set(true);
    },

    unblackboxContentScripts: function()
    {
        WebInspector.moduleSetting("skipContentScripts").set(false);
    },

    /**
     * @param {string} url
     */
    _blackboxURL: function(url)
    {
        var regexPatterns = WebInspector.moduleSetting("skipStackFramesPattern").getAsArray();
        var regexValue = this._urlToRegExpString(url);
        if (!regexValue)
            return;
        var found = false;
        for (var i = 0; i < regexPatterns.length; ++i) {
            var item = regexPatterns[i];
            if (item.pattern === regexValue) {
                item.disabled = false;
                found = true;
                break;
            }
        }
        if (!found)
            regexPatterns.push({ pattern: regexValue });
        WebInspector.moduleSetting("skipStackFramesPattern").setAsArray(regexPatterns);
    },

    /**
     * @param {string} url
     */
    _unblackboxURL: function(url)
    {
        var regexPatterns = WebInspector.moduleSetting("skipStackFramesPattern").getAsArray();
        var regexValue = WebInspector.blackboxManager._urlToRegExpString(url);
        if (!regexValue)
            return;
        regexPatterns = regexPatterns.filter(function(item) {
            return item.pattern !== regexValue;
        });
        for (var i = 0; i < regexPatterns.length; ++i) {
            var item = regexPatterns[i];
            if (item.disabled)
                continue;
            try {
                var regex = new RegExp(item.pattern);
                if (regex.test(url))
                    item.disabled = true;
            } catch (e) {
            }
        }
        WebInspector.moduleSetting("skipStackFramesPattern").setAsArray(regexPatterns);
    },

    _patternChanged: function()
    {
        this._isBlackboxedURLCache.clear();

        var promises = [];
        for (var debuggerModel of WebInspector.DebuggerModel.instances()) {
            for (var scriptId in debuggerModel.scripts) {
                var script = debuggerModel.scripts[scriptId];
                promises.push(this._addScript(script)
                                  .then(loadSourceMap.bind(this, script)));
            }
        }
        Promise.all(promises).then(this._patternChangeFinishedForTests);

        /**
         * @param {!WebInspector.Script} script
         * @return {!Promise<undefined>}
         * @this {WebInspector.BlackboxManager}
         */
        function loadSourceMap(script)
        {
            return this.sourceMapLoaded(script, this._debuggerWorkspaceBinding.sourceMapForScript(script));
        }
    },

    _patternChangeFinishedForTests: function()
    {
        // This method is sniffed in tests.
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _globalObjectCleared: function(event)
    {
        var debuggerModel = /** @type {!WebInspector.DebuggerModel} */ (event.target);
        this._debuggerModelData.delete(debuggerModel);
        this._isBlackboxedURLCache.clear();
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _parsedScriptSource: function(event)
    {
        var script = /** @type {!WebInspector.Script} */ (event.data);
        this._addScript(script);
    },

    /**
     * @param {!WebInspector.Script} script
     * @return {!Promise<undefined>}
     */
    _addScript: function(script)
    {
        var blackboxed = this._isBlackboxedScript(script);
        return this._setScriptState(script, blackboxed ? [ { line: 0, column: 0 } ] : []);
    },

    /**
     * @param {!WebInspector.Script} script
     * @return {boolean}
     */
    _isBlackboxedScript: function(script)
    {
        return this.isBlackboxedURL(script.sourceURL, script.isContentScript());
    },

    /**
     * @param {!WebInspector.Script} script
     * @return {?Array<!DebuggerAgent.ScriptPosition>}
     */
    _scriptPositions: function(script)
    {
        if (this._debuggerModelData.has(script.debuggerModel))
            return this._debuggerModelData.get(script.debuggerModel).get(script.scriptId) || null;
        return null;
    },

    /**
     * @param {!WebInspector.Script} script
     * @param {!Array<!DebuggerAgent.ScriptPosition>} positions
     */
    _setScriptPositions: function(script, positions)
    {
        var debuggerModel = script.debuggerModel;
        if (!this._debuggerModelData.has(debuggerModel))
            this._debuggerModelData.set(debuggerModel, new Map());
        this._debuggerModelData.get(debuggerModel).set(script.scriptId, positions);
    },

    /**
     * @param {!WebInspector.Script} script
     * @param {!Array<!DebuggerAgent.ScriptPosition>} positions
     * @return {!Promise<undefined>}
     */
    _setScriptState: function(script, positions)
    {
        var previousScriptState = this._scriptPositions(script);
        if (previousScriptState) {
            var hasChanged = false;
            hasChanged = previousScriptState.length !== positions.length;
            for (var i = 0; !hasChanged && i < positions.length; ++i)
                hasChanged = positions[i].line !== previousScriptState[i].line || positions[i].column !== previousScriptState[i].column;
            if (!hasChanged)
                return Promise.resolve();
        } else {
            if (positions.length === 0)
                return Promise.resolve().then(updateState.bind(this, false));
        }

        return script.setBlackboxedRanges(positions).then(updateState.bind(this));

        /**
         * @param {boolean} success
         * @this {WebInspector.BlackboxManager}
         */
        function updateState(success)
        {
            if (success) {
                this._setScriptPositions(script, positions);
                this._debuggerWorkspaceBinding.updateLocations(script);
                var isBlackboxed = positions.length !== 0;
                if (!isBlackboxed && script.sourceMapURL)
                    this._debuggerWorkspaceBinding.maybeLoadSourceMap(script);
            } else {
                var hasPositions = !!this._scriptPositions(script);
                if (!hasPositions)
                    this._setScriptPositions(script, []);
            }
        }
    },

    /**
     * @param {string} url
     * @return {string}
     */
    _urlToRegExpString: function(url)
    {
        var parsedURL = new WebInspector.ParsedURL(url);
        if (parsedURL.isAboutBlank() || parsedURL.isDataURL())
            return "";
        if (!parsedURL.isValid)
            return "^" + url.escapeForRegExp() + "$";
        var name = parsedURL.lastPathComponent;
        if (name)
            name = "/" + name;
        else if (parsedURL.folderPathComponents)
            name = parsedURL.folderPathComponents + "/";
        if (!name)
            name = parsedURL.host;
        if (!name)
            return "";
        var scheme = parsedURL.scheme;
        var prefix = "";
        if (scheme && scheme !== "http" && scheme !== "https") {
            prefix = "^" + scheme + "://";
            if (scheme === "chrome-extension")
                prefix += parsedURL.host + "\\b";
            prefix += ".*";
        }
        return prefix + name.escapeForRegExp() + (url.endsWith(name) ? "$" : "\\b");
    }
}

/** @type {!WebInspector.BlackboxManager} */
WebInspector.blackboxManager;
;/* NetworkMapping.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {!WebInspector.TargetManager} targetManager
 * @param {!WebInspector.Workspace} workspace
 * @param {!WebInspector.FileSystemWorkspaceBinding} fileSystemWorkspaceBinding
 * @param {!WebInspector.FileSystemMapping} fileSystemMapping
 */
WebInspector.NetworkMapping = function(targetManager, workspace, fileSystemWorkspaceBinding, fileSystemMapping)
{
    this._targetManager = targetManager;
    this._workspace = workspace;
    this._fileSystemWorkspaceBinding = fileSystemWorkspaceBinding;
    this._fileSystemMapping = fileSystemMapping;
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.RevealSourceLine, this._revealSourceLine, this);

    // For now, following block is here primarily for testing since in the real life, network manager is created early enough to capture those events.
    var fileSystemManager = fileSystemWorkspaceBinding.fileSystemManager();
    for (var path of fileSystemManager.fileSystemPaths()) {
        var fileSystem = fileSystemManager.fileSystem(path);
        this._fileSystemAdded(new WebInspector.Event(fileSystemManager, WebInspector.IsolatedFileSystemManager.Events.FileSystemAdded, fileSystem));
    }
    if (fileSystemManager.fileSystemsLoaded())
        this._fileSystemsLoaded();

    fileSystemManager.addEventListener(WebInspector.IsolatedFileSystemManager.Events.FileSystemAdded, this._fileSystemAdded, this);
    fileSystemManager.addEventListener(WebInspector.IsolatedFileSystemManager.Events.FileSystemRemoved, this._fileSystemRemoved, this);
    fileSystemManager.addEventListener(WebInspector.IsolatedFileSystemManager.Events.FileSystemsLoaded, this._fileSystemsLoaded, this);

    this._fileSystemMapping.addEventListener(WebInspector.FileSystemMapping.Events.FileMappingAdded, this._fileSystemMappingChanged, this);
    this._fileSystemMapping.addEventListener(WebInspector.FileSystemMapping.Events.FileMappingRemoved, this._fileSystemMappingChanged, this);
}

WebInspector.NetworkMapping.prototype = {
    /**
     * @param {!WebInspector.Event} event
     */
    _fileSystemAdded: function(event)
    {
        this._addingFileSystem = true;
        var fileSystem = /** @type {!WebInspector.IsolatedFileSystem} */ (event.data);
        this._fileSystemMapping.addFileSystem(fileSystem.path());

        var mappings = fileSystem.projectProperty("mappings");
        for (var i = 0; Array.isArray(mappings) && i < mappings.length; ++i) {
            var mapping = mappings[i];
            if (!mapping || typeof mapping !== "object")
                continue;
            var folder = mapping["folder"];
            var url = mapping["url"];
            if (typeof folder !== "string" || typeof url !== "string")
                continue;
            this._fileSystemMapping.addNonConfigurableFileMapping(fileSystem.path(), url, folder);
        }
        this._addingFileSystem = false;
        this._fileSystemMappingChanged();
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _fileSystemRemoved: function(event)
    {
        var fileSystem = /** @type {!WebInspector.IsolatedFileSystem} */ (event.data);
        this._fileSystemMapping.removeFileSystem(fileSystem.path());
        this._fileSystemMappingChanged();
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @return {string}
     */
    networkURL: function(uiSourceCode)
    {
        if (uiSourceCode.project().type() === WebInspector.projectTypes.FileSystem) {
            var fileSystemPath = this._fileSystemWorkspaceBinding.fileSystemPath(uiSourceCode.project().id());
            return this._networkURLForFileSystemURL(fileSystemPath, uiSourceCode.url());
        }
        return uiSourceCode.url();
    },

    /**
     * @param {string} url
     * @return {boolean}
     */
    hasMappingForNetworkURL: function(url)
    {
        return this._fileSystemMapping.hasMappingForNetworkURL(url);
    },

    /**
     * @param {!WebInspector.Target} target
     * @param {?WebInspector.ResourceTreeFrame} frame
     * @param {string} url
     * @return {?WebInspector.UISourceCode}
     */
    _networkUISourceCodeForURL: function(target, frame, url)
    {
        return this._workspace.uiSourceCode(WebInspector.NetworkProject.projectId(target, frame, false), url);
    },

    /**
     * @param {!WebInspector.Target} target
     * @param {?WebInspector.ResourceTreeFrame} frame
     * @param {string} url
     * @return {?WebInspector.UISourceCode}
     */
    _contentScriptUISourceCodeForURL: function(target, frame, url)
    {
        return this._workspace.uiSourceCode(WebInspector.NetworkProject.projectId(target, frame, true), url);
    },

    /**
     * @param {string} url
     * @return {?WebInspector.UISourceCode}
     */
    _fileSystemUISourceCodeForURL: function(url)
    {
        var file = this._fileSystemMapping.fileForURL(url);
        if (file) {
            var projectId = WebInspector.FileSystemWorkspaceBinding.projectId(file.fileSystemPath);
            return this._workspace.uiSourceCode(projectId, file.fileURL);
        }
        return null;
    },

    /**
     * @param {!WebInspector.Target} target
     * @param {?WebInspector.ResourceTreeFrame} frame
     * @param {string} url
     * @return {?WebInspector.UISourceCode}
     */
    _uiSourceCodeForURL: function(target, frame, url)
    {
        return this._fileSystemUISourceCodeForURL(url) || this._networkUISourceCodeForURL(target, frame, url) || this._contentScriptUISourceCodeForURL(target, frame, url);
    },

    /**
     * @param {string} url
     * @param {!WebInspector.Script} script
     * @return {?WebInspector.UISourceCode}
     */
    uiSourceCodeForScriptURL: function(url, script)
    {
        var frame = WebInspector.ResourceTreeFrame.fromScript(script);
        return this._uiSourceCodeForURL(script.target(), frame, url);
    },

    /**
     * @param {string} url
     * @param {!WebInspector.CSSStyleSheetHeader} header
     * @return {?WebInspector.UISourceCode}
     */
    uiSourceCodeForStyleURL: function(url, header)
    {
        var frame = WebInspector.ResourceTreeFrame.fromStyleSheet(header);
        return this._uiSourceCodeForURL(header.target(), frame, url);
    },

    /**
     * @param {string} url
     * @return {?WebInspector.UISourceCode}
     */
    uiSourceCodeForURLForAnyTarget: function(url)
    {
        return this._fileSystemUISourceCodeForURL(url) || WebInspector.workspace.uiSourceCodeForURL(url);
    },

    /**
     * @param {string} fileSystemPath
     * @param {string} filePath
     * @return {string}
     */
    _networkURLForFileSystemURL: function(fileSystemPath, filePath)
    {
        return this._fileSystemMapping.networkURLForFileSystemURL(fileSystemPath, filePath);
    },

    /**
     * @param {!WebInspector.UISourceCode} networkUISourceCode
     * @param {!WebInspector.UISourceCode} uiSourceCode
     */
    addMapping: function(networkUISourceCode, uiSourceCode)
    {
        var url = this.networkURL(networkUISourceCode);
        var path = uiSourceCode.url();
        var fileSystemPath = this._fileSystemWorkspaceBinding.fileSystemPath(uiSourceCode.project().id());
        this._fileSystemMapping.addMappingForResource(url, fileSystemPath, path);
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     */
    removeMapping: function(uiSourceCode)
    {
        var networkURL = this.networkURL(uiSourceCode);
        this._fileSystemMapping.removeMappingForURL(networkURL);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _revealSourceLine: function(event)
    {
        var url = /** @type {string} */ (event.data["url"]);
        var lineNumber = /** @type {number} */ (event.data["lineNumber"]);
        var columnNumber = /** @type {number} */ (event.data["columnNumber"]);

        var uiSourceCode = this.uiSourceCodeForURLForAnyTarget(url);
        if (uiSourceCode) {
            WebInspector.Revealer.reveal(uiSourceCode.uiLocation(lineNumber, columnNumber));
            return;
        }

        /**
         * @param {!WebInspector.Event} event
         * @this {WebInspector.NetworkMapping}
         */
        function listener(event)
        {
            var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (event.data);
            if (this.networkURL(uiSourceCode) === url) {
                WebInspector.Revealer.reveal(uiSourceCode.uiLocation(lineNumber, columnNumber));
                this._workspace.removeEventListener(WebInspector.Workspace.Events.UISourceCodeAdded, listener, this);
            }
        }

        this._workspace.addEventListener(WebInspector.Workspace.Events.UISourceCodeAdded, listener, this);
    },

    _fileSystemsLoaded: function()
    {
        this._fileSystemsReady = true;
    },

    _fileSystemMappingChanged: function()
    {
        if (!this._fileSystemsReady || this._addingFileSystem)
            return;
        this._targetManager.suspendAndResumeAllTargets();
    },

    dispose: function()
    {
        this._fileSystemWorkspaceBinding.fileSystemManager().removeEventListener(WebInspector.IsolatedFileSystemManager.Events.FileSystemAdded, this._fileSystemAdded, this);
        this._fileSystemWorkspaceBinding.fileSystemManager().removeEventListener(WebInspector.IsolatedFileSystemManager.Events.FileSystemRemoved, this._fileSystemRemoved, this);
        this._fileSystemMapping.removeEventListener(WebInspector.FileSystemMapping.Events.FileMappingAdded, this._fileSystemMappingChanged, this);
        this._fileSystemMapping.removeEventListener(WebInspector.FileSystemMapping.Events.FileMappingRemoved, this._fileSystemMappingChanged, this);
    }
}

/**
 * @type {!WebInspector.NetworkMapping}
 */
WebInspector.networkMapping;
;/* NetworkProject.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {!WebInspector.TargetManager} targetManager
 * @param {!WebInspector.Workspace} workspace
 * @param {!WebInspector.NetworkMapping} networkMapping
 * @implements {WebInspector.TargetManager.Observer}
 */
WebInspector.NetworkProjectManager = function(targetManager, workspace, networkMapping)
{
    this._workspace = workspace;
    this._networkMapping = networkMapping;
    targetManager.observeTargets(this);
}

WebInspector.NetworkProjectManager.prototype = {
    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target)
    {
        new WebInspector.NetworkProject(target, this._workspace, this._networkMapping);
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target)
    {
        WebInspector.NetworkProject.forTarget(target)._dispose();
    }
}

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!WebInspector.Target} target
 * @param {!WebInspector.Workspace} workspace
 * @param {!WebInspector.NetworkMapping} networkMapping
 */
WebInspector.NetworkProject = function(target, workspace, networkMapping)
{
    WebInspector.SDKObject.call(this, target);
    this._workspace = workspace;
    this._networkMapping = networkMapping;
    /** @type {!Map<string, !WebInspector.ContentProviderBasedProject>} */
    this._workspaceProjects = new Map();
    target[WebInspector.NetworkProject._networkProjectSymbol] = this;

    target.resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.ResourceAdded, this._resourceAdded, this);
    target.resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.FrameWillNavigate, this._frameWillNavigate, this);
    target.resourceTreeModel.addEventListener(WebInspector.ResourceTreeModel.EventTypes.MainFrameNavigated, this._mainFrameNavigated, this);

    var debuggerModel = WebInspector.DebuggerModel.fromTarget(target);
    if (debuggerModel) {
        debuggerModel.addEventListener(WebInspector.DebuggerModel.Events.ParsedScriptSource, this._parsedScriptSource, this);
        debuggerModel.addEventListener(WebInspector.DebuggerModel.Events.FailedToParseScriptSource, this._parsedScriptSource, this);
    }
    var cssModel = WebInspector.CSSStyleModel.fromTarget(target);
    if (cssModel) {
        cssModel.addEventListener(WebInspector.CSSStyleModel.Events.StyleSheetAdded, this._styleSheetAdded, this);
        cssModel.addEventListener(WebInspector.CSSStyleModel.Events.StyleSheetRemoved, this._styleSheetRemoved, this);
    }
    target.targetManager().addEventListener(WebInspector.TargetManager.Events.SuspendStateChanged, this._suspendStateChanged, this);
}

WebInspector.NetworkProject._networkProjectSymbol = Symbol("networkProject");
WebInspector.NetworkProject._resourceSymbol = Symbol("resource");
WebInspector.NetworkProject._scriptSymbol = Symbol("script");
WebInspector.NetworkProject._styleSheetSymbol = Symbol("styleSheet");
WebInspector.NetworkProject._targetSymbol = Symbol("target");
WebInspector.NetworkProject._frameSymbol = Symbol("frame");

/**
 * @param {!WebInspector.Target} target
 * @param {?WebInspector.ResourceTreeFrame} frame
 * @param {boolean} isContentScripts
 * @return {string}
 */
WebInspector.NetworkProject.projectId = function(target, frame, isContentScripts)
{
    return target.id() + ":" + (frame ? frame.id : "") + ":" + (isContentScripts ? "contentscripts" : "");
}

/**
 * @param {!WebInspector.Target} target
 * @return {!WebInspector.NetworkProject}
 */
WebInspector.NetworkProject.forTarget = function(target)
{
    return target[WebInspector.NetworkProject._networkProjectSymbol];
}

/**
 * @param {!WebInspector.Project} project
 * @return {?WebInspector.Target} target
 */
WebInspector.NetworkProject.targetForProject = function(project)
{
    return project[WebInspector.NetworkProject._targetSymbol] || null;
}

/**
 * @param {!WebInspector.Project} project
 * @return {?WebInspector.ResourceTreeFrame}
 */
WebInspector.NetworkProject.frameForProject = function(project)
{
    return project[WebInspector.NetworkProject._frameSymbol] || null;
}

/**
 * @param {!WebInspector.UISourceCode} uiSourceCode
 * @return {?WebInspector.Target} target
 */
WebInspector.NetworkProject.targetForUISourceCode = function(uiSourceCode)
{
    return uiSourceCode[WebInspector.NetworkProject._targetSymbol] || null;
}

/**
 * @param {!WebInspector.UISourceCode} uiSourceCode
 * @return {string}
 */
WebInspector.NetworkProject.uiSourceCodeMimeType = function(uiSourceCode)
{
    if (uiSourceCode[WebInspector.NetworkProject._scriptSymbol] ||
        uiSourceCode[WebInspector.NetworkProject._styleSheetSymbol]) {
        return uiSourceCode.contentType().canonicalMimeType();
    }
    var resource = uiSourceCode[WebInspector.NetworkProject._resourceSymbol];
    if (resource)
        return resource.mimeType;
    var mimeType = WebInspector.ResourceType.mimeFromURL(uiSourceCode.url());
    return mimeType || uiSourceCode.contentType().canonicalMimeType();
}

/**
 * @param {!WebInspector.UISourceCode} uiSourceCode
 * @return {?WebInspector.ResourceTreeFrame}
 */
WebInspector.NetworkProject.uiSourceCodeFrame = function(uiSourceCode)
{
    var target = uiSourceCode[WebInspector.NetworkProject._targetSymbol];
    if (!target)
        return null;

    var frameId;

    var script = uiSourceCode[WebInspector.NetworkProject._scriptSymbol];
    if (script) {
        var executionContext = script.executionContext();
        if (executionContext)
            frameId = executionContext.frameId;
    }

    if (!frameId) {
        var header = uiSourceCode[WebInspector.NetworkProject._styleSheetSymbol];
        if (header)
            frameId = header.frameId;
    }

    if (!frameId) {
        var resource = uiSourceCode[WebInspector.NetworkProject._resourceSymbol];
        if (resource)
            frameId = resource.frameId;
    }

    return frameId ? target.resourceTreeModel.frameForId(frameId) : null;
}

WebInspector.NetworkProject.prototype = {
    /**
     * @param {?WebInspector.ResourceTreeFrame} frame
     * @param {boolean} isContentScripts
     * @return {!WebInspector.ContentProviderBasedProject}
     */
    _workspaceProject: function(frame, isContentScripts)
    {
        var projectId = WebInspector.NetworkProject.projectId(this.target(), frame, isContentScripts);
        var projectType = isContentScripts ? WebInspector.projectTypes.ContentScripts : WebInspector.projectTypes.Network;

        var project = this._workspaceProjects.get(projectId);
        if (project)
            return project;

        project = new WebInspector.ContentProviderBasedProject(this._workspace, projectId, projectType, "");
        project[WebInspector.NetworkProject._targetSymbol] = this.target();
        project[WebInspector.NetworkProject._frameSymbol] = frame;
        this._workspaceProjects.set(projectId, project);
        return project;
    },

    /**
     * @param {string} url
     * @param {?WebInspector.ResourceTreeFrame} frame
     * @param {!WebInspector.ContentProvider} contentProvider
     * @param {boolean=} isContentScript
     * @return {?WebInspector.UISourceCode}
     */
    addFileForURL: function(url, contentProvider, frame, isContentScript)
    {
        return this._createFile(url, contentProvider, frame, isContentScript || false, true);
    },

    /**
     * @param {?WebInspector.ResourceTreeFrame} frame
     * @param {string} url
     */
    _removeFileForURL: function(frame, url)
    {
        var project = this._workspaceProjects.get(WebInspector.NetworkProject.projectId(this.target(), frame, false));
        if (!project)
            return;
        project.removeFile(url);
    },

    _populate: function()
    {
        /**
         * @param {!WebInspector.ResourceTreeFrame} frame
         * @this {WebInspector.NetworkProject}
         */
        function populateFrame(frame)
        {
            for (var i = 0; i < frame.childFrames.length; ++i)
                populateFrame.call(this, frame.childFrames[i]);

            var resources = frame.resources();
            for (var i = 0; i < resources.length; ++i)
                this._addResource(resources[i]);
        }

        var mainFrame = this.target().resourceTreeModel.mainFrame;
        if (mainFrame)
            populateFrame.call(this, mainFrame);
    },

    /**
     * @param {!WebInspector.UISourceCode} uiSourceCode
     * @param {!WebInspector.ContentProvider} contentProvider
     */
    _addUISourceCodeWithProvider: function(uiSourceCode, contentProvider)
    {
        /** @type {!WebInspector.ContentProviderBasedProject} */ (uiSourceCode.project()).addUISourceCodeWithProvider(uiSourceCode, contentProvider);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _parsedScriptSource: function(event)
    {
        var script = /** @type {!WebInspector.Script} */ (event.data);
        if (!script.sourceURL || script.isLiveEdit() || (script.isInlineScript() && !script.hasSourceURL))
            return;
        // Filter out embedder injected content scripts.
        if (script.isContentScript() && !script.hasSourceURL) {
            var parsedURL = new WebInspector.ParsedURL(script.sourceURL);
            if (!parsedURL.isValid)
                return;
        }
        var uiSourceCode = this._createFile(script.sourceURL, script, WebInspector.ResourceTreeFrame.fromScript(script), script.isContentScript(), false);
        if (uiSourceCode) {
            uiSourceCode[WebInspector.NetworkProject._scriptSymbol] = script;
            this._addUISourceCodeWithProvider(uiSourceCode, script);
        }
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _styleSheetAdded: function(event)
    {
        var header = /** @type {!WebInspector.CSSStyleSheetHeader} */ (event.data);
        if (header.isInline && !header.hasSourceURL && header.origin !== "inspector")
            return;

        var uiSourceCode = this._createFile(header.resourceURL(), header, WebInspector.ResourceTreeFrame.fromStyleSheet(header), false, false);
        if (uiSourceCode) {
            uiSourceCode[WebInspector.NetworkProject._styleSheetSymbol] = header;
            this._addUISourceCodeWithProvider(uiSourceCode, header);
        }
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _styleSheetRemoved: function(event)
    {
        var header = /** @type {!WebInspector.CSSStyleSheetHeader} */ (event.data);
        if (header.isInline && !header.hasSourceURL && header.origin !== "inspector")
            return;

        this._removeFileForURL(WebInspector.ResourceTreeFrame.fromStyleSheet(header), header.resourceURL());
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _resourceAdded: function(event)
    {
        var resource = /** @type {!WebInspector.Resource} */ (event.data);
        this._addResource(resource);
    },

    /**
     * @param {!WebInspector.Resource} resource
     */
    _addResource: function(resource)
    {
        var resourceType = resource.resourceType();
        // Only load selected resource types from resources.
        if (resourceType !== WebInspector.resourceTypes.Image &&
            resourceType !== WebInspector.resourceTypes.Font &&
            resourceType !== WebInspector.resourceTypes.Document &&
            resourceType !== WebInspector.resourceTypes.Manifest) {
            return;
        }

        // Ignore non-images and non-fonts.
        if (resourceType === WebInspector.resourceTypes.Image && resource.mimeType && !resource.mimeType.startsWith("image"))
            return;
        if (resourceType === WebInspector.resourceTypes.Font && resource.mimeType && !resource.mimeType.includes("font"))
            return;
        if ((resourceType === WebInspector.resourceTypes.Image || resourceType === WebInspector.resourceTypes.Font) && resource.contentURL().startsWith("data:"))
            return;

        // Never load document twice.
        if (this._workspace.uiSourceCodeForURL(resource.url))
            return;

        var uiSourceCode = this._createFile(resource.url, resource, WebInspector.ResourceTreeFrame.fromResource(resource), false, false);
        if (uiSourceCode) {
            uiSourceCode[WebInspector.NetworkProject._resourceSymbol] = resource;
            this._addUISourceCodeWithProvider(uiSourceCode, resource);
        }
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _frameWillNavigate: function(event)
    {
        var frame = /** @type {!WebInspector.ResourceTreeFrame} */ (event.data);
        var project = this._workspaceProject(frame, false);
        for (var resource of frame.resources())
            project.removeUISourceCode(resource.url);
        project = this._workspaceProject(frame, true);
        for (var resource of frame.resources())
            project.removeUISourceCode(resource.url);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _mainFrameNavigated: function(event)
    {
        this._reset();
        this._populate();
    },

    _suspendStateChanged: function()
    {
        if (this.target().targetManager().allTargetsSuspended())
            this._reset();
        else
            this._populate();
    },

    /**
     * @param {string} url
     * @param {!WebInspector.ContentProvider} contentProvider
     * @param {?WebInspector.ResourceTreeFrame} frame
     * @param {boolean} isContentScript
     * @param {boolean} addIntoProject
     * @return {?WebInspector.UISourceCode}
     */
    _createFile: function(url, contentProvider, frame, isContentScript, addIntoProject)
    {
        if (this._networkMapping.hasMappingForNetworkURL(url))
            return null;

        var project = this._workspaceProject(frame, isContentScript);
        var uiSourceCode = project.createUISourceCode(url, contentProvider.contentType());
        uiSourceCode[WebInspector.NetworkProject._targetSymbol] = this.target();
        if (addIntoProject)
            project.addUISourceCodeWithProvider(uiSourceCode, contentProvider);
        return uiSourceCode;
    },

    _dispose: function()
    {
        this._reset();
        var target = this.target();
        target.resourceTreeModel.removeEventListener(WebInspector.ResourceTreeModel.EventTypes.ResourceAdded, this._resourceAdded, this);
        target.resourceTreeModel.removeEventListener(WebInspector.ResourceTreeModel.EventTypes.MainFrameNavigated, this._mainFrameNavigated, this);
        var debuggerModel = WebInspector.DebuggerModel.fromTarget(target);
        if (debuggerModel) {
            debuggerModel.removeEventListener(WebInspector.DebuggerModel.Events.ParsedScriptSource, this._parsedScriptSource, this);
            debuggerModel.removeEventListener(WebInspector.DebuggerModel.Events.FailedToParseScriptSource, this._parsedScriptSource, this);
        }
        var cssModel = WebInspector.CSSStyleModel.fromTarget(target);
        if (cssModel) {
            cssModel.removeEventListener(WebInspector.CSSStyleModel.Events.StyleSheetAdded, this._styleSheetAdded, this);
            cssModel.removeEventListener(WebInspector.CSSStyleModel.Events.StyleSheetRemoved, this._styleSheetRemoved, this);
        }
        delete target[WebInspector.NetworkProject._networkProjectSymbol];
    },

    _reset: function()
    {
        for (var project of this._workspaceProjects.values())
            project.reset();
        this._workspaceProjects.clear();
    },

    __proto__: WebInspector.SDKObject.prototype
}
;/* PresentationConsoleMessageHelper.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {!WebInspector.Workspace} workspace
 */
WebInspector.PresentationConsoleMessageHelper = function(workspace)
{
    this._workspace = workspace;

    /** @type {!Object.<string, !Array.<!WebInspector.ConsoleMessage>>} */
    this._pendingConsoleMessages = {};

    /** @type {!Array.<!WebInspector.PresentationConsoleMessage>} */
    this._presentationConsoleMessages = [];

    WebInspector.multitargetConsoleModel.addEventListener(WebInspector.ConsoleModel.Events.ConsoleCleared, this._consoleCleared, this);
    WebInspector.multitargetConsoleModel.addEventListener(WebInspector.ConsoleModel.Events.MessageAdded, this._onConsoleMessageAdded, this);
    WebInspector.multitargetConsoleModel.messages().forEach(this._consoleMessageAdded, this);
    WebInspector.targetManager.addModelListener(WebInspector.DebuggerModel, WebInspector.DebuggerModel.Events.ParsedScriptSource, this._parsedScriptSource, this);
    WebInspector.targetManager.addModelListener(WebInspector.DebuggerModel, WebInspector.DebuggerModel.Events.FailedToParseScriptSource, this._parsedScriptSource, this);
    WebInspector.targetManager.addModelListener(WebInspector.DebuggerModel, WebInspector.DebuggerModel.Events.GlobalObjectCleared, this._debuggerReset, this);
}

WebInspector.PresentationConsoleMessageHelper.prototype = {
    /**
     * @param {!WebInspector.Event} event
     */
    _onConsoleMessageAdded: function(event)
    {
        var message = /** @type {!WebInspector.ConsoleMessage} */ (event.data);
        this._consoleMessageAdded(message);
    },

    /**
     * @param {!WebInspector.ConsoleMessage} message
     */
    _consoleMessageAdded: function(message)
    {
        if (!message.url || !message.isErrorOrWarning())
            return;

        var rawLocation = this._rawLocation(message);
        if (rawLocation)
            this._addConsoleMessageToScript(message, rawLocation);
        else
            this._addPendingConsoleMessage(message);
    },

    /**
     * @param {!WebInspector.ConsoleMessage} message
     * @return {?WebInspector.DebuggerModel.Location}
     */
    _rawLocation: function(message)
    {
        var debuggerModel = WebInspector.DebuggerModel.fromTarget(message.target());
        if (!debuggerModel)
            return null;
        var callFrame = message.stackTrace && message.stackTrace.callFrames ? message.stackTrace.callFrames[0] : null;
        // FIXME(62725): stack trace line/column numbers are one-based.
        var lineNumber = callFrame ? callFrame.lineNumber - 1 : message.line - 1;
        var columnNumber = message.column ? message.column - 1 : 0;
        if (callFrame && callFrame.columnNumber)
            columnNumber = callFrame.columnNumber - 1;
        if (message.scriptId)
            return debuggerModel.createRawLocationByScriptId(message.scriptId, lineNumber, columnNumber);
        return debuggerModel.createRawLocationByURL(message.url || "", lineNumber, columnNumber);
    },

    /**
     * @param {!WebInspector.ConsoleMessage} message
     * @param {!WebInspector.DebuggerModel.Location} rawLocation
     */
    _addConsoleMessageToScript: function(message, rawLocation)
    {
        this._presentationConsoleMessages.push(new WebInspector.PresentationConsoleMessage(message, rawLocation));
    },

    /**
     * @param {!WebInspector.ConsoleMessage} message
     */
    _addPendingConsoleMessage: function(message)
    {
        if (!message.url)
            return;
        if (!this._pendingConsoleMessages[message.url])
            this._pendingConsoleMessages[message.url] = [];
        this._pendingConsoleMessages[message.url].push(message);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _parsedScriptSource: function(event)
    {
        var script = /** @type {!WebInspector.Script} */ (event.data);

        var messages = this._pendingConsoleMessages[script.sourceURL];
        if (!messages)
            return;

        var pendingMessages = [];
        for (var i = 0; i < messages.length; i++) {
            var message = messages[i];
            var rawLocation = this._rawLocation(message);
            if (!rawLocation)
                continue;
            if (script.target() === message.target() && script.scriptId === rawLocation.scriptId)
                this._addConsoleMessageToScript(message, rawLocation);
            else
                pendingMessages.push(message);
        }

        if (pendingMessages.length)
            this._pendingConsoleMessages[script.sourceURL] = pendingMessages;
        else
            delete this._pendingConsoleMessages[script.sourceURL];
    },

    _consoleCleared: function()
    {
        this._pendingConsoleMessages = {};
        for (var i = 0; i < this._presentationConsoleMessages.length; ++i)
            this._presentationConsoleMessages[i].dispose();
        this._presentationConsoleMessages = [];
    },

    _debuggerReset: function()
    {
        this._consoleCleared();
    }
}

/**
 * @constructor
 * @param {!WebInspector.ConsoleMessage} message
 * @param {!WebInspector.DebuggerModel.Location} rawLocation
 */
WebInspector.PresentationConsoleMessage = function(message, rawLocation)
{
    this._text = message.messageText;
    this._level = message.level === WebInspector.ConsoleMessage.MessageLevel.Error ? WebInspector.UISourceCode.Message.Level.Error : WebInspector.UISourceCode.Message.Level.Warning;
    this._liveLocation = WebInspector.debuggerWorkspaceBinding.createLiveLocation(rawLocation, this._updateLocation.bind(this));
}

WebInspector.PresentationConsoleMessage.prototype = {
    /**
     * @param {!WebInspector.LiveLocation} liveLocation
     */
    _updateLocation: function(liveLocation)
    {
        if (this._uiMessage)
            this._uiMessage.remove();
        var uiLocation = liveLocation.uiLocation();
        if (!uiLocation)
            return;
        this._uiMessage = uiLocation.uiSourceCode.addLineMessage(this._level, this._text, uiLocation.lineNumber, uiLocation.columnNumber);
    },

    dispose: function()
    {
        this._liveLocation.dispose();
        if (this._uiMessage)
            this._uiMessage.remove();
    }
}

/** @type {!WebInspector.PresentationConsoleMessageHelper} */
WebInspector.presentationConsoleMessageHelper;
;/* ResourceUtils.js */
/*
 * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.
 * Copyright (C) 2007 Matt Lilek (pewtermoose@gmail.com).
 * Copyright (C) 2009 Joseph Pecoraro
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @param {string} url
 * @return {?WebInspector.Resource}
 */
WebInspector.resourceForURL = function(url)
{
    var targets = WebInspector.targetManager.targets();
    for (var i = 0; i < targets.length; ++i) {
        var resource = targets[i].resourceTreeModel.resourceForURL(url);
        if (resource)
            return resource;
    }
    return null;
}

/**
 * @param {function(!WebInspector.Resource)} callback
 */
WebInspector.forAllResources = function(callback)
{
    var targets = WebInspector.targetManager.targets();
    for (var i = 0; i < targets.length; ++i)
        targets[i].resourceTreeModel.forAllResources(callback);
}

/**
 * @param {string} url
 * @return {string}
 */
WebInspector.displayNameForURL = function(url)
{
    if (!url)
        return "";

    var resource = WebInspector.resourceForURL(url);
    if (resource)
        return resource.displayName;

    var uiSourceCode = WebInspector.networkMapping.uiSourceCodeForURLForAnyTarget(url);
    if (uiSourceCode)
        return uiSourceCode.displayName();

    if (!WebInspector.targetManager.inspectedPageURL())
        return url.trimURL("");

    var parsedURL = WebInspector.targetManager.inspectedPageURL().asParsedURL();
    var lastPathComponent = parsedURL ? parsedURL.lastPathComponent : parsedURL;
    var index = WebInspector.targetManager.inspectedPageURL().indexOf(lastPathComponent);
    if (index !== -1 && index + lastPathComponent.length === WebInspector.targetManager.inspectedPageURL().length) {
        var baseURL = WebInspector.targetManager.inspectedPageURL().substring(0, index);
        if (url.startsWith(baseURL))
            return url.substring(index);
    }

    if (!parsedURL)
        return url;

    var displayName = url.trimURL(parsedURL.host);
    return displayName === "/" ? parsedURL.host + "/" : displayName;
}
;/* TempFile.js */
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;

/**
 * @constructor
 */
WebInspector.TempFile = function()
{
    this._fileEntry = null;
    this._writer = null;
}

/**
 * @param {string} dirPath
 * @param {string} name
 * @return {!Promise.<!WebInspector.TempFile>}
 */
WebInspector.TempFile.create = function(dirPath, name)
{
    var file = new WebInspector.TempFile();

    function requestTempFileSystem()
    {
        return new Promise(window.requestFileSystem.bind(window, window.TEMPORARY, 10));
    }

    /**
     * @param {!FileSystem} fs
     */
    function getDirectoryEntry(fs)
    {
        return new Promise(fs.root.getDirectory.bind(fs.root, dirPath, { create: true }));
    }

    /**
     * @param {!DirectoryEntry} dir
     */
    function getFileEntry(dir)
    {
        return new Promise(dir.getFile.bind(dir, name, { create: true }));
    }

    /**
     * @param {!FileEntry} fileEntry
     */
    function createFileWriter(fileEntry)
    {
        file._fileEntry = fileEntry;
        return new Promise(fileEntry.createWriter.bind(fileEntry));
    }

    /**
     * @param {!FileWriter} writer
     */
    function truncateFile(writer)
    {
        if (!writer.length) {
            file._writer = writer;
            return Promise.resolve(file);
        }

        /**
         * @param {function(?)} fulfill
         * @param {function(*)} reject
         */
        function truncate(fulfill, reject)
        {
            writer.onwriteend = fulfill;
            writer.onerror = reject;
            writer.truncate(0);
        }

        function didTruncate()
        {
            file._writer = writer;
            writer.onwriteend = null;
            writer.onerror = null;
            return Promise.resolve(file);
        }

        function onTruncateError(e)
        {
            writer.onwriteend = null;
            writer.onerror = null;
            throw e;
        }

        return new Promise(truncate).then(didTruncate, onTruncateError);
    }

    return WebInspector.TempFile.ensureTempStorageCleared()
        .then(requestTempFileSystem)
        .then(getDirectoryEntry)
        .then(getFileEntry)
        .then(createFileWriter)
        .then(truncateFile);
}

WebInspector.TempFile.prototype = {
    /**
     * @param {!Array.<string>} strings
     * @param {function(number)} callback
     */
    write: function(strings, callback)
    {
        var blob = new Blob(strings, {type: 'text/plain'});
        this._writer.onerror = function(e)
        {
            WebInspector.console.error("Failed to write into a temp file: " + e.target.error.message);
            callback(-1);
        }
        this._writer.onwriteend = function(e)
        {
            callback(e.target.length);
        }
        this._writer.write(blob);
    },

    finishWriting: function()
    {
        this._writer = null;
    },

    /**
     * @param {function(?string)} callback
     */
    read: function(callback)
    {
        this.readRange(undefined, undefined, callback);
    },

    /**
     * @param {number|undefined} startOffset
     * @param {number|undefined} endOffset
     * @param {function(?string)} callback
     */
    readRange: function(startOffset, endOffset, callback)
    {
        /**
         * @param {!Blob} file
         */
        function didGetFile(file)
        {
            var reader = new FileReader();

            if (typeof startOffset === "number" || typeof endOffset === "number")
                file = file.slice(/** @type {number} */ (startOffset), /** @type {number} */ (endOffset));
            /**
             * @this {FileReader}
             */
            reader.onloadend = function(e)
            {
                callback(/** @type {?string} */ (this.result));
            };
            reader.onerror = function(error)
            {
                WebInspector.console.error("Failed to read from temp file: " + error.message);
            };
            reader.readAsText(file);
        }
        function didFailToGetFile(error)
        {
            WebInspector.console.error("Failed to load temp file: " + error.message);
            callback(null);
        }
        this._fileEntry.file(didGetFile, didFailToGetFile);
    },

    /**
     * @param {!WebInspector.OutputStream} outputStream
     * @param {!WebInspector.OutputStreamDelegate} delegate
     */
    writeToOutputSteam: function(outputStream, delegate)
    {
        /**
         * @param {!File} file
         */
        function didGetFile(file)
        {
            var reader = new WebInspector.ChunkedFileReader(file, 10*1000*1000, delegate);
            reader.start(outputStream);
        }

        function didFailToGetFile(error)
        {
            WebInspector.console.error("Failed to load temp file: " + error.message);
            outputStream.close();
        }

        this._fileEntry.file(didGetFile, didFailToGetFile);
    },

    remove: function()
    {
        if (this._fileEntry)
            this._fileEntry.remove(function() {});
    }
}

/**
 * @constructor
 * @param {string} dirPath
 * @param {string} name
 */
WebInspector.DeferredTempFile = function(dirPath, name)
{
    /** @type {!Array.<!{strings: !Array.<string>, callback: function(number)}>} */
    this._chunks = [];
    this._tempFile = null;
    this._isWriting = false;
    this._finishCallback = null;
    this._finishedWriting = false;
    this._callsPendingOpen = [];
    this._pendingReads = [];
    WebInspector.TempFile.create(dirPath, name)
        .then(this._didCreateTempFile.bind(this), this._failedToCreateTempFile.bind(this));
}

WebInspector.DeferredTempFile.prototype = {
    /**
     * @param {!Array.<string>} strings
     * @param {function(number)=} callback
     */
    write: function(strings, callback)
    {
        if (!this._chunks)
            return;
        if (this._finishCallback)
            throw new Error("No writes are allowed after close.");
        this._chunks.push({strings: strings, callback: callback});
        if (this._tempFile && !this._isWriting)
            this._writeNextChunk();
    },

    /**
     * @param {function(?WebInspector.TempFile)} callback
     */
    finishWriting: function(callback)
    {
        this._finishCallback = callback;
        if (this._finishedWriting)
            callback(this._tempFile);
        else if (!this._isWriting && !this._chunks.length)
            this._notifyFinished();
    },

    /**
     * @param {*} e
     */
    _failedToCreateTempFile: function(e)
    {
        WebInspector.console.error("Failed to create temp file " + e.code + " : " + e.message);
        this._notifyFinished();
    },

    /**
     * @param {!WebInspector.TempFile} tempFile
     */
    _didCreateTempFile: function(tempFile)
    {
        this._tempFile = tempFile;
        var callsPendingOpen = this._callsPendingOpen;
        this._callsPendingOpen = null;
        for (var i = 0; i < callsPendingOpen.length; ++i)
            callsPendingOpen[i]();
        if (this._chunks.length)
            this._writeNextChunk();
    },

    _writeNextChunk: function()
    {
        // File was deleted while create or write was in-flight.
        if (!this._tempFile)
            return;
        var chunk = this._chunks.shift();
        this._isWriting = true;
        this._tempFile.write(/** @type {!Array.<string>} */(chunk.strings), this._didWriteChunk.bind(this, chunk.callback));
    },

    /**
     * @param {?function(number)} callback
     * @param {number} size
     */
    _didWriteChunk: function(callback, size)
    {
        this._isWriting = false;
        if (size === -1) {
            this._tempFile = null;
            this._notifyFinished();
            return;
        }
        if (callback)
            callback(size);
        if (this._chunks.length)
            this._writeNextChunk();
        else if (this._finishCallback)
            this._notifyFinished();
    },

    _notifyFinished: function()
    {
        this._finishedWriting = true;
        if (this._tempFile)
            this._tempFile.finishWriting();
        var chunks = this._chunks;
        this._chunks = [];
        for (var i = 0; i < chunks.length; ++i) {
            if (chunks[i].callback)
                chunks[i].callback(-1);
        }
        if (this._finishCallback)
            this._finishCallback(this._tempFile);
        var pendingReads = this._pendingReads;
        this._pendingReads = [];
        for (var i = 0; i < pendingReads.length; ++i)
            pendingReads[i]();
    },

    /**
     * @param {number|undefined} startOffset
     * @param {number|undefined} endOffset
     * @param {function(string?)} callback
     */
    readRange: function(startOffset, endOffset, callback)
    {
        if (!this._finishedWriting) {
            this._pendingReads.push(this.readRange.bind(this, startOffset, endOffset, callback));
            return;
        }
        if (!this._tempFile) {
            callback(null);
            return;
        }
        this._tempFile.readRange(startOffset, endOffset, callback);
    },

    /**
     * @param {!WebInspector.OutputStream} outputStream
     * @param {!WebInspector.OutputStreamDelegate} delegate
     */
    writeToOutputStream: function(outputStream, delegate)
    {
        if (this._callsPendingOpen) {
            this._callsPendingOpen.push(this.writeToOutputStream.bind(this, outputStream, delegate));
            return;
        }
        if (this._tempFile)
            this._tempFile.writeToOutputSteam(outputStream, delegate);
    },

    remove: function()
    {
        if (this._callsPendingOpen) {
            this._callsPendingOpen.push(this.remove.bind(this));
            return;
        }
        if (this._tempFile)
            this._tempFile.remove();
        this._tempFile = null;
    }
}

/**
 * @param {function(?)} fulfill
 * @param {function(*)} reject
 */
WebInspector.TempFile._clearTempStorage = function(fulfill, reject)
{
    /**
     * @param {!Event} event
     */
    function handleError(event)
    {
        WebInspector.console.error(WebInspector.UIString("Failed to clear temp storage: %s", event.data));
        reject(event.data);
    }

    /**
     * @param {!Event} event
     */
    function handleMessage(event)
    {
        if (event.data.type === "tempStorageCleared") {
            if (event.data.error)
                WebInspector.console.error(event.data.error);
            else
                fulfill(undefined);
            return;
        }
        reject(event.data);
    }

    try {
        var worker = new WorkerRuntime.Worker("temp_storage_shared_worker", "TempStorageCleaner");
        worker.onerror = handleError;
        worker.port.onmessage = handleMessage;
        worker.port.onerror = handleError;
    } catch (e) {
        if (e.name === "URLMismatchError")
            console.log("Shared worker wasn't started due to url difference. " + e);
        else
            throw e;
    }
}

/**
 * @return {!Promise.<undefined>}
 */
WebInspector.TempFile.ensureTempStorageCleared = function()
{
    if (!WebInspector.TempFile._storageCleanerPromise)
        WebInspector.TempFile._storageCleanerPromise = new Promise(WebInspector.TempFile._clearTempStorage);
    return WebInspector.TempFile._storageCleanerPromise;
}

/**
 * @constructor
 * @implements {WebInspector.BackingStorage}
 * @param {string} dirName
 */
WebInspector.TempFileBackingStorage = function(dirName)
{
    this._dirName = dirName;
    this.reset();
}

/**
 * @typedef {{
 *      string: ?string,
 *      startOffset: number,
 *      endOffset: number
 * }}
 */
WebInspector.TempFileBackingStorage.Chunk;

WebInspector.TempFileBackingStorage.prototype = {
    /**
     * @override
     * @param {string} string
     */
    appendString: function(string)
    {
        this._strings.push(string);
        this._stringsLength += string.length;
        var flushStringLength = 10 * 1024 * 1024;
        if (this._stringsLength > flushStringLength)
            this._flush(false);
    },

    /**
     * @override
     * @param {string} string
     * @return {function():!Promise.<?string>}
     */
    appendAccessibleString: function(string)
    {
        this._flush(false);
        this._strings.push(string);
        var chunk = /** @type {!WebInspector.TempFileBackingStorage.Chunk} */ (this._flush(true));

        /**
         * @param {!WebInspector.TempFileBackingStorage.Chunk} chunk
         * @param {!WebInspector.DeferredTempFile} file
         * @return {!Promise.<?string>}
         */
        function readString(chunk, file)
        {
            if (chunk.string)
                return /** @type {!Promise.<?string>} */ (Promise.resolve(chunk.string));

            console.assert(chunk.endOffset);
            if (!chunk.endOffset)
                return Promise.reject("Nor string nor offset to the string in the file were found.");

            /**
             * @param {function(?string)} fulfill
             * @param {function(*)} reject
             */
            function readRange(fulfill, reject)
            {
                // FIXME: call reject for null strings.
                file.readRange(chunk.startOffset, chunk.endOffset, fulfill);
            }

            return new Promise(readRange);
        }

        return readString.bind(null, chunk, this._file);
    },

    /**
     * @param {boolean} createChunk
     * @return {?WebInspector.TempFileBackingStorage.Chunk}
     */
    _flush: function(createChunk)
    {
        if (!this._strings.length)
            return null;

        var chunk = null;
        if (createChunk) {
            console.assert(this._strings.length === 1);
            chunk = {
                string: this._strings[0],
                startOffset: 0,
                endOffset: 0
            };
        }

        /**
         * @this {WebInspector.TempFileBackingStorage}
         * @param {?WebInspector.TempFileBackingStorage.Chunk} chunk
         * @param {number} fileSize
         */
        function didWrite(chunk, fileSize)
        {
            if (fileSize === -1)
                return;
            if (chunk) {
                chunk.startOffset = this._fileSize;
                chunk.endOffset = fileSize;
                chunk.string = null;
            }
            this._fileSize = fileSize;
        }

        this._file.write(this._strings, didWrite.bind(this, chunk));
        this._strings = [];
        this._stringsLength = 0;
        return chunk;
    },

    /**
     * @override
     */
    finishWriting: function()
    {
        this._flush(false);
        this._file.finishWriting(function() {});
    },

    /**
     * @override
     */
    reset: function()
    {
        if (this._file)
            this._file.remove();
        this._file = new WebInspector.DeferredTempFile(this._dirName, String(Date.now()));
        /**
         * @type {!Array.<string>}
         */
        this._strings = [];
        this._stringsLength = 0;
        this._fileSize = 0;
    },

    /**
     * @param {!WebInspector.OutputStream} outputStream
     * @param {!WebInspector.OutputStreamDelegate} delegate
     */
    writeToStream: function(outputStream, delegate)
    {
        this._file.writeToOutputStream(outputStream, delegate);
    }
}
;
/* Module components */
/* BreakpointsSidebarPaneBase.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SidebarPane}
 * @param {string} title
 */
WebInspector.BreakpointsSidebarPaneBase = function(title)
{
    WebInspector.SidebarPane.call(this, title);
    this.registerRequiredCSS("components/breakpointsList.css");

    this.listElement = createElement("ol");
    this.listElement.className = "breakpoint-list";

    this.emptyElement = createElement("div");
    this.emptyElement.className = "info";
    this.emptyElement.textContent = WebInspector.UIString("No Breakpoints");

    this.element.appendChild(this.emptyElement);
}

WebInspector.BreakpointsSidebarPaneBase.prototype = {
    /**
     * @param {!Element} element
     * @param {?Node=} beforeNode
     * @protected
     */
    addListElement: function(element, beforeNode)
    {
        if (beforeNode) {
            this.listElement.insertBefore(element, beforeNode);
        } else {
            if (!this.listElement.firstChild) {
                this.element.removeChild(this.emptyElement);
                this.element.appendChild(this.listElement);
            }
            this.listElement.appendChild(element);
        }
    },

    /**
     * @param {!Element} element
     * @protected
     */
    removeListElement: function(element)
    {
        this.listElement.removeChild(element);
        if (!this.listElement.firstChild) {
            this.element.removeChild(this.listElement);
            this.element.appendChild(this.emptyElement);
        }
    },

    /**
     * @protected
     */
    reset: function()
    {
        this.listElement.removeChildren();
        if (this.listElement.parentElement) {
            this.element.removeChild(this.listElement);
            this.element.appendChild(this.emptyElement);
        }
    },

    __proto__: WebInspector.SidebarPane.prototype
}
;/* CustomPreviewSection.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {!WebInspector.RemoteObject} object
 */
WebInspector.CustomPreviewSection = function(object)
{
    this._sectionElement = createElementWithClass("span", "custom-expandable-section");
    this._object = object;
    this._expanded = false;
    this._cachedContent = null;
    var customPreview = object.customPreview();

    try {
        var headerJSON = JSON.parse(customPreview.header);
    } catch (e) {
        WebInspector.console.error("Broken formatter: header is invalid json " + e);
        return;
    }
    this._header = this._renderJSONMLTag(headerJSON);
    if (this._header.nodeType === Node.TEXT_NODE) {
        WebInspector.console.error("Broken formatter: header should be an element node.");
        return;
    }

    if (customPreview.hasBody) {
        this._header.classList.add("custom-expandable-section-header");
        this._header.addEventListener("click", this._onClick.bind(this), false);
    }

    this._sectionElement.appendChild(this._header);
}

/**
 * @constructor
 * @param {!WebInspector.RemoteObject} object
 */
WebInspector.CustomPreviewComponent = function(object)
{
    this._object = object;
    this._customPreviewSection = new WebInspector.CustomPreviewSection(object);
    this.element  = createElementWithClass("span", "source-code");
    var shadowRoot = WebInspector.createShadowRootWithCoreStyles(this.element, "components/customPreviewSection.css");
    this.element.addEventListener("contextmenu", this._contextMenuEventFired.bind(this), false);
    shadowRoot.appendChild(this._customPreviewSection.element());
}

WebInspector.CustomPreviewComponent.prototype = {
    expandIfPossible: function()
    {
        if (this._object.customPreview().hasBody && this._customPreviewSection)
            this._customPreviewSection._loadBody();
    },

    /**
     * @param {!Event} event
     */
    _contextMenuEventFired: function(event)
    {
        var contextMenu = new WebInspector.ContextMenu(event);
        if (this._customPreviewSection)
            contextMenu.appendItem(WebInspector.UIString.capitalize("Show as Javascript ^object" ), this._disassemble.bind(this));
        contextMenu.appendApplicableItems(this._object);
        contextMenu.show();
    },

    _disassemble: function()
    {
        this.element.shadowRoot.textContent = "";
        this._customPreviewSection = null;
        this.element.shadowRoot.appendChild(WebInspector.ObjectPropertiesSection.defaultObjectPresentation(this._object));
    }
}

WebInspector.CustomPreviewSection._tagsWhiteList = new Set(["span", "div", "ol", "li","table", "tr", "td"]);

WebInspector.CustomPreviewSection.prototype = {

    /**
     * @return {!Element}
     */
    element: function()
    {
        return this._sectionElement;
    },

    /**
     * @param {*} jsonML
     * @return {!Node}
     */
    _renderJSONMLTag: function(jsonML)
    {
        if (!Array.isArray(jsonML))
            return createTextNode(jsonML + "");

        var array = /** @type {!Array.<*>} */(jsonML);
        if (array[0] === "object")
            return this._layoutObjectTag(array);
        else
            return this._renderElement(array);
    },

    /**
     *
     * @param {!Array.<*>} object
     * @return {!Node}
     */
    _renderElement: function(object)
    {
        var tagName = object.shift();
        if (!WebInspector.CustomPreviewSection._tagsWhiteList.has(tagName)) {
            WebInspector.console.error("Broken formatter: element " + tagName + " is not allowed!");
            return createElement("span");
        }
        var element = createElement(/** @type {string} */ (tagName));
        if ((typeof object[0] == "object") && !Array.isArray(object[0])) {
            var attributes = object.shift();
            for (var key in attributes) {
                var value = attributes[key];
                if ((key !== "style") || (typeof value !== "string"))
                    continue;

                element.setAttribute(key, value);
            }
        }

        this._appendJsonMLTags(element, object);
        return element;
    },

    /**
     * @param {!Array.<*>} objectTag
     * @return {!Node}
     */
    _layoutObjectTag: function(objectTag)
    {
        objectTag.shift();
        var attributes = objectTag.shift();
        var remoteObject = this._object.target().runtimeModel.createRemoteObject(/** @type {!RuntimeAgent.RemoteObject} */ (attributes));
        if (remoteObject.customPreview())
            return (new WebInspector.CustomPreviewSection(remoteObject)).element();

        var sectionElement = WebInspector.ObjectPropertiesSection.defaultObjectPresentation(remoteObject);
        sectionElement.classList.toggle("custom-expandable-section-standard-section", remoteObject.hasChildren);
        return sectionElement;
    },

    /**
     * @param {!Node} parentElement
     * @param {!Array.<*>} jsonMLTags
     */
    _appendJsonMLTags: function(parentElement, jsonMLTags)
    {
        for (var i = 0; i < jsonMLTags.length; ++i)
            parentElement.appendChild(this._renderJSONMLTag(jsonMLTags[i]));
    },

    /**
     * @param {!Event} event
     */
    _onClick: function(event)
    {
        event.consume(true);
        if (this._cachedContent)
            this._toggleExpand();
        else
            this._loadBody();
    },

    _toggleExpand: function()
    {
        this._expanded = !this._expanded;
        this._header.classList.toggle("expanded", this._expanded);
        this._cachedContent.classList.toggle("hidden", !this._expanded);
    },

    _loadBody: function()
    {
        /**
         * @suppressReceiverCheck
         * @suppressGlobalPropertiesCheck
         * @suppress {undefinedVars}
         * @this {Object}
         * @param {*=} formatter
         * @param {*=} config
         */
        function load(formatter, config)
        {
            /**
             * @param {*} jsonMLObject
             * @throws {string} error message
             */
            function substituteObjectTagsInCustomPreview(jsonMLObject)
            {
                if (!jsonMLObject || (typeof jsonMLObject !== "object") || (typeof jsonMLObject.splice !== "function"))
                    return;

                var obj = jsonMLObject.length;
                if (!(typeof obj === "number" && obj >>> 0 === obj && (obj > 0 || 1 / obj > 0)))
                    return;

                var startIndex = 1;
                if (jsonMLObject[0] === "object") {
                    var attributes = jsonMLObject[1];
                    var originObject = attributes["object"];
                    var config = attributes["config"];
                    if (typeof originObject === "undefined")
                        throw "Illegal format: obligatory attribute \"object\" isn't specified";

                    jsonMLObject[1] = bindRemoteObject(originObject, false, false, null, false, config);
                    startIndex = 2;
                }
                for (var i = startIndex; i < jsonMLObject.length; ++i)
                    substituteObjectTagsInCustomPreview(jsonMLObject[i]);
            }

            try {
                var body = formatter.body(this, config);
                substituteObjectTagsInCustomPreview(body);
                return body;
            } catch (e) {
                console.error("Custom Formatter Failed: " + e);
                return null;
            }
        }

        var customPreview = this._object.customPreview();
        var args = [{objectId: customPreview.formatterObjectId}];
        if (customPreview.configObjectId)
            args.push({objectId: customPreview.configObjectId});
        this._object.callFunctionJSON(load, args, onBodyLoaded.bind(this));

        /**
         * @param {*} bodyJsonML
         * @this {WebInspector.CustomPreviewSection}
         */
        function onBodyLoaded(bodyJsonML)
        {
            if (!bodyJsonML)
                return;

            this._cachedContent = this._renderJSONMLTag(bodyJsonML);
            this._sectionElement.appendChild(this._cachedContent);
            this._toggleExpand();
        }
    }
}
;/* DataSaverInfobar.js */
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.Infobar}
 */
WebInspector.DataSaverInfobar = function()
{
    WebInspector.Infobar.call(this, WebInspector.Infobar.Type.Warning, WebInspector.UIString("Consider disabling Chrome Data Saver while debugging."), WebInspector.settings.moduleSetting("disableDataSaverInfobar"));
    var message = this.createDetailsRowMessage();
    message.createTextChild("More information about  ");
    message.appendChild(WebInspector.linkifyURLAsNode("https://support.google.com/chrome/answer/2392284?hl=en", "Chrome Data Saver", undefined, true));
    message.createTextChild(".");
}

WebInspector.DataSaverInfobar._infobars = [];

/**
 * @param {!WebInspector.Panel} panel
 */
WebInspector.DataSaverInfobar.maybeShowInPanel = function(panel)
{
    if (Runtime.queryParam("remoteFrontend")) {
        var infobar = new WebInspector.DataSaverInfobar();
        WebInspector.DataSaverInfobar._infobars.push(infobar);
        panel.showInfobar(infobar);
    }
}

WebInspector.DataSaverInfobar.prototype = {
    /**
     * @override
     */
    dispose: function()
    {
        for (var infobar of WebInspector.DataSaverInfobar._infobars)
            WebInspector.Infobar.prototype.dispose.call(infobar);
    },

    __proto__: WebInspector.Infobar.prototype
}
;/* DOMBreakpointsSidebarPane.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.BreakpointsSidebarPaneBase}
 */
WebInspector.DOMBreakpointsSidebarPane = function()
{
    WebInspector.BreakpointsSidebarPaneBase.call(this, WebInspector.UIString("DOM Breakpoints"));
    this._domBreakpointsSetting = WebInspector.settings.createLocalSetting("domBreakpoints", []);
    this.listElement.classList.add("dom-breakpoints-list");

    this._breakpointElements = {};

    this._breakpointTypes = {
        SubtreeModified: "subtree-modified",
        AttributeModified: "attribute-modified",
        NodeRemoved: "node-removed"
    };
    this._breakpointTypeLabels = {};
    this._breakpointTypeLabels[this._breakpointTypes.SubtreeModified] = WebInspector.UIString("Subtree Modified");
    this._breakpointTypeLabels[this._breakpointTypes.AttributeModified] = WebInspector.UIString("Attribute Modified");
    this._breakpointTypeLabels[this._breakpointTypes.NodeRemoved] = WebInspector.UIString("Node Removed");

    this._contextMenuLabels = {};
    this._contextMenuLabels[this._breakpointTypes.SubtreeModified] = WebInspector.UIString.capitalize("Subtree ^modifications");
    this._contextMenuLabels[this._breakpointTypes.AttributeModified] = WebInspector.UIString.capitalize("Attributes ^modifications");
    this._contextMenuLabels[this._breakpointTypes.NodeRemoved] = WebInspector.UIString.capitalize("Node ^removal");

    WebInspector.targetManager.addEventListener(WebInspector.TargetManager.Events.InspectedURLChanged, this._inspectedURLChanged, this);
    WebInspector.targetManager.addModelListener(WebInspector.DOMModel, WebInspector.DOMModel.Events.NodeRemoved, this._nodeRemoved, this);
}

WebInspector.DOMBreakpointsSidebarPane.Marker = "breakpoint-marker";

WebInspector.DOMBreakpointsSidebarPane.prototype = {
    _inspectedURLChanged: function(event)
    {
        this._breakpointElements = {};
        this.reset();
        var url = /** @type {string} */ (event.data);
        this._inspectedURL = url.removeURLFragment();
    },

    /**
     * @param {!WebInspector.DOMNode} node
     * @param {!WebInspector.ContextMenu} contextMenu
     * @param {boolean} createSubMenu
     */
    populateNodeContextMenu: function(node, contextMenu, createSubMenu)
    {
        if (node.pseudoType())
            return;

        var nodeBreakpoints = this._nodeBreakpoints(node);

        /**
         * @param {!DOMDebuggerAgent.DOMBreakpointType} type
         * @this {WebInspector.DOMBreakpointsSidebarPane}
         */
        function toggleBreakpoint(type)
        {
            if (!nodeBreakpoints[type])
                this._setBreakpoint(node, type, true);
            else
                this._removeBreakpoint(node, type);
            this._saveBreakpoints();
        }

        var breakpointsMenu = createSubMenu ? contextMenu.appendSubMenuItem(WebInspector.UIString("Break on...")) : contextMenu;
        for (var key in this._breakpointTypes) {
            var type = this._breakpointTypes[key];
            var label = this._contextMenuLabels[type];
            breakpointsMenu.appendCheckboxItem(label, toggleBreakpoint.bind(this, type), nodeBreakpoints[type]);
        }
    },

    /**
     * @param {!WebInspector.DOMNode} node
     * @return {!Object<string, boolean>}
     */
    _nodeBreakpoints: function(node)
    {
        var nodeBreakpoints = {};
        for (var id in this._breakpointElements) {
            var element = this._breakpointElements[id];
            if (element._node === node && element._checkboxElement.checked)
                nodeBreakpoints[element._type] = true;
        }
        return nodeBreakpoints;
    },

    /**
     * @param {!WebInspector.DOMNode} node
     * @return {boolean}
     */
    hasBreakpoints: function(node)
    {
        for (var id in this._breakpointElements) {
            var element = this._breakpointElements[id];
            if (element._node === node && element._checkboxElement.checked)
                return true;
        }
        return false;
    },

    /**
     * @param {!WebInspector.DebuggerPausedDetails} details
     * @param {function(!Element)} callback
     */
    createBreakpointHitStatusMessage: function(details, callback)
    {
        var auxData = /** @type {!Object} */ (details.auxData);
        var domModel = WebInspector.DOMModel.fromTarget(details.target());
        if (!domModel)
            return;
        if (auxData.type === this._breakpointTypes.SubtreeModified) {
            var targetNodeObject = details.target().runtimeModel.createRemoteObject(auxData["targetNode"]);
            domModel.pushObjectAsNodeToFrontend(targetNodeObject, didPushNodeToFrontend.bind(this));
        } else {
            this._doCreateBreakpointHitStatusMessage(auxData, domModel.nodeForId(auxData.nodeId), null, callback);
        }

        /**
         * @param {?WebInspector.DOMNode} targetNode
         * @this {WebInspector.DOMBreakpointsSidebarPane}
         */
        function didPushNodeToFrontend(targetNode)
        {
            if (targetNode)
                targetNodeObject.release();
            this._doCreateBreakpointHitStatusMessage(auxData, domModel.nodeForId(auxData.nodeId), targetNode, callback);
        }
    },

    /**
     * @param {!Object} auxData
     * @param {?WebInspector.DOMNode} node
     * @param {?WebInspector.DOMNode} targetNode
     * @param {function(!Element)} callback
     */
    _doCreateBreakpointHitStatusMessage: function(auxData, node, targetNode, callback)
    {
        var message;
        var typeLabel = this._breakpointTypeLabels[auxData.type];
        var linkifiedNode = WebInspector.DOMPresentationUtils.linkifyNodeReference(node);
        var substitutions = [typeLabel, linkifiedNode];
        var targetNodeLink = "";
        if (targetNode)
            targetNodeLink = WebInspector.DOMPresentationUtils.linkifyNodeReference(targetNode);

        if (auxData.type === this._breakpointTypes.SubtreeModified) {
            if (auxData.insertion) {
                if (targetNode !== node) {
                    message = "Paused on a \"%s\" breakpoint set on %s, because a new child was added to its descendant %s.";
                    substitutions.push(targetNodeLink);
                } else
                    message = "Paused on a \"%s\" breakpoint set on %s, because a new child was added to that node.";
            } else {
                message = "Paused on a \"%s\" breakpoint set on %s, because its descendant %s was removed.";
                substitutions.push(targetNodeLink);
            }
        } else
            message = "Paused on a \"%s\" breakpoint set on %s.";

        var element = WebInspector.formatLocalized(message, substitutions);

        callback(element);
    },

    _nodeRemoved: function(event)
    {
        var node = event.data.node;
        this._removeBreakpointsForNode(event.data.node);
        var children = node.children();
        if (!children)
            return;
        for (var i = 0; i < children.length; ++i)
            this._removeBreakpointsForNode(children[i]);
        this._saveBreakpoints();
    },

    /**
     * @param {!WebInspector.DOMNode} node
     */
    _removeBreakpointsForNode: function(node)
    {
        for (var id in this._breakpointElements) {
            var element = this._breakpointElements[id];
            if (element._node === node)
                this._removeBreakpoint(element._node, element._type);
        }
    },

    /**
     * @param {!WebInspector.DOMNode} node
     * @param {!DOMDebuggerAgent.DOMBreakpointType} type
     * @param {boolean} enabled
     */
    _setBreakpoint: function(node, type, enabled)
    {
        var breakpointId = this._createBreakpointId(node.id, type);
        var breakpointElement = this._breakpointElements[breakpointId];
        if (!breakpointElement) {
            breakpointElement = this._createBreakpointElement(node, type, enabled);
            this._breakpointElements[breakpointId] = breakpointElement;
        } else {
            breakpointElement._checkboxElement.checked = enabled;
        }
        if (enabled)
            node.target().domdebuggerAgent().setDOMBreakpoint(node.id, type);
        node.setMarker(WebInspector.DOMBreakpointsSidebarPane.Marker, true);
    },

    /**
     * @param {!WebInspector.DOMNode} node
     * @param {!DOMDebuggerAgent.DOMBreakpointType} type
     * @param {boolean} enabled
     */
    _createBreakpointElement: function(node, type, enabled)
    {
        var element = createElement("li");
        element._node = node;
        element._type = type;
        element.addEventListener("contextmenu", this._contextMenu.bind(this, node, type), true);

        var checkboxLabel = createCheckboxLabel("", enabled);
        checkboxLabel.addEventListener("click", this._checkboxClicked.bind(this, node, type), false);
        element._checkboxElement = checkboxLabel.checkboxElement;
        element.appendChild(checkboxLabel);

        var labelElement = createElementWithClass("div", "dom-breakpoint");
        element.appendChild(labelElement);

        var linkifiedNode = WebInspector.DOMPresentationUtils.linkifyNodeReference(node);
        linkifiedNode.classList.add("monospace");
        linkifiedNode.style.display = "block";
        labelElement.appendChild(linkifiedNode);

        var description = createElement("div");
        description.textContent = this._breakpointTypeLabels[type];
        labelElement.appendChild(description);

        var currentElement = this.listElement.firstChild;
        while (currentElement) {
            if (currentElement._type && currentElement._type < element._type)
                break;
            currentElement = currentElement.nextSibling;
        }
        this.addListElement(element, currentElement);
        return element;
    },

    _removeAllBreakpoints: function()
    {
        for (var id in this._breakpointElements) {
            var element = this._breakpointElements[id];
            this._removeBreakpoint(element._node, element._type);
        }
        this._saveBreakpoints();
    },

    /**
     * @param {!WebInspector.DOMNode} node
     * @param {!DOMDebuggerAgent.DOMBreakpointType} type
     */
    _removeBreakpoint: function(node, type)
    {
        var breakpointId = this._createBreakpointId(node.id, type);
        var element = this._breakpointElements[breakpointId];
        if (!element)
            return;

        this.removeListElement(element);
        delete this._breakpointElements[breakpointId];
        if (element._checkboxElement.checked)
            node.target().domdebuggerAgent().removeDOMBreakpoint(node.id, type);
        node.setMarker(WebInspector.DOMBreakpointsSidebarPane.Marker, this.hasBreakpoints(node) ? true : null);
    },

    /**
     * @param {!WebInspector.DOMNode} node
     * @param {!DOMDebuggerAgent.DOMBreakpointType} type
     * @param {!Event} event
     */
    _contextMenu: function(node, type, event)
    {
        var contextMenu = new WebInspector.ContextMenu(event);

        /**
         * @this {WebInspector.DOMBreakpointsSidebarPane}
         */
        function removeBreakpoint()
        {
            this._removeBreakpoint(node, type);
            this._saveBreakpoints();
        }
        contextMenu.appendItem(WebInspector.UIString.capitalize("Remove ^breakpoint"), removeBreakpoint.bind(this));
        contextMenu.appendItem(WebInspector.UIString.capitalize("Remove ^all DOM breakpoints"), this._removeAllBreakpoints.bind(this));
        contextMenu.show();
    },

    /**
     * @param {!WebInspector.DOMNode} node
     * @param {!DOMDebuggerAgent.DOMBreakpointType} type
     * @param {!Event} event
     */
    _checkboxClicked: function(node, type, event)
    {
        if (event.target.checked)
            node.target().domdebuggerAgent().setDOMBreakpoint(node.id, type);
        else
            node.target().domdebuggerAgent().removeDOMBreakpoint(node.id, type);
        this._saveBreakpoints();
    },

    highlightBreakpoint: function(auxData)
    {
        var breakpointId = this._createBreakpointId(auxData.nodeId, auxData.type);
        var element = this._breakpointElements[breakpointId];
        if (!element)
            return;
        this.expand();
        element.classList.add("breakpoint-hit");
        this._highlightedElement = element;
    },

    clearBreakpointHighlight: function()
    {
        if (this._highlightedElement) {
            this._highlightedElement.classList.remove("breakpoint-hit");
            delete this._highlightedElement;
        }
    },

    /**
     * @param {number} nodeId
     * @param {!DOMDebuggerAgent.DOMBreakpointType} type
     */
    _createBreakpointId: function(nodeId, type)
    {
        return nodeId + ":" + type;
    },

    _saveBreakpoints: function()
    {
        var breakpoints = [];
        var storedBreakpoints = this._domBreakpointsSetting.get();
        for (var i = 0; i < storedBreakpoints.length; ++i) {
            var breakpoint = storedBreakpoints[i];
            if (breakpoint.url !== this._inspectedURL)
                breakpoints.push(breakpoint);
        }
        for (var id in this._breakpointElements) {
            var element = this._breakpointElements[id];
            breakpoints.push({ url: this._inspectedURL, path: element._node.path(), type: element._type, enabled: element._checkboxElement.checked });
        }
        this._domBreakpointsSetting.set(breakpoints);
    },

    /**
     * @param {!WebInspector.DOMModel} domModel
     */
    restoreBreakpoints: function(domModel)
    {
        var pathToBreakpoints = {};

        /**
         * @param {string} path
         * @param {?DOMAgent.NodeId} nodeId
         * @this {WebInspector.DOMBreakpointsSidebarPane}
         */
        function didPushNodeByPathToFrontend(path, nodeId)
        {
            var node = nodeId ? domModel.nodeForId(nodeId) : null;
            if (!node)
                return;

            var breakpoints = pathToBreakpoints[path];
            for (var i = 0; i < breakpoints.length; ++i)
                this._setBreakpoint(node, breakpoints[i].type, breakpoints[i].enabled);
        }

        var breakpoints = this._domBreakpointsSetting.get();
        for (var i = 0; i < breakpoints.length; ++i) {
            var breakpoint = breakpoints[i];
            if (breakpoint.url !== this._inspectedURL)
                continue;
            var path = breakpoint.path;
            if (!pathToBreakpoints[path]) {
                pathToBreakpoints[path] = [];
                domModel.pushNodeByPathToFrontend(path, didPushNodeByPathToFrontend.bind(this, path));
            }
            pathToBreakpoints[path].push(breakpoint);
        }
    },

    /**
     * @param {!WebInspector.Panel} panel
     * @return {!WebInspector.DOMBreakpointsSidebarPane.Proxy}
     */
    createProxy: function(panel)
    {
        var proxy = new WebInspector.DOMBreakpointsSidebarPane.Proxy(this, panel);
        if (!this._proxies)
            this._proxies = [];
        this._proxies.push(proxy);
        return proxy;
    },

    onContentReady: function()
    {
        for (var i = 0; i != this._proxies.length; i++)
            this._proxies[i].onContentReady();
    },

    __proto__: WebInspector.BreakpointsSidebarPaneBase.prototype
}

/**
 * @constructor
 * @extends {WebInspector.SidebarPane}
 * @param {!WebInspector.DOMBreakpointsSidebarPane} pane
 * @param {!WebInspector.Panel} panel
 */
WebInspector.DOMBreakpointsSidebarPane.Proxy = function(pane, panel)
{
    WebInspector.SidebarPane.call(this, pane.title());
    this.registerRequiredCSS("components/breakpointsList.css");

    this._wrappedPane = pane;
    this._panel = panel;
}

WebInspector.DOMBreakpointsSidebarPane.Proxy.prototype = {
    expand: function()
    {
        this._wrappedPane.expand();
    },

    onContentReady: function()
    {
        if (this._panel.isShowing())
            this._reattachBody();

        WebInspector.SidebarPane.prototype.onContentReady.call(this);
    },

    wasShown: function()
    {
        WebInspector.SidebarPane.prototype.wasShown.call(this);
        this._reattachBody();
    },

    _reattachBody: function()
    {
        if (this._wrappedPane.element.parentNode !== this.element)
            this._wrappedPane.show(this.element);
    },

    __proto__: WebInspector.SidebarPane.prototype
}

/**
 * @type {!WebInspector.DOMBreakpointsSidebarPane}
 */
WebInspector.domBreakpointsSidebarPane;
;/* DOMPresentationUtils.js */
/*
 * Copyright (C) 2011 Google Inc.  All rights reserved.
 * Copyright (C) 2007, 2008 Apple Inc.  All rights reserved.
 * Copyright (C) 2008 Matt Lilek <webkit@mattlilek.com>
 * Copyright (C) 2009 Joseph Pecoraro
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

WebInspector.DOMPresentationUtils = {}

/**
 * @param {!WebInspector.DOMNode} node
 * @param {!Element} parentElement
 */
WebInspector.DOMPresentationUtils.decorateNodeLabel = function(node, parentElement)
{
    var originalNode = node;
    var isPseudo = node.nodeType() === Node.ELEMENT_NODE && node.pseudoType();
    if (isPseudo && node.parentNode)
        node = node.parentNode;

    var title = node.nodeNameInCorrectCase();

    var nameElement = parentElement.createChild("span", "node-label-name");
    nameElement.textContent = title;

    var idAttribute = node.getAttribute("id");
    if (idAttribute) {
        var idElement = parentElement.createChild("span", "node-label-id");
        var part = "#" + idAttribute;
        title += part;
        idElement.createTextChild(part);

        // Mark the name as extra, since the ID is more important.
        nameElement.classList.add("extra");
    }

    var classAttribute = node.getAttribute("class");
    if (classAttribute) {
        var classes = classAttribute.split(/\s+/);
        var foundClasses = {};

        if (classes.length) {
            var classesElement = parentElement.createChild("span", "extra node-label-class");
            for (var i = 0; i < classes.length; ++i) {
                var className = classes[i];
                if (className && !(className in foundClasses)) {
                    var part = "." + className;
                    title += part;
                    classesElement.createTextChild(part);
                    foundClasses[className] = true;
                }
            }
        }
    }

    if (isPseudo) {
        var pseudoElement = parentElement.createChild("span", "extra node-label-pseudo");
        var pseudoText = "::" + originalNode.pseudoType();
        pseudoElement.createTextChild(pseudoText);
        title += pseudoText;
    }
    parentElement.title = title;
}

/**
 * @param {!Element} container
 * @param {string} nodeTitle
 */
WebInspector.DOMPresentationUtils.createSpansForNodeTitle = function(container, nodeTitle)
{
    var match = nodeTitle.match(/([^#.]+)(#[^.]+)?(\..*)?/);
    container.createChild("span", "webkit-html-tag-name").textContent = match[1];
    if (match[2])
        container.createChild("span", "webkit-html-attribute-value").textContent = match[2];
    if (match[3])
        container.createChild("span", "webkit-html-attribute-name").textContent = match[3];
}

/**
 * @param {?WebInspector.DOMNode} node
 * @param {string=} idref
 * @return {!Node}
 */
WebInspector.DOMPresentationUtils.linkifyNodeReference = function(node, idref)
{
    if (!node)
        return createTextNode(WebInspector.UIString("<node>"));

    var root = createElementWithClass("span", "monospace");
    var shadowRoot = WebInspector.createShadowRootWithCoreStyles(root, "components/domUtils.css");
    var link = shadowRoot.createChild("div", "node-link");

    if (idref)
        link.createChild("span", "node-label-id").createTextChild("#" + idref);
    else
        WebInspector.DOMPresentationUtils.decorateNodeLabel(node, link);

    link.addEventListener("click", WebInspector.Revealer.reveal.bind(WebInspector.Revealer, node, undefined), false);
    link.addEventListener("mouseover", node.highlight.bind(node, undefined, undefined), false);
    link.addEventListener("mouseleave", WebInspector.DOMModel.hideDOMNodeHighlight.bind(WebInspector.DOMModel), false);

    return root;
}

/**
 * @param {!WebInspector.DeferredDOMNode} deferredNode
 * @return {!Node}
 */
WebInspector.DOMPresentationUtils.linkifyDeferredNodeReference = function(deferredNode)
{
    var root = createElement("div");
    var shadowRoot = WebInspector.createShadowRootWithCoreStyles(root, "components/domUtils.css");
    var link = shadowRoot.createChild("div", "node-link");
    link.createChild("content");
    link.addEventListener("click", deferredNode.resolve.bind(deferredNode, onDeferredNodeResolved), false);
    link.addEventListener("mousedown", consumeEvent, false);

    /**
     * @param {?WebInspector.DOMNode} node
     */
    function onDeferredNodeResolved(node)
    {
        WebInspector.Revealer.reveal(node);
    }

    return root;
}

/**
 * @param {!WebInspector.Target} target
 * @param {string} originalImageURL
 * @param {boolean} showDimensions
 * @param {function(!Element=)} userCallback
 * @param {!Object=} precomputedFeatures
 */
WebInspector.DOMPresentationUtils.buildImagePreviewContents = function(target, originalImageURL, showDimensions, userCallback, precomputedFeatures)
{
    var resource = target.resourceTreeModel.resourceForURL(originalImageURL);
    var imageURL = originalImageURL;
    if (!isImageResource(resource) && precomputedFeatures && precomputedFeatures.currentSrc) {
        imageURL = precomputedFeatures.currentSrc;
        resource = target.resourceTreeModel.resourceForURL(imageURL);
    }
    if (!isImageResource(resource)) {
        userCallback();
        return;
    }

    var imageElement = createElement("img");
    imageElement.addEventListener("load", buildContent, false);
    imageElement.addEventListener("error", errorCallback, false);
    resource.populateImageSource(imageElement);

    function errorCallback()
    {
        // Drop the event parameter when invoking userCallback.
        userCallback();
    }

    /**
     * @param {?WebInspector.Resource} resource
     * @return {boolean}
     */
    function isImageResource(resource)
    {
        return !!resource && resource.resourceType() === WebInspector.resourceTypes.Image;
    }

    function buildContent()
    {
        var container = createElement("table");
        container.className = "image-preview-container";
        var naturalWidth = precomputedFeatures ? precomputedFeatures.naturalWidth : imageElement.naturalWidth;
        var naturalHeight = precomputedFeatures ? precomputedFeatures.naturalHeight : imageElement.naturalHeight;
        var offsetWidth = precomputedFeatures ? precomputedFeatures.offsetWidth : naturalWidth;
        var offsetHeight = precomputedFeatures ? precomputedFeatures.offsetHeight : naturalHeight;
        var description;
        if (showDimensions) {
            if (offsetHeight === naturalHeight && offsetWidth === naturalWidth)
                description = WebInspector.UIString("%d \xd7 %d pixels", offsetWidth, offsetHeight);
            else
                description = WebInspector.UIString("%d \xd7 %d pixels (Natural: %d \xd7 %d pixels)", offsetWidth, offsetHeight, naturalWidth, naturalHeight);
        }

        container.createChild("tr").createChild("td", "image-container").appendChild(imageElement);
        if (description)
            container.createChild("tr").createChild("td").createChild("span", "description").textContent = description;
        if (imageURL !== originalImageURL)
            container.createChild("tr").createChild("td").createChild("span", "description").textContent = String.sprintf("currentSrc: %s", imageURL.trimMiddle(100));
        userCallback(container);
    }
}

/**
 * @param {!WebInspector.Target} target
 * @param {!WebInspector.Linkifier} linkifier
 * @param {!RuntimeAgent.StackTrace=} stackTrace
 * @return {!Element}
 */
WebInspector.DOMPresentationUtils.buildStackTracePreviewContents = function(target, linkifier, stackTrace)
{
    var element = createElement("span");
    element.style.display = "inline-block";
    var shadowRoot = WebInspector.createShadowRootWithCoreStyles(element, "components/domUtils.css");
    var contentElement = shadowRoot.createChild("table", "stack-preview-container");

    /**
     * @param {!RuntimeAgent.StackTrace} stackTrace
     */
    function appendStackTrace(stackTrace)
    {
        for (var stackFrame of stackTrace.callFrames) {
            var row = createElement("tr");
            row.createChild("td", "function-name").textContent = WebInspector.beautifyFunctionName(stackFrame.functionName);
            row.createChild("td").textContent = " @ ";
            row.createChild("td").appendChild(linkifier.linkifyConsoleCallFrame(target, stackFrame));
            contentElement.appendChild(row);
        }
    }

    if (!stackTrace)
        return element;

    appendStackTrace(stackTrace);

    var asyncStackTrace = stackTrace.parent;
    while (asyncStackTrace) {
        if (!asyncStackTrace.callFrames.length) {
            asyncStackTrace = asyncStackTrace.parent;
            continue;
        }
        var row = contentElement.createChild("tr");
        row.createChild("td", "stack-preview-async-description").textContent = WebInspector.asyncStackTraceLabel(asyncStackTrace.description);
        row.createChild("td");
        row.createChild("td");
        appendStackTrace(asyncStackTrace);
        asyncStackTrace = asyncStackTrace.parent;
    }

    return element;
}

/**
 * @param {!WebInspector.DOMNode} node
 * @param {boolean=} justSelector
 * @return {string}
 */
WebInspector.DOMPresentationUtils.fullQualifiedSelector = function(node, justSelector)
{
    if (node.nodeType() !== Node.ELEMENT_NODE)
        return node.localName() || node.nodeName().toLowerCase();
    return WebInspector.DOMPresentationUtils.cssPath(node, justSelector);
}

/**
 * @param {!WebInspector.DOMNode} node
 * @return {string}
 */
WebInspector.DOMPresentationUtils.simpleSelector = function(node)
{
    var lowerCaseName = node.localName() || node.nodeName().toLowerCase();
    if (node.nodeType() !== Node.ELEMENT_NODE)
        return lowerCaseName;
    if (lowerCaseName === "input" && node.getAttribute("type") && !node.getAttribute("id") && !node.getAttribute("class"))
        return lowerCaseName + "[type=\"" + node.getAttribute("type") + "\"]";
    if (node.getAttribute("id"))
        return lowerCaseName + "#" + node.getAttribute("id");
    if (node.getAttribute("class"))
        return (lowerCaseName === "div" ? "" : lowerCaseName) + "." + node.getAttribute("class").trim().replace(/\s+/g, ".");
    return lowerCaseName;
}

/**
 * @param {!WebInspector.DOMNode} node
 * @param {boolean=} optimized
 * @return {string}
 */
WebInspector.DOMPresentationUtils.cssPath = function(node, optimized)
{
    if (node.nodeType() !== Node.ELEMENT_NODE)
        return "";

    var steps = [];
    var contextNode = node;
    while (contextNode) {
        var step = WebInspector.DOMPresentationUtils._cssPathStep(contextNode, !!optimized, contextNode === node);
        if (!step)
            break; // Error - bail out early.
        steps.push(step);
        if (step.optimized)
            break;
        contextNode = contextNode.parentNode;
    }

    steps.reverse();
    return steps.join(" > ");
}

/**
 * @param {!WebInspector.DOMNode} node
 * @param {boolean} optimized
 * @param {boolean} isTargetNode
 * @return {?WebInspector.DOMNodePathStep}
 */
WebInspector.DOMPresentationUtils._cssPathStep = function(node, optimized, isTargetNode)
{
    if (node.nodeType() !== Node.ELEMENT_NODE)
        return null;

    var id = node.getAttribute("id");
    if (optimized) {
        if (id)
            return new WebInspector.DOMNodePathStep(idSelector(id), true);
        var nodeNameLower = node.nodeName().toLowerCase();
        if (nodeNameLower === "body" || nodeNameLower === "head" || nodeNameLower === "html")
            return new WebInspector.DOMNodePathStep(node.nodeNameInCorrectCase(), true);
    }
    var nodeName = node.nodeNameInCorrectCase();

    if (id)
        return new WebInspector.DOMNodePathStep(nodeName + idSelector(id), true);
    var parent = node.parentNode;
    if (!parent || parent.nodeType() === Node.DOCUMENT_NODE)
        return new WebInspector.DOMNodePathStep(nodeName, true);

    /**
     * @param {!WebInspector.DOMNode} node
     * @return {!Array.<string>}
     */
    function prefixedElementClassNames(node)
    {
        var classAttribute = node.getAttribute("class");
        if (!classAttribute)
            return [];

        return classAttribute.split(/\s+/g).filter(Boolean).map(function(name) {
            // The prefix is required to store "__proto__" in a object-based map.
            return "$" + name;
        });
    }

    /**
     * @param {string} id
     * @return {string}
     */
    function idSelector(id)
    {
        return "#" + escapeIdentifierIfNeeded(id);
    }

    /**
     * @param {string} ident
     * @return {string}
     */
    function escapeIdentifierIfNeeded(ident)
    {
        if (isCSSIdentifier(ident))
            return ident;
        var shouldEscapeFirst = /^(?:[0-9]|-[0-9-]?)/.test(ident);
        var lastIndex = ident.length - 1;
        return ident.replace(/./g, function(c, i) {
            return ((shouldEscapeFirst && i === 0) || !isCSSIdentChar(c)) ? escapeAsciiChar(c, i === lastIndex) : c;
        });
    }

    /**
     * @param {string} c
     * @param {boolean} isLast
     * @return {string}
     */
    function escapeAsciiChar(c, isLast)
    {
        return "\\" + toHexByte(c) + (isLast ? "" : " ");
    }

    /**
     * @param {string} c
     */
    function toHexByte(c)
    {
        var hexByte = c.charCodeAt(0).toString(16);
        if (hexByte.length === 1)
          hexByte = "0" + hexByte;
        return hexByte;
    }

    /**
     * @param {string} c
     * @return {boolean}
     */
    function isCSSIdentChar(c)
    {
        if (/[a-zA-Z0-9_-]/.test(c))
            return true;
        return c.charCodeAt(0) >= 0xA0;
    }

    /**
     * @param {string} value
     * @return {boolean}
     */
    function isCSSIdentifier(value)
    {
        return /^-?[a-zA-Z_][a-zA-Z0-9_-]*$/.test(value);
    }

    var prefixedOwnClassNamesArray = prefixedElementClassNames(node);
    var needsClassNames = false;
    var needsNthChild = false;
    var ownIndex = -1;
    var elementIndex = -1;
    var siblings = parent.children();
    for (var i = 0; (ownIndex === -1 || !needsNthChild) && i < siblings.length; ++i) {
        var sibling = siblings[i];
        if (sibling.nodeType() !== Node.ELEMENT_NODE)
            continue;
        elementIndex += 1;
        if (sibling === node) {
            ownIndex = elementIndex;
            continue;
        }
        if (needsNthChild)
            continue;
        if (sibling.nodeNameInCorrectCase() !== nodeName)
            continue;

        needsClassNames = true;
        var ownClassNames = prefixedOwnClassNamesArray.keySet();
        var ownClassNameCount = 0;
        for (var name in ownClassNames)
            ++ownClassNameCount;
        if (ownClassNameCount === 0) {
            needsNthChild = true;
            continue;
        }
        var siblingClassNamesArray = prefixedElementClassNames(sibling);
        for (var j = 0; j < siblingClassNamesArray.length; ++j) {
            var siblingClass = siblingClassNamesArray[j];
            if (!ownClassNames.hasOwnProperty(siblingClass))
                continue;
            delete ownClassNames[siblingClass];
            if (!--ownClassNameCount) {
                needsNthChild = true;
                break;
            }
        }
    }

    var result = nodeName;
    if (isTargetNode && nodeName.toLowerCase() === "input" && node.getAttribute("type") && !node.getAttribute("id") && !node.getAttribute("class"))
        result += "[type=\"" + node.getAttribute("type") + "\"]";
    if (needsNthChild) {
        result += ":nth-child(" + (ownIndex + 1) + ")";
    } else if (needsClassNames) {
        for (var prefixedName in prefixedOwnClassNamesArray.keySet())
            result += "." + escapeIdentifierIfNeeded(prefixedName.substr(1));
    }

    return new WebInspector.DOMNodePathStep(result, false);
}

/**
 * @param {!WebInspector.DOMNode} node
 * @param {boolean=} optimized
 * @return {string}
 */
WebInspector.DOMPresentationUtils.xPath = function(node, optimized)
{
    if (node.nodeType() === Node.DOCUMENT_NODE)
        return "/";

    var steps = [];
    var contextNode = node;
    while (contextNode) {
        var step = WebInspector.DOMPresentationUtils._xPathValue(contextNode, optimized);
        if (!step)
            break; // Error - bail out early.
        steps.push(step);
        if (step.optimized)
            break;
        contextNode = contextNode.parentNode;
    }

    steps.reverse();
    return (steps.length && steps[0].optimized ? "" : "/") + steps.join("/");
}

/**
 * @param {!WebInspector.DOMNode} node
 * @param {boolean=} optimized
 * @return {?WebInspector.DOMNodePathStep}
 */
WebInspector.DOMPresentationUtils._xPathValue = function(node, optimized)
{
    var ownValue;
    var ownIndex = WebInspector.DOMPresentationUtils._xPathIndex(node);
    if (ownIndex === -1)
        return null; // Error.

    switch (node.nodeType()) {
    case Node.ELEMENT_NODE:
        if (optimized && node.getAttribute("id"))
            return new WebInspector.DOMNodePathStep("//*[@id=\"" + node.getAttribute("id") + "\"]", true);
        ownValue = node.localName();
        break;
    case Node.ATTRIBUTE_NODE:
        ownValue = "@" + node.nodeName();
        break;
    case Node.TEXT_NODE:
    case Node.CDATA_SECTION_NODE:
        ownValue = "text()";
        break;
    case Node.PROCESSING_INSTRUCTION_NODE:
        ownValue = "processing-instruction()";
        break;
    case Node.COMMENT_NODE:
        ownValue = "comment()";
        break;
    case Node.DOCUMENT_NODE:
        ownValue = "";
        break;
    default:
        ownValue = "";
        break;
    }

    if (ownIndex > 0)
        ownValue += "[" + ownIndex + "]";

    return new WebInspector.DOMNodePathStep(ownValue, node.nodeType() === Node.DOCUMENT_NODE);
}

/**
 * @param {!WebInspector.DOMNode} node
 * @return {number}
 */
WebInspector.DOMPresentationUtils._xPathIndex = function(node)
{
    // Returns -1 in case of error, 0 if no siblings matching the same expression, <XPath index among the same expression-matching sibling nodes> otherwise.
    function areNodesSimilar(left, right)
    {
        if (left === right)
            return true;

        if (left.nodeType() === Node.ELEMENT_NODE && right.nodeType() === Node.ELEMENT_NODE)
            return left.localName() === right.localName();

        if (left.nodeType() === right.nodeType())
            return true;

        // XPath treats CDATA as text nodes.
        var leftType = left.nodeType() === Node.CDATA_SECTION_NODE ? Node.TEXT_NODE : left.nodeType();
        var rightType = right.nodeType() === Node.CDATA_SECTION_NODE ? Node.TEXT_NODE : right.nodeType();
        return leftType === rightType;
    }

    var siblings = node.parentNode ? node.parentNode.children() : null;
    if (!siblings)
        return 0; // Root node - no siblings.
    var hasSameNamedElements;
    for (var i = 0; i < siblings.length; ++i) {
        if (areNodesSimilar(node, siblings[i]) && siblings[i] !== node) {
            hasSameNamedElements = true;
            break;
        }
    }
    if (!hasSameNamedElements)
        return 0;
    var ownIndex = 1; // XPath indices start with 1.
    for (var i = 0; i < siblings.length; ++i) {
        if (areNodesSimilar(node, siblings[i])) {
            if (siblings[i] === node)
                return ownIndex;
            ++ownIndex;
        }
    }
    return -1; // An error occurred: |node| not found in parent's children.
}

/**
 * @constructor
 * @param {string} value
 * @param {boolean} optimized
 */
WebInspector.DOMNodePathStep = function(value, optimized)
{
    this.value = value;
    this.optimized = optimized || false;
}

WebInspector.DOMNodePathStep.prototype = {
    /**
     * @override
     * @return {string}
     */
    toString: function()
    {
        return this.value;
    }
}

/**
 * @interface
 */
WebInspector.DOMPresentationUtils.MarkerDecorator = function()
{
}

WebInspector.DOMPresentationUtils.MarkerDecorator.prototype = {
    /**
     * @param {!WebInspector.DOMNode} node
     * @return {?{title: string, color: string}}
     */
    decorate: function(node) { }
}

/**
 * @constructor
 * @implements {WebInspector.DOMPresentationUtils.MarkerDecorator}
 * @param {!Runtime.Extension} extension
 */
WebInspector.DOMPresentationUtils.GenericDecorator = function(extension)
{
    this._title = WebInspector.UIString(extension.title(WebInspector.platform()));
    this._color = extension.descriptor()['color'];
}

WebInspector.DOMPresentationUtils.GenericDecorator.prototype = {
    /**
     * @override
     * @param {!WebInspector.DOMNode} node
     * @return {?{title: string, color: string}}
     */
    decorate: function(node)
    {
        return { title: this._title, color: this._color };
    }
}
;/* DockController.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @param {boolean} canDock
 */
WebInspector.DockController = function(canDock)
{
    this._canDock = canDock;

    this._closeButton = new WebInspector.ToolbarButton(WebInspector.UIString("Close"), "delete-toolbar-item");
    this._closeButton.addEventListener("click", InspectorFrontendHost.closeWindow.bind(InspectorFrontendHost));

    if (!canDock) {
        this._dockSide = WebInspector.DockController.State.Undocked;
        this._updateUI();
        return;
    }

    this._states = [WebInspector.DockController.State.DockedToRight, WebInspector.DockController.State.DockedToBottom, WebInspector.DockController.State.Undocked];
    this._currentDockStateSetting = WebInspector.settings.createSetting("currentDockState", "right");
    this._lastDockStateSetting = WebInspector.settings.createSetting("lastDockState", "bottom");
    if (this._states.indexOf(this._currentDockStateSetting.get()) === -1)
        this._currentDockStateSetting.set("right");
    if (this._states.indexOf(this._lastDockStateSetting.get()) === -1)
        this._currentDockStateSetting.set("bottom");
}

WebInspector.DockController.State = {
    DockedToBottom: "bottom",
    DockedToRight: "right",
    Undocked: "undocked"
}

// Use BeforeDockSideChanged to do something before all the UI bits are updated,
// DockSideChanged to update UI, and AfterDockSideChanged to perform actions
// after frontend is docked/undocked in the browser.
WebInspector.DockController.Events = {
    BeforeDockSideChanged: "BeforeDockSideChanged",
    DockSideChanged: "DockSideChanged",
    AfterDockSideChanged: "AfterDockSideChanged"
}

WebInspector.DockController.prototype = {
    initialize: function()
    {
        if (!this._canDock)
            return;

        this._titles = [WebInspector.UIString("Dock to right"), WebInspector.UIString("Dock to bottom"), WebInspector.UIString("Undock into separate window")];
        this.setDockSide(this._currentDockStateSetting.get());
    },

    /**
     * @return {string}
     */
    dockSide: function()
    {
        return this._dockSide;
    },

    /**
     * @return {boolean}
     */
    canDock: function()
    {
        return this._canDock;
    },

    /**
     * @return {boolean}
     */
    isVertical: function()
    {
        return this._dockSide === WebInspector.DockController.State.DockedToRight;
    },

    /**
     * @param {string} dockSide
     */
    setDockSide: function(dockSide)
    {
        if (this._states.indexOf(dockSide) === -1)
            dockSide = this._states[0];

        if (this._dockSide === dockSide)
            return;

        if (this._dockSide)
            this._lastDockStateSetting.set(this._dockSide);
        this._currentDockStateSetting.set(dockSide);
        var eventData = { from: this._dockSide, to: dockSide };
        this.dispatchEventToListeners(WebInspector.DockController.Events.BeforeDockSideChanged, eventData);
        console.timeStamp("DockController.setIsDocked");
        InspectorFrontendHost.setIsDocked(dockSide !== WebInspector.DockController.State.Undocked, this._setIsDockedResponse.bind(this, eventData));
        this._dockSide = dockSide;
        this._updateUI();
        this.dispatchEventToListeners(WebInspector.DockController.Events.DockSideChanged, eventData);
    },

    /**
     * @param {{from: string, to: string}} eventData
     */
    _setIsDockedResponse: function(eventData)
    {
        this.dispatchEventToListeners(WebInspector.DockController.Events.AfterDockSideChanged, eventData);
    },

    /**
     * @suppressGlobalPropertiesCheck
     */
    _updateUI: function()
    {
        var body = document.body;  // Only for main window.
        switch (this._dockSide) {
        case WebInspector.DockController.State.DockedToBottom:
            body.classList.remove("undocked");
            body.classList.remove("dock-to-right");
            body.classList.add("dock-to-bottom");
            break;
        case WebInspector.DockController.State.DockedToRight:
            body.classList.remove("undocked");
            body.classList.add("dock-to-right");
            body.classList.remove("dock-to-bottom");
            break;
        case WebInspector.DockController.State.Undocked:
            body.classList.add("undocked");
            body.classList.remove("dock-to-right");
            body.classList.remove("dock-to-bottom");
            break;
        }
        this._closeButton.setVisible(this._dockSide !== WebInspector.DockController.State.Undocked);
    },

    _toggleDockSide: function()
    {
        if (this._lastDockStateSetting.get() === this._currentDockStateSetting.get()) {
            var index = this._states.indexOf(this._currentDockStateSetting.get()) || 0;
            this._lastDockStateSetting.set(this._states[(index + 1) % this._states.length]);
        }
        this.setDockSide(this._lastDockStateSetting.get());
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @constructor
 * @implements {WebInspector.ActionDelegate}
 */
WebInspector.DockController.ToggleDockActionDelegate = function()
{
}

WebInspector.DockController.ToggleDockActionDelegate.prototype = {
    /**
     * @override
     * @param {!WebInspector.Context} context
     * @param {string} actionId
     * @return {boolean}
     */
    handleAction: function(context, actionId)
    {
        WebInspector.dockController._toggleDockSide();
        return true;
    }
}

/**
 * @constructor
 * @implements {WebInspector.ToolbarItem.Provider}
 */
WebInspector.DockController.CloseButtonProvider = function()
{
}

WebInspector.DockController.CloseButtonProvider.prototype = {
    /**
     * @override
     * @return {?WebInspector.ToolbarItem}
     */
    item: function()
    {
        return WebInspector.dockController._closeButton;
    }
}

/**
 * @type {!WebInspector.DockController}
 */
WebInspector.dockController;
;/* Drawer.js */
/*
 * Copyright (C) 2007, 2008 Apple Inc.  All rights reserved.
 * Copyright (C) 2009 Joseph Pecoraro
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.VBox}
 * @param {!WebInspector.SplitWidget} splitWidget
 */
WebInspector.Drawer = function(splitWidget)
{
    WebInspector.VBox.call(this);
    this.element.id = "drawer-contents";

    this._splitWidget = splitWidget;
    splitWidget.hideDefaultResizer();
    splitWidget.setSidebarWidget(this);
    this.setMinimumSize(0, 27);

    this._tabbedPane = new WebInspector.TabbedPane();
    this._tabbedPane.element.id = "drawer-tabbed-pane";
    this._tabbedPane.addEventListener(WebInspector.TabbedPane.EventTypes.TabSelected, this._tabSelected, this);

    var toolbar = new WebInspector.Toolbar("drawer-close-toolbar");
    var closeButton = new WebInspector.ToolbarButton(WebInspector.UIString("Close drawer"), "delete-toolbar-item");
    closeButton.addEventListener("click", this.closeDrawer.bind(this));
    toolbar.appendToolbarItem(closeButton);
    this._tabbedPane.appendAfterTabStrip(toolbar.element);

    this._extensibleTabbedPaneController = new WebInspector.ExtensibleTabbedPaneController(this._tabbedPane, "drawer-view");
    this._extensibleTabbedPaneController.enableMoreTabsButton();

    splitWidget.installResizer(this._tabbedPane.headerElement());
    this._lastSelectedViewSetting = WebInspector.settings.createSetting("WebInspector.Drawer.lastSelectedView", "console");
    this._tabbedPane.show(this.element);
}

WebInspector.Drawer.prototype = {
    /**
     * @param {string} id
     * @param {boolean=} immediate
     * @return {!Promise.<?WebInspector.Widget>}
     */
    showView: function(id, immediate)
    {
        this._innerShow(immediate);
        WebInspector.userMetrics.drawerShown(id);
        return this._extensibleTabbedPaneController.showTab(id);
    },

    showDrawer: function()
    {
        this._innerShow();
    },

    wasShown: function()
    {
        var id = this._lastSelectedViewSetting.get();
        if (!this._firstTabSelected && this._tabbedPane.hasTab(id))
            this.showView(id);
    },

    willHide: function()
    {
    },

    /**
     * @param {boolean=} immediate
     */
    _innerShow: function(immediate)
    {
        if (this.isShowing())
            return;

        this._splitWidget.showBoth(!immediate);

        if (this._visibleView())
            this._visibleView().focus();
    },

    closeDrawer: function()
    {
        if (!this.isShowing())
            return;

        WebInspector.restoreFocusFromElement(this.element);
        this._splitWidget.hideSidebar(true);
    },

    /**
     * @return {?WebInspector.Widget} view
     */
    _visibleView: function()
    {
        return this._tabbedPane.visibleView;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _tabSelected: function(event)
    {
        this._firstTabSelected = true;
        var tabId = this._tabbedPane.selectedTabId;
        if (tabId && event.data["isUserGesture"])
            this._lastSelectedViewSetting.set(tabId);
    },

    /**
     * @return {?string}
     */
    selectedViewId: function()
    {
        return this._tabbedPane.selectedTabId;
    },

    initialPanelShown: function()
    {
        this._initialPanelWasShown = true;
    },

    __proto__: WebInspector.VBox.prototype
}
;/* ExecutionContextSelector.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @implements {WebInspector.TargetManager.Observer}
 * @param {!WebInspector.TargetManager} targetManager
 * @param {!WebInspector.Context} context
 */
WebInspector.ExecutionContextSelector = function(targetManager, context)
{
    targetManager.observeTargets(this);
    context.addFlavorChangeListener(WebInspector.ExecutionContext, this._executionContextChanged, this);
    context.addFlavorChangeListener(WebInspector.Target, this._targetChanged, this);

    targetManager.addModelListener(WebInspector.RuntimeModel, WebInspector.RuntimeModel.Events.ExecutionContextCreated, this._onExecutionContextCreated, this);
    targetManager.addModelListener(WebInspector.RuntimeModel, WebInspector.RuntimeModel.Events.ExecutionContextDestroyed, this._onExecutionContextDestroyed, this);
    this._targetManager = targetManager;
    this._context = context;
}

WebInspector.ExecutionContextSelector.prototype = {

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target)
    {
        if (!target.hasJSContext())
            return;
        // Defer selecting default target since we need all clients to get their
        // targetAdded notifications first.
        setImmediate(deferred.bind(this));

        /**
         * @this {WebInspector.ExecutionContextSelector}
         */
        function deferred()
        {
            // We always want the second context for the service worker targets.
            if (!this._context.flavor(WebInspector.Target))
                this._context.setFlavor(WebInspector.Target, target);
        }
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target)
    {
        if (!target.hasJSContext())
            return;
        var currentExecutionContext = this._context.flavor(WebInspector.ExecutionContext);
        if (currentExecutionContext && currentExecutionContext.target() === target)
            this._currentExecutionContextGone();

        var targets = this._targetManager.targetsWithJSContext();
        if (this._context.flavor(WebInspector.Target) === target && targets.length)
            this._context.setFlavor(WebInspector.Target, targets[0]);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _executionContextChanged: function(event)
    {
        var newContext = /** @type {?WebInspector.ExecutionContext} */ (event.data);
        if (newContext) {
            this._context.setFlavor(WebInspector.Target, newContext.target());
            if (!this._contextIsGoingAway)
                this._lastSelectedContextId = this._contextPersistentId(newContext);
        }
    },

    /**
     * @param {!WebInspector.ExecutionContext} executionContext
     * @return {string}
     */
    _contextPersistentId: function(executionContext)
    {
        return executionContext.isMainWorldContext ? executionContext.target().name() + ":" + executionContext.frameId : "";
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _targetChanged: function(event)
    {
        var newTarget = /** @type {?WebInspector.Target} */(event.data);
        var currentContext = this._context.flavor(WebInspector.ExecutionContext);

        if (!newTarget || (currentContext && currentContext.target() === newTarget))
            return;

        var executionContexts = newTarget.runtimeModel.executionContexts();
        if (!executionContexts.length)
            return;

        var newContext = executionContexts[0];
        for (var i = 1; i < executionContexts.length; ++i) {
            if (executionContexts[i].isMainWorldContext)
                newContext = executionContexts[i];
        }
        this._context.setFlavor(WebInspector.ExecutionContext, newContext);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onExecutionContextCreated: function(event)
    {
        var executionContext = /** @type {!WebInspector.ExecutionContext} */ (event.data);
        if (!this._context.flavor(WebInspector.ExecutionContext) || (this._lastSelectedContextId && this._lastSelectedContextId === this._contextPersistentId(executionContext)))
            this._context.setFlavor(WebInspector.ExecutionContext, executionContext);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onExecutionContextDestroyed: function(event)
    {
        var executionContext = /** @type {!WebInspector.ExecutionContext}*/ (event.data);
        if (this._context.flavor(WebInspector.ExecutionContext) === executionContext)
            this._currentExecutionContextGone();
    },

    _currentExecutionContextGone: function()
    {
        var targets = this._targetManager.targetsWithJSContext();
        var newContext = null;
        for (var i = 0; i < targets.length; ++i) {
            if (targets[i].isServiceWorker())
                continue;
            var executionContexts = targets[i].runtimeModel.executionContexts();
            if (executionContexts.length) {
                newContext = executionContexts[0];
                break;
            }
        }
        this._contextIsGoingAway = true;
        this._context.setFlavor(WebInspector.ExecutionContext, newContext);
        this._contextIsGoingAway = false;
    }
}

/**
 * @param {!Element} proxyElement
 * @param {string} text
 * @param {number} cursorOffset
 * @param {!Range} wordRange
 * @param {boolean} force
 * @param {function(!Array.<string>, number=)} completionsReadyCallback
 */
WebInspector.ExecutionContextSelector.completionsForTextPromptInCurrentContext = function(proxyElement, text, cursorOffset, wordRange, force, completionsReadyCallback)
{
    var executionContext = WebInspector.context.flavor(WebInspector.ExecutionContext);
    if (!executionContext) {
        completionsReadyCallback([]);
        return;
    }

    // Pass less stop characters to rangeOfWord so the range will be a more complete expression.
    var expressionRange = wordRange.startContainer.rangeOfWord(wordRange.startOffset, " =:({;,!+-*/&|^<>", proxyElement, "backward");
    var expressionString = expressionRange.toString();

    // The "[" is also a stop character, except when it's the last character of the expression.
    var pos = expressionString.lastIndexOf("[", expressionString.length - 2);
    if (pos !== -1)
        expressionString = expressionString.substr(pos + 1);

    var prefix = wordRange.toString();
    executionContext.completionsForExpression(expressionString, text, cursorOffset, prefix, force, completionsReadyCallback);
}
;/* ExecutionContextModel.js */
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @implements {WebInspector.TargetManager.Observer}
 * @param {!Element} selectElement
 */
WebInspector.ExecutionContextModel = function(selectElement)
{
    this._selectElement = selectElement;
    /**
     * @type {!Map.<!WebInspector.ExecutionContext, !Element>}
     */
    this._optionByExecutionContext = new Map();

    WebInspector.targetManager.observeTargets(this);
    WebInspector.targetManager.addModelListener(WebInspector.RuntimeModel, WebInspector.RuntimeModel.Events.ExecutionContextCreated, this._onExecutionContextCreated, this);
    WebInspector.targetManager.addModelListener(WebInspector.RuntimeModel, WebInspector.RuntimeModel.Events.ExecutionContextDestroyed, this._onExecutionContextDestroyed, this);
    WebInspector.targetManager.addModelListener(WebInspector.ResourceTreeModel, WebInspector.ResourceTreeModel.EventTypes.FrameNavigated, this._onFrameNavigated, this);

    this._selectElement.addEventListener("change", this._executionContextChanged.bind(this), false);
    WebInspector.context.addFlavorChangeListener(WebInspector.ExecutionContext, this._executionContextChangedExternally, this);
}

WebInspector.ExecutionContextModel.prototype = {
    /**
     * @param {!WebInspector.ExecutionContext} executionContext
     * @return {string}
     */
    _titleFor: function(executionContext)
    {
        var result;
        if (executionContext.isMainWorldContext) {
            if (executionContext.frameId) {
                var frame = executionContext.target().resourceTreeModel.frameForId(executionContext.frameId);
                result =  frame ? frame.displayName() : (executionContext.origin || executionContext.name);
            } else {
                var parsedUrl = executionContext.origin.asParsedURL();
                var name = parsedUrl? parsedUrl.lastPathComponentWithFragment() : executionContext.name;
                result = executionContext.target().decorateLabel(name);
            }
        } else {
            result = "\u00a0\u00a0\u00a0\u00a0" + (executionContext.name || executionContext.origin);
        }

        var maxLength = 50;
        return result.trimMiddle(maxLength);
    },

    /**
     * @param {!WebInspector.ExecutionContext} executionContext
     */
    _executionContextCreated: function(executionContext)
    {
        // FIXME(413886): We never want to show execution context for the main thread of shadow page in service/shared worker frontend.
        // This check could be removed once we do not send this context to frontend.
        if (executionContext.target().isServiceWorker())
            return;

        var newOption = createElement("option");
        newOption.__executionContext = executionContext;
        newOption.text = this._titleFor(executionContext);
        this._optionByExecutionContext.set(executionContext, newOption);
        var options = this._selectElement.options;
        var contexts = Array.prototype.map.call(options, mapping);
        var index = insertionIndexForObjectInListSortedByFunction(executionContext, contexts, WebInspector.ExecutionContext.comparator);
        this._selectElement.insertBefore(newOption, options[index]);

        if (executionContext === WebInspector.context.flavor(WebInspector.ExecutionContext))
            this._select(newOption);

        /**
         * @param {!Element} option
         * @return {!WebInspector.ExecutionContext}
         */
        function mapping(option)
        {
            return option.__executionContext;
        }
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onExecutionContextCreated: function(event)
    {
        var executionContext = /** @type {!WebInspector.ExecutionContext} */ (event.data);
        this._executionContextCreated(executionContext);
    },

    /**
     * @param {!WebInspector.ExecutionContext} executionContext
     */
    _executionContextDestroyed: function(executionContext)
    {
        var option = this._optionByExecutionContext.remove(executionContext);
        option.remove();
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onExecutionContextDestroyed: function(event)
    {
        var executionContext = /** @type {!WebInspector.ExecutionContext} */ (event.data);
        this._executionContextDestroyed(executionContext);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onFrameNavigated: function(event)
    {
        var frame = /** @type {!WebInspector.ResourceTreeFrame} */ (event.data);
        var executionContexts = this._optionByExecutionContext.keysArray();
        for (var i = 0; i < executionContexts.length; ++i) {
            var context = executionContexts[i];
            if (context.frameId === frame.id)
                this._optionByExecutionContext.get(context).text = this._titleFor(context);
        }
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _executionContextChangedExternally: function(event)
    {
        var executionContext =  /** @type {?WebInspector.ExecutionContext} */ (event.data);
        if (!executionContext)
            return;

        var options = this._selectElement.options;
        for (var i = 0; i < options.length; ++i) {
            if (options[i].__executionContext === executionContext)
                this._select(options[i]);
        }
    },

    _executionContextChanged: function()
    {
        var option = this._selectedOption();
        var newContext = option ? option.__executionContext : null;
        WebInspector.context.setFlavor(WebInspector.ExecutionContext, newContext);
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target)
    {
        target.runtimeModel.executionContexts().forEach(this._executionContextCreated, this);
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target)
    {
        var executionContexts = this._optionByExecutionContext.keysArray();
        for (var i = 0; i < executionContexts.length; ++i) {
            if (executionContexts[i].target() === target)
                this._executionContextDestroyed(executionContexts[i]);
        }
    },

    /**
     * @param {!Element} option
     */
    _select: function(option)
    {
        this._selectElement.selectedIndex = Array.prototype.indexOf.call(/** @type {?} */ (this._selectElement), option);
    },

    /**
     * @return {?Element}
     */
    _selectedOption: function()
    {
        if (this._selectElement.selectedIndex >= 0)
            return this._selectElement[this._selectElement.selectedIndex];
        return null;
    }
}
;/* HandlerRegistry.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Object}
 */
WebInspector.HandlerRegistry = function(setting)
{
    WebInspector.Object.call(this);
    this._handlers = {};
    this._setting = setting;
    this._activeHandler = this._setting.get();
}

WebInspector.HandlerRegistry.prototype = {
    get handlerNames()
    {
        return Object.getOwnPropertyNames(this._handlers);
    },

    get activeHandler()
    {
        return this._activeHandler;
    },

    set activeHandler(value)
    {
        this._activeHandler = value;
        this._setting.set(value);
    },

    /**
     * @param {!Object} data
     * @return {boolean}
     */
    dispatch: function(data)
    {
        return this.dispatchToHandler(this._activeHandler, data);
    },

    /**
     * @param {string} name
     * @param {!Object} data
     * @return {boolean}
     */
    dispatchToHandler: function(name, data)
    {
        var handler = this._handlers[name];
        var result = handler && handler(data);
        return !!result;
    },

    registerHandler: function(name, handler)
    {
        this._handlers[name] = handler;
        this.dispatchEventToListeners(WebInspector.HandlerRegistry.EventTypes.HandlersUpdated);
    },

    unregisterHandler: function(name)
    {
        delete this._handlers[name];
        this.dispatchEventToListeners(WebInspector.HandlerRegistry.EventTypes.HandlersUpdated);
    },

    /**
     * @param {string} url
     */
    _openInNewTab: function(url)
    {
        InspectorFrontendHost.openInNewTab(url);
    },

    /**
     * @param {!WebInspector.ContextMenu} contextMenu
     * @param {!Object} target
     */
    _appendContentProviderItems: function(contextMenu, target)
    {
        if (!(target instanceof WebInspector.UISourceCode || target instanceof WebInspector.Resource || target instanceof WebInspector.NetworkRequest))
            return;
        var contentProvider = /** @type {!WebInspector.ContentProvider} */ (target);
        if (!contentProvider.contentURL())
            return;

        contextMenu.appendItem(WebInspector.openLinkExternallyLabel(), this._openInNewTab.bind(this, contentProvider.contentURL()));
        // Skip 0th handler, as it's 'Use default panel' one.
        for (var i = 1; i < this.handlerNames.length; ++i) {
            var handler = this.handlerNames[i];
            contextMenu.appendItem(WebInspector.UIString.capitalize("Open ^using %s", handler),
                this.dispatchToHandler.bind(this, handler, { url: contentProvider.contentURL() }));
        }
        contextMenu.appendItem(WebInspector.copyLinkAddressLabel(), InspectorFrontendHost.copyText.bind(InspectorFrontendHost, contentProvider.contentURL()));

        if (!contentProvider.contentURL())
            return;

        if (!contentProvider.contentType().isDocumentOrScriptOrStyleSheet())
            return;

        /**
         * @param {boolean} forceSaveAs
         * @param {?string} content
         */
        function doSave(forceSaveAs, content)
        {
            var url = contentProvider.contentURL();
            WebInspector.fileManager.save(url, /** @type {string} */ (content), forceSaveAs);
            WebInspector.fileManager.close(url);
        }

        /**
         * @param {boolean} forceSaveAs
         */
        function save(forceSaveAs)
        {
            if (contentProvider instanceof WebInspector.UISourceCode) {
                var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (contentProvider);
                if (forceSaveAs)
                    uiSourceCode.saveAs();
                else
                    uiSourceCode.commitWorkingCopy();
                return;
            }
            contentProvider.requestContent().then(doSave.bind(null, forceSaveAs));
        }

        contextMenu.appendSeparator();
        contextMenu.appendItem(WebInspector.UIString("Save"), save.bind(null, false));

        if (contentProvider instanceof WebInspector.UISourceCode) {
            var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (contentProvider);
            if (uiSourceCode.project().type() !== WebInspector.projectTypes.FileSystem && uiSourceCode.project().type() !== WebInspector.projectTypes.Snippets)
                contextMenu.appendItem(WebInspector.UIString.capitalize("Save ^as..."), save.bind(null, true));
        }
    },

    /**
     * @param {!WebInspector.ContextMenu} contextMenu
     * @param {!Object} target
     */
    _appendHrefItems: function(contextMenu, target)
    {
        if (!(target instanceof Node))
            return;
        var targetNode = /** @type {!Node} */ (target);

        var anchorElement = targetNode.enclosingNodeOrSelfWithClass("webkit-html-resource-link") || targetNode.enclosingNodeOrSelfWithClass("webkit-html-external-link");
        if (!anchorElement)
            return;

        var uiLocation = WebInspector.Linkifier.uiLocationByAnchor(anchorElement);
        var resourceURL = uiLocation ? uiLocation.uiSourceCode.contentURL() : anchorElement.href;
        var uiSourceCode = uiLocation ? uiLocation.uiSourceCode : (resourceURL ? WebInspector.networkMapping.uiSourceCodeForURLForAnyTarget(resourceURL) : null);
        function open()
        {
            WebInspector.Revealer.reveal(uiSourceCode);
        }
        if (uiSourceCode)
            contextMenu.appendItem("Open", open);

        if (!resourceURL)
            return;
        // Add resource-related actions.
        contextMenu.appendItem(WebInspector.openLinkExternallyLabel(), this._openInNewTab.bind(this, resourceURL));

        /**
         * @param {string} resourceURL
         */
        function openInResourcesPanel(resourceURL)
        {
            var resource = WebInspector.resourceForURL(resourceURL);
            if (resource)
                WebInspector.Revealer.reveal(resource);
            else
                InspectorFrontendHost.openInNewTab(resourceURL);
        }
        if (!targetNode.enclosingNodeOrSelfWithClassList(["resources", "panel"]) && WebInspector.resourceForURL(resourceURL))
            contextMenu.appendItem(WebInspector.UIString.capitalize("Open ^link in Resources ^panel"), openInResourcesPanel.bind(null, resourceURL));


        contextMenu.appendItem(WebInspector.copyLinkAddressLabel(), InspectorFrontendHost.copyText.bind(InspectorFrontendHost, resourceURL));
    },

    __proto__: WebInspector.Object.prototype
}


WebInspector.HandlerRegistry.EventTypes = {
    HandlersUpdated: "HandlersUpdated"
}

/**
 * @constructor
 */
WebInspector.HandlerSelector = function(handlerRegistry)
{
    this._handlerRegistry = handlerRegistry;
    this.element = createElementWithClass("select", "chrome-select");
    this.element.addEventListener("change", this._onChange.bind(this), false);
    this._update();
    this._handlerRegistry.addEventListener(WebInspector.HandlerRegistry.EventTypes.HandlersUpdated, this._update.bind(this));
}

WebInspector.HandlerSelector.prototype =
{
    _update: function()
    {
        this.element.removeChildren();
        var names = this._handlerRegistry.handlerNames;
        var activeHandler = this._handlerRegistry.activeHandler;

        for (var i = 0; i < names.length; ++i) {
            var option = createElement("option");
            option.textContent = names[i];
            option.selected = activeHandler === names[i];
            this.element.appendChild(option);
        }
        this.element.disabled = names.length <= 1;
    },

    _onChange: function(event)
    {
        var value = event.target.value;
        this._handlerRegistry.activeHandler = value;
    }
}

/**
 * @constructor
 * @implements {WebInspector.ContextMenu.Provider}
 */
WebInspector.HandlerRegistry.ContextMenuProvider = function()
{
}

WebInspector.HandlerRegistry.ContextMenuProvider.prototype = {
    /**
     * @override
     * @param {!Event} event
     * @param {!WebInspector.ContextMenu} contextMenu
     * @param {!Object} target
     */
    appendApplicableItems: function(event, contextMenu, target)
    {
        WebInspector.openAnchorLocationRegistry._appendContentProviderItems(contextMenu, target);
        WebInspector.openAnchorLocationRegistry._appendHrefItems(contextMenu, target);
    }
}

/**
 * @constructor
 * @implements {WebInspector.Linkifier.LinkHandler}
 */
WebInspector.HandlerRegistry.LinkHandler = function()
{
}

WebInspector.HandlerRegistry.LinkHandler.prototype = {
    /**
     * @override
     * @param {string} url
     * @param {number=} lineNumber
     * @return {boolean}
     */
    handleLink: function(url, lineNumber)
    {
        return WebInspector.openAnchorLocationRegistry.dispatch({ url: url, lineNumber: lineNumber});
    }
}

/**
 * @constructor
 * @implements {WebInspector.SettingUI}
 */
WebInspector.HandlerRegistry.OpenAnchorLocationSettingUI = function()
{
}

WebInspector.HandlerRegistry.OpenAnchorLocationSettingUI.prototype = {
    /**
     * @override
     * @return {?Element}
     */
    settingElement: function()
    {
        if (!WebInspector.openAnchorLocationRegistry.handlerNames.length)
            return null;

        var handlerSelector = new WebInspector.HandlerSelector(WebInspector.openAnchorLocationRegistry);
        return WebInspector.SettingsUI.createCustomSetting(WebInspector.UIString("Link handling:"), handlerSelector.element);
    }
}

/**
 * @type {!WebInspector.HandlerRegistry}
 */
WebInspector.openAnchorLocationRegistry;
;/* InspectorView.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.VBox}
 */
WebInspector.InspectorView = function()
{
    WebInspector.VBox.call(this);
    WebInspector.Dialog.setModalHostView(this);
    WebInspector.GlassPane.DefaultFocusedViewStack.push(this);
    this.setMinimumSize(240, 72);

    // DevTools sidebar is a vertical split of panels tabbed pane and a drawer.
    this._drawerSplitWidget = new WebInspector.SplitWidget(false, true, "Inspector.drawerSplitViewState", 200, 200);
    this._drawerSplitWidget.hideSidebar();
    this._drawerSplitWidget.enableShowModeSaving();
    this._drawerSplitWidget.show(this.element);

    this._tabbedPane = new WebInspector.TabbedPane();
    this._tabbedPane.registerRequiredCSS("components/inspectorViewTabbedPane.css");
    this._tabbedPane.element.classList.add("inspector-view-tabbed-pane");
    this._tabbedPane.setTabSlider(true);
    this._tabbedPane.setAllowTabReorder(true, false);
    this._tabbedPane.addEventListener(WebInspector.TabbedPane.EventTypes.TabOrderChanged, this._persistPanelOrder, this);
    this._tabOrderSetting = WebInspector.settings.createSetting("InspectorView.panelOrder", {});
    this._drawerSplitWidget.setMainWidget(this._tabbedPane);
    this._drawer = new WebInspector.Drawer(this._drawerSplitWidget);

    this._panels = {};
    // Used by tests.
    WebInspector["panels"] = this._panels;

    this._history = [];
    this._historyIterator = -1;
    this._keyDownBound = this._keyDown.bind(this);
    this._keyPressBound = this._keyPress.bind(this);
    /** @type {!Object.<string, !WebInspector.PanelDescriptor>} */
    this._panelDescriptors = {};
    /** @type {!Object.<string, !Promise.<!WebInspector.Panel> >} */
    this._panelPromises = {};

    // Windows and Mac have two different definitions of '[' and ']', so accept both of each.
    this._openBracketIdentifiers = ["U+005B", "U+00DB"].keySet();
    this._closeBracketIdentifiers = ["U+005D", "U+00DD"].keySet();
    this._lastActivePanelSetting = WebInspector.settings.createSetting("lastActivePanel", "elements");

    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.ShowPanel, showPanel.bind(this));
    this._loadPanelDesciptors();

    /**
     * @this {WebInspector.InspectorView}
     * @param {!WebInspector.Event} event
     */
    function showPanel(event)
    {
        var panelName = /** @type {string} */ (event.data);
        this.showPanel(panelName);
    }

    WebInspector.targetManager.addEventListener(WebInspector.TargetManager.Events.SuspendStateChanged, this._onSuspendStateChanged.bind(this));
};

WebInspector.InspectorView.prototype = {
    wasShown: function()
    {
        this.element.ownerDocument.addEventListener("keydown", this._keyDownBound, false);
        this.element.ownerDocument.addEventListener("keypress", this._keyPressBound, false);
    },

    willHide: function()
    {
        this.element.ownerDocument.removeEventListener("keydown", this._keyDownBound, false);
        this.element.ownerDocument.removeEventListener("keypress", this._keyPressBound, false);
    },

    _loadPanelDesciptors: function()
    {
        /**
         * @param {!Runtime.Extension} extension
         * @this {!WebInspector.InspectorView}
         */
        function processPanelExtensions(extension)
        {
            var descriptor = new WebInspector.RuntimeExtensionPanelDescriptor(extension);
            var weight = this._tabOrderSetting.get()[descriptor.name()];
            if (weight === undefined)
                weight = extension.descriptor()["order"];
            if (weight === undefined)
                weight = 10000;
            panelWeights.set(descriptor, weight);
        }

        /**
         * @param {!WebInspector.PanelDescriptor} left
         * @param {!WebInspector.PanelDescriptor} right
         */
        function orderComparator(left, right)
        {
            return panelWeights.get(left) > panelWeights.get(right);
        }

        WebInspector.startBatchUpdate();
        /** @type {!Map.<!WebInspector.PanelDescriptor, number>} */
        var panelWeights = new Map();
        self.runtime.extensions(WebInspector.PanelFactory).forEach(processPanelExtensions.bind(this));
        var sortedPanels = panelWeights.keysArray().sort(orderComparator);
        for (var panelDescriptor of sortedPanels)
            this._innerAddPanel(panelDescriptor);
        WebInspector.endBatchUpdate();
    },

    createToolbars: function()
    {
        this._leftToolbar = new WebInspector.ExtensibleToolbar("main-toolbar-left");
        this._leftToolbar.element.classList.add("inspector-view-toolbar", "inspector-view-toolbar-left");

        this._tabbedPane.insertBeforeTabStrip(this._leftToolbar.element);

        var rightToolbarContainer = createElementWithClass("div", "hbox flex-none flex-centered");
        this._tabbedPane.appendAfterTabStrip(rightToolbarContainer);

        this._rightToolbar = new WebInspector.ExtensibleToolbar("main-toolbar-right");
        this._rightToolbar.element.classList.add("inspector-view-toolbar", "flex-none");
        rightToolbarContainer.appendChild(this._rightToolbar.element);
    },

    /**
     * @param {!WebInspector.PanelDescriptor} panelDescriptor
     * @param {number=} index
     */
    _innerAddPanel: function(panelDescriptor, index)
    {
        var panelName = panelDescriptor.name();
        this._panelDescriptors[panelName] = panelDescriptor;
        this._tabbedPane.appendTab(panelName, panelDescriptor.title(), new WebInspector.Widget(), undefined, undefined, undefined, index);
        if (this._lastActivePanelSetting.get() === panelName)
            this._tabbedPane.selectTab(panelName);
    },

    /**
     * @param {!WebInspector.PanelDescriptor} panelDescriptor
     */
    addPanel: function(panelDescriptor)
    {
        var weight = this._tabOrderSetting.get()[panelDescriptor.name()];
        // Keep in sync with _persistPanelOrder().
        if (weight)
            weight = Math.max(0, Math.round(weight / 10) - 1);
        this._innerAddPanel(panelDescriptor, weight);
    },

    /**
     * @param {string} panelName
     * @return {boolean}
     */
    hasPanel: function(panelName)
    {
        return !!this._panelDescriptors[panelName];
    },

    /**
     * @param {string} panelName
     * @return {!Promise.<!WebInspector.Panel>}
     */
    panel: function(panelName)
    {
        var panelDescriptor = this._panelDescriptors[panelName];
        if (!panelDescriptor)
            return Promise.reject(new Error("Can't load panel without the descriptor: " + panelName));

        var promise = this._panelPromises[panelName];
        if (promise)
            return promise;

        promise = panelDescriptor.panel();
        this._panelPromises[panelName] = promise;

        promise.then(cachePanel.bind(this));

        /**
         * @param {!WebInspector.Panel} panel
         * @return {!WebInspector.Panel}
         * @this {WebInspector.InspectorView}
         */
        function cachePanel(panel)
        {
            delete this._panelPromises[panelName];
            this._panels[panelName] = panel;
            return panel;
        }
        return promise;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onSuspendStateChanged: function(event)
    {
        this._currentPanelLocked = WebInspector.targetManager.allTargetsSuspended();
        this._tabbedPane.setCurrentTabLocked(this._currentPanelLocked);
        if (this._leftToolbar)
            this._leftToolbar.setEnabled(!this._currentPanelLocked);
        if (this._rightToolbar)
            this._rightToolbar.setEnabled(!this._currentPanelLocked);
    },

    /**
     * The returned Promise is resolved with null if another showPanel()
     * gets called while this.panel(panelName) Promise is in flight.
     *
     * @param {string} panelName
     * @return {!Promise.<?WebInspector.Panel>}
     */
    showPanel: function(panelName)
    {
        if (this._currentPanelLocked) {
            if (this._currentPanel !== this._panels[panelName])
                return Promise.reject(new Error("Current panel locked"));
            return Promise.resolve(this._currentPanel);
        }

        this._panelForShowPromise = this.panel(panelName);
        return this._panelForShowPromise.then(setCurrentPanelIfNecessary.bind(this, this._panelForShowPromise));

        /**
         * @param {!Promise.<!WebInspector.Panel>} panelPromise
         * @param {!WebInspector.Panel} panel
         * @return {?WebInspector.Panel}
         * @this {WebInspector.InspectorView}
         */
        function setCurrentPanelIfNecessary(panelPromise, panel)
        {
            if (this._panelForShowPromise !== panelPromise)
                return null;

            this.setCurrentPanel(panel);
            return panel;
        }
    },

    /**
     * @param {string} panelName
     * @param {string} iconType
     * @param {string=} iconTooltip
     */
    setPanelIcon: function(panelName, iconType, iconTooltip)
    {
        this._tabbedPane.setTabIcon(panelName, iconType, iconTooltip);
    },

    /**
     * @return {!WebInspector.Panel}
     */
    currentPanel: function()
    {
        return this._currentPanel;
    },

    showInitialPanel: function()
    {
        if (InspectorFrontendHost.isUnderTest())
            return;
        this._showInitialPanel();
    },

    _showInitialPanel: function()
    {
        this._tabbedPane.addEventListener(WebInspector.TabbedPane.EventTypes.TabSelected, this._tabSelected, this);
        this._tabSelected();
        this._drawer.initialPanelShown();
    },

    /**
     * @param {string} panelName
     */
    showInitialPanelForTest: function(panelName)
    {
        this._tabbedPane.addEventListener(WebInspector.TabbedPane.EventTypes.TabSelected, this._tabSelected, this);
        this.setCurrentPanel(this._panels[panelName]);
        this._drawer.initialPanelShown();
    },

    _tabSelected: function()
    {
        var panelName = this._tabbedPane.selectedTabId;
        if (!panelName)
            return;

        this.showPanel(panelName);
    },

    /**
     * @param {!WebInspector.Panel} panel
     * @param {boolean=} suppressBringToFront
     * @return {!WebInspector.Panel}
     */
    setCurrentPanel: function(panel, suppressBringToFront)
    {
        delete this._panelForShowPromise;

        if (this._currentPanelLocked)
            return this._currentPanel;

        if (!suppressBringToFront)
            InspectorFrontendHost.bringToFront();

        if (this._currentPanel === panel)
            return panel;

        this._currentPanel = panel;
        if (!this._panels[panel.name])
            this._panels[panel.name] = panel;
        this._tabbedPane.changeTabView(panel.name, panel);
        this._tabbedPane.removeEventListener(WebInspector.TabbedPane.EventTypes.TabSelected, this._tabSelected, this);
        this._tabbedPane.selectTab(panel.name);
        this._tabbedPane.addEventListener(WebInspector.TabbedPane.EventTypes.TabSelected, this._tabSelected, this);

        this._lastActivePanelSetting.set(panel.name);
        this._pushToHistory(panel.name);
        WebInspector.userMetrics.panelShown(panel.name);
        panel.focus();

        return panel;
    },

    showDrawer: function()
    {
        this._drawer.showDrawer();
    },

    /**
     * @return {boolean}
     */
    drawerVisible: function()
    {
        return this._drawer.isShowing();
    },

    /**
     * @param {string} id
     * @param {boolean=} immediate
     * @return {!Promise.<?WebInspector.Widget>}
     */
    showViewInDrawer: function(id, immediate)
    {
        return this._drawer.showView(id, immediate);
    },

    /**
     * @return {?string}
     */
    selectedViewInDrawer: function()
    {
        return this._drawer.selectedViewId();
    },

    closeDrawer: function()
    {
        this._drawer.closeDrawer();
    },

    /**
     * @param {boolean} minimized
     */
    setDrawerMinimized: function(minimized)
    {
        this._drawerSplitWidget.setSidebarMinimized(minimized);
        this._drawerSplitWidget.setResizable(!minimized);
    },

    /**
     * @override
     * @return {!Element}
     */
    defaultFocusedElement: function()
    {
        return this._currentPanel ? this._currentPanel.defaultFocusedElement() : null;
    },

    _keyPress: function(event)
    {
        // BUG 104250: Windows 7 posts a WM_CHAR message upon the Ctrl+']' keypress.
        // Any charCode < 32 is not going to be a valid keypress.
        if (event.charCode < 32 && WebInspector.isWin())
            return;
        clearTimeout(this._keyDownTimer);
        delete this._keyDownTimer;
    },

    _keyDown: function(event)
    {
        if (!WebInspector.KeyboardShortcut.eventHasCtrlOrMeta(event))
            return;

        var keyboardEvent = /** @type {!KeyboardEvent} */ (event);
        // Ctrl/Cmd + 1-9 should show corresponding panel.
        var panelShortcutEnabled = WebInspector.moduleSetting("shortcutPanelSwitch").get();
        if (panelShortcutEnabled && !event.shiftKey && !event.altKey) {
            var panelIndex = -1;
            if (event.keyCode > 0x30 && event.keyCode < 0x3A)
                panelIndex = event.keyCode - 0x31;
            else if (event.keyCode > 0x60 && event.keyCode < 0x6A && keyboardEvent.location === KeyboardEvent.DOM_KEY_LOCATION_NUMPAD)
                panelIndex = event.keyCode - 0x61;
            if (panelIndex !== -1) {
                var panelName = this._tabbedPane.allTabs()[panelIndex];
                if (panelName) {
                    if (!WebInspector.Dialog.hasInstance() && !this._currentPanelLocked)
                        this.showPanel(panelName);
                    event.consume(true);
                }
                return;
            }
        }

        // BUG85312: On French AZERTY keyboards, AltGr-]/[ combinations (synonymous to Ctrl-Alt-]/[ on Windows) are used to enter ]/[,
        // so for a ]/[-related keydown we delay the panel switch using a timer, to see if there is a keypress event following this one.
        // If there is, we cancel the timer and do not consider this a panel switch.
        if (!WebInspector.isWin() || (!this._openBracketIdentifiers[event.keyIdentifier] && !this._closeBracketIdentifiers[event.keyIdentifier])) {
            this._keyDownInternal(event);
            return;
        }

        this._keyDownTimer = setTimeout(this._keyDownInternal.bind(this, event), 0);
    },

    _keyDownInternal: function(event)
    {
        if (this._currentPanelLocked)
            return;

        var direction = 0;

        if (this._openBracketIdentifiers[event.keyIdentifier])
            direction = -1;

        if (this._closeBracketIdentifiers[event.keyIdentifier])
            direction = 1;

        if (!direction)
            return;

        if (!event.shiftKey && !event.altKey) {
            if (!WebInspector.Dialog.hasInstance())
                this._changePanelInDirection(direction);
            event.consume(true);
            return;
        }

        if (event.altKey && this._moveInHistory(direction))
            event.consume(true);
    },

    /**
     * @param {number} direction
     */
    _changePanelInDirection: function(direction)
    {
        var panelOrder = this._tabbedPane.allTabs();
        var index = panelOrder.indexOf(this.currentPanel().name);
        index = (index + panelOrder.length + direction) % panelOrder.length;
        this.showPanel(panelOrder[index]);
    },

    /**
     * @param {number} move
     */
    _moveInHistory: function(move)
    {
        var newIndex = this._historyIterator + move;
        if (newIndex >= this._history.length || newIndex < 0)
            return false;

        this._inHistory = true;
        this._historyIterator = newIndex;
        if (!WebInspector.Dialog.hasInstance())
            this.setCurrentPanel(this._panels[this._history[this._historyIterator]]);
        delete this._inHistory;

        return true;
    },

    _pushToHistory: function(panelName)
    {
        if (this._inHistory)
            return;

        this._history.splice(this._historyIterator + 1, this._history.length - this._historyIterator - 1);
        if (!this._history.length || this._history[this._history.length - 1] !== panelName)
            this._history.push(panelName);
        this._historyIterator = this._history.length - 1;
    },

    onResize: function()
    {
        WebInspector.Dialog.modalHostRepositioned();
    },

    /**
     * @return {!Element}
     */
    topResizerElement: function()
    {
        return this._tabbedPane.headerElement();
    },

    toolbarItemResized: function()
    {
        this._tabbedPane.headerResized();
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _persistPanelOrder: function(event)
    {
        var tabs = /** @type {!Array.<!WebInspector.TabbedPaneTab>} */(event.data);
        var tabOrders = this._tabOrderSetting.get();
        for (var i = 0; i < tabs.length; i++)
            tabOrders[tabs[i].id] = (i + 1)* 10;
        this._tabOrderSetting.set(tabOrders);
    },

    __proto__: WebInspector.VBox.prototype
};

/**
 * @type {!WebInspector.InspectorView}
 */
WebInspector.inspectorView;

/**
 * @constructor
 * @implements {WebInspector.ActionDelegate}
 */
WebInspector.InspectorView.DrawerToggleActionDelegate = function()
{
}

WebInspector.InspectorView.DrawerToggleActionDelegate.prototype = {
    /**
     * @override
     * @param {!WebInspector.Context} context
     * @param {string} actionId
     * @return {boolean}
     */
    handleAction: function(context, actionId)
    {
        if (WebInspector.inspectorView.drawerVisible())
            WebInspector.inspectorView.closeDrawer();
        else
            WebInspector.inspectorView.showDrawer();
        return true;
    }
}
;/* Linkifier.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @interface
 */
WebInspector.LinkifierFormatter = function()
{
}

WebInspector.LinkifierFormatter.prototype = {
    /**
     * @param {!Element} anchor
     * @param {!WebInspector.UILocation} uiLocation
     * @param {boolean} isBlackboxed
     */
    formatLiveAnchor: function(anchor, uiLocation, isBlackboxed) { }
}

/**
 * @constructor
 * @implements {WebInspector.TargetManager.Observer}
 * @param {!WebInspector.LinkifierFormatter=} formatter
 */
WebInspector.Linkifier = function(formatter)
{
    this._formatter = formatter || new WebInspector.Linkifier.DefaultFormatter(WebInspector.Linkifier.MaxLengthForDisplayedURLs);
    /** @type {!Map.<!WebInspector.Target, !Map.<!Element, !WebInspector.LiveLocation>>}*/
    this._liveLocationsByTarget = new Map();
    WebInspector.targetManager.observeTargets(this);
}

/**
 * @param {?WebInspector.Linkifier.LinkHandler} handler
 */
WebInspector.Linkifier.setLinkHandler = function(handler)
{
    WebInspector.Linkifier._linkHandler = handler;
}

/**
 * @param {string} url
 * @param {number=} lineNumber
 * @return {boolean}
 */
WebInspector.Linkifier.handleLink = function(url, lineNumber)
{
    if (!WebInspector.Linkifier._linkHandler)
        return false;
    return WebInspector.Linkifier._linkHandler.handleLink(url, lineNumber);
}

/**
 * @param {!Object} revealable
 * @param {string} text
 * @param {string=} fallbackHref
 * @param {number=} fallbackLineNumber
 * @param {string=} title
 * @param {string=} classes
 * @return {!Element}
 */
WebInspector.Linkifier.linkifyUsingRevealer = function(revealable, text, fallbackHref, fallbackLineNumber, title, classes)
{
    var a = createElement("a");
    a.className = (classes || "") + " webkit-html-resource-link";
    a.textContent = text.trimMiddle(WebInspector.Linkifier.MaxLengthForDisplayedURLs);
    a.title = title || text;
    if (fallbackHref) {
        a.href = fallbackHref;
        a.lineNumber = fallbackLineNumber;
    }
    /**
     * @param {!Event} event
     * @this {Object}
     */
    function clickHandler(event)
    {
        event.stopImmediatePropagation();
        event.preventDefault();
        if (fallbackHref && WebInspector.Linkifier.handleLink(fallbackHref, fallbackLineNumber))
            return;

        WebInspector.Revealer.reveal(this);
    }
    a.addEventListener("click", clickHandler.bind(revealable), false);
    return a;
}

WebInspector.Linkifier._uiLocationSymbol = Symbol("uiLocation");
WebInspector.Linkifier._fallbackAnchorSymbol = Symbol("fallbackAnchor");

WebInspector.Linkifier.prototype = {
    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target)
    {
        this._liveLocationsByTarget.set(target, new Map());
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target)
    {
        var liveLocations = this._liveLocationsByTarget.remove(target);
        var anchors = liveLocations.keysArray();
        for (var i = 0; i < anchors.length; ++i) {
            var anchor = anchors[i];
            var location = liveLocations.get(anchor);
            delete anchor[WebInspector.Linkifier._uiLocationSymbol];
            var fallbackAnchor = anchor[WebInspector.Linkifier._fallbackAnchorSymbol];
            if (fallbackAnchor) {
                anchor.href = fallbackAnchor.href;
                anchor.lineNumber = fallbackAnchor.lineNumber;
                anchor.title = fallbackAnchor.title;
                anchor.className = fallbackAnchor.className;
                anchor.textContent = fallbackAnchor.textContent;
                delete anchor[WebInspector.Linkifier._fallbackAnchorSymbol];
            }
            location.dispose();
        }
    },

    /**
     * @param {?WebInspector.Target} target
     * @param {?string} scriptId
     * @param {string} sourceURL
     * @param {number} lineNumber
     * @param {number=} columnNumber
     * @param {string=} classes
     * @return {!Element}
     */
    linkifyScriptLocation: function(target, scriptId, sourceURL, lineNumber, columnNumber, classes)
    {
        var fallbackAnchor = WebInspector.linkifyResourceAsNode(sourceURL, lineNumber, columnNumber, classes);
        if (!target || target.isDetached())
            return fallbackAnchor;
        var debuggerModel = WebInspector.DebuggerModel.fromTarget(target);
        if (!debuggerModel)
            return fallbackAnchor;

        var rawLocation = scriptId ? debuggerModel.createRawLocationByScriptId(scriptId, lineNumber, columnNumber || 0) :
                                     debuggerModel.createRawLocationByURL(sourceURL, lineNumber, columnNumber || 0);
        if (!rawLocation)
            return fallbackAnchor;

        var anchor = this._createAnchor(classes);
        var liveLocation = WebInspector.debuggerWorkspaceBinding.createLiveLocation(rawLocation, this._updateAnchor.bind(this, anchor));
        this._liveLocationsByTarget.get(rawLocation.target()).set(anchor, liveLocation);
        anchor[WebInspector.Linkifier._fallbackAnchorSymbol] = fallbackAnchor;
        return anchor;
    },

    /**
     * @param {!WebInspector.DebuggerModel.Location} rawLocation
     * @param {string} fallbackUrl
     * @param {string=} classes
     * @return {!Element}
     */
    linkifyRawLocation: function(rawLocation, fallbackUrl, classes)
    {
        return this.linkifyScriptLocation(rawLocation.target(), rawLocation.scriptId, fallbackUrl, rawLocation.lineNumber, rawLocation.columnNumber, classes);
    },

    /**
     * @param {?WebInspector.Target} target
     * @param {!RuntimeAgent.CallFrame} callFrame
     * @param {string=} classes
     * @return {!Element}
     */
    linkifyConsoleCallFrame: function(target, callFrame, classes)
    {
        return this.linkifyScriptLocation(target, callFrame.scriptId, callFrame.url, WebInspector.DebuggerModel.fromOneBased(callFrame.lineNumber), WebInspector.DebuggerModel.fromOneBased(callFrame.columnNumber), classes);
    },

    /**
     * @param {!WebInspector.Target} target
     * @param {!RuntimeAgent.StackTrace} stackTrace
     * @param {string=} classes
     * @return {!Element}
     */
    linkifyStackTraceTopFrame: function(target, stackTrace, classes)
    {
        console.assert(stackTrace.callFrames && stackTrace.callFrames.length);

        var topFrame = stackTrace.callFrames[0];
        var fallbackAnchor = WebInspector.linkifyResourceAsNode(topFrame.url, WebInspector.DebuggerModel.fromOneBased(topFrame.lineNumber), WebInspector.DebuggerModel.fromOneBased(topFrame.columnNumber), classes);
        if (target.isDetached())
            return fallbackAnchor;

        var debuggerModel = WebInspector.DebuggerModel.fromTarget(target);
        var rawLocations = debuggerModel.createRawLocationsByStackTrace(stackTrace);
        if (rawLocations.length === 0)
            return fallbackAnchor;

        var anchor = this._createAnchor(classes);
        var liveLocation = WebInspector.debuggerWorkspaceBinding.createStackTraceTopFrameLiveLocation(rawLocations, this._updateAnchor.bind(this, anchor));
        this._liveLocationsByTarget.get(target).set(anchor, liveLocation);
        anchor[WebInspector.Linkifier._fallbackAnchorSymbol] = fallbackAnchor;
        return anchor;
    },

    /**
     * @param {!WebInspector.CSSLocation} rawLocation
     * @param {string=} classes
     * @return {!Element}
     */
    linkifyCSSLocation: function(rawLocation, classes)
    {
        var anchor = this._createAnchor(classes);
        var liveLocation = WebInspector.cssWorkspaceBinding.createLiveLocation(rawLocation, this._updateAnchor.bind(this, anchor));
        this._liveLocationsByTarget.get(rawLocation.target()).set(anchor, liveLocation);
        return anchor;
    },

    /**
     * @param {!WebInspector.Target} target
     * @param {!Element} anchor
     */
    disposeAnchor: function(target, anchor)
    {
        delete anchor[WebInspector.Linkifier._uiLocationSymbol];
        delete anchor[WebInspector.Linkifier._fallbackAnchorSymbol];
        var liveLocations = this._liveLocationsByTarget.get(target);
        if (!liveLocations)
            return;
        var location = liveLocations.remove(anchor);
        if (location)
            location.dispose();
    },

    /**
     * @param {string=} classes
     * @return {!Element}
     */
    _createAnchor: function(classes)
    {
        var anchor = createElement("a");
        anchor.className = (classes || "") + " webkit-html-resource-link";

        /**
         * @param {!Event} event
         */
        function clickHandler(event)
        {
            var uiLocation = anchor[WebInspector.Linkifier._uiLocationSymbol];
            if (!uiLocation)
                return;

            event.consume(true);
            var networkURL = WebInspector.networkMapping.networkURL(uiLocation.uiSourceCode);
            if (WebInspector.Linkifier.handleLink(networkURL, uiLocation.lineNumber))
                return;
            WebInspector.Revealer.reveal(uiLocation);
        }
        anchor.addEventListener("click", clickHandler, false);
        return anchor;
    },

    reset: function()
    {
        var targets = this._liveLocationsByTarget.keysArray();
        for (var i = 0; i < targets.length; ++i) {
            var target = targets[i];
            this.targetRemoved(target);
            this.targetAdded(target);
        }
    },

    dispose: function()
    {
        this.reset();
        WebInspector.targetManager.unobserveTargets(this);
        this._liveLocationsByTarget.clear();
    },

    /**
     * @param {!Element} anchor
     * @param {!WebInspector.LiveLocation} liveLocation
     */
    _updateAnchor: function(anchor, liveLocation)
    {
        var uiLocation = liveLocation.uiLocation();
        if (!uiLocation)
            return;
        anchor[WebInspector.Linkifier._uiLocationSymbol] = uiLocation;
        this._formatter.formatLiveAnchor(anchor, uiLocation, liveLocation.isBlackboxed());
    }
}

/**
 * @param {!Element} anchor
 * @return {?WebInspector.UILocation} uiLocation
 */
WebInspector.Linkifier.uiLocationByAnchor = function(anchor)
{
    return anchor[WebInspector.Linkifier._uiLocationSymbol];
}

/**
 * @constructor
 * @implements {WebInspector.LinkifierFormatter}
 * @param {number=} maxLength
 */
WebInspector.Linkifier.DefaultFormatter = function(maxLength)
{
    this._maxLength = maxLength;
}

WebInspector.Linkifier.DefaultFormatter.prototype = {
    /**
     * @override
     * @param {!Element} anchor
     * @param {!WebInspector.UILocation} uiLocation
     * @param {boolean} isBlackboxed
     */
    formatLiveAnchor: function(anchor, uiLocation, isBlackboxed)
    {
        var text = uiLocation.linkText();
        text = text.replace(/([a-f0-9]{7})[a-f0-9]{13}[a-f0-9]*/g, "$1\u2026");
        if (this._maxLength)
            text = text.trimMiddle(this._maxLength);
        anchor.textContent = text;

        var titleText = uiLocation.uiSourceCode.url();
        if (typeof uiLocation.lineNumber === "number")
            titleText += ":" + (uiLocation.lineNumber + 1);
        anchor.title = titleText;

        anchor.classList.toggle("webkit-html-blackbox-link", isBlackboxed);
    }
}

/**
 * @constructor
 * @extends {WebInspector.Linkifier.DefaultFormatter}
 */
WebInspector.Linkifier.DefaultCSSFormatter = function()
{
    WebInspector.Linkifier.DefaultFormatter.call(this, WebInspector.Linkifier.DefaultCSSFormatter.MaxLengthForDisplayedURLs);
}

WebInspector.Linkifier.DefaultCSSFormatter.MaxLengthForDisplayedURLs = 30;

WebInspector.Linkifier.DefaultCSSFormatter.prototype = {
    /**
     * @override
     * @param {!Element} anchor
     * @param {!WebInspector.UILocation} uiLocation
     * @param {boolean} isBlackboxed
     */
    formatLiveAnchor: function(anchor, uiLocation, isBlackboxed)
    {
        WebInspector.Linkifier.DefaultFormatter.prototype.formatLiveAnchor.call(this, anchor, uiLocation, isBlackboxed);
        anchor.classList.add("webkit-html-resource-link");
        anchor.setAttribute("data-uncopyable", anchor.textContent);
        anchor.textContent = "";
    },
    __proto__: WebInspector.Linkifier.DefaultFormatter.prototype
}

/**
 * The maximum number of characters to display in a URL.
 * @const
 * @type {number}
 */
WebInspector.Linkifier.MaxLengthForDisplayedURLs = 150;

/**
 * @interface
 */
WebInspector.Linkifier.LinkHandler = function()
{
}

WebInspector.Linkifier.LinkHandler.prototype = {
    /**
     * @param {string} url
     * @param {number=} lineNumber
     * @return {boolean}
     */
    handleLink: function(url, lineNumber) {}
}

/**
 * @param {!WebInspector.Target} target
 * @param {string} scriptId
 * @param {number} lineNumber
 * @param {number=} columnNumber
 * @return {string}
 */
WebInspector.Linkifier.liveLocationText = function(target, scriptId, lineNumber, columnNumber)
{
    var debuggerModel = WebInspector.DebuggerModel.fromTarget(target);
    if (!debuggerModel)
        return "";
    var script = debuggerModel.scriptForId(scriptId);
    if (!script)
        return "";
    var location = /** @type {!WebInspector.DebuggerModel.Location} */ (debuggerModel.createRawLocation(script, lineNumber, columnNumber || 0));
    var uiLocation = /** @type {!WebInspector.UILocation} */ (WebInspector.debuggerWorkspaceBinding.rawLocationToUILocation(location));
    return uiLocation.linkText();
}

/**
 * @param {string} string
 * @param {function(string,string,number=,number=):!Node} linkifier
 * @return {!DocumentFragment}
 */
WebInspector.linkifyStringAsFragmentWithCustomLinkifier = function(string, linkifier)
{
    var container = createDocumentFragment();
    var linkStringRegEx = /(?:[a-zA-Z][a-zA-Z0-9+.-]{2,}:\/\/|data:|www\.)[\w$\-_+*'=\|\/\\(){}[\]^%@&#~,:;.!?]{2,}[\w$\-_+*=\|\/\\({^%@&#~]/;

    while (string && string.length < 10000) {
        var linkString = linkStringRegEx.exec(string);
        if (!linkString)
            break;

        linkString = linkString[0];
        var linkIndex = string.indexOf(linkString);
        var nonLink = string.substring(0, linkIndex);
        container.appendChild(createTextNode(nonLink));

        var title = linkString;
        var realURL = (linkString.startsWith("www.") ? "http://" + linkString : linkString);
        var splitResult = WebInspector.ParsedURL.splitLineAndColumn(realURL);
        var linkNode;
        if (splitResult)
            linkNode = linkifier(title, splitResult.url, splitResult.lineNumber, splitResult.columnNumber);
        else
            linkNode = linkifier(title, realURL);

        container.appendChild(linkNode);
        string = string.substring(linkIndex + linkString.length, string.length);
    }

    if (string)
        container.appendChild(createTextNode(string));

    return container;
}

/**
 * @param {string} string
 * @return {!DocumentFragment}
 */
WebInspector.linkifyStringAsFragment = function(string)
{
    /**
     * @param {string} title
     * @param {string} url
     * @param {number=} lineNumber
     * @param {number=} columnNumber
     * @return {!Node}
     */
    function linkifier(title, url, lineNumber, columnNumber)
    {
        var isExternal = !WebInspector.resourceForURL(url) && !WebInspector.networkMapping.uiSourceCodeForURLForAnyTarget(url);
        var urlNode = WebInspector.linkifyURLAsNode(url, title, undefined, isExternal);
        if (typeof lineNumber !== "undefined") {
            urlNode.lineNumber = lineNumber;
            if (typeof columnNumber !== "undefined")
                urlNode.columnNumber = columnNumber;
        }

        return urlNode;
    }

    return WebInspector.linkifyStringAsFragmentWithCustomLinkifier(string, linkifier);
}

/**
 * @param {string} url
 * @param {string=} linkText
 * @param {string=} classes
 * @param {boolean=} isExternal
 * @param {string=} tooltipText
 * @return {!Element}
 */
WebInspector.linkifyURLAsNode = function(url, linkText, classes, isExternal, tooltipText)
{
    if (!linkText)
        linkText = url;
    classes = (classes ? classes + " " : "");
    classes += isExternal ? "webkit-html-external-link" : "webkit-html-resource-link";

    var a = createElement("a");
    var href = sanitizeHref(url);
    if (href !== null)
        a.href = href;
    a.className = classes;
    if (!tooltipText && linkText !== url)
        a.title = url;
    else if (tooltipText)
        a.title = tooltipText;
    a.textContent = linkText.trimMiddle(WebInspector.Linkifier.MaxLengthForDisplayedURLs);
    if (isExternal)
        a.setAttribute("target", "_blank");

    return a;
}

/**
 * @param {string} article
 * @param {string} title
 * @return {!Element}
 */
WebInspector.linkifyDocumentationURLAsNode = function(article, title)
{
    return WebInspector.linkifyURLAsNode("https://developers.google.com/web/tools/chrome-devtools/" + article, title, undefined, true);
}

/**
 * @param {string} url
 * @param {number=} lineNumber
 * @param {number=} columnNumber
 * @param {string=} classes
 * @param {string=} tooltipText
 * @param {string=} urlDisplayName
 * @return {!Element}
 */
WebInspector.linkifyResourceAsNode = function(url, lineNumber, columnNumber, classes, tooltipText, urlDisplayName)
{
    var linkText = urlDisplayName ? urlDisplayName : url ? WebInspector.displayNameForURL(url) : WebInspector.UIString("(program)");
    if (typeof lineNumber === "number")
        linkText += ":" + (lineNumber + 1);
    var anchor = WebInspector.linkifyURLAsNode(url, linkText, classes, false, tooltipText);
    anchor.lineNumber = lineNumber;
    anchor.columnNumber = columnNumber;
    return anchor;
}

/**
 * @param {!WebInspector.NetworkRequest} request
 * @return {!Element}
 */
WebInspector.linkifyRequestAsNode = function(request)
{
    var anchor = WebInspector.linkifyURLAsNode(request.url);
    anchor.requestId = request.requestId;
    return anchor;
}
;/* NetworkConditionsSelector.js */
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {function(!Array<!WebInspector.NetworkConditionsGroup>):!Array<?WebInspector.NetworkManager.Conditions>} populateCallback
 * @param {function(number)} selectCallback
 */
WebInspector.NetworkConditionsSelector = function(populateCallback, selectCallback)
{
    this._populateCallback = populateCallback;
    this._selectCallback = selectCallback;
    this._customSetting = WebInspector.moduleSetting("customNetworkConditions");
    this._customSetting.addChangeListener(this._populateOptions, this);
    this._manager = WebInspector.multitargetNetworkManager;
    this._manager.addEventListener(WebInspector.MultitargetNetworkManager.Events.ConditionsChanged, this._conditionsChanged, this);
    this._populateOptions();
}

/** @typedef {!{title: string, items: !Array<!WebInspector.NetworkManager.Conditions>}} */
WebInspector.NetworkConditionsGroup;

/**
 * @param {number} throughput
 * @param {boolean=} plainText
 * @return {string}
 */
WebInspector.NetworkConditionsSelector._throughputText = function(throughput, plainText)
{
    if (throughput < 0)
        return "";
    var throughputInKbps = throughput / (1024 / 8);
    var delimiter = plainText ? "" : " ";
    if (throughputInKbps < 1024)
        return WebInspector.UIString("%d%skb/s", throughputInKbps, delimiter);
    if (throughputInKbps < 1024 * 10)
        return WebInspector.UIString("%.1f%sMb/s", throughputInKbps / 1024, delimiter);
    return WebInspector.UIString("%d%sMb/s", (throughputInKbps / 1024) | 0, delimiter);
}

/** @type {!Array.<!WebInspector.NetworkManager.Conditions>} */
WebInspector.NetworkConditionsSelector._presets = [
    {title: "Offline", download: 0 * 1024 / 8, upload: 0 * 1024 / 8, latency: 0},
    {title: "GPRS", download: 50 * 1024 / 8, upload: 20 * 1024 / 8, latency: 500},
    {title: "Regular 2G", download: 250 * 1024 / 8, upload: 50 * 1024 / 8, latency: 300},
    {title: "Good 2G", download: 450 * 1024 / 8, upload: 150 * 1024 / 8, latency: 150},
    {title: "Regular 3G", download: 750 * 1024 / 8, upload: 250 * 1024 / 8, latency: 100},
    {title: "Good 3G", download: 1.5 * 1024 * 1024 / 8, upload: 750 * 1024 / 8, latency: 40},
    {title: "Regular 4G", download: 4 * 1024 * 1024 / 8, upload: 3 * 1024 * 1024 / 8, latency: 20},
    {title: "DSL", download: 2 * 1024 * 1024 / 8, upload: 1 * 1024 * 1024 / 8, latency: 5},
    {title: "WiFi", download: 30 * 1024 * 1024 / 8, upload: 15 * 1024 * 1024 / 8, latency: 2}
];

/**
 * @param {!WebInspector.NetworkManager.Conditions} conditions
 * @param {boolean=} plainText
 * @return {!{text: string, title: string}}
 */
WebInspector.NetworkConditionsSelector._conditionsTitle = function(conditions, plainText)
{
    var downloadInKbps = conditions.download / (1024 / 8);
    var uploadInKbps = conditions.upload / (1024 / 8);
    var isThrottling = (downloadInKbps >= 0) || (uploadInKbps >= 0) || (conditions.latency > 0);
    var conditionTitle = WebInspector.UIString(conditions.title);
    if (!isThrottling)
        return {text: conditionTitle, title: conditionTitle};

    var downloadText = WebInspector.NetworkConditionsSelector._throughputText(conditions.download, plainText);
    var uploadText = WebInspector.NetworkConditionsSelector._throughputText(conditions.upload, plainText);
    var pattern = plainText ? "%s (%dms, %s, %s)" : "%s (%dms RTT, %s\u2b07, %s\u2b06)";
    var title = WebInspector.UIString(pattern, conditionTitle, conditions.latency, downloadText, uploadText);
    return {text: title, title: WebInspector.UIString("Maximum download throughput: %s.\r\nMaximum upload throughput: %s.\r\nMinimum round-trip time: %dms.", downloadText, uploadText, conditions.latency)};
}

WebInspector.NetworkConditionsSelector.prototype = {
    _populateOptions: function()
    {
        var customGroup = {title: WebInspector.UIString("Custom"), items: this._customSetting.get()};
        var presetsGroup = {title: WebInspector.UIString("Presets"), items: WebInspector.NetworkConditionsSelector._presets};
        var disabledGroup = {title: WebInspector.UIString("Disabled"), items: [WebInspector.NetworkManager.NoThrottlingConditions]};
        this._options = this._populateCallback([customGroup, presetsGroup, disabledGroup]);
        this._conditionsChanged();
    },

    revealAndUpdate: function()
    {
        WebInspector.Revealer.reveal(this._customSetting);
        this._conditionsChanged();
    },

    /**
     * @param {!WebInspector.NetworkManager.Conditions} conditions
     */
    optionSelected: function(conditions)
    {
        this._manager.setNetworkConditions(conditions);
    },

    _conditionsChanged: function()
    {
        var value = this._manager.networkConditions();
        for (var index = 0; index < this._options.length; ++index) {
            var option = this._options[index];
            if (!option)
                continue;
            if (option.download === value.download && option.upload === value.upload && option.latency === value.latency && option.title === value.title)
                this._selectCallback(index);
        }
    }
}

/**
 * @param {!HTMLSelectElement} selectElement
 */
WebInspector.NetworkConditionsSelector.decorateSelect = function(selectElement)
{
    var options = [];
    var selector = new WebInspector.NetworkConditionsSelector(populate, select);
    selectElement.addEventListener("change", optionSelected, false);

    /**
     * @param {!Array.<!WebInspector.NetworkConditionsGroup>} groups
     * @return {!Array<?WebInspector.NetworkManager.Conditions>}
     */
    function populate(groups)
    {
        selectElement.removeChildren();
        options = [];
        for (var i = 0; i < groups.length; ++i) {
            var group = groups[i];
            var groupElement = selectElement.createChild("optgroup");
            groupElement.label = group.title;
            if (!i) {
                groupElement.appendChild(new Option(WebInspector.UIString("Add\u2026"), WebInspector.UIString("Add\u2026")));
                options.push(null);
            }
            for (var conditions of group.items) {
                var title = WebInspector.NetworkConditionsSelector._conditionsTitle(conditions, true);
                var option = new Option(title.text, title.text);
                option.title = title.title;
                groupElement.appendChild(option);
                options.push(conditions);
            }
        }
        return options;
    }

    function optionSelected()
    {
        if (selectElement.selectedIndex === 0)
            selector.revealAndUpdate();
        else
            selector.optionSelected(options[selectElement.selectedIndex]);
    }

    /**
     * @param {number} index
     */
    function select(index)
    {
        if (selectElement.selectedIndex !== index)
            selectElement.selectedIndex = index;
    }
}

/**
 * @return {!WebInspector.ToolbarMenuButton}
 */
WebInspector.NetworkConditionsSelector.createToolbarMenuButton = function()
{
    var button = new WebInspector.ToolbarMenuButton(appendItems);
    button.setGlyph("");
    button.turnIntoSelect();

    /** @type {!Array<?WebInspector.NetworkManager.Conditions>} */
    var options = [];
    var selectedIndex = -1;
    var selector = new WebInspector.NetworkConditionsSelector(populate, select);
    return button;

    /**
     * @param {!WebInspector.ContextMenu} contextMenu
     */
    function appendItems(contextMenu)
    {
        for (var index = 0; index < options.length; ++index) {
            var conditions = options[index];
            if (!conditions)
                contextMenu.appendSeparator();
            else
                contextMenu.appendCheckboxItem(WebInspector.NetworkConditionsSelector._conditionsTitle(conditions, true).text, selector.optionSelected.bind(selector, conditions), selectedIndex === index);
        }
        contextMenu.appendItem(WebInspector.UIString("Edit\u2026"), selector.revealAndUpdate.bind(selector));
    }

    /**
     * @param {!Array.<!WebInspector.NetworkConditionsGroup>} groups
     * @return {!Array<?WebInspector.NetworkManager.Conditions>}
     */
    function populate(groups)
    {
        options = [];
        for (var group of groups) {
            for (var conditions of group.items)
                options.push(conditions);
            options.push(null);
        }
        return options;
    }

    /**
     * @param {number} index
     */
    function select(index)
    {
        selectedIndex = index;
        button.setText(options[index].title);
    }
}

/**
 * @constructor
 * @extends {WebInspector.VBox}
 * @implements {WebInspector.ListWidget.Delegate}
 */
WebInspector.NetworkConditionsSettingsTab = function()
{
    WebInspector.VBox.call(this, true);
    this.registerRequiredCSS("components/networkConditionsSettingsTab.css");

    this.contentElement.createChild("div", "header").textContent = WebInspector.UIString("Network Throttling Profiles");

    var addButton = createTextButton(WebInspector.UIString("Add custom profile..."), this._addButtonClicked.bind(this), "add-conditions-button");
    this.contentElement.appendChild(addButton);

    this._list = new WebInspector.ListWidget(this);
    this._list.element.classList.add("conditions-list");
    this._list.registerRequiredCSS("components/networkConditionsSettingsTab.css");
    this._list.show(this.contentElement);

    this._customSetting = WebInspector.moduleSetting("customNetworkConditions");
    this._customSetting.addChangeListener(this._conditionsUpdated, this);

    this.setDefaultFocusedElement(addButton);
    this.contentElement.tabIndex = 0;
}

WebInspector.NetworkConditionsSettingsTab.prototype = {
    wasShown: function()
    {
        WebInspector.VBox.prototype.wasShown.call(this);
        this._conditionsUpdated();
    },

    _conditionsUpdated: function()
    {
        this._list.clear();

        var conditions = this._customSetting.get();
        for (var i = 0; i < conditions.length; ++i)
            this._list.appendItem(conditions[i], true);

        this._list.appendSeparator();

        conditions = WebInspector.NetworkConditionsSelector._presets;
        for (var i = 0; i < conditions.length; ++i)
            this._list.appendItem(conditions[i], false);
    },

    _addButtonClicked: function()
    {
        this._list.addNewItem(this._customSetting.get().length, {title: "", download: -1, upload: -1, latency: 0});
    },

    /**
     * @override
     * @param {*} item
     * @param {boolean} editable
     * @return {!Element}
     */
    renderItem: function(item, editable)
    {
        var conditions = /** @type {!WebInspector.NetworkManager.Conditions} */ (item);
        var element = createElementWithClass("div", "conditions-list-item");
        var title = element.createChild("div", "conditions-list-text conditions-list-title");
        var titleText = title.createChild("div", "conditions-list-title-text");
        titleText.textContent = conditions.title;
        titleText.title = conditions.title;
        element.createChild("div", "conditions-list-separator");
        element.createChild("div", "conditions-list-text").textContent = WebInspector.NetworkConditionsSelector._throughputText(conditions.download);
        element.createChild("div", "conditions-list-separator");
        element.createChild("div", "conditions-list-text").textContent = WebInspector.NetworkConditionsSelector._throughputText(conditions.upload);
        element.createChild("div", "conditions-list-separator");
        element.createChild("div", "conditions-list-text").textContent = WebInspector.UIString("%dms", conditions.latency);
        return element;
    },

    /**
     * @override
     * @param {*} item
     * @param {number} index
     */
    removeItemRequested: function(item, index)
    {
        var list = this._customSetting.get();
        list.splice(index, 1);
        this._customSetting.set(list);
    },

    /**
     * @override
     * @param {*} item
     * @param {!WebInspector.ListWidget.Editor} editor
     * @param {boolean} isNew
     */
    commitEdit: function(item, editor, isNew)
    {
        var conditions = /** @type {?WebInspector.NetworkManager.Conditions} */ (item);
        conditions.title = editor.control("title").value.trim();
        var download = editor.control("download").value.trim();
        conditions.download = download ? parseInt(download, 10) * (1024 / 8) : -1;
        var upload = editor.control("upload").value.trim();
        conditions.upload = upload ? parseInt(upload, 10) * (1024 / 8) : -1;
        var latency = editor.control("latency").value.trim();
        conditions.latency = latency ? parseInt(latency, 10) : 0;

        var list = this._customSetting.get();
        if (isNew)
            list.push(conditions);
        this._customSetting.set(list);
    },

    /**
     * @override
     * @param {*} item
     * @return {!WebInspector.ListWidget.Editor}
     */
    beginEdit: function(item)
    {
        var conditions = /** @type {?WebInspector.NetworkManager.Conditions} */ (item);
        var editor = this._createEditor();
        editor.control("title").value = conditions.title;
        editor.control("download").value = conditions.download <= 0 ? "" : String(conditions.download / (1024 / 8));
        editor.control("upload").value = conditions.upload <= 0 ? "" : String(conditions.upload / (1024 / 8));
        editor.control("latency").value = conditions.latency ? String(conditions.latency) : "";
        return editor;
    },

    /**
     * @return {!WebInspector.ListWidget.Editor}
     */
    _createEditor: function()
    {
        if (this._editor)
            return this._editor;

        var editor = new WebInspector.ListWidget.Editor();
        this._editor = editor;
        var content = editor.contentElement();

        var titles = content.createChild("div", "conditions-edit-row");
        titles.createChild("div", "conditions-list-text conditions-list-title").textContent = WebInspector.UIString("Profile Name");
        titles.createChild("div", "conditions-list-separator conditions-list-separator-invisible");
        titles.createChild("div", "conditions-list-text").textContent = WebInspector.UIString("Download");
        titles.createChild("div", "conditions-list-separator conditions-list-separator-invisible");
        titles.createChild("div", "conditions-list-text").textContent = WebInspector.UIString("Upload");
        titles.createChild("div", "conditions-list-separator conditions-list-separator-invisible");
        titles.createChild("div", "conditions-list-text").textContent = WebInspector.UIString("Latency");

        var fields = content.createChild("div", "conditions-edit-row");
        fields.createChild("div", "conditions-list-text conditions-list-title").appendChild(editor.createInput("title", "text", "", titleValidator));
        fields.createChild("div", "conditions-list-separator conditions-list-separator-invisible");

        var cell = fields.createChild("div", "conditions-list-text");
        cell.appendChild(editor.createInput("download", "text", WebInspector.UIString("kb/s"), throughputValidator));
        cell.createChild("div", "conditions-edit-optional").textContent = WebInspector.UIString("optional");
        fields.createChild("div", "conditions-list-separator conditions-list-separator-invisible");

        cell = fields.createChild("div", "conditions-list-text");
        cell.appendChild(editor.createInput("upload", "text", WebInspector.UIString("kb/s"), throughputValidator));
        cell.createChild("div", "conditions-edit-optional").textContent = WebInspector.UIString("optional");
        fields.createChild("div", "conditions-list-separator conditions-list-separator-invisible");

        cell = fields.createChild("div", "conditions-list-text");
        cell.appendChild(editor.createInput("latency", "text", WebInspector.UIString("ms"), latencyValidator));
        cell.createChild("div", "conditions-edit-optional").textContent = WebInspector.UIString("optional");

        return editor;

        /**
         * @param {*} item
         * @param {number} index
         * @param {!HTMLInputElement|!HTMLSelectElement} input
         * @return {boolean}
         */
        function titleValidator(item, index, input)
        {
            var value = input.value.trim();
            return value.length > 0 && value.length < 50;
        }

        /**
         * @param {*} item
         * @param {number} index
         * @param {!HTMLInputElement|!HTMLSelectElement} input
         * @return {boolean}
         */
        function throughputValidator(item, index, input)
        {
            var value = input.value.trim();
            return !value || (/^[\d]+(\.\d+)?|\.\d+$/.test(value) && value >= 0 && value <= 10000000);
        }

        /**
         * @param {*} item
         * @param {number} index
         * @param {!HTMLInputElement|!HTMLSelectElement} input
         * @return {boolean}
         */
        function latencyValidator(item, index, input)
        {
            var value = input.value.trim();
            return !value || (/^[\d]+$/.test(value) && value >= 0 && value <= 1000000);
        }
    },

    __proto__: WebInspector.VBox.prototype
}
;/* ObjectPopoverHelper.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.PopoverHelper}
 * @param {!Element} panelElement
 * @param {function(!Element, !Event):(!Element|!AnchorBox|undefined)} getAnchor
 * @param {function(!Element, function(!WebInspector.RemoteObject, boolean, !Element=):undefined, string):undefined} queryObject
 * @param {function()=} onHide
 * @param {boolean=} disableOnClick
 */
WebInspector.ObjectPopoverHelper = function(panelElement, getAnchor, queryObject, onHide, disableOnClick)
{
    WebInspector.PopoverHelper.call(this, panelElement, getAnchor, this._showObjectPopover.bind(this), this._onHideObjectPopover.bind(this), disableOnClick);
    this._queryObject = queryObject;
    this._onHideCallback = onHide;
    this._popoverObjectGroup = "popover";
    panelElement.addEventListener("scroll", this.hidePopover.bind(this), true);
};

WebInspector.ObjectPopoverHelper.MaxPopoverTextLength = 10000;

WebInspector.ObjectPopoverHelper.prototype = {
    /**
     * @param {!Element} element
     * @param {!WebInspector.Popover} popover
     */
    _showObjectPopover: function(element, popover)
    {
        /**
         * @param {!WebInspector.RemoteObject} funcObject
         * @param {!Element} popoverContentElement
         * @param {!Element} popoverValueElement
         * @param {!Element} anchorElement
         * @param {?Array.<!WebInspector.RemoteObjectProperty>} properties
         * @param {?Array.<!WebInspector.RemoteObjectProperty>} internalProperties
         * @this {WebInspector.ObjectPopoverHelper}
         */
        function didGetFunctionProperties(funcObject, popoverContentElement, popoverValueElement, anchorElement, properties, internalProperties)
        {
            if (internalProperties) {
                for (var i = 0; i < internalProperties.length; i++) {
                    if (internalProperties[i].name === "[[TargetFunction]]") {
                        funcObject = internalProperties[i].value;
                        break;
                    }
                }
            }
            WebInspector.ObjectPropertiesSection.formatObjectAsFunction(funcObject, popoverValueElement, true);
            funcObject.functionDetails(didGetFunctionDetails.bind(this, popoverContentElement, anchorElement));
        }

        /**
         * @param {!Element} popoverContentElement
         * @param {!Element} anchorElement
         * @param {?WebInspector.DebuggerModel.FunctionDetails} response
         * @this {WebInspector.ObjectPopoverHelper}
         */
        function didGetFunctionDetails(popoverContentElement, anchorElement, response)
        {
            if (!response || popover.disposed)
                return;

            var container = createElementWithClass("div", "object-popover-container");
            var title = container.createChild("div", "function-popover-title source-code");
            var functionName = title.createChild("span", "function-name");
            functionName.textContent = WebInspector.beautifyFunctionName(response.functionName);

            var rawLocation = response.location;
            var sourceURL = response.sourceURL;
            if (rawLocation && sourceURL) {
                var link = this._lazyLinkifier().linkifyRawLocation(rawLocation, sourceURL, "function-location-link");
                title.appendChild(link);
            }

            container.appendChild(popoverContentElement);
            popover.showForAnchor(container, anchorElement);
        }

        /**
         * @param {?WebInspector.DebuggerModel.GeneratorObjectDetails} response
         * @this {WebInspector.ObjectPopoverHelper}
         */
        function didGetGeneratorObjectDetails(response)
        {
            if (!response || popover.disposed)
                return;

            var rawLocation = response.location;
            var sourceURL = response.sourceURL;
            if (rawLocation && sourceURL) {
                var link = this._lazyLinkifier().linkifyRawLocation(rawLocation, sourceURL, "function-location-link");
                this._titleElement.appendChild(link);
            }
        }

        /**
         * @param {!WebInspector.RemoteObject} result
         * @param {boolean} wasThrown
         * @param {!Element=} anchorOverride
         * @this {WebInspector.ObjectPopoverHelper}
         */
        function didQueryObject(result, wasThrown, anchorOverride)
        {
            if (popover.disposed)
                return;
            if (wasThrown) {
                this.hidePopover();
                return;
            }
            this._objectTarget = result.target();
            var anchorElement = anchorOverride || element;
            var description = result.description.trimEnd(WebInspector.ObjectPopoverHelper.MaxPopoverTextLength);
            var popoverContentElement = null;
            if (result.type !== "object") {
                popoverContentElement =  createElement("span");
                WebInspector.appendStyle(popoverContentElement, "components/objectValue.css");
                var valueElement = popoverContentElement.createChild("span", "monospace object-value-" + result.type);
                valueElement.style.whiteSpace = "pre";

                if (result.type === "string")
                    valueElement.createTextChildren("\"", description, "\"");
                else if (result.type !== "function")
                    valueElement.textContent = description;

                if (result.type === "function") {
                    result.getOwnProperties(didGetFunctionProperties.bind(this, result, popoverContentElement, valueElement, anchorElement));
                    return;
                }
                popover.showForAnchor(popoverContentElement, anchorElement);
            } else {
                if (result.subtype === "node") {
                    WebInspector.DOMModel.highlightObjectAsDOMNode(result);
                    this._resultHighlightedAsDOM = true;
                }

                if (result.customPreview()) {
                    var customPreviewComponent = new WebInspector.CustomPreviewComponent(result);
                    customPreviewComponent.expandIfPossible();
                    popoverContentElement = customPreviewComponent.element;
                } else {
                    popoverContentElement = createElement("div");
                    this._titleElement = popoverContentElement.createChild("div", "monospace");
                    this._titleElement.createChild("span", "source-frame-popover-title").textContent = description;
                    var section = new WebInspector.ObjectPropertiesSection(result, "");
                    section.element.classList.add("source-frame-popover-tree");
                    section.titleLessMode();
                    popoverContentElement.appendChild(section.element);

                    if (result.subtype === "generator")
                        result.generatorObjectDetails(didGetGeneratorObjectDetails.bind(this));
                }
                var popoverWidth = 300;
                var popoverHeight = 250;
                popover.showForAnchor(popoverContentElement, anchorElement, popoverWidth, popoverHeight);
            }
        }

        this._queryObject(element, didQueryObject.bind(this), this._popoverObjectGroup);
    },

    _onHideObjectPopover: function()
    {
        if (this._resultHighlightedAsDOM) {
            WebInspector.DOMModel.hideDOMNodeHighlight();
            delete this._resultHighlightedAsDOM;
        }
        if (this._linkifier) {
            this._linkifier.dispose();
            delete this._linkifier;
        }
        if (this._onHideCallback)
            this._onHideCallback();
        if (this._objectTarget) {
            this._objectTarget.runtimeAgent().releaseObjectGroup(this._popoverObjectGroup);
            delete this._objectTarget;
        }
    },

    /**
     * @return {!WebInspector.Linkifier}
     */
    _lazyLinkifier: function()
    {
        if (!this._linkifier)
            this._linkifier = new WebInspector.Linkifier();
        return this._linkifier;
    },

    __proto__: WebInspector.PopoverHelper.prototype
}
;/* ObjectPropertiesSection.js */
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 * Copyright (C) 2009 Joseph Pecoraro
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {TreeOutlineInShadow}
 * @param {!WebInspector.RemoteObject} object
 * @param {?string|!Element=} title
 * @param {?string=} emptyPlaceholder
 * @param {boolean=} ignoreHasOwnProperty
 * @param {!Array.<!WebInspector.RemoteObjectProperty>=} extraProperties
 */
WebInspector.ObjectPropertiesSection = function(object, title, emptyPlaceholder, ignoreHasOwnProperty, extraProperties)
{
    this._object = object;
    this._editable = true;
    TreeOutlineInShadow.call(this);
    this.hideOverflow();
    this.setFocusable(false);
    this._objectTreeElement = new WebInspector.ObjectPropertiesSection.RootElement(object, emptyPlaceholder, ignoreHasOwnProperty, extraProperties);
    this.appendChild(this._objectTreeElement);
    if (typeof title === "string" || !title)
        this.element.createChild("span").textContent = title || "";
    else
        this.element.appendChild(title);

    this.element._section = this;
    this.registerRequiredCSS("components/objectValue.css");
    this.registerRequiredCSS("components/objectPropertiesSection.css");
    this.rootElement().childrenListElement.classList.add("source-code", "object-properties-section");
}

/** @const */
WebInspector.ObjectPropertiesSection._arrayLoadThreshold = 100;

/**
 * @param {!WebInspector.RemoteObject} object
 * @param {boolean=} skipProto
 * @return {!Element}
 */
WebInspector.ObjectPropertiesSection.defaultObjectPresentation = function(object, skipProto)
{
    var componentRoot = createElementWithClass("span", "source-code");
    var shadowRoot = WebInspector.createShadowRootWithCoreStyles(componentRoot, "components/objectValue.css");
    shadowRoot.appendChild(WebInspector.ObjectPropertiesSection.createValueElement(object, false));
    if (!object.hasChildren)
        return componentRoot;

    var objectPropertiesSection = new WebInspector.ObjectPropertiesSection(object, componentRoot);
    objectPropertiesSection.editable = false;
    if (skipProto)
        objectPropertiesSection.skipProto();

    return objectPropertiesSection.element;
}

WebInspector.ObjectPropertiesSection.prototype = {
    skipProto: function()
    {
        this._skipProto = true;
    },

    expand: function()
    {
        this._objectTreeElement.expand();
    },

    /**
     * @return {!TreeElement}
     */
    objectTreeElement: function()
    {
        return this._objectTreeElement;
    },

    enableContextMenu: function()
    {
        this.element.addEventListener("contextmenu", this._contextMenuEventFired.bind(this), false);
    },

    _contextMenuEventFired: function(event)
    {
        var contextMenu = new WebInspector.ContextMenu(event);
        contextMenu.appendApplicableItems(this._object);
        contextMenu.show();
    },

    titleLessMode: function()
    {
        this._objectTreeElement.listItemElement.classList.add("hidden");
        this._objectTreeElement.childrenListElement.classList.add("title-less-mode");
        this._objectTreeElement.expand();
    },

    __proto__: TreeOutlineInShadow.prototype
}

/**
 * @param {!WebInspector.RemoteObjectProperty} propertyA
 * @param {!WebInspector.RemoteObjectProperty} propertyB
 * @return {number}
 */
WebInspector.ObjectPropertiesSection.CompareProperties = function(propertyA, propertyB)
{
    var a = propertyA.name;
    var b = propertyB.name;
    if (a === "__proto__")
        return 1;
    if (b === "__proto__")
        return -1;
    if (propertyA.symbol && !propertyB.symbol)
        return 1;
    if (propertyB.symbol && !propertyA.symbol)
        return -1;
    return String.naturalOrderComparator(a, b);
}

/**
 * @constructor
 * @extends {TreeElement}
 * @param {!WebInspector.RemoteObject} object
 * @param {?string=} emptyPlaceholder
 * @param {boolean=} ignoreHasOwnProperty
 * @param {!Array.<!WebInspector.RemoteObjectProperty>=} extraProperties
 */
WebInspector.ObjectPropertiesSection.RootElement = function(object, emptyPlaceholder, ignoreHasOwnProperty, extraProperties)
{
    this._object = object;
    this._extraProperties = extraProperties || [];
    this._ignoreHasOwnProperty = !!ignoreHasOwnProperty;
    this._emptyPlaceholder = emptyPlaceholder;
    var contentElement = createElement("content");
    TreeElement.call(this, contentElement);
    this.setExpandable(true);
    this.selectable = false;
    this.toggleOnClick = true;
    this.listItemElement.classList.add("object-properties-section-root-element");
}

WebInspector.ObjectPropertiesSection.RootElement.prototype = {

    onexpand: function()
    {
        if (this.treeOutline)
            this.treeOutline.element.classList.add("expanded");
    },

    oncollapse: function()
    {
        if (this.treeOutline)
            this.treeOutline.element.classList.remove("expanded");
    },

    /**
     * @override
     * @param {!Event} e
     * @return {boolean}
     */
    ondblclick: function(e)
    {
        return true;
    },

    onpopulate: function()
    {
        WebInspector.ObjectPropertyTreeElement._populate(this, this._object, !!this.treeOutline._skipProto, this._emptyPlaceholder, this._ignoreHasOwnProperty, this._extraProperties);
    },

    __proto__: TreeElement.prototype
}

/**
 * @constructor
 * @extends {TreeElement}
 * @param {!WebInspector.RemoteObjectProperty} property
 */
WebInspector.ObjectPropertyTreeElement = function(property)
{
    this.property = property;

    // Pass an empty title, the title gets made later in onattach.
    TreeElement.call(this);
    this.toggleOnClick = true;
    this.selectable = false;
}

WebInspector.ObjectPropertyTreeElement.prototype = {
    onpopulate: function()
    {
        var propertyValue = /** @type {!WebInspector.RemoteObject} */ (this.property.value);
        console.assert(propertyValue);
        var skipProto = this.treeOutline ? this.treeOutline._skipProto : true;
        var targetValue = this.property.name !== '__proto__' ? propertyValue : this.property.parentObject;
        WebInspector.ObjectPropertyTreeElement._populate(this, propertyValue, skipProto, undefined, undefined, undefined, targetValue);
    },

    /**
     * @override
     * @return {boolean}
     */
    ondblclick: function(event)
    {
        var editableElement = this.valueElement;
        if (!this.property.value.customPreview() && (this.property.writable || this.property.setter) && event.target.isSelfOrDescendant(editableElement))
            this._startEditing();
        return false;
    },

    /**
     * @override
     */
    onattach: function()
    {
        this.update();
        this._updateExpandable();
    },

    update: function()
    {
        this.nameElement = WebInspector.ObjectPropertiesSection.createNameElement(this.property.name);
        if (!this.property.enumerable)
            this.nameElement.classList.add("object-properties-section-dimmed");
        if (this.property.isAccessorProperty())
            this.nameElement.classList.add("properties-accessor-property-name");
        if (this.property.synthetic)
            this.nameElement.classList.add("synthetic-property");
        if (this.property.symbol)
            this.nameElement.addEventListener("contextmenu", this._contextMenuFired.bind(this, this.property.symbol), false);

        var separatorElement = createElementWithClass("span", "object-properties-section-separator");
        separatorElement.textContent = ": ";

        if (this.property.value) {
            this.valueElement = WebInspector.ObjectPropertiesSection.createValueElementWithCustomSupport(this.property.value, this.property.wasThrown, this.listItemElement);
            this.valueElement.addEventListener("contextmenu", this._contextMenuFired.bind(this, this.property.value), false);
        } else if (this.property.getter) {
            this.valueElement = WebInspector.ObjectPropertyTreeElement.createRemoteObjectAccessorPropertySpan(this.property.parentObject, [this.property.name], this._onInvokeGetterClick.bind(this));
        } else {
            this.valueElement = createElementWithClass("span", "object-value-undefined");
            this.valueElement.textContent = WebInspector.UIString("<unreadable>");
            this.valueElement.title = WebInspector.UIString("No property getter");
        }

        this.listItemElement.removeChildren();
        this.listItemElement.appendChildren(this.nameElement, separatorElement, this.valueElement);
    },

    _contextMenuFired: function(value, event)
    {
        var contextMenu = new WebInspector.ContextMenu(event);
        contextMenu.appendApplicableItems(value);
        contextMenu.show();
    },

    _startEditing: function()
    {
        if (this._prompt || !this.treeOutline._editable || this._readOnly)
            return;

        this._editableDiv = this.listItemElement.createChild("span");

        var text = this.property.value.description;
        if (this.property.value.type === "string" && typeof text === "string")
            text = "\"" + text + "\"";

        this._editableDiv.setTextContentTruncatedIfNeeded(text, WebInspector.UIString("<string is too large to edit>"));
        var originalContent = this._editableDiv.textContent;

        this.valueElement.classList.add("hidden");

        // Lie about our children to prevent expanding on double click and to collapse subproperties.
        this.setExpandable(false);
        this.listItemElement.classList.add("editing-sub-part");

        this._prompt = new WebInspector.ObjectPropertyPrompt();

        var proxyElement = this._prompt.attachAndStartEditing(this._editableDiv, this._editingCommitted.bind(this, originalContent));
        this.listItemElement.getComponentSelection().setBaseAndExtent(this._editableDiv, 0, this._editableDiv, 1);
        proxyElement.addEventListener("keydown", this._promptKeyDown.bind(this, originalContent), false);
    },

    _editingEnded: function()
    {
       this._prompt.detach();
       delete this._prompt;
       this._editableDiv.remove();
       this._updateExpandable();
       this.listItemElement.scrollLeft = 0;
       this.listItemElement.classList.remove("editing-sub-part");
    },

    _editingCancelled: function()
    {
       this.valueElement.classList.remove("hidden");
       this._editingEnded();
    },

    /**
     * @param {string} originalContent
     */
    _editingCommitted: function(originalContent)
    {
       var userInput = this._prompt.text();
       if (userInput === originalContent) {
           this._editingCancelled(); // nothing changed, so cancel
           return;
       }

       this._editingEnded();
       this._applyExpression(userInput);
    },

    /**
     * @param {string} originalContent
     * @param {!Event} event
     */
    _promptKeyDown: function(originalContent, event)
    {
        if (isEnterKey(event)) {
            event.consume(true);
            this._editingCommitted(originalContent);
            return;
        }
        if (event.keyIdentifier === "U+001B") { // Esc
            event.consume();
            this._editingCancelled();
            return;
        }
    },

    /**
     * @param {string} expression
     */
    _applyExpression: function(expression)
    {
        var property = WebInspector.RemoteObject.toCallArgument(this.property.symbol || this.property.name);
        expression = expression.trim();
        if (expression)
            this.property.parentObject.setPropertyValue(property, expression, callback.bind(this));
        else
            this.property.parentObject.deleteProperty(property, callback.bind(this));

        /**
         * @param {?Protocol.Error} error
         * @this {WebInspector.ObjectPropertyTreeElement}
         */
        function callback(error)
        {
            if (error) {
                this.update();
                return;
            }

            if (!expression) {
                // The property was deleted, so remove this tree element.
                this.parent.removeChild(this);
            } else {
                // Call updateSiblings since their value might be based on the value that just changed.
                var parent = this.parent;
                parent.invalidateChildren();
                parent.expand();
            }
        };
    },

    /**
     * @param {?WebInspector.RemoteObject} result
     * @param {boolean=} wasThrown
     */
    _onInvokeGetterClick: function(result, wasThrown)
    {
        if (!result)
            return;
        this.property.value = result;
        this.property.wasThrown = wasThrown;

        this.update();
        this.invalidateChildren();
        this._updateExpandable();
    },

    _updateExpandable: function()
    {
        if (this.property.value)
            this.setExpandable(!this.property.value.customPreview() && this.property.value.hasChildren && !this.property.wasThrown);
        else
            this.setExpandable(false);
    },

    __proto__: TreeElement.prototype
}

/**
 * @param {!TreeElement} treeElement
 * @param {!WebInspector.RemoteObject} value
 * @param {boolean} skipProto
 * @param {?string=} emptyPlaceholder
 * @param {boolean=} flattenProtoChain
 * @param {!Array.<!WebInspector.RemoteObjectProperty>=} extraProperties
 * @param {!WebInspector.RemoteObject=} targetValue
 */
WebInspector.ObjectPropertyTreeElement._populate = function(treeElement, value, skipProto, emptyPlaceholder, flattenProtoChain, extraProperties, targetValue)
{
    if (value.arrayLength() > WebInspector.ObjectPropertiesSection._arrayLoadThreshold) {
        treeElement.removeChildren();
        WebInspector.ArrayGroupingTreeElement._populateArray(treeElement, value, 0, value.arrayLength() - 1);
        return;
    }

    /**
     * @param {?Array.<!WebInspector.RemoteObjectProperty>} properties
     * @param {?Array.<!WebInspector.RemoteObjectProperty>} internalProperties
     */
    function callback(properties, internalProperties)
    {
        treeElement.removeChildren();
        if (!properties)
            return;

        extraProperties = extraProperties || [];
        for (var i = 0; i < extraProperties.length; ++i)
            properties.push(extraProperties[i]);

        WebInspector.ObjectPropertyTreeElement.populateWithProperties(treeElement, properties, internalProperties,
            skipProto, targetValue || value, emptyPlaceholder);
    }

    if (flattenProtoChain)
        value.getAllProperties(false, callback);
    else
        WebInspector.RemoteObject.loadFromObjectPerProto(value, callback);
}

/**
 * @param {!TreeElement} treeNode
 * @param {!Array.<!WebInspector.RemoteObjectProperty>} properties
 * @param {?Array.<!WebInspector.RemoteObjectProperty>} internalProperties
 * @param {boolean} skipProto
 * @param {?WebInspector.RemoteObject} value
 * @param {?string=} emptyPlaceholder
 */
WebInspector.ObjectPropertyTreeElement.populateWithProperties = function(treeNode, properties, internalProperties, skipProto, value, emptyPlaceholder) {
    properties.sort(WebInspector.ObjectPropertiesSection.CompareProperties);

    for (var i = 0; i < properties.length; ++i) {
        var property = properties[i];
        if (skipProto && property.name === "__proto__")
            continue;
        if (property.isAccessorProperty()) {
            if (property.name !== "__proto__" && property.getter) {
                property.parentObject = value;
                treeNode.appendChild(new WebInspector.ObjectPropertyTreeElement(property));
            }
            if (property.isOwn) {
                if (property.getter) {
                    var getterProperty = new WebInspector.RemoteObjectProperty("get " + property.name, property.getter);
                    getterProperty.parentObject = value;
                    treeNode.appendChild(new WebInspector.ObjectPropertyTreeElement(getterProperty));
                }
                if (property.setter) {
                    var setterProperty = new WebInspector.RemoteObjectProperty("set " + property.name, property.setter);
                    setterProperty.parentObject = value;
                    treeNode.appendChild(new WebInspector.ObjectPropertyTreeElement(setterProperty));
                }
            }
        } else {
            property.parentObject = value;
            treeNode.appendChild(new WebInspector.ObjectPropertyTreeElement(property));
        }
    }
    if (internalProperties) {
        for (var i = 0; i < internalProperties.length; i++) {
            internalProperties[i].parentObject = value;
            treeNode.appendChild(new WebInspector.ObjectPropertyTreeElement(internalProperties[i]));
        }
    }
    if (value && value.type === "function") {
        // Whether function has TargetFunction internal property.
        // This is a simple way to tell that the function is actually a bound function (we are not told).
        // Bound function never has inner scope and doesn't need corresponding UI node.
        var hasTargetFunction = false;

        if (internalProperties) {
            for (var i = 0; i < internalProperties.length; i++) {
                if (internalProperties[i].name == "[[TargetFunction]]") {
                    hasTargetFunction = true;
                    break;
                }
            }
        }
        if (!hasTargetFunction)
            treeNode.appendChild(new WebInspector.FunctionScopeMainTreeElement(value));
    }
    if (value && value.type === "object" && (value.subtype === "map" || value.subtype === "set" || value.subtype === "iterator"))
        treeNode.appendChild(new WebInspector.CollectionEntriesMainTreeElement(value));

    WebInspector.ObjectPropertyTreeElement._appendEmptyPlaceholderIfNeeded(treeNode, emptyPlaceholder);
}

/**
 * @param {!TreeElement} treeNode
 * @param {?string=} emptyPlaceholder
 */
WebInspector.ObjectPropertyTreeElement._appendEmptyPlaceholderIfNeeded = function(treeNode, emptyPlaceholder)
{
    if (treeNode.childCount())
        return;
    var title = createElementWithClass("div", "info");
    title.textContent = emptyPlaceholder || WebInspector.UIString("No Properties");
    var infoElement = new TreeElement(title);
    treeNode.appendChild(infoElement);
}

/**
 * @param {?WebInspector.RemoteObject} object
 * @param {!Array.<string>} propertyPath
 * @param {function(?WebInspector.RemoteObject, boolean=)} callback
 * @return {!Element}
 */
WebInspector.ObjectPropertyTreeElement.createRemoteObjectAccessorPropertySpan = function(object, propertyPath, callback)
{
    var rootElement = createElement("span");
    var element = rootElement.createChild("span");
    element.textContent = WebInspector.UIString("(...)");
    if (!object)
        return rootElement;
    element.classList.add("object-value-calculate-value-button");
    element.title = WebInspector.UIString("Invoke property getter");
    element.addEventListener("click", onInvokeGetterClick, false);

    function onInvokeGetterClick(event)
    {
        event.consume();
        object.getProperty(propertyPath, callback);
    }

    return rootElement;
}

/**
 * @constructor
 * @extends {TreeElement}
 * @param {!WebInspector.RemoteObject} remoteObject
 */
WebInspector.FunctionScopeMainTreeElement = function(remoteObject)
{
    TreeElement.call(this, "<function scope>", true);
    this.toggleOnClick = true;
    this.selectable = false;
    this._remoteObject = remoteObject;
}

WebInspector.FunctionScopeMainTreeElement.prototype = {
    onpopulate: function()
    {
        /**
         * @param {?WebInspector.DebuggerModel.FunctionDetails} response
         * @this {WebInspector.FunctionScopeMainTreeElement}
         */
        function didGetDetails(response)
        {
            if (!response)
                return;
            this.removeChildren();

            var scopeChain = response.scopeChain || [];
            for (var i = 0; i < scopeChain.length; ++i) {
                var scope = scopeChain[i];
                var title = null;
                var isTrueObject = false;

                switch (scope.type) {
                case DebuggerAgent.ScopeType.Local:
                    // Not really expecting this scope type here.
                    title = WebInspector.UIString("Local");
                    break;
                case DebuggerAgent.ScopeType.Closure:
                    title = WebInspector.UIString("Closure");
                    break;
                case DebuggerAgent.ScopeType.Catch:
                    title = WebInspector.UIString("Catch");
                    break;
                case DebuggerAgent.ScopeType.Block:
                    title = WebInspector.UIString("Block");
                    break;
                case DebuggerAgent.ScopeType.Script:
                    title = WebInspector.UIString("Script");
                    break;
                case DebuggerAgent.ScopeType.With:
                    title = WebInspector.UIString("With Block");
                    isTrueObject = true;
                    break;
                case DebuggerAgent.ScopeType.Global:
                    title = WebInspector.UIString("Global");
                    isTrueObject = true;
                    break;
                default:
                    console.error("Unknown scope type: " + scope.type);
                    continue;
                }

                var runtimeModel = this._remoteObject.target().runtimeModel;
                if (isTrueObject) {
                    var remoteObject = runtimeModel.createRemoteObject(scope.object);
                    var property = new WebInspector.RemoteObjectProperty(title, remoteObject);
                    property.writable = false;
                    property.parentObject = null;
                    this.appendChild(new WebInspector.ObjectPropertyTreeElement(property));
                } else {
                    var scopeRef = new WebInspector.ScopeRef(i, undefined, this._remoteObject.objectId);
                    var remoteObject = runtimeModel.createScopeRemoteObject(scope.object, scopeRef);
                    var scopeTreeElement = new WebInspector.ScopeTreeElement(title, remoteObject);
                    this.appendChild(scopeTreeElement);
                }
            }

            WebInspector.ObjectPropertyTreeElement._appendEmptyPlaceholderIfNeeded(this, WebInspector.UIString("No Scopes"));
        }

        this._remoteObject.functionDetails(didGetDetails.bind(this));
    },

    __proto__: TreeElement.prototype
}

/**
 * @constructor
 * @extends {TreeElement}
 * @param {!WebInspector.RemoteObject} remoteObject
 */
WebInspector.CollectionEntriesMainTreeElement = function(remoteObject)
{
    TreeElement.call(this, "<entries>", true);
    this.toggleOnClick = true;
    this.selectable = false;
    this._remoteObject = remoteObject;
    this.expand();
}

WebInspector.CollectionEntriesMainTreeElement.prototype = {
    onpopulate: function()
    {
        /**
         * @param {?Array.<!DebuggerAgent.CollectionEntry>} entries
         * @this {WebInspector.CollectionEntriesMainTreeElement}
         */
        function didGetCollectionEntries(entries)
        {
            if (!entries)
                return;
            this.removeChildren();

            var entriesLocalObject = [];
            var runtimeModel = this._remoteObject.target().runtimeModel;
            for (var i = 0; i < entries.length; ++i) {
                var entry = entries[i];
                if (entry.key) {
                    entriesLocalObject.push(new WebInspector.MapEntryLocalJSONObject({
                        key: runtimeModel.createRemoteObject(entry.key),
                        value: runtimeModel.createRemoteObject(entry.value)
                    }));
                } else {
                    entriesLocalObject.push(runtimeModel.createRemoteObject(entry.value));
                }
            }
            WebInspector.ObjectPropertyTreeElement._populate(this, WebInspector.RemoteObject.fromLocalObject(entriesLocalObject), true, WebInspector.UIString("No Entries"));
            this.title = "<entries>[" + entriesLocalObject.length + "]";
        }

        this._remoteObject.collectionEntries(didGetCollectionEntries.bind(this));
    },

    __proto__: TreeElement.prototype
}

/**
 * @constructor
 * @extends {TreeElement}
 * @param {string} title
 * @param {!WebInspector.RemoteObject} remoteObject
 */
WebInspector.ScopeTreeElement = function(title, remoteObject)
{
    TreeElement.call(this, title, true);
    this.toggleOnClick = true;
    this.selectable = false;
    this._remoteObject = remoteObject;
}

WebInspector.ScopeTreeElement.prototype = {
    onpopulate: function()
    {
        WebInspector.ObjectPropertyTreeElement._populate(this, this._remoteObject, false);
    },

    __proto__: TreeElement.prototype
}

/**
 * @constructor
 * @extends {TreeElement}
 * @param {!WebInspector.RemoteObject} object
 * @param {number} fromIndex
 * @param {number} toIndex
 * @param {number} propertyCount
 */
WebInspector.ArrayGroupingTreeElement = function(object, fromIndex, toIndex, propertyCount)
{
    TreeElement.call(this, String.sprintf("[%d \u2026 %d]", fromIndex, toIndex), true);
    this.toggleOnClick = true;
    this.selectable = false;
    this._fromIndex = fromIndex;
    this._toIndex = toIndex;
    this._object = object;
    this._readOnly = true;
    this._propertyCount = propertyCount;
}

WebInspector.ArrayGroupingTreeElement._bucketThreshold = 100;
WebInspector.ArrayGroupingTreeElement._sparseIterationThreshold = 250000;
WebInspector.ArrayGroupingTreeElement._getOwnPropertyNamesThreshold = 500000;

/**
 * @param {!TreeElement} treeNode
 * @param {!WebInspector.RemoteObject} object
 * @param {number} fromIndex
 * @param {number} toIndex
 */
WebInspector.ArrayGroupingTreeElement._populateArray = function(treeNode, object, fromIndex, toIndex)
{
    WebInspector.ArrayGroupingTreeElement._populateRanges(treeNode, object, fromIndex, toIndex, true);
}

/**
 * @param {!TreeElement} treeNode
 * @param {!WebInspector.RemoteObject} object
 * @param {number} fromIndex
 * @param {number} toIndex
 * @param {boolean} topLevel
 * @this {WebInspector.ArrayGroupingTreeElement}
 */
WebInspector.ArrayGroupingTreeElement._populateRanges = function(treeNode, object, fromIndex, toIndex, topLevel)
{
    object.callFunctionJSON(packRanges, [
        { value: fromIndex },
        { value: toIndex },
        { value: WebInspector.ArrayGroupingTreeElement._bucketThreshold },
        { value: WebInspector.ArrayGroupingTreeElement._sparseIterationThreshold },
        { value: WebInspector.ArrayGroupingTreeElement._getOwnPropertyNamesThreshold }
    ], callback);

    /**
     * Note: must declare params as optional.
     * @param {number=} fromIndex
     * @param {number=} toIndex
     * @param {number=} bucketThreshold
     * @param {number=} sparseIterationThreshold
     * @param {number=} getOwnPropertyNamesThreshold
     * @suppressReceiverCheck
     * @this {Object}
     */
    function packRanges(fromIndex, toIndex, bucketThreshold, sparseIterationThreshold, getOwnPropertyNamesThreshold)
    {
        var ownPropertyNames = null;
        var consecutiveRange = (toIndex - fromIndex >= sparseIterationThreshold) && ArrayBuffer.isView(this);
        var skipGetOwnPropertyNames = consecutiveRange && (toIndex - fromIndex >= getOwnPropertyNamesThreshold);

        function* arrayIndexes(object)
        {
            if (toIndex - fromIndex < sparseIterationThreshold) {
                for (var i = fromIndex; i <= toIndex; ++i) {
                    if (i in object)
                        yield i;
                }
            } else {
                ownPropertyNames = ownPropertyNames || Object.getOwnPropertyNames(object);
                for (var i = 0; i < ownPropertyNames.length; ++i) {
                    var name = ownPropertyNames[i];
                    var index = name >>> 0;
                    if (("" + index) === name && fromIndex <= index && index <= toIndex)
                        yield index;
                }
            }
        }

        var count = 0;
        if (consecutiveRange) {
            count = toIndex - fromIndex + 1;
        } else {
            for (var i of arrayIndexes(this))
                ++count;
        }

        var bucketSize = count;
        if (count <= bucketThreshold)
            bucketSize = count;
        else
            bucketSize = Math.pow(bucketThreshold, Math.ceil(Math.log(count) / Math.log(bucketThreshold)) - 1);

        var ranges = [];
        if (consecutiveRange) {
            for (var i = fromIndex; i <= toIndex; i += bucketSize) {
                var groupStart = i;
                var groupEnd = groupStart + bucketSize - 1;
                if (groupEnd > toIndex)
                    groupEnd = toIndex;
                ranges.push([groupStart, groupEnd, groupEnd - groupStart + 1]);
            }
        } else {
            count = 0;
            var groupStart = -1;
            var groupEnd = 0;
            for (var i of arrayIndexes(this)) {
                if (groupStart === -1)
                    groupStart = i;
                groupEnd = i;
                if (++count === bucketSize) {
                    ranges.push([groupStart, groupEnd, count]);
                    count = 0;
                    groupStart = -1;
                }
            }
            if (count > 0)
                ranges.push([groupStart, groupEnd, count]);
        }

        return { ranges: ranges, skipGetOwnPropertyNames: skipGetOwnPropertyNames };
    }

    function callback(result)
    {
        if (!result)
            return;
        var ranges = /** @type {!Array.<!Array.<number>>} */ (result.ranges);
        if (ranges.length == 1) {
            WebInspector.ArrayGroupingTreeElement._populateAsFragment(treeNode, object, ranges[0][0], ranges[0][1]);
        } else {
            for (var i = 0; i < ranges.length; ++i) {
                var fromIndex = ranges[i][0];
                var toIndex = ranges[i][1];
                var count = ranges[i][2];
                if (fromIndex == toIndex)
                    WebInspector.ArrayGroupingTreeElement._populateAsFragment(treeNode, object, fromIndex, toIndex);
                else
                    treeNode.appendChild(new WebInspector.ArrayGroupingTreeElement(object, fromIndex, toIndex, count));
            }
        }
        if (topLevel)
            WebInspector.ArrayGroupingTreeElement._populateNonIndexProperties(treeNode, object, result.skipGetOwnPropertyNames);
    }
}

/**
 * @param {!TreeElement} treeNode
 * @param {!WebInspector.RemoteObject} object
 * @param {number} fromIndex
 * @param {number} toIndex
 * @this {WebInspector.ArrayGroupingTreeElement}
 */
WebInspector.ArrayGroupingTreeElement._populateAsFragment = function(treeNode, object, fromIndex, toIndex)
{
    object.callFunction(buildArrayFragment, [{value: fromIndex}, {value: toIndex}, {value: WebInspector.ArrayGroupingTreeElement._sparseIterationThreshold}], processArrayFragment.bind(this));

    /**
     * @suppressReceiverCheck
     * @this {Object}
     * @param {number=} fromIndex // must declare optional
     * @param {number=} toIndex // must declare optional
     * @param {number=} sparseIterationThreshold // must declare optional
     */
    function buildArrayFragment(fromIndex, toIndex, sparseIterationThreshold)
    {
        var result = Object.create(null);
        if (toIndex - fromIndex < sparseIterationThreshold) {
            for (var i = fromIndex; i <= toIndex; ++i) {
                if (i in this)
                    result[i] = this[i];
            }
        } else {
            var ownPropertyNames = Object.getOwnPropertyNames(this);
            for (var i = 0; i < ownPropertyNames.length; ++i) {
                var name = ownPropertyNames[i];
                var index = name >>> 0;
                if (String(index) === name && fromIndex <= index && index <= toIndex)
                    result[index] = this[index];
            }
        }
        return result;
    }

    /**
     * @param {?WebInspector.RemoteObject} arrayFragment
     * @param {boolean=} wasThrown
     * @this {WebInspector.ArrayGroupingTreeElement}
     */
    function processArrayFragment(arrayFragment, wasThrown)
    {
        if (!arrayFragment || wasThrown)
            return;
        arrayFragment.getAllProperties(false, processProperties.bind(this));
    }

    /** @this {WebInspector.ArrayGroupingTreeElement} */
    function processProperties(properties, internalProperties)
    {
        if (!properties)
            return;

        properties.sort(WebInspector.ObjectPropertiesSection.CompareProperties);
        for (var i = 0; i < properties.length; ++i) {
            properties[i].parentObject = this._object;
            var childTreeElement = new WebInspector.ObjectPropertyTreeElement(properties[i]);
            childTreeElement._readOnly = true;
            treeNode.appendChild(childTreeElement);
        }
    }
}

/**
 * @param {!TreeElement} treeNode
 * @param {!WebInspector.RemoteObject} object
 * @param {boolean} skipGetOwnPropertyNames
 * @this {WebInspector.ArrayGroupingTreeElement}
 */
WebInspector.ArrayGroupingTreeElement._populateNonIndexProperties = function(treeNode, object, skipGetOwnPropertyNames)
{
    object.callFunction(buildObjectFragment, [{value: skipGetOwnPropertyNames}], processObjectFragment.bind(this));

    /**
     * @param {boolean=} skipGetOwnPropertyNames
     * @suppressReceiverCheck
     * @this {Object}
     */
    function buildObjectFragment(skipGetOwnPropertyNames)
    {
        var result = { __proto__: this.__proto__ };
        if (skipGetOwnPropertyNames)
            return result;
        var names = Object.getOwnPropertyNames(this);
        for (var i = 0; i < names.length; ++i) {
            var name = names[i];
            // Array index check according to the ES5-15.4.
            if (String(name >>> 0) === name && name >>> 0 !== 0xffffffff)
                continue;
            var descriptor = Object.getOwnPropertyDescriptor(this, name);
            if (descriptor)
                Object.defineProperty(result, name, descriptor);
        }
        return result;
    }

    /**
     * @param {?WebInspector.RemoteObject} arrayFragment
     * @param {boolean=} wasThrown
     * @this {WebInspector.ArrayGroupingTreeElement}
     */
    function processObjectFragment(arrayFragment, wasThrown)
    {
        if (!arrayFragment || wasThrown)
            return;
        arrayFragment.getOwnProperties(processProperties.bind(this));
    }

    /**
     * @param {?Array.<!WebInspector.RemoteObjectProperty>} properties
     * @param {?Array.<!WebInspector.RemoteObjectProperty>=} internalProperties
     * @this {WebInspector.ArrayGroupingTreeElement}
     */
    function processProperties(properties, internalProperties)
    {
        if (!properties)
            return;
        properties.sort(WebInspector.ObjectPropertiesSection.CompareProperties);
        for (var i = 0; i < properties.length; ++i) {
            properties[i].parentObject = this._object;
            var childTreeElement = new WebInspector.ObjectPropertyTreeElement(properties[i]);
            childTreeElement._readOnly = true;
            treeNode.appendChild(childTreeElement);
        }
    }
}

WebInspector.ArrayGroupingTreeElement.prototype = {
    onpopulate: function()
    {
        if (this._propertyCount >= WebInspector.ArrayGroupingTreeElement._bucketThreshold) {
            WebInspector.ArrayGroupingTreeElement._populateRanges(this, this._object, this._fromIndex, this._toIndex, false);
            return;
        }
        WebInspector.ArrayGroupingTreeElement._populateAsFragment(this, this._object, this._fromIndex, this._toIndex);
    },

    onattach: function()
    {
        this.listItemElement.classList.add("object-properties-section-name");
    },

    __proto__: TreeElement.prototype
}

/**
 * @constructor
 * @extends {WebInspector.TextPrompt}
 */
WebInspector.ObjectPropertyPrompt = function()
{
    WebInspector.TextPrompt.call(this, WebInspector.ExecutionContextSelector.completionsForTextPromptInCurrentContext);
    this.setSuggestBoxEnabled(true);
}

WebInspector.ObjectPropertyPrompt.prototype = {
    __proto__: WebInspector.TextPrompt.prototype
}

/**
 * @param {?string} name
 * @return {!Element}
 */
WebInspector.ObjectPropertiesSection.createNameElement = function(name)
{
    var nameElement = createElementWithClass("span", "name");
    if (/^\s|\s$|^$|\n/.test(name))
        nameElement.createTextChildren("\"", name.replace(/\n/g, "\u21B5"), "\"");
    else
        nameElement.textContent = name;
    return nameElement;
}

/**
 * @param {?string=} description
 * @return {string} valueText
 */
WebInspector.ObjectPropertiesSection.valueTextForFunctionDescription = function(description)
{
    var matches = /function\s([^)]*)/.exec(description);
    if (!matches) {
        // process shorthand methods
        matches = /[^(]*(\([^)]*)/.exec(description);
    }
    var match = matches ? matches[1] : null;
    return match ? match.replace(/\n/g, " ") + ")" : (description || "");
}

/**
 * @param {!WebInspector.RemoteObject} value
 * @param {boolean} wasThrown
 * @param {!Element=} parentElement
 * @return {!Element}
 */
WebInspector.ObjectPropertiesSection.createValueElementWithCustomSupport = function(value, wasThrown, parentElement)
{
    if (value.customPreview()) {
        var result = (new WebInspector.CustomPreviewComponent(value)).element;
        result.classList.add("object-properties-section-custom-section");
        return result
    }
    return WebInspector.ObjectPropertiesSection.createValueElement(value, wasThrown, parentElement);
}

/**
 * @param {!WebInspector.RemoteObject} value
 * @param {boolean} wasThrown
 * @param {!Element=} parentElement
 * @return {!Element}
 */
WebInspector.ObjectPropertiesSection.createValueElement = function(value, wasThrown, parentElement)
{
    var valueElement = createElementWithClass("span", "value");
    var type = value.type;
    var subtype = value.subtype;
    var description = value.description;
    var prefix;
    var valueText;
    var suffix;
    if (wasThrown) {
        prefix = "[Exception: ";
        valueText = description;
        suffix = "]";
    } else if (type === "string" && typeof description === "string") {
        // Render \n as a nice unicode cr symbol.
        prefix = "\"";
        valueText = description.replace(/\n/g, "\u21B5");
        suffix = "\"";
    } else if (type === "function") {
        valueText = WebInspector.ObjectPropertiesSection.valueTextForFunctionDescription(description);
    } else if (type !== "object" || subtype !== "node") {
        valueText = description;
    }
    if (type !== "number" || valueText.indexOf("e") === -1) {
        valueElement.setTextContentTruncatedIfNeeded(valueText || "");
        if (prefix)
            valueElement.insertBefore(createTextNode(prefix), valueElement.firstChild);
        if (suffix)
            valueElement.createTextChild(suffix);
    } else {
        var numberParts = valueText.split("e");
        var mantissa = valueElement.createChild("span", "object-value-scientific-notation-mantissa");
        mantissa.textContent = numberParts[0];
        var exponent = valueElement.createChild("span", "object-value-scientific-notation-exponent");
        exponent.textContent = "e" + numberParts[1];
        valueElement.classList.add("object-value-scientific-notation-number");
        if (parentElement)  // FIXME: do it in the caller.
            parentElement.classList.add("hbox");
    }

    if (wasThrown)
        valueElement.classList.add("error");
    if (subtype || type)
        valueElement.classList.add("object-value-" + (subtype || type));

    if (type === "object" && subtype === "node" && description) {
        WebInspector.DOMPresentationUtils.createSpansForNodeTitle(valueElement, description);
        valueElement.addEventListener("click", mouseClick, false);
        valueElement.addEventListener("mousemove", mouseMove, false);
        valueElement.addEventListener("mouseleave", mouseLeave, false);
    } else {
        valueElement.title = description || "";
    }

    function mouseMove()
    {
        WebInspector.DOMModel.highlightObjectAsDOMNode(value);
    }

    function mouseLeave()
    {
        WebInspector.DOMModel.hideDOMNodeHighlight();
    }

    /**
     * @param {!Event} event
     */
    function mouseClick(event)
    {
        WebInspector.Revealer.reveal(value);
        event.consume(true);
    }

    return valueElement;
}

/**
 * @param {!WebInspector.RemoteObject} func
 * @param {!Element} element
 * @param {boolean} linkify
 * @param {boolean=} includePreview
 */
WebInspector.ObjectPropertiesSection.formatObjectAsFunction = function(func, element, linkify, includePreview)
{
    func.functionDetails(didGetDetails);

    /**
     * @param {?WebInspector.DebuggerModel.FunctionDetails} response
     */
    function didGetDetails(response)
    {
        if (!response) {
            var valueText = WebInspector.ObjectPropertiesSection.valueTextForFunctionDescription(func.description);
            element.createTextChild(valueText);
            return;
        }

        if (linkify && response && response.location) {
            var anchor = createElement("span");
            element.classList.add("linkified");
            element.appendChild(anchor);
            element.addEventListener("click", WebInspector.Revealer.reveal.bind(WebInspector.Revealer, response.location, undefined));
            element = anchor;
        }

        var text = func.description.substring(0, 200);
        if (includePreview) {
            element.textContent = text.replace(/^function /, "") + (func.description.length > 200 ? "\u2026" : "");
            return;
        }

        // Now parse description and get the real params and title.
        self.runtime.instancePromise(WebInspector.TokenizerFactory).then(processTokens);

        var params = null;
        var functionName = response ? response.functionName : "";

        /**
         * @param {!WebInspector.TokenizerFactory} tokenizerFactory
         */
        function processTokens(tokenizerFactory)
        {
            var tokenize = tokenizerFactory.createTokenizer("text/javascript");
            tokenize(text, processToken);
            element.textContent = (functionName || "anonymous") + "(" + (params || []).join(", ") + ")";
        }

        var doneProcessing = false;

        /**
         * @param {string} token
         * @param {?string} tokenType
         * @param {number} column
         * @param {number} newColumn
         */
        function processToken(token, tokenType, column, newColumn)
        {
            if (!params && tokenType === "js-def" && !functionName)
                functionName = token;
            doneProcessing = doneProcessing || token === ")";
            if (doneProcessing)
                return;
            if (token === "(") {
                params = [];
                return;
            }
            if (params && tokenType === "js-def")
                params.push(token);
        }
    }
}

/**
 * @constructor
 */
WebInspector.ObjectPropertiesSectionExpandController = function()
{
    /** @type {!Set.<string>} */
    this._expandedProperties = new Set();
}

WebInspector.ObjectPropertiesSectionExpandController._cachedPathSymbol = Symbol("cachedPath");
WebInspector.ObjectPropertiesSectionExpandController._treeOutlineId = Symbol("treeOutlineId");

WebInspector.ObjectPropertiesSectionExpandController.prototype = {
    /**
     * @param {string} id
     * @param {!WebInspector.ObjectPropertiesSection} section
     */
    watchSection: function(id, section)
    {
        section.addEventListener(TreeOutline.Events.ElementAttached, this._elementAttached, this);
        section.addEventListener(TreeOutline.Events.ElementExpanded, this._elementExpanded, this);
        section.addEventListener(TreeOutline.Events.ElementCollapsed, this._elementCollapsed, this);
        section[WebInspector.ObjectPropertiesSectionExpandController._treeOutlineId] = id;

        if (this._expandedProperties.has(id))
            section.expand();
    },

    /**
     * @param {string} id
     */
    stopWatchSectionsWithId: function(id)
    {
        for (var property of this._expandedProperties) {
            if (property.startsWith(id + ":"))
                this._expandedProperties.delete(property);
        }
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _elementAttached: function(event)
    {
        var element = /** @type {!TreeElement} */ (event.data);
        if (element.isExpandable() && this._expandedProperties.has(this._propertyPath(element)))
            element.expand();
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _elementExpanded: function(event)
    {
        var element = /** @type {!TreeElement} */ (event.data);
        this._expandedProperties.add(this._propertyPath(element));
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _elementCollapsed: function(event)
    {
        var element = /** @type {!TreeElement} */ (event.data);
        this._expandedProperties.delete(this._propertyPath(element));
    },

    /**
     * @param {!TreeElement} treeElement
     * @return {string}
     */
    _propertyPath: function(treeElement)
    {
        var cachedPropertyPath = treeElement[WebInspector.ObjectPropertiesSectionExpandController._cachedPathSymbol];
        if (cachedPropertyPath)
            return cachedPropertyPath;

        var current = treeElement;
        var rootElement = treeElement.treeOutline.objectTreeElement();

        var result;

        while (current !== rootElement) {
            var currentName = "";
            if (current.property)
                currentName = current.property.name;
            else
                currentName = typeof current.title === "string" ? current.title : current.title.textContent;

            result = currentName + (result ? "." + result : "");
            current = current.parent;
        }
        var treeOutlineId = treeElement.treeOutline[WebInspector.ObjectPropertiesSectionExpandController._treeOutlineId];
        result = treeOutlineId + (result ? ":" + result : "");
        treeElement[WebInspector.ObjectPropertiesSectionExpandController._cachedPathSymbol] = result;
        return result;
    }
};/* RemoteObjectPreviewFormatter.js */
// Copyright (c) 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 */
WebInspector.RemoteObjectPreviewFormatter = function()
{
}

WebInspector.RemoteObjectPreviewFormatter.prototype = {
    /**
     * @param {!Element} parentElement
     * @param {!RuntimeAgent.ObjectPreview} preview
     * @return {boolean} true iff preview captured all information.
     */
    appendObjectPreview: function(parentElement, preview)
    {
        var description = preview.description;
        if (preview.type !== "object" || preview.subtype === "null") {
            parentElement.appendChild(this.renderPropertyPreview(preview.type, preview.subtype, description));
            return true;
        }
        if (description && preview.subtype !== "array") {
            var text = preview.subtype ? description : this._abbreviateFullQualifiedClassName(description);
            parentElement.createTextChildren(text, " ");
        }
        if (preview.entries)
            return this._appendEntriesPreview(parentElement, preview);
        return this._appendPropertiesPreview(parentElement, preview);
    },

    /**
     * @param {string} description
     * @return {string}
     */
    _abbreviateFullQualifiedClassName: function(description)
    {
        var abbreviatedDescription = description.split(".");
        for (var i = 0; i < abbreviatedDescription.length - 1; ++i)
            abbreviatedDescription[i] = abbreviatedDescription[i].trimMiddle(3);
        return abbreviatedDescription.join(".");
    },

    /**
     * @param {!Element} parentElement
     * @param {!RuntimeAgent.ObjectPreview} preview
     * @return {boolean} true iff preview captured all information.
     */
    _appendPropertiesPreview: function(parentElement, preview)
    {
        var isArray = preview.subtype === "array";
        var arrayLength = WebInspector.RemoteObject.arrayLength(preview);
        var properties = preview.properties;
        if (isArray)
            properties = properties.slice().stableSort(compareIndexesFirst);

        /**
         * @param {!RuntimeAgent.PropertyPreview} a
         * @param {!RuntimeAgent.PropertyPreview} b
         */
        function compareIndexesFirst(a, b)
        {
            var index1 = toArrayIndex(a.name);
            var index2 = toArrayIndex(b.name);
            if (index1 < 0)
                return index2 < 0 ? 0 : 1;
            return index2 < 0 ? -1 : index1 - index2;
        }

        /**
         * @param {string} name
         * @return {number}
         */
        function toArrayIndex(name)
        {
            var index = name >>> 0;
            if (String(index) === name && index < arrayLength)
                return index;
            return -1;
        }

        parentElement.createTextChild(isArray ? "[" : "{");
        for (var i = 0; i < properties.length; ++i) {
            if (i > 0)
                parentElement.createTextChild(", ");

            var property = properties[i];
            var name = property.name;
            if (!isArray || name != i || i >= arrayLength) {
                if (/^\s|\s$|^$|\n/.test(name))
                    parentElement.createChild("span", "name").createTextChildren("\"", name.replace(/\n/g, "\u21B5"), "\"");
                else
                    parentElement.createChild("span", "name").textContent = name;
                parentElement.createTextChild(": ");
            }

            parentElement.appendChild(this._renderPropertyPreviewOrAccessor([property]));
        }
        if (preview.overflow)
            parentElement.createChild("span").textContent = "\u2026";
        parentElement.createTextChild(isArray ? "]" : "}");
        return preview.lossless;
    },


    /**
     * @param {!Element} parentElement
     * @param {!RuntimeAgent.ObjectPreview} preview
     * @return {boolean} true iff preview captured all information.
     */
    _appendEntriesPreview: function(parentElement, preview)
    {
        var lossless = preview.lossless && !preview.properties.length;
        parentElement.createTextChild("{");
        for (var i = 0; i < preview.entries.length; ++i) {
            if (i > 0)
                parentElement.createTextChild(", ");

            var entry = preview.entries[i];
            if (entry.key) {
                this.appendObjectPreview(parentElement, entry.key);
                parentElement.createTextChild(" => ");
            }
            this.appendObjectPreview(parentElement, entry.value);
        }
        if (preview.overflow)
            parentElement.createChild("span").textContent = "\u2026";
        parentElement.createTextChild("}");
        return lossless;
    },


    /**
     * @param {!Array.<!RuntimeAgent.PropertyPreview>} propertyPath
     * @return {!Element}
     */
    _renderPropertyPreviewOrAccessor: function(propertyPath)
    {
        var property = propertyPath.peekLast();
        return this.renderPropertyPreview(property.type, /** @type {string} */ (property.subtype), property.value);
    },

    /**
     * @param {string} type
     * @param {string=} subtype
     * @param {string=} description
     * @return {!Element}
     */
    renderPropertyPreview: function(type, subtype, description)
    {
        var span = createElementWithClass("span", "object-value-" + (subtype || type));
        description = description || "";

        if (type === "function") {
            span.textContent = "function";
            return span;
        }

        if (type === "object" && subtype === "node" && description) {
            span.classList.add("object-value-preview-node");
            WebInspector.DOMPresentationUtils.createSpansForNodeTitle(span, description);
            return span;
        }

        if (type === "string") {
            span.createTextChildren("\"", description.replace(/\n/g, "\u21B5"), "\"");
            return span;
        }

        if (type === "object" && !subtype) {
            span.textContent = this._abbreviateFullQualifiedClassName(description);
            return span;
        }

        span.textContent = description;
        return span;
    }
}
;/* ShortcutsScreen.js */
/*
 * Copyright (C) 2010 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 */
WebInspector.ShortcutsScreen = function()
{
    /** @type {!Object.<string, !WebInspector.ShortcutsSection>} */
    this._sections = {};
}

WebInspector.ShortcutsScreen.prototype = {
    /**
     * @param {string} name
     * @return {!WebInspector.ShortcutsSection}
     */
    section: function(name)
    {
        var section = this._sections[name];
        if (!section)
            this._sections[name] = section = new WebInspector.ShortcutsSection(name);
        return section;
    },

    /**
     * @return {!WebInspector.Widget}
     */
    createShortcutsTabView: function()
    {
        var orderedSections = [];
        for (var section in this._sections)
            orderedSections.push(this._sections[section]);
        function compareSections(a, b)
        {
            return a.order - b.order;
        }
        orderedSections.sort(compareSections);

        var widget = new WebInspector.Widget();

        widget.element.className = "settings-tab-container"; // Override
        widget.element.createChild("header").createChild("h3").createTextChild(WebInspector.UIString("Shortcuts"));
        var scrollPane = widget.element.createChild("div", "help-container-wrapper");
        var container = scrollPane.createChild("div");
        container.className = "help-content help-container";
        for (var i = 0; i < orderedSections.length; ++i)
            orderedSections[i].renderSection(container);

        var note = scrollPane.createChild("p", "help-footnote");
        note.appendChild(WebInspector.linkifyDocumentationURLAsNode("iterate/inspect-styles/shortcuts", WebInspector.UIString("Full list of DevTools keyboard shortcuts and gestures")));

        return widget;
    }
}

/**
 * We cannot initialize it here as localized strings are not loaded yet.
 * @type {!WebInspector.ShortcutsScreen}
 */
WebInspector.shortcutsScreen;

/**
 * @constructor
 * @param {string} name
 */
WebInspector.ShortcutsSection = function(name)
{
    this.name = name;
    this._lines = /** @type {!Array.<!{key: !Node, text: string}>} */ ([]);
    this.order = ++WebInspector.ShortcutsSection._sequenceNumber;
};

WebInspector.ShortcutsSection._sequenceNumber = 0;

WebInspector.ShortcutsSection.prototype = {
    /**
     * @param {!WebInspector.KeyboardShortcut.Descriptor} key
     * @param {string} description
     */
    addKey: function(key, description)
    {
        this._addLine(this._renderKey(key), description);
    },

    /**
     * @param {!Array.<!WebInspector.KeyboardShortcut.Descriptor>} keys
     * @param {string} description
     */
    addRelatedKeys: function(keys, description)
    {
        this._addLine(this._renderSequence(keys, "/"), description);
    },

    /**
     * @param {!Array.<!WebInspector.KeyboardShortcut.Descriptor>} keys
     * @param {string} description
     */
    addAlternateKeys: function(keys, description)
    {
        this._addLine(this._renderSequence(keys, WebInspector.UIString("or")), description);
    },

    /**
     * @param {!Node} keyElement
     * @param {string} description
     */
    _addLine: function(keyElement, description)
    {
        this._lines.push({ key: keyElement, text: description });
    },

    /**
     * @param {!Element} container
     */
    renderSection: function(container)
    {
        var parent = container.createChild("div", "help-block");

        var headLine = parent.createChild("div", "help-line");
        headLine.createChild("div", "help-key-cell");
        headLine.createChild("div", "help-section-title help-cell").textContent = this.name;

        for (var i = 0; i < this._lines.length; ++i) {
            var line = parent.createChild("div", "help-line");
            var keyCell = line.createChild("div", "help-key-cell");
            keyCell.appendChild(this._lines[i].key);
            keyCell.appendChild(this._createSpan("help-key-delimiter", ":"));
            line.createChild("div", "help-cell").textContent = this._lines[i].text;
        }
    },

    /**
     * @param {!Array.<!WebInspector.KeyboardShortcut.Descriptor>} sequence
     * @param {string} delimiter
     * @return {!Node}
     */
    _renderSequence: function(sequence, delimiter)
    {
        var delimiterSpan = this._createSpan("help-key-delimiter", delimiter);
        return this._joinNodes(sequence.map(this._renderKey.bind(this)), delimiterSpan);
    },

    /**
     * @param {!WebInspector.KeyboardShortcut.Descriptor} key
     * @return {!Node}
     */
    _renderKey: function(key)
    {
        var keyName = key.name;
        var plus = this._createSpan("help-combine-keys", "+");
        return this._joinNodes(keyName.split(" + ").map(this._createSpan.bind(this, "help-key")), plus);
    },

    /**
     * @param {string} className
     * @param {string} textContent
     * @return {!Element}
     */
    _createSpan: function(className, textContent)
    {
        var node = createElement("span");
        node.className = className;
        node.textContent = textContent;
        return node;
    },

    /**
     * @param {!Array.<!Element>} nodes
     * @param {!Element} delimiter
     * @return {!Node}
     */
    _joinNodes: function(nodes, delimiter)
    {
        var result = createDocumentFragment();
        for (var i = 0; i < nodes.length; ++i) {
            if (i > 0)
                result.appendChild(delimiter.cloneNode(true));
            result.appendChild(nodes[i]);
        }
        return result;
    }
}

WebInspector.ShortcutsScreen.registerShortcuts = function()
{
    // Elements panel
    var elementsSection = WebInspector.shortcutsScreen.section(WebInspector.UIString("Elements Panel"));

    var navigate = WebInspector.ShortcutsScreen.ElementsPanelShortcuts.NavigateUp.concat(WebInspector.ShortcutsScreen.ElementsPanelShortcuts.NavigateDown);
    elementsSection.addRelatedKeys(navigate, WebInspector.UIString("Navigate elements"));

    var expandCollapse = WebInspector.ShortcutsScreen.ElementsPanelShortcuts.Expand.concat(WebInspector.ShortcutsScreen.ElementsPanelShortcuts.Collapse);
    elementsSection.addRelatedKeys(expandCollapse, WebInspector.UIString("Expand/collapse"));

    elementsSection.addAlternateKeys(WebInspector.ShortcutsScreen.ElementsPanelShortcuts.EditAttribute, WebInspector.UIString("Edit attribute"));
    elementsSection.addAlternateKeys(WebInspector.ShortcutsScreen.ElementsPanelShortcuts.HideElement, WebInspector.UIString("Hide element"));
    elementsSection.addAlternateKeys(WebInspector.ShortcutsScreen.ElementsPanelShortcuts.ToggleEditAsHTML, WebInspector.UIString("Toggle edit as HTML"));

    var stylesPaneSection = WebInspector.shortcutsScreen.section(WebInspector.UIString("Styles Pane"));

    var nextPreviousProperty = WebInspector.ShortcutsScreen.ElementsPanelShortcuts.NextProperty.concat(WebInspector.ShortcutsScreen.ElementsPanelShortcuts.PreviousProperty);
    stylesPaneSection.addRelatedKeys(nextPreviousProperty, WebInspector.UIString("Next/previous property"));

    stylesPaneSection.addRelatedKeys(WebInspector.ShortcutsScreen.ElementsPanelShortcuts.IncrementValue, WebInspector.UIString("Increment value"));
    stylesPaneSection.addRelatedKeys(WebInspector.ShortcutsScreen.ElementsPanelShortcuts.DecrementValue, WebInspector.UIString("Decrement value"));

    stylesPaneSection.addAlternateKeys(WebInspector.ShortcutsScreen.ElementsPanelShortcuts.IncrementBy10, WebInspector.UIString("Increment by %f", 10));
    stylesPaneSection.addAlternateKeys(WebInspector.ShortcutsScreen.ElementsPanelShortcuts.DecrementBy10, WebInspector.UIString("Decrement by %f", 10));

    stylesPaneSection.addAlternateKeys(WebInspector.ShortcutsScreen.ElementsPanelShortcuts.IncrementBy100, WebInspector.UIString("Increment by %f", 100));
    stylesPaneSection.addAlternateKeys(WebInspector.ShortcutsScreen.ElementsPanelShortcuts.DecrementBy100, WebInspector.UIString("Decrement by %f", 100));

    stylesPaneSection.addAlternateKeys(WebInspector.ShortcutsScreen.ElementsPanelShortcuts.IncrementBy01, WebInspector.UIString("Increment by %f", 0.1));
    stylesPaneSection.addAlternateKeys(WebInspector.ShortcutsScreen.ElementsPanelShortcuts.DecrementBy01, WebInspector.UIString("Decrement by %f", 0.1));


    // Debugger
    var section = WebInspector.shortcutsScreen.section(WebInspector.UIString("Debugger"));

    section.addAlternateKeys(WebInspector.shortcutRegistry.shortcutDescriptorsForAction("debugger.toggle-pause"), WebInspector.UIString("Pause/ Continue"));
    section.addAlternateKeys(WebInspector.shortcutRegistry.shortcutDescriptorsForAction("debugger.step-over"), WebInspector.UIString("Step over"));
    section.addAlternateKeys(WebInspector.shortcutRegistry.shortcutDescriptorsForAction("debugger.step-into"), WebInspector.UIString("Step into"));
    section.addAlternateKeys(WebInspector.shortcutRegistry.shortcutDescriptorsForAction("debugger.step-out"), WebInspector.UIString("Step out"));
    if (Runtime.experiments.isEnabled("stepIntoAsync"))
        section.addAlternateKeys(WebInspector.shortcutRegistry.shortcutDescriptorsForAction("debugger.step-into"), WebInspector.UIString("Step into"));

    var nextAndPrevFrameKeys = WebInspector.ShortcutsScreen.SourcesPanelShortcuts.NextCallFrame.concat(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.PrevCallFrame);
    section.addRelatedKeys(nextAndPrevFrameKeys, WebInspector.UIString("Next/previous call frame"));

    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.EvaluateSelectionInConsole, WebInspector.UIString("Evaluate selection in console"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.AddSelectionToWatch, WebInspector.UIString("Add selection to watch"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.ToggleBreakpoint, WebInspector.UIString("Toggle breakpoint"));
    section.addAlternateKeys(WebInspector.shortcutRegistry.shortcutDescriptorsForAction("debugger.toggle-breakpoints-active"), WebInspector.UIString("Toggle all breakpoints"));

    // Editing
    section = WebInspector.shortcutsScreen.section(WebInspector.UIString("Text Editor"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.GoToMember, WebInspector.UIString("Go to member"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.ToggleAutocompletion, WebInspector.UIString("Autocompletion"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.GoToLine, WebInspector.UIString("Go to line"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.JumpToPreviousLocation, WebInspector.UIString("Jump to previous editing location"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.JumpToNextLocation, WebInspector.UIString("Jump to next editing location"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.ToggleComment, WebInspector.UIString("Toggle comment"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.IncreaseCSSUnitByOne, WebInspector.UIString("Increment CSS unit by 1"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.DecreaseCSSUnitByOne, WebInspector.UIString("Decrement CSS unit by 1"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.IncreaseCSSUnitByTen, WebInspector.UIString("Increment CSS unit by 10"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.DecreaseCSSUnitByTen, WebInspector.UIString("Decrement CSS unit by 10"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.SelectNextOccurrence, WebInspector.UIString("Select next occurrence"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.SoftUndo, WebInspector.UIString("Soft undo"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.GotoMatchingBracket, WebInspector.UIString("Go to matching bracket"));
    section.addAlternateKeys(WebInspector.ShortcutsScreen.SourcesPanelShortcuts.CloseEditorTab, WebInspector.UIString("Close editor tab"));
    section.addAlternateKeys(WebInspector.shortcutRegistry.shortcutDescriptorsForAction("sources.switch-file"), WebInspector.UIString("Switch between files with the same name and different extensions."));

    // Timeline panel
    section = WebInspector.shortcutsScreen.section(WebInspector.UIString("Timeline Panel"));
    section.addAlternateKeys(WebInspector.shortcutRegistry.shortcutDescriptorsForAction("timeline.toggle-recording"), WebInspector.UIString("Start/stop recording"));
    section.addAlternateKeys(WebInspector.shortcutRegistry.shortcutDescriptorsForAction("main.reload"), WebInspector.UIString("Record page reload"));
    section.addAlternateKeys(WebInspector.shortcutRegistry.shortcutDescriptorsForAction("timeline.save-to-file"), WebInspector.UIString("Save timeline data"));
    section.addAlternateKeys(WebInspector.shortcutRegistry.shortcutDescriptorsForAction("timeline.load-from-file"), WebInspector.UIString("Load timeline data"));
    section.addRelatedKeys(WebInspector.shortcutRegistry.shortcutDescriptorsForAction("timeline.jump-to-previous-frame").concat(WebInspector.shortcutRegistry.shortcutDescriptorsForAction("timeline.jump-to-next-frame")), WebInspector.UIString("Jump to previous/next frame"));


    // Profiles panel
    section = WebInspector.shortcutsScreen.section(WebInspector.UIString("Profiles Panel"));
    section.addAlternateKeys(WebInspector.shortcutRegistry.shortcutDescriptorsForAction("profiler.toggle-recording"), WebInspector.UIString("Start/stop recording"));

    // Layers panel
    if (Runtime.experiments.isEnabled("layersPanel")) {
        section = WebInspector.shortcutsScreen.section(WebInspector.UIString("Layers Panel"));
        section.addAlternateKeys(WebInspector.ShortcutsScreen.LayersPanelShortcuts.ResetView, WebInspector.UIString("Reset view"));
        section.addAlternateKeys(WebInspector.ShortcutsScreen.LayersPanelShortcuts.PanMode, WebInspector.UIString("Switch to pan mode"));
        section.addAlternateKeys(WebInspector.ShortcutsScreen.LayersPanelShortcuts.RotateMode, WebInspector.UIString("Switch to rotate mode"));
        section.addAlternateKeys(WebInspector.ShortcutsScreen.LayersPanelShortcuts.TogglePanRotate, WebInspector.UIString("Temporarily toggle pan/rotate mode while held"));
        section.addAlternateKeys(WebInspector.ShortcutsScreen.LayersPanelShortcuts.ZoomIn, WebInspector.UIString("Zoom in"));
        section.addAlternateKeys(WebInspector.ShortcutsScreen.LayersPanelShortcuts.ZoomOut, WebInspector.UIString("Zoom out"));
        section.addRelatedKeys(WebInspector.ShortcutsScreen.LayersPanelShortcuts.Up.concat(WebInspector.ShortcutsScreen.LayersPanelShortcuts.Down), WebInspector.UIString("Pan or rotate up/down"));
        section.addRelatedKeys(WebInspector.ShortcutsScreen.LayersPanelShortcuts.Left.concat(WebInspector.ShortcutsScreen.LayersPanelShortcuts.Right), WebInspector.UIString("Pan or rotate left/right"));
    }
}

WebInspector.ShortcutsScreen.ElementsPanelShortcuts = {
    NavigateUp: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Up)
    ],

    NavigateDown: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Down)
    ],

    Expand: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Right)
    ],

    Collapse: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Left)
    ],

    EditAttribute: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Enter)
    ],

    HideElement: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.H)
    ],

    ToggleEditAsHTML: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.F2)
    ],

    NextProperty: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Tab)
    ],

    PreviousProperty: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Tab, WebInspector.KeyboardShortcut.Modifiers.Shift)
    ],

    IncrementValue: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Up)
    ],

    DecrementValue: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Down)
    ],

    IncrementBy10: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.PageUp),
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Up, WebInspector.KeyboardShortcut.Modifiers.Shift)
    ],

    DecrementBy10: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.PageDown),
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Down, WebInspector.KeyboardShortcut.Modifiers.Shift)
    ],

    IncrementBy100: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.PageUp, WebInspector.KeyboardShortcut.Modifiers.Shift)
    ],

    DecrementBy100: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.PageDown, WebInspector.KeyboardShortcut.Modifiers.Shift)
    ],

    IncrementBy01: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Up, WebInspector.KeyboardShortcut.Modifiers.Alt)
    ],

    DecrementBy01: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Down, WebInspector.KeyboardShortcut.Modifiers.Alt)
    ]
};

WebInspector.ShortcutsScreen.SourcesPanelShortcuts = {
    SelectNextOccurrence: [
        WebInspector.KeyboardShortcut.makeDescriptor("d", WebInspector.KeyboardShortcut.Modifiers.CtrlOrMeta)
    ],

    SoftUndo: [
        WebInspector.KeyboardShortcut.makeDescriptor("u", WebInspector.KeyboardShortcut.Modifiers.CtrlOrMeta)
    ],

    GotoMatchingBracket: [
        WebInspector.KeyboardShortcut.makeDescriptor("m", WebInspector.KeyboardShortcut.Modifiers.Ctrl)
    ],

    ToggleAutocompletion: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Space, WebInspector.KeyboardShortcut.Modifiers.Ctrl)
    ],

    IncreaseCSSUnitByOne: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Up, WebInspector.KeyboardShortcut.Modifiers.Alt)
    ],

    DecreaseCSSUnitByOne: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Down, WebInspector.KeyboardShortcut.Modifiers.Alt)
    ],

    IncreaseCSSUnitByTen: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.PageUp, WebInspector.KeyboardShortcut.Modifiers.Alt)
    ],

    DecreaseCSSUnitByTen: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.PageDown, WebInspector.KeyboardShortcut.Modifiers.Alt)
    ],
    EvaluateSelectionInConsole: [
        WebInspector.KeyboardShortcut.makeDescriptor("e", WebInspector.KeyboardShortcut.Modifiers.Shift | WebInspector.KeyboardShortcut.Modifiers.Ctrl)
    ],

    AddSelectionToWatch: [
        WebInspector.KeyboardShortcut.makeDescriptor("a", WebInspector.KeyboardShortcut.Modifiers.Shift | WebInspector.KeyboardShortcut.Modifiers.Ctrl)
    ],

    GoToMember: [
        WebInspector.KeyboardShortcut.makeDescriptor("p", WebInspector.KeyboardShortcut.Modifiers.CtrlOrMeta | WebInspector.KeyboardShortcut.Modifiers.Shift)
    ],

    GoToLine: [
        WebInspector.KeyboardShortcut.makeDescriptor("g", WebInspector.KeyboardShortcut.Modifiers.Ctrl)
    ],

    ToggleBreakpoint: [
        WebInspector.KeyboardShortcut.makeDescriptor("b", WebInspector.KeyboardShortcut.Modifiers.CtrlOrMeta)
    ],

    NextCallFrame: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Period, WebInspector.KeyboardShortcut.Modifiers.Ctrl)
    ],

    PrevCallFrame: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Comma, WebInspector.KeyboardShortcut.Modifiers.Ctrl)
    ],

    ToggleComment: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Slash, WebInspector.KeyboardShortcut.Modifiers.CtrlOrMeta)
    ],

    JumpToPreviousLocation: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Minus, WebInspector.KeyboardShortcut.Modifiers.Alt)
    ],

    JumpToNextLocation: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Plus, WebInspector.KeyboardShortcut.Modifiers.Alt)
    ],

    CloseEditorTab: [
        WebInspector.KeyboardShortcut.makeDescriptor("w", WebInspector.KeyboardShortcut.Modifiers.Alt)
    ],

    Save: [
        WebInspector.KeyboardShortcut.makeDescriptor("s", WebInspector.KeyboardShortcut.Modifiers.CtrlOrMeta)
    ],

    SaveAll: [
        WebInspector.KeyboardShortcut.makeDescriptor("s", WebInspector.KeyboardShortcut.Modifiers.CtrlOrMeta | WebInspector.KeyboardShortcut.Modifiers.ShiftOrOption)
    ],
};

WebInspector.ShortcutsScreen.LayersPanelShortcuts = {
    ResetView: [
        WebInspector.KeyboardShortcut.makeDescriptor("0")
    ],

    PanMode: [
        WebInspector.KeyboardShortcut.makeDescriptor("x")
    ],

    RotateMode: [
        WebInspector.KeyboardShortcut.makeDescriptor("v")
    ],

    TogglePanRotate: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Shift)
    ],

    ZoomIn: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Plus, WebInspector.KeyboardShortcut.Modifiers.Shift),
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.NumpadPlus)
    ],

    ZoomOut: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Minus, WebInspector.KeyboardShortcut.Modifiers.Shift),
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.NumpadMinus)
    ],

    Up: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Up),
        WebInspector.KeyboardShortcut.makeDescriptor("w")
    ],

    Down: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Down),
        WebInspector.KeyboardShortcut.makeDescriptor("s")
    ],

    Left: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Left),
        WebInspector.KeyboardShortcut.makeDescriptor("a")
    ],

    Right: [
        WebInspector.KeyboardShortcut.makeDescriptor(WebInspector.KeyboardShortcut.Keys.Right),
        WebInspector.KeyboardShortcut.makeDescriptor("d")
    ]
}
;/* EventListenersUtils.js */
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/** @typedef {{eventListeners:!Array<!WebInspector.EventListener>, internalHandlers:?WebInspector.RemoteArray}} */
WebInspector.FrameworkEventListenersObject;

/** @typedef {{type: string, useCapture: boolean, handler: function()}} */
WebInspector.EventListenerObjectInInspectedPage;

/**
 * @param {!WebInspector.RemoteObject} object
 * @return {!Promise<!WebInspector.FrameworkEventListenersObject>}
 */
WebInspector.EventListener.frameworkEventListeners = function(object)
{
    if (!object.target().isPage()) {
        // TODO(kozyatinskiy): figure out how this should work for |window|.
        return Promise.resolve(/** @type {!WebInspector.FrameworkEventListenersObject} */ ({eventListeners: [], internalHandlers: null}));
    }

    var listenersResult = /** @type {!WebInspector.FrameworkEventListenersObject} */({eventListeners: []});
    return object.callFunctionPromise(frameworkEventListeners, undefined)
                 .then(assertCallFunctionResult)
                 .then(getOwnProperties)
                 .then(createEventListeners)
                 .then(returnResult)
                 .catchException(listenersResult);

    /**
     * @param {!WebInspector.RemoteObject} object
     * @return {!Promise<!{properties: ?Array.<!WebInspector.RemoteObjectProperty>, internalProperties: ?Array.<!WebInspector.RemoteObjectProperty>}>}
     */
    function getOwnProperties(object)
    {
        return object.getOwnPropertiesPromise();
    }

    /**
     * @param {!{properties: ?Array<!WebInspector.RemoteObjectProperty>, internalProperties: ?Array<!WebInspector.RemoteObjectProperty>}} result
     * @return {!Promise<undefined>}
     */
    function createEventListeners(result)
    {
        if (!result.properties)
            throw new Error("Object properties is empty");
        var promises = [];
        for (var property of result.properties) {
            if (property.name === "eventListeners" && property.value)
                promises.push(convertToEventListeners(property.value).then(storeEventListeners));
            if (property.name === "internalHandlers" && property.value)
                promises.push(convertToInternalHandlers(property.value).then(storeInternalHandlers));
            if (property.name === "errorString" && property.value)
                printErrorString(property.value);
        }
        return /** @type {!Promise<undefined>} */(Promise.all(promises));
    }

    /**
     * @param {!WebInspector.RemoteObject} pageEventListenersObject
     * @return {!Promise<!Array<!WebInspector.EventListener>>}
     */
    function convertToEventListeners(pageEventListenersObject)
    {
        return WebInspector.RemoteArray.objectAsArray(pageEventListenersObject).map(toEventListener).then(filterOutEmptyObjects);

        /**
         * @param {!WebInspector.RemoteObject} listenerObject
         * @return {!Promise<?WebInspector.EventListener>}
         */
        function toEventListener(listenerObject)
        {
            /** @type {string} */
            var type;
            /** @type {boolean} */
            var useCapture;
            /** @type {?WebInspector.RemoteObject} */
            var handler = null;
            /** @type {?WebInspector.RemoteObject} */
            var originalHandler = null;
            /** @type {?WebInspector.DebuggerModel.Location} */
            var location = null;
            /** @type {?WebInspector.RemoteObject} */
            var removeFunctionObject = null;

            var promises = [];
            promises.push(listenerObject.callFunctionJSONPromise(truncatePageEventListener, undefined).then(storeTruncatedListener));

            /**
             * @suppressReceiverCheck
             * @this {WebInspector.EventListenerObjectInInspectedPage}
             * @return {!{type:string, useCapture:boolean}}
             */
            function truncatePageEventListener()
            {
                return {type: this.type, useCapture: this.useCapture};
            }

            /**
             * @param {!{type:string, useCapture: boolean}} truncatedListener
             */
            function storeTruncatedListener(truncatedListener)
            {
                type = truncatedListener.type;
                useCapture = truncatedListener.useCapture;
            }

            promises.push(listenerObject.callFunctionPromise(handlerFunction).then(assertCallFunctionResult).then(storeOriginalHandler).then(toTargetFunction).then(storeFunctionWithDetails));

            /**
             * @suppressReceiverCheck
             * @return {function()}
             * @this {WebInspector.EventListenerObjectInInspectedPage}
             */
            function handlerFunction()
            {
                return this.handler;
            }

            /**
             * @param {!WebInspector.RemoteObject} functionObject
             * @return {!WebInspector.RemoteObject}
             */
            function storeOriginalHandler(functionObject)
            {
                originalHandler = functionObject;
                return originalHandler;
            }

            /**
             * @param {!WebInspector.RemoteObject} functionObject
             * @return {!Promise<undefined>}
             */
            function storeFunctionWithDetails(functionObject)
            {
                handler = functionObject;
                return /** @type {!Promise<undefined>} */(functionObject.functionDetailsPromise().then(storeFunctionDetails));
            }

            /**
             * @param {?WebInspector.DebuggerModel.FunctionDetails} functionDetails
             */
            function storeFunctionDetails(functionDetails)
            {
                location = functionDetails ? functionDetails.location : null;
            }

            promises.push(listenerObject.callFunctionPromise(getRemoveFunction).then(assertCallFunctionResult).then(storeRemoveFunction));

            /**
             * @suppressReceiverCheck
             * @return {function()}
             * @this {WebInspector.EventListenerObjectInInspectedPage}
             */
            function getRemoveFunction()
            {
                return this.remove;
            }

            /**
             * @param {!WebInspector.RemoteObject} functionObject
             */
            function storeRemoveFunction(functionObject)
            {
                if (functionObject.type !== "function")
                    return;
                removeFunctionObject = functionObject;
            }

            return Promise.all(promises).then(createEventListener).catchException(/** @type {?WebInspector.EventListener} */(null));

            /**
             * @return {!WebInspector.EventListener}
             */
            function createEventListener()
            {
                if (!location)
                    throw new Error("Empty event listener's location");
                return new WebInspector.EventListener(handler._target, type, useCapture, handler, originalHandler, location, removeFunctionObject, "frameworkUser");
            }
        }
    }

    /**
     * @param {!WebInspector.RemoteObject} pageInternalHandlersObject
     * @return {!Promise<!WebInspector.RemoteArray>}
     */
    function convertToInternalHandlers(pageInternalHandlersObject)
    {
        return WebInspector.RemoteArray.objectAsArray(pageInternalHandlersObject).map(toTargetFunction)
                                       .then(WebInspector.RemoteArray.createFromRemoteObjects);
    }

    /**
     * @param {!WebInspector.RemoteObject} functionObject
     * @return {!Promise<!WebInspector.RemoteObject>}
     */
    function toTargetFunction(functionObject)
    {
        return WebInspector.RemoteFunction.objectAsFunction(functionObject).targetFunction();
    }

    /**
     * @param {!Array<!WebInspector.EventListener>} eventListeners
     */
    function storeEventListeners(eventListeners)
    {
        listenersResult.eventListeners = eventListeners;
    }

    /**
     * @param {!WebInspector.RemoteArray} internalHandlers
     */
    function storeInternalHandlers(internalHandlers)
    {
        listenersResult.internalHandlers = internalHandlers;
    }

    /**
     * @param {!WebInspector.RemoteObject} errorString
     */
    function printErrorString(errorString)
    {
        WebInspector.console.error(errorString.value);
    }

    /**
     * @return {!WebInspector.FrameworkEventListenersObject}
     */
    function returnResult()
    {
        return listenersResult;
    }

    /**
     * @param {!WebInspector.CallFunctionResult} result
     * @return {!WebInspector.RemoteObject}
     */
    function assertCallFunctionResult(result)
    {
        if (result.wasThrown || !result.object)
            throw new Error("Exception in callFunction or empty result");
        return result.object;
    }

    /**
     * @param {!Array<?T>} objects
     * @return {!Array<!T>}
     * @template T
     */
    function filterOutEmptyObjects(objects)
    {
        return objects.filter(filterOutEmpty);

        /**
         * @param {?T} object
         * @return {boolean}
         * @template T
         */
        function filterOutEmpty(object)
        {
            return !!object;
        }
    }

    /*
    frameworkEventListeners fetcher functions should produce following output:
        {
          // framework event listeners
          "eventListeners": [
            {
              "handler": function(),
              "useCapture": true,
              "type": "change",
              "remove": function(type, handler, useCapture)
            },
            ...
          ],
          // internal framework event handlers
          "internalHandlers": [
            function(),
            function(),
            ...
          ]
        }
    */
    /**
     * @suppressReceiverCheck
     * @return {!{eventListeners:!Array<!WebInspector.EventListenerObjectInInspectedPage>, internalHandlers:?Array<function()>}}
     * @this {Object}
     */
    function frameworkEventListeners()
    {
        var errorLines = [];
        var eventListeners = [];
        var internalHandlers = [];
        var fetchers = [jQueryFetcher];
        try {
            if (self.devtoolsFrameworkEventListeners && isArrayLike(self.devtoolsFrameworkEventListeners))
                fetchers = fetchers.concat(self.devtoolsFrameworkEventListeners);
        } catch (e) {
            errorLines.push("devtoolsFrameworkEventListeners call produced error: " + toString(e));
        }

        for (var i = 0; i < fetchers.length; ++i) {
            try {
                var fetcherResult = fetchers[i](this);
                if (fetcherResult.eventListeners && isArrayLike(fetcherResult.eventListeners)) {
                    eventListeners = eventListeners.concat(fetcherResult.eventListeners.map(checkEventListener).filter(nonEmptyObject));
                }
                if (fetcherResult.internalHandlers && isArrayLike(fetcherResult.internalHandlers))
                    internalHandlers = internalHandlers.concat(fetcherResult.internalHandlers.map(checkInternalHandler).filter(nonEmptyObject));
            } catch (e) {
                errorLines.push("fetcher call produced error: " + toString(e));
            }
        }
        var result = {eventListeners: eventListeners};
        if (internalHandlers.length)
            result.internalHandlers = internalHandlers;
        if (errorLines.length) {
            var errorString = "Framework Event Listeners API Errors:\n\t" + errorLines.join("\n\t");
            errorString = errorString.substr(0, errorString.length - 1);
            result.errorString = errorString;
        }
        return result;

        /**
         * @param {?Object} obj
         * @return {boolean}
         */
        function isArrayLike(obj)
        {
            if (!obj || typeof obj !== "object")
                return false;
            try {
                if (typeof obj.splice === "function") {
                    var len = obj.length;
                    return typeof len === "number" && (len >>> 0 === len && (len > 0 || 1 / len > 0));
                }
            } catch (e) {
            }
            return false;
        }

        /**
         * @param {*} eventListener
         * @return {?WebInspector.EventListenerObjectInInspectedPage}
         */
        function checkEventListener(eventListener)
        {
            try {
                var errorString = "";
                if (!eventListener)
                    errorString += "empty event listener, ";
                var type = eventListener.type;
                if (!type || (typeof type !== "string"))
                    errorString += "event listener's type isn't string or empty, ";
                var useCapture = eventListener.useCapture;
                if (typeof useCapture !== "boolean")
                    errorString += "event listener's useCapture isn't boolean or undefined, ";
                var handler = eventListener.handler;
                if (!handler || (typeof handler !== "function"))
                    errorString += "event listener's handler isn't a function or empty, ";
                var remove = eventListener.remove;
                if (remove && (typeof remove !== "function"))
                    errorString += "event listener's remove isn't a function, ";
                if (!errorString){
                    return {type: type, useCapture: useCapture, handler: handler, remove: remove};
                } else {
                    errorLines.push(errorString.substr(0, errorString.length - 2));
                    return null;
                }
            } catch (e) {
                errorLines.push(toString(e));
                return null;
            }
        }

        /**
         * @param {*} handler
         * @return {function()|null}
         */
        function checkInternalHandler(handler)
        {
            if (handler && (typeof handler === "function"))
                return handler;
            errorLines.push("internal handler isn't a function or empty");
            return null;
        }

        /**
         * @param {*} obj
         * @return {string}
         * @suppress {uselessCode}
         */
        function toString(obj)
        {
            try {
                return "" + obj;
            } catch (e) {
                return "<error>";
            }
        }

        /**
         * @param {*} obj
         * @return {boolean}
         */
        function nonEmptyObject(obj)
        {
            return !!obj;
        }

        function jQueryFetcher(node)
        {
            if (!node || !(node instanceof Node))
                return {eventListeners: []};
            var jQuery = /** @type {?{fn,data,_data}}*/(window["jQuery"]);
            if (!jQuery || !jQuery.fn)
                return {eventListeners: []};
            var jQueryFunction = /** @type {function(!Node)} */(jQuery);
            var data = jQuery._data || jQuery.data;

            var eventListeners = [];
            var internalHandlers = [];

            if (typeof data === "function") {
                var events = data(node, "events");
                for (var type in events) {
                    for (var key in events[type]) {
                        var frameworkListener = events[type][key];
                        if (typeof frameworkListener === "object" || typeof frameworkListener === "function") {
                            var listener = {
                                handler: frameworkListener.handler || frameworkListener,
                                useCapture: true,
                                type: type
                            };
                            listener.remove = jQueryRemove.bind(node, frameworkListener.selector);
                            eventListeners.push(listener);
                        }
                    }
                }
                var nodeData = data(node);
                if (nodeData && typeof nodeData.handle === "function")
                    internalHandlers.push(nodeData.handle);
            }
            var entry = jQueryFunction(node)[0];
            if (entry) {
                var entryEvents = entry["$events"];
                for (var type in entryEvents) {
                    var events = entryEvents[type];
                    for (var key in events) {
                        if (typeof events[key] === "function") {
                            var listener = {
                                handler: events[key],
                                useCapture: true,
                                type: type
                            };
                            // We don't support removing for old version < 1.4 of jQuery because it doesn't provide API for getting "selector".
                            eventListeners.push(listener);
                        }
                    }
                }
                if (entry && entry["$handle"])
                    internalHandlers.push(entry["$handle"]);
            }
            return {eventListeners: eventListeners, internalHandlers: internalHandlers};
        }

        /**
         * @param {string} selector
         * @param {string} type
         * @param {function()} handler
         * @this {?Object}
         */
        function jQueryRemove(selector, type, handler)
        {
            if (!this || !(this instanceof Node))
                return;
            var node = /** @type {!Node} */(this);
            var jQuery = /** @type {?{fn,data,_data}}*/(window["jQuery"]);
            if (!jQuery || !jQuery.fn)
                return;
            var jQueryFunction = /** @type {function(!Node)} */(jQuery);
            jQueryFunction(node).off(type, selector, handler);
        }
    }
}
;/* EventListenersView.js */
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
* @typedef {Array<{object: !WebInspector.RemoteObject, eventListeners: ?Array<!WebInspector.EventListener>, frameworkEventListeners: ?{eventListeners: ?Array<!WebInspector.EventListener>, internalHandlers: ?WebInspector.RemoteArray}, isInternal: ?Array<boolean>}>}
*/
WebInspector.EventListenersResult;

/**
 * @constructor
 * @param {!Element} element
 */
WebInspector.EventListenersView = function(element)
{
    this._element = element;
    this._treeOutline = new TreeOutlineInShadow();
    this._treeOutline.hideOverflow();
    this._treeOutline.registerRequiredCSS("components/objectValue.css");
    this._treeOutline.registerRequiredCSS("components/eventListenersView.css");
    this._treeOutline.setComparator(WebInspector.EventListenersTreeElement.comparator);
    this._treeOutline.element.classList.add("monospace");
    this._element.appendChild(this._treeOutline.element)
    this._emptyHolder = createElementWithClass("div", "info");
    this._emptyHolder.textContent = WebInspector.UIString("No Event Listeners");
    this._linkifier = new WebInspector.Linkifier();
    /** @type {!Map<string, !WebInspector.EventListenersTreeElement>} */
    this._treeItemMap = new Map();
}

WebInspector.EventListenersView.prototype = {
    /**
     * @param {!Array<!WebInspector.RemoteObject>} objects
     * @return {!Promise<undefined>}
     */
    addObjects: function(objects)
    {
        this.reset();
        var promises = [];
        for (var object of objects)
            promises.push(this._addObject(object));
        return Promise.all(promises).then(this.addEmptyHolderIfNeeded.bind(this)).then(this._eventListenersArrivedForTest.bind(this));
     },

    /**
     * @param {!WebInspector.RemoteObject} object
     * @return {!Promise<undefined>}
     */
    _addObject: function(object)
    {
        /** @type {?Array<!WebInspector.EventListener>} */
        var eventListeners = null;
        /** @type {?WebInspector.FrameworkEventListenersObject}*/
        var frameworkEventListenersObject = null;

        var promises = [];
        promises.push(object.eventListeners().then(storeEventListeners));
        promises.push(WebInspector.EventListener.frameworkEventListeners(object).then(storeFrameworkEventListenersObject));
        return Promise.all(promises).then(markInternalEventListeners).then(addEventListeners.bind(this));

        /**
         * @param {?Array<!WebInspector.EventListener>} result
         */
        function storeEventListeners(result)
        {
            eventListeners = result;
        }

        /**
         * @param {?WebInspector.FrameworkEventListenersObject} result
         */
        function storeFrameworkEventListenersObject(result)
        {
            frameworkEventListenersObject = result;
        }

        /**
         * @return {!Promise<undefined>}
         */
        function markInternalEventListeners()
        {
            if (!eventListeners || !frameworkEventListenersObject.internalHandlers)
                return Promise.resolve(undefined);
            return frameworkEventListenersObject.internalHandlers.object().callFunctionJSONPromise(isInternalEventListener, eventListeners.map(handlerArgument)).then(setIsInternal);

            /**
             * @param {!WebInspector.EventListener} listener
             * @return {!RuntimeAgent.CallArgument}
             */
            function handlerArgument(listener)
            {
                return WebInspector.RemoteObject.toCallArgument(listener.handler());
            }

            /**
             * @suppressReceiverCheck
             * @return {!Array<boolean>}
             * @this {Array<*>}
             */
            function isInternalEventListener()
            {
                var isInternal = [];
                var internalHandlersSet = new Set(this);
                for (var handler of arguments)
                    isInternal.push(internalHandlersSet.has(handler));
                return isInternal;
            }

            /**
             * @param {!Array<boolean>} isInternal
             */
            function setIsInternal(isInternal)
            {
                for (var i = 0; i < eventListeners.length; ++i) {
                    if (isInternal[i])
                        eventListeners[i].setListenerType("frameworkInternal");
                }
            }
        }

        /**
         * @this {WebInspector.EventListenersView}
         */
        function addEventListeners()
        {
            this._addObjectEventListeners(object, eventListeners);
            this._addObjectEventListeners(object, frameworkEventListenersObject.eventListeners);
        }
    },

    /**
     * @param {!WebInspector.RemoteObject} object
     * @param {?Array<!WebInspector.EventListener>} eventListeners
     */
    _addObjectEventListeners: function(object, eventListeners)
    {
        if (!eventListeners)
            return;
        for (var eventListener of eventListeners) {
            var treeItem = this._getOrCreateTreeElementForType(eventListener.type());
            treeItem.addObjectEventListener(eventListener, object);
        }
    },

    /**
     * @param {boolean} showFramework
     */
    showFrameworkListeners: function(showFramework)
    {
        var eventTypes = this._treeOutline.rootElement().children();
        for (var eventType of eventTypes) {
            var hiddenEventType = true;
            for (var listenerElement of eventType.children()) {
                var listenerType = listenerElement.eventListener().listenerType();
                var hidden = false;
                if (listenerType === "frameworkUser" && !showFramework)
                    hidden = true;
                if (listenerType === "frameworkInternal" && showFramework)
                    hidden = true;
                listenerElement.hidden = hidden;
                hiddenEventType = hiddenEventType && hidden;
            }
            eventType.hidden = hiddenEventType;
        }
    },

    /**
     * @param {string} type
     * @return {!WebInspector.EventListenersTreeElement}
     */
    _getOrCreateTreeElementForType: function(type)
    {
        var treeItem = this._treeItemMap.get(type);
        if (!treeItem) {
            treeItem = new WebInspector.EventListenersTreeElement(type, this._linkifier);
            this._treeItemMap.set(type, treeItem);
            treeItem.hidden = true;
            this._treeOutline.appendChild(treeItem);
        }
        this._emptyHolder.remove();
        return treeItem;
    },

    addEmptyHolderIfNeeded: function()
    {
        var allHidden = true;
        for (var eventType of this._treeOutline.rootElement().children()) {
            eventType.hidden = !eventType.firstChild();
            allHidden = allHidden && eventType.hidden;
        }
        if (allHidden && !this._emptyHolder.parentNode)
           this._element.appendChild(this._emptyHolder);
    },

    reset: function()
    {
        var eventTypes = this._treeOutline.rootElement().children();
        for (var eventType of eventTypes)
            eventType.removeChildren();
        this._linkifier.reset();
    },

    _eventListenersArrivedForTest: function()
    {
    }
}

/**
 * @constructor
 * @extends {TreeElement}
 * @param {string} type
 * @param {!WebInspector.Linkifier} linkifier
 */
WebInspector.EventListenersTreeElement = function(type, linkifier)
{
    TreeElement.call(this, type);
    this.toggleOnClick = true;
    this.selectable = false;
    this._linkifier = linkifier;
}

/**
 * @param {!TreeElement} element1
 * @param {!TreeElement} element2
 * @return {number}
 */
WebInspector.EventListenersTreeElement.comparator = function(element1, element2) {
    if (element1.title === element2.title)
        return 0;
    return element1.title > element2.title ? 1 : -1;
}

WebInspector.EventListenersTreeElement.prototype = {
    /**
     * @param {!WebInspector.EventListener} eventListener
     * @param {!WebInspector.RemoteObject} object
     */
    addObjectEventListener: function(eventListener, object)
    {
        var treeElement = new WebInspector.ObjectEventListenerBar(eventListener, object, this._linkifier);
        this.appendChild(/** @type {!TreeElement} */ (treeElement));
    },

    __proto__: TreeElement.prototype
}

/**
 * @constructor
 * @extends {TreeElement}
 * @param {!WebInspector.EventListener} eventListener
 * @param {!WebInspector.RemoteObject} object
 * @param {!WebInspector.Linkifier} linkifier
 */
WebInspector.ObjectEventListenerBar = function(eventListener, object, linkifier)
{
    TreeElement.call(this, "", true);
    this._eventListener = eventListener;
    this.editable = false;
    this.selectable = false;
    this._setTitle(object, linkifier);
}

WebInspector.ObjectEventListenerBar.prototype = {
    onpopulate: function()
    {
        var properties = [];
        var eventListener = this._eventListener;
        var runtimeModel = eventListener.target().runtimeModel;
        properties.push(runtimeModel.createRemotePropertyFromPrimitiveValue("useCapture", eventListener.useCapture()));
        if (typeof eventListener.handler() !== "undefined")
            properties.push(new WebInspector.RemoteObjectProperty("handler", eventListener.handler()));
        WebInspector.ObjectPropertyTreeElement.populateWithProperties(this, properties, [], true, null);
    },

    /**
     * @param {!WebInspector.RemoteObject} object
     * @param {!WebInspector.Linkifier} linkifier
     */
    _setTitle: function(object, linkifier)
    {
        var title = this.listItemElement.createChild("span");
        var subtitle = this.listItemElement.createChild("span", "event-listener-tree-subtitle");
        subtitle.appendChild(linkifier.linkifyRawLocation(this._eventListener.location(), this._eventListener.sourceURL()));

        title.appendChild(WebInspector.ObjectPropertiesSection.createValueElement(object, false));

        if (this._eventListener.removeFunction()) {
            var deleteButton = title.createChild("span", "event-listener-delete-button");
            deleteButton.textContent = WebInspector.UIString("Remove");
            deleteButton.title = WebInspector.UIString("Delete event listener");
            deleteButton.addEventListener("click", removeListener.bind(this), false);
            title.appendChild(deleteButton);
        }

        /**
         * @param {!WebInspector.Event} event
         * @this {WebInspector.ObjectEventListenerBar}
         */
        function removeListener(event)
        {
            event.consume();
            this._removeListenerBar();
            this._eventListener.remove();
        }
    },

    _removeListenerBar: function()
    {
        var parent = this.parent;
        parent.removeChild(this);
        if (!parent.childCount()) {
            parent.parent.removeChild(parent);
            return;
        }
        var allHidden = true;
        for (var i = 0; i < parent.childCount(); ++i)
            if (!parent.childAt(i).hidden)
                allHidden = false;
        parent.hidden = allHidden;
    },

    /**
     * @return {!WebInspector.EventListener}
     */
    eventListener: function()
    {
        return this._eventListener;
    },

    __proto__: TreeElement.prototype
}
;/* Reload.js */
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

WebInspector.reload = function()
{
    if (WebInspector.dockController.canDock() && WebInspector.dockController.dockSide() === WebInspector.DockController.State.Undocked)
        InspectorFrontendHost.setIsDocked(true, function() {});
    window.location.reload();
}
;
/* Module extensions */
/* ExtensionAPI.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

function defineCommonExtensionSymbols(apiPrivate)
{
    if (!apiPrivate.audits)
        apiPrivate.audits = {};
    apiPrivate.audits.Severity = {
        Info: "info",
        Warning: "warning",
        Severe: "severe"
    };

    if (!apiPrivate.panels)
        apiPrivate.panels = {};
    apiPrivate.panels.SearchAction = {
        CancelSearch: "cancelSearch",
        PerformSearch: "performSearch",
        NextSearchResult: "nextSearchResult",
        PreviousSearchResult: "previousSearchResult"
    };

    apiPrivate.Events = {
        AuditStarted: "audit-started-",
        ButtonClicked: "button-clicked-",
        PanelObjectSelected: "panel-objectSelected-",
        NetworkRequestFinished: "network-request-finished",
        OpenResource: "open-resource",
        PanelSearch: "panel-search-",
        ResourceAdded: "resource-added",
        ResourceContentCommitted: "resource-content-committed",
        ViewShown: "view-shown-",
        ViewHidden: "view-hidden-"
    };

    apiPrivate.Commands = {
        AddAuditCategory: "addAuditCategory",
        AddAuditResult: "addAuditResult",
        AddRequestHeaders: "addRequestHeaders",
        ApplyStyleSheet: "applyStyleSheet",
        CreatePanel: "createPanel",
        CreateSidebarPane: "createSidebarPane",
        CreateToolbarButton: "createToolbarButton",
        EvaluateOnInspectedPage: "evaluateOnInspectedPage",
        ForwardKeyboardEvent: "_forwardKeyboardEvent",
        GetHAR: "getHAR",
        GetPageResources: "getPageResources",
        GetRequestContent: "getRequestContent",
        GetResourceContent: "getResourceContent",
        InspectedURLChanged: "inspectedURLChanged",
        OpenResource: "openResource",
        Reload: "Reload",
        Subscribe: "subscribe",
        SetOpenResourceHandler: "setOpenResourceHandler",
        SetResourceContent: "setResourceContent",
        SetSidebarContent: "setSidebarContent",
        SetSidebarHeight: "setSidebarHeight",
        SetSidebarPage: "setSidebarPage",
        ShowPanel: "showPanel",
        StopAuditCategoryRun: "stopAuditCategoryRun",
        Unsubscribe: "unsubscribe",
        UpdateAuditProgress: "updateAuditProgress",
        UpdateButton: "updateButton"
    };
}

/**
 * @param {number} injectedScriptId
 * @return {!Object}
 * @suppressGlobalPropertiesCheck
 */
function injectedExtensionAPI(injectedScriptId)
{

var apiPrivate = {};

defineCommonExtensionSymbols(apiPrivate);

var commands = apiPrivate.Commands;
var events = apiPrivate.Events;
var userAction = false;

// Here and below, all constructors are private to API implementation.
// For a public type Foo, if internal fields are present, these are on
// a private FooImpl type, an instance of FooImpl is used in a closure
// by Foo consutrctor to re-bind publicly exported members to an instance
// of Foo.

/**
 * @constructor
 */
function EventSinkImpl(type, customDispatch)
{
    this._type = type;
    this._listeners = [];
    this._customDispatch = customDispatch;
}

EventSinkImpl.prototype = {
    addListener: function(callback)
    {
        if (typeof callback !== "function")
            throw "addListener: callback is not a function";
        if (this._listeners.length === 0)
            extensionServer.sendRequest({ command: commands.Subscribe, type: this._type });
        this._listeners.push(callback);
        extensionServer.registerHandler("notify-" + this._type, this._dispatch.bind(this));
    },

    removeListener: function(callback)
    {
        var listeners = this._listeners;

        for (var i = 0; i < listeners.length; ++i) {
            if (listeners[i] === callback) {
                listeners.splice(i, 1);
                break;
            }
        }
        if (this._listeners.length === 0)
            extensionServer.sendRequest({ command: commands.Unsubscribe, type: this._type });
    },

    /**
     * @param {...} vararg
     */
    _fire: function(vararg)
    {
        var listeners = this._listeners.slice();
        for (var i = 0; i < listeners.length; ++i)
            listeners[i].apply(null, arguments);
    },

    _dispatch: function(request)
    {
         if (this._customDispatch)
             this._customDispatch.call(this, request);
         else
             this._fire.apply(this, request.arguments);
    }
}

/**
 * @constructor
 */
function InspectorExtensionAPI()
{
    this.audits = new Audits();
    this.inspectedWindow = new InspectedWindow();
    this.panels = new Panels();
    this.network = new Network();
    defineDeprecatedProperty(this, "webInspector", "resources", "network");
}

/**
 * @constructor
 */
function Network()
{
    /**
     * @this {EventSinkImpl}
     */
    function dispatchRequestEvent(message)
    {
        var request = message.arguments[1];
        request.__proto__ = new Request(message.arguments[0]);
        this._fire(request);
    }
    this.onRequestFinished = new EventSink(events.NetworkRequestFinished, dispatchRequestEvent);
    defineDeprecatedProperty(this, "network", "onFinished", "onRequestFinished");
    this.onNavigated = new EventSink(events.InspectedURLChanged);
}

Network.prototype = {
    getHAR: function(callback)
    {
        function callbackWrapper(result)
        {
            var entries = (result && result.entries) || [];
            for (var i = 0; i < entries.length; ++i) {
                entries[i].__proto__ = new Request(entries[i]._requestId);
                delete entries[i]._requestId;
            }
            callback(result);
        }
        extensionServer.sendRequest({ command: commands.GetHAR }, callback && callbackWrapper);
    },

    addRequestHeaders: function(headers)
    {
        extensionServer.sendRequest({ command: commands.AddRequestHeaders, headers: headers, extensionId: window.location.hostname });
    }
}

/**
 * @constructor
 */
function RequestImpl(id)
{
    this._id = id;
}

RequestImpl.prototype = {
    getContent: function(callback)
    {
        function callbackWrapper(response)
        {
            callback(response.content, response.encoding);
        }
        extensionServer.sendRequest({ command: commands.GetRequestContent, id: this._id }, callback && callbackWrapper);
    }
}

/**
 * @constructor
 */
function Panels()
{
    var panels = {
        elements: new ElementsPanel(),
        sources: new SourcesPanel(),
    };

    function panelGetter(name)
    {
        return panels[name];
    }
    for (var panel in panels)
        this.__defineGetter__(panel, panelGetter.bind(null, panel));
    this.applyStyleSheet = function(styleSheet) { extensionServer.sendRequest({ command: commands.ApplyStyleSheet, styleSheet: styleSheet }); };
}

Panels.prototype = {
    create: function(title, icon, page, callback)
    {
        var id = "extension-panel-" + extensionServer.nextObjectId();
        var request = {
            command: commands.CreatePanel,
            id: id,
            title: title,
            icon: icon,
            page: page
        };
        extensionServer.sendRequest(request, callback && callback.bind(this, new ExtensionPanel(id)));
    },

    setOpenResourceHandler: function(callback)
    {
        var hadHandler = extensionServer.hasHandler(events.OpenResource);

        function callbackWrapper(message)
        {
            // Allow the panel to show itself when handling the event.
            userAction = true;
            try {
                callback.call(null, new Resource(message.resource), message.lineNumber);
            } finally {
                userAction = false;
            }
        }

        if (!callback)
            extensionServer.unregisterHandler(events.OpenResource);
        else
            extensionServer.registerHandler(events.OpenResource, callbackWrapper);

        // Only send command if we either removed an existing handler or added handler and had none before.
        if (hadHandler === !callback)
            extensionServer.sendRequest({ command: commands.SetOpenResourceHandler, "handlerPresent": !!callback });
    },

    openResource: function(url, lineNumber, callback)
    {
        extensionServer.sendRequest({ command: commands.OpenResource, "url": url, "lineNumber": lineNumber }, callback);
    },

    get SearchAction()
    {
        return apiPrivate.panels.SearchAction;
    }
}

/**
 * @constructor
 */
function ExtensionViewImpl(id)
{
    this._id = id;

    /**
     * @this {EventSinkImpl}
     */
    function dispatchShowEvent(message)
    {
        var frameIndex = message.arguments[0];
        if (typeof frameIndex === "number")
            this._fire(window.parent.frames[frameIndex]);
        else
            this._fire();
    }

    if (id) {
        this.onShown = new EventSink(events.ViewShown + id, dispatchShowEvent);
        this.onHidden = new EventSink(events.ViewHidden + id);
    }
}

/**
 * @constructor
 * @extends {ExtensionViewImpl}
 * @param {string} hostPanelName
 */
function PanelWithSidebarImpl(hostPanelName)
{
    ExtensionViewImpl.call(this, null);
    this._hostPanelName = hostPanelName;
    this.onSelectionChanged = new EventSink(events.PanelObjectSelected + hostPanelName);
}

PanelWithSidebarImpl.prototype = {
    createSidebarPane: function(title, callback)
    {
        var id = "extension-sidebar-" + extensionServer.nextObjectId();
        var request = {
            command: commands.CreateSidebarPane,
            panel: this._hostPanelName,
            id: id,
            title: title
        };
        function callbackWrapper()
        {
            callback(new ExtensionSidebarPane(id));
        }
        extensionServer.sendRequest(request, callback && callbackWrapper);
    },

    __proto__: ExtensionViewImpl.prototype
}

function declareInterfaceClass(implConstructor)
{
    return function()
    {
        var impl = { __proto__: implConstructor.prototype };
        implConstructor.apply(impl, arguments);
        populateInterfaceClass(this, impl);
    };
}

function defineDeprecatedProperty(object, className, oldName, newName)
{
    var warningGiven = false;
    function getter()
    {
        if (!warningGiven) {
            console.warn(className + "." + oldName + " is deprecated. Use " + className + "." + newName + " instead");
            warningGiven = true;
        }
        return object[newName];
    }
    object.__defineGetter__(oldName, getter);
}

function extractCallbackArgument(args)
{
    var lastArgument = args[args.length - 1];
    return typeof lastArgument === "function" ? lastArgument : undefined;
}

var AuditCategory = declareInterfaceClass(AuditCategoryImpl);
var AuditResult = declareInterfaceClass(AuditResultImpl);
var Button = declareInterfaceClass(ButtonImpl);
var EventSink = declareInterfaceClass(EventSinkImpl);
var ExtensionPanel = declareInterfaceClass(ExtensionPanelImpl);
var ExtensionSidebarPane = declareInterfaceClass(ExtensionSidebarPaneImpl);
var PanelWithSidebar = declareInterfaceClass(PanelWithSidebarImpl);
var Request = declareInterfaceClass(RequestImpl);
var Resource = declareInterfaceClass(ResourceImpl);

/**
 * @constructor
 * @extends {PanelWithSidebar}
 */
function ElementsPanel()
{
    PanelWithSidebar.call(this, "elements");
}

ElementsPanel.prototype = {
    __proto__: PanelWithSidebar.prototype
}

/**
 * @constructor
 * @extends {PanelWithSidebar}
 */
function SourcesPanel()
{
    PanelWithSidebar.call(this, "sources");
}

SourcesPanel.prototype = {
    __proto__: PanelWithSidebar.prototype
}

/**
 * @constructor
 * @extends {ExtensionViewImpl}
 */
function ExtensionPanelImpl(id)
{
    ExtensionViewImpl.call(this, id);
    this.onSearch = new EventSink(events.PanelSearch + id);
}

ExtensionPanelImpl.prototype = {
    /**
     * @return {!Object}
     */
    createStatusBarButton: function(iconPath, tooltipText, disabled)
    {
        var id = "button-" + extensionServer.nextObjectId();
        var request = {
            command: commands.CreateToolbarButton,
            panel: this._id,
            id: id,
            icon: iconPath,
            tooltip: tooltipText,
            disabled: !!disabled
        };
        extensionServer.sendRequest(request);
        return new Button(id);
    },

    show: function()
    {
        if (!userAction)
            return;

        var request = {
            command: commands.ShowPanel,
            id: this._id
        };
        extensionServer.sendRequest(request);
    },

    __proto__: ExtensionViewImpl.prototype
}

/**
 * @constructor
 * @extends {ExtensionViewImpl}
 */
function ExtensionSidebarPaneImpl(id)
{
    ExtensionViewImpl.call(this, id);
}

ExtensionSidebarPaneImpl.prototype = {
    setHeight: function(height)
    {
        extensionServer.sendRequest({ command: commands.SetSidebarHeight, id: this._id, height: height });
    },

    setExpression: function(expression, rootTitle, evaluateOptions)
    {
        var request = {
            command: commands.SetSidebarContent,
            id: this._id,
            expression: expression,
            rootTitle: rootTitle,
            evaluateOnPage: true,
        };
        if (typeof evaluateOptions === "object")
            request.evaluateOptions = evaluateOptions;
        extensionServer.sendRequest(request, extractCallbackArgument(arguments));
    },

    setObject: function(jsonObject, rootTitle, callback)
    {
        extensionServer.sendRequest({ command: commands.SetSidebarContent, id: this._id, expression: jsonObject, rootTitle: rootTitle }, callback);
    },

    setPage: function(page)
    {
        extensionServer.sendRequest({ command: commands.SetSidebarPage, id: this._id, page: page });
    },

    __proto__: ExtensionViewImpl.prototype
}

/**
 * @constructor
 */
function ButtonImpl(id)
{
    this._id = id;
    this.onClicked = new EventSink(events.ButtonClicked + id);
}

ButtonImpl.prototype = {
    update: function(iconPath, tooltipText, disabled)
    {
        var request = {
            command: commands.UpdateButton,
            id: this._id,
            icon: iconPath,
            tooltip: tooltipText,
            disabled: !!disabled
        };
        extensionServer.sendRequest(request);
    }
};

/**
 * @constructor
 */
function Audits()
{
}

Audits.prototype = {
    /**
     * @return {!AuditCategory}
     */
    addCategory: function(displayName, resultCount)
    {
        var id = "extension-audit-category-" + extensionServer.nextObjectId();
        if (typeof resultCount !== "undefined")
            console.warn("Passing resultCount to audits.addCategory() is deprecated. Use AuditResult.updateProgress() instead.");
        extensionServer.sendRequest({ command: commands.AddAuditCategory, id: id, displayName: displayName, resultCount: resultCount });
        return new AuditCategory(id);
    }
}

/**
 * @constructor
 */
function AuditCategoryImpl(id)
{
    /**
     * @this {EventSinkImpl}
     */
    function dispatchAuditEvent(request)
    {
        var auditResult = new AuditResult(request.arguments[0]);
        try {
            this._fire(auditResult);
        } catch (e) {
            console.error("Uncaught exception in extension audit event handler: " + e);
            auditResult.done();
        }
    }
    this._id = id;
    this.onAuditStarted = new EventSink(events.AuditStarted + id, dispatchAuditEvent);
}

/**
 * @constructor
 */
function AuditResultImpl(id)
{
    this._id = id;

    this.createURL = this._nodeFactory.bind(this, "url");
    this.createSnippet = this._nodeFactory.bind(this, "snippet");
    this.createText = this._nodeFactory.bind(this, "text");
    this.createObject = this._nodeFactory.bind(this, "object");
    this.createNode = this._nodeFactory.bind(this, "node");
}

AuditResultImpl.prototype = {
    addResult: function(displayName, description, severity, details)
    {
        // shorthand for specifying details directly in addResult().
        if (details && !(details instanceof AuditResultNode))
            details = new AuditResultNode(Array.isArray(details) ? details : [details]);

        var request = {
            command: commands.AddAuditResult,
            resultId: this._id,
            displayName: displayName,
            description: description,
            severity: severity,
            details: details
        };
        extensionServer.sendRequest(request);
    },

    /**
     * @return {!Object}
     */
    createResult: function()
    {
        return new AuditResultNode(Array.prototype.slice.call(arguments));
    },

    updateProgress: function(worked, totalWork)
    {
        extensionServer.sendRequest({ command: commands.UpdateAuditProgress, resultId: this._id, progress: worked / totalWork });
    },

    done: function()
    {
        extensionServer.sendRequest({ command: commands.StopAuditCategoryRun, resultId: this._id });
    },

    /**
     * @type {!Object.<string, string>}
     */
    get Severity()
    {
        return apiPrivate.audits.Severity;
    },

    /**
     * @return {!{type: string, arguments: !Array.<string|number>}}
     */
    createResourceLink: function(url, lineNumber)
    {
        return {
            type: "resourceLink",
            arguments: [url, lineNumber && lineNumber - 1]
        };
    },

    /**
     * @return {!{type: string, arguments: !Array.<string|number>}}
     */
    _nodeFactory: function(type)
    {
        return {
            type: type,
            arguments: Array.prototype.slice.call(arguments, 1)
        };
    }
}

/**
 * @constructor
 */
function AuditResultNode(contents)
{
    this.contents = contents;
    this.children = [];
    this.expanded = false;
}

AuditResultNode.prototype = {
    /**
     * @return {!Object}
     */
    addChild: function()
    {
        var node = new AuditResultNode(Array.prototype.slice.call(arguments));
        this.children.push(node);
        return node;
    }
};

/**
 * @constructor
 */
function InspectedWindow()
{
    /**
     * @this {EventSinkImpl}
     */
    function dispatchResourceEvent(message)
    {
        this._fire(new Resource(message.arguments[0]));
    }

    /**
     * @this {EventSinkImpl}
     */
    function dispatchResourceContentEvent(message)
    {
        this._fire(new Resource(message.arguments[0]), message.arguments[1]);
    }

    this.onResourceAdded = new EventSink(events.ResourceAdded, dispatchResourceEvent);
    this.onResourceContentCommitted = new EventSink(events.ResourceContentCommitted, dispatchResourceContentEvent);
}

InspectedWindow.prototype = {
    reload: function(optionsOrUserAgent)
    {
        var options = null;
        if (typeof optionsOrUserAgent === "object") {
            options = optionsOrUserAgent;
        } else if (typeof optionsOrUserAgent === "string") {
            options = { userAgent: optionsOrUserAgent };
            console.warn("Passing userAgent as string parameter to inspectedWindow.reload() is deprecated. " +
                         "Use inspectedWindow.reload({ userAgent: value}) instead.");
        }
        extensionServer.sendRequest({ command: commands.Reload, options: options });
    },

    /**
     * @return {?Object}
     */
    eval: function(expression, evaluateOptions)
    {
        var callback = extractCallbackArgument(arguments);
        function callbackWrapper(result)
        {
            if (result.isError || result.isException)
                callback(undefined, result);
            else
                callback(result.value);
        }
        var request = {
            command: commands.EvaluateOnInspectedPage,
            expression: expression
        };
        if (typeof evaluateOptions === "object")
            request.evaluateOptions = evaluateOptions;
        extensionServer.sendRequest(request, callback && callbackWrapper);
        return null;
    },

    getResources: function(callback)
    {
        function wrapResource(resourceData)
        {
            return new Resource(resourceData);
        }
        function callbackWrapper(resources)
        {
            callback(resources.map(wrapResource));
        }
        extensionServer.sendRequest({ command: commands.GetPageResources }, callback && callbackWrapper);
    }
}

/**
 * @constructor
 */
function ResourceImpl(resourceData)
{
    this._url = resourceData.url;
    this._type = resourceData.type;
}

ResourceImpl.prototype = {
    get url()
    {
        return this._url;
    },

    get type()
    {
        return this._type;
    },

    getContent: function(callback)
    {
        function callbackWrapper(response)
        {
            callback(response.content, response.encoding);
        }

        extensionServer.sendRequest({ command: commands.GetResourceContent, url: this._url }, callback && callbackWrapper);
    },

    setContent: function(content, commit, callback)
    {
        extensionServer.sendRequest({ command: commands.SetResourceContent, url: this._url, content: content, commit: commit }, callback);
    }
}

var keyboardEventRequestQueue = [];
var forwardTimer = null;

function forwardKeyboardEvent(event)
{
    const Esc = "U+001B";
    // We only care about global hotkeys, not about random text
    if (!event.ctrlKey && !event.altKey && !event.metaKey && !/^F\d+$/.test(event.keyIdentifier) && event.keyIdentifier !== Esc)
        return;
    var requestPayload = {
        eventType: event.type,
        ctrlKey: event.ctrlKey,
        altKey: event.altKey,
        metaKey: event.metaKey,
        keyIdentifier: event.keyIdentifier,
        location: event.location,
        keyCode: event.keyCode
    };
    keyboardEventRequestQueue.push(requestPayload);
    if (!forwardTimer)
        forwardTimer = setTimeout(forwardEventQueue, 0);
}

function forwardEventQueue()
{
    forwardTimer = null;
    var request = {
        command: commands.ForwardKeyboardEvent,
        entries: keyboardEventRequestQueue
    };
    extensionServer.sendRequest(request);
    keyboardEventRequestQueue = [];
}

document.addEventListener("keydown", forwardKeyboardEvent, false);
document.addEventListener("keypress", forwardKeyboardEvent, false);

/**
 * @constructor
 */
function ExtensionServerClient()
{
    this._callbacks = {};
    this._handlers = {};
    this._lastRequestId = 0;
    this._lastObjectId = 0;

    this.registerHandler("callback", this._onCallback.bind(this));

    var channel = new MessageChannel();
    this._port = channel.port1;
    this._port.addEventListener("message", this._onMessage.bind(this), false);
    this._port.start();

    window.parent.postMessage("registerExtension", [ channel.port2 ], "*");
}

ExtensionServerClient.prototype = {
    /**
     * @param {!Object} message
     * @param {function()=} callback
     */
    sendRequest: function(message, callback)
    {
        if (typeof callback === "function")
            message.requestId = this._registerCallback(callback);
        this._port.postMessage(message);
    },

    /**
     * @return {boolean}
     */
    hasHandler: function(command)
    {
        return !!this._handlers[command];
    },

    registerHandler: function(command, handler)
    {
        this._handlers[command] = handler;
    },

    unregisterHandler: function(command)
    {
        delete this._handlers[command];
    },

    /**
     * @return {string}
     */
    nextObjectId: function()
    {
        return injectedScriptId.toString() + "_" + ++this._lastObjectId;
    },

    _registerCallback: function(callback)
    {
        var id = ++this._lastRequestId;
        this._callbacks[id] = callback;
        return id;
    },

    _onCallback: function(request)
    {
        if (request.requestId in this._callbacks) {
            var callback = this._callbacks[request.requestId];
            delete this._callbacks[request.requestId];
            callback(request.result);
        }
    },

    _onMessage: function(event)
    {
        var request = event.data;
        var handler = this._handlers[request.command];
        if (handler)
            handler.call(this, request);
    }
}

function populateInterfaceClass(interfaze, implementation)
{
    for (var member in implementation) {
        if (member.charAt(0) === "_")
            continue;
        var descriptor = null;
        // Traverse prototype chain until we find the owner.
        for (var owner = implementation; owner && !descriptor; owner = owner.__proto__)
            descriptor = Object.getOwnPropertyDescriptor(owner, member);
        if (!descriptor)
            continue;
        if (typeof descriptor.value === "function")
            interfaze[member] = descriptor.value.bind(implementation);
        else if (typeof descriptor.get === "function")
            interfaze.__defineGetter__(member, descriptor.get.bind(implementation));
        else
            Object.defineProperty(interfaze, member, descriptor);
    }
}

// extensionServer is a closure variable defined by the glue below -- make sure we fail if it's not there.
if (!extensionServer)
    extensionServer = new ExtensionServerClient();

return new InspectorExtensionAPI();
}

/**
 * @suppress {checkVars, checkTypes}
 */
function platformExtensionAPI(coreAPI)
{
    function getTabId()
    {
        return tabId;
    }
    chrome = window.chrome || {};
    // Override chrome.devtools as a workaround for a error-throwing getter being exposed
    // in extension pages loaded into a non-extension process (only happens for remote client
    // extensions)
    var devtools_descriptor = Object.getOwnPropertyDescriptor(chrome, "devtools");
    if (!devtools_descriptor || devtools_descriptor.get)
        Object.defineProperty(chrome, "devtools", { value: {}, enumerable: true });
    // Only expose tabId on chrome.devtools.inspectedWindow, not webInspector.inspectedWindow.
    chrome.devtools.inspectedWindow = {};
    chrome.devtools.inspectedWindow.__defineGetter__("tabId", getTabId);
    chrome.devtools.inspectedWindow.__proto__ = coreAPI.inspectedWindow;
    chrome.devtools.network = coreAPI.network;
    chrome.devtools.panels = coreAPI.panels;

    // default to expose experimental APIs for now.
    if (extensionInfo.exposeExperimentalAPIs !== false) {
        chrome.experimental = chrome.experimental || {};
        chrome.experimental.devtools = chrome.experimental.devtools || {};

        var properties = Object.getOwnPropertyNames(coreAPI);
        for (var i = 0; i < properties.length; ++i) {
            var descriptor = Object.getOwnPropertyDescriptor(coreAPI, properties[i]);
            Object.defineProperty(chrome.experimental.devtools, properties[i], descriptor);
        }
        chrome.experimental.devtools.inspectedWindow = chrome.devtools.inspectedWindow;
    }
    if (extensionInfo.exposeWebInspectorNamespace)
        window.webInspector = coreAPI;
}

/**
 * @param {!ExtensionDescriptor} extensionInfo
 * @param {string} inspectedTabId
 * @return {string}
 */
function buildPlatformExtensionAPI(extensionInfo, inspectedTabId)
{
    return "var extensionInfo = " + JSON.stringify(extensionInfo) + ";" +
       "var tabId = " + inspectedTabId + ";" +
       platformExtensionAPI.toString();
}

/**
 * @param {!ExtensionDescriptor} extensionInfo
 * @param {string} inspectedTabId
 * @return {string}
 */
function buildExtensionAPIInjectedScript(extensionInfo, inspectedTabId)
{
    return "(function(injectedScriptId){ " +
        "var extensionServer;" +
        defineCommonExtensionSymbols.toString() + ";" +
        injectedExtensionAPI.toString() + ";" +
        buildPlatformExtensionAPI(extensionInfo, inspectedTabId) + ";" +
        "platformExtensionAPI(injectedExtensionAPI(injectedScriptId));" +
        "return {};" +
        "})";
}
;/* ExtensionAuditCategory.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {string} extensionOrigin
 * @param {string} id
 * @param {string} displayName
 * @param {number=} ruleCount
 */
WebInspector.ExtensionAuditCategory = function(extensionOrigin, id, displayName, ruleCount)
{
    this.extensionOrigin = extensionOrigin;
    this.id = id;
    this.displayName = displayName;
    this.ruleCount  = ruleCount;
}

/**
 * @interface
 */
WebInspector.ExtensionAuditCategoryResults = function()
{
}

WebInspector.ExtensionAuditCategoryResults.prototype = {
    /**
     * @return {string}
     */
    id: function() { },

    /**
     * @param {string} displayName
     * @param {string} description
     * @param {string} severity
     * @param {!Object} details
     */
    addResult: function(displayName, description, severity, details) { },

    /**
     * @param {number} progress
     */
    updateProgress: function(progress) { },

    done: function() { }
}
;/* ExtensionRegistryStub.js */
/*
 * Copyright (C) 2010 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

if (!window.InspectorExtensionRegistry) {

/**
 * @constructor
 */
WebInspector.InspectorExtensionRegistryStub = function()
{
}

WebInspector.InspectorExtensionRegistryStub.prototype = {
    getExtensionsAsync: function()
    {
    }
}

var InspectorExtensionRegistry = new WebInspector.InspectorExtensionRegistryStub();

}
;/* ExtensionServer.js */
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @suppressGlobalPropertiesCheck
 */
WebInspector.ExtensionServer = function()
{
    this._clientObjects = {};
    this._handlers = {};
    this._subscribers = {};
    this._subscriptionStartHandlers = {};
    this._subscriptionStopHandlers = {};
    this._extraHeaders = {};
    this._requests = {};
    this._lastRequestId = 0;
    this._registeredExtensions = {};
    this._status = new WebInspector.ExtensionStatus();
    /** @type {!Array.<!WebInspector.ExtensionSidebarPane>} */
    this._sidebarPanes = [];
    /** @type {!Array.<!WebInspector.ExtensionAuditCategory>} */
    this._auditCategories = [];

    var commands = WebInspector.extensionAPI.Commands;

    this._registerHandler(commands.AddAuditCategory, this._onAddAuditCategory.bind(this));
    this._registerHandler(commands.AddAuditResult, this._onAddAuditResult.bind(this));
    this._registerHandler(commands.AddRequestHeaders, this._onAddRequestHeaders.bind(this));
    this._registerHandler(commands.ApplyStyleSheet, this._onApplyStyleSheet.bind(this));
    this._registerHandler(commands.CreatePanel, this._onCreatePanel.bind(this));
    this._registerHandler(commands.CreateSidebarPane, this._onCreateSidebarPane.bind(this));
    this._registerHandler(commands.CreateToolbarButton, this._onCreateToolbarButton.bind(this));
    this._registerHandler(commands.EvaluateOnInspectedPage, this._onEvaluateOnInspectedPage.bind(this));
    this._registerHandler(commands.ForwardKeyboardEvent, this._onForwardKeyboardEvent.bind(this));
    this._registerHandler(commands.GetHAR, this._onGetHAR.bind(this));
    this._registerHandler(commands.GetPageResources, this._onGetPageResources.bind(this));
    this._registerHandler(commands.GetRequestContent, this._onGetRequestContent.bind(this));
    this._registerHandler(commands.GetResourceContent, this._onGetResourceContent.bind(this));
    this._registerHandler(commands.Reload, this._onReload.bind(this));
    this._registerHandler(commands.SetOpenResourceHandler, this._onSetOpenResourceHandler.bind(this));
    this._registerHandler(commands.SetResourceContent, this._onSetResourceContent.bind(this));
    this._registerHandler(commands.SetSidebarHeight, this._onSetSidebarHeight.bind(this));
    this._registerHandler(commands.SetSidebarContent, this._onSetSidebarContent.bind(this));
    this._registerHandler(commands.SetSidebarPage, this._onSetSidebarPage.bind(this));
    this._registerHandler(commands.ShowPanel, this._onShowPanel.bind(this));
    this._registerHandler(commands.StopAuditCategoryRun, this._onStopAuditCategoryRun.bind(this));
    this._registerHandler(commands.Subscribe, this._onSubscribe.bind(this));
    this._registerHandler(commands.OpenResource, this._onOpenResource.bind(this));
    this._registerHandler(commands.Unsubscribe, this._onUnsubscribe.bind(this));
    this._registerHandler(commands.UpdateButton, this._onUpdateButton.bind(this));
    this._registerHandler(commands.UpdateAuditProgress, this._onUpdateAuditProgress.bind(this));
    window.addEventListener("message", this._onWindowMessage.bind(this), false);  // Only for main window.

    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.AddExtensions, this._addExtensions, this);
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.SetInspectedTabId, this._setInspectedTabId, this);

    this._initExtensions();
}

WebInspector.ExtensionServer.Events = {
    SidebarPaneAdded: "SidebarPaneAdded",
    AuditCategoryAdded: "AuditCategoryAdded"
}

WebInspector.ExtensionServer.prototype = {
    initializeExtensions: function()
    {
        this._initializeCommandIssued = true;
        if (this._pendingExtensionInfos) {
            this._pendingExtensionInfos.forEach(this._addExtension, this);
            delete this._pendingExtensionInfos;
        }
    },

    /**
     * @return {boolean}
     */
    hasExtensions: function()
    {
        return !!Object.keys(this._registeredExtensions).length;
    },

    /**
     * @param {string} panelId
     * @param {string} action
     * @param {string=} searchString
     */
    notifySearchAction: function(panelId, action, searchString)
    {
        this._postNotification(WebInspector.extensionAPI.Events.PanelSearch + panelId, action, searchString);
    },

    /**
     * @param {string} identifier
     * @param {number=} frameIndex
     */
    notifyViewShown: function(identifier, frameIndex)
    {
        this._postNotification(WebInspector.extensionAPI.Events.ViewShown + identifier, frameIndex);
    },

    /**
     * @param {string} identifier
     */
    notifyViewHidden: function(identifier)
    {
        this._postNotification(WebInspector.extensionAPI.Events.ViewHidden + identifier);
    },

    /**
     * @param {string} identifier
     */
    notifyButtonClicked: function(identifier)
    {
        this._postNotification(WebInspector.extensionAPI.Events.ButtonClicked + identifier);
    },

    _inspectedURLChanged: function(event)
    {
        this._requests = {};
        var url = event.data;
        this._postNotification(WebInspector.extensionAPI.Events.InspectedURLChanged, url);
    },


    /**
     * @param {string} categoryId
     * @param {!WebInspector.ExtensionAuditCategoryResults} auditResults
     */
    startAuditRun: function(categoryId, auditResults)
    {
        this._clientObjects[auditResults.id()] = auditResults;
        this._postNotification("audit-started-" + categoryId, auditResults.id());
    },

    /**
     * @param {!WebInspector.ExtensionAuditCategoryResults} auditResults
     */
    stopAuditRun: function(auditResults)
    {
        delete this._clientObjects[auditResults.id()];
    },

    /**
     * @param {string} type
     * @return {boolean}
     */
    hasSubscribers: function(type)
    {
        return !!this._subscribers[type];
    },

    /**
     * @param {string} type
     * @param {...*} vararg
     */
    _postNotification: function(type, vararg)
    {
        var subscribers = this._subscribers[type];
        if (!subscribers)
            return;
        var message = {
            command: "notify-" + type,
            arguments: Array.prototype.slice.call(arguments, 1)
        };
        for (var i = 0; i < subscribers.length; ++i)
            subscribers[i].postMessage(message);
    },

    _onSubscribe: function(message, port)
    {
        var subscribers = this._subscribers[message.type];
        if (subscribers)
            subscribers.push(port);
        else {
            this._subscribers[message.type] = [ port ];
            if (this._subscriptionStartHandlers[message.type])
                this._subscriptionStartHandlers[message.type]();
        }
    },

    _onUnsubscribe: function(message, port)
    {
        var subscribers = this._subscribers[message.type];
        if (!subscribers)
            return;
        subscribers.remove(port);
        if (!subscribers.length) {
            delete this._subscribers[message.type];
            if (this._subscriptionStopHandlers[message.type])
                this._subscriptionStopHandlers[message.type]();
        }
    },

    _onAddRequestHeaders: function(message)
    {
        var id = message.extensionId;
        if (typeof id !== "string")
            return this._status.E_BADARGTYPE("extensionId", typeof id, "string");
        var extensionHeaders = this._extraHeaders[id];
        if (!extensionHeaders) {
            extensionHeaders = {};
            this._extraHeaders[id] = extensionHeaders;
        }
        for (var name in message.headers)
            extensionHeaders[name] = message.headers[name];
        var allHeaders = /** @type {!NetworkAgent.Headers} */ ({});
        for (var extension in this._extraHeaders) {
            var headers = this._extraHeaders[extension];
            for (name in headers) {
                if (typeof headers[name] === "string")
                    allHeaders[name] = headers[name];
            }
        }

        WebInspector.multitargetNetworkManager.setExtraHTTPHeaders(allHeaders);
    },

    /**
     * @param {*} message
     * @suppressGlobalPropertiesCheck
     */
    _onApplyStyleSheet: function(message)
    {
        if (!Runtime.experiments.isEnabled("applyCustomStylesheet"))
            return;
        var styleSheet = createElement("style");
        styleSheet.textContent = message.styleSheet;
        document.head.appendChild(styleSheet);
    },

    _onCreatePanel: function(message, port)
    {
        var id = message.id;
        // The ids are generated on the client API side and must be unique, so the check below
        // shouldn't be hit unless someone is bypassing the API.
        if (id in this._clientObjects || WebInspector.inspectorView.hasPanel(id))
            return this._status.E_EXISTS(id);

        var page = this._expandResourcePath(port._extensionOrigin, message.page);
        var persistentId = port._extensionOrigin + message.title;
        persistentId = persistentId.replace(/\s/g, "");
        var panelDescriptor = new WebInspector.ExtensionServerPanelDescriptor(persistentId, message.title, new WebInspector.ExtensionPanel(this, persistentId, id, page));
        this._clientObjects[id] = panelDescriptor;
        WebInspector.inspectorView.addPanel(panelDescriptor);
        return this._status.OK();
    },

    _onShowPanel: function(message)
    {
        var panelName = message.id;
        var panelDescriptor = this._clientObjects[message.id];
        if (panelDescriptor && panelDescriptor instanceof WebInspector.ExtensionServerPanelDescriptor)
            panelName = panelDescriptor.name();
        WebInspector.inspectorView.showPanel(panelName);
    },

    _onCreateToolbarButton: function(message, port)
    {
        var panelDescriptor = this._clientObjects[message.panel];
        if (!panelDescriptor || !(panelDescriptor instanceof WebInspector.ExtensionServerPanelDescriptor))
            return this._status.E_NOTFOUND(message.panel);
        var button = new WebInspector.ExtensionButton(this, message.id, this._expandResourcePath(port._extensionOrigin, message.icon), message.tooltip, message.disabled);
        this._clientObjects[message.id] = button;

        panelDescriptor.panel().then(appendButton);

        /**
         * @param {!WebInspector.Panel} panel
         */
        function appendButton(panel)
        {
            /** @type {!WebInspector.ExtensionPanel} panel*/ (panel).addToolbarItem(button.toolbarButton());
        }

        return this._status.OK();
    },

    _onUpdateButton: function(message, port)
    {
        var button = this._clientObjects[message.id];
        if (!button || !(button instanceof WebInspector.ExtensionButton))
            return this._status.E_NOTFOUND(message.id);
        button.update(this._expandResourcePath(port._extensionOrigin, message.icon), message.tooltip, message.disabled);
        return this._status.OK();
    },

    _onCreateSidebarPane: function(message)
    {
        if (message.panel !== "elements" && message.panel !== "sources")
            return this._status.E_NOTFOUND(message.panel);
        var id = message.id;
        var sidebar = new WebInspector.ExtensionSidebarPane(this, message.panel, message.title, id);
        this._sidebarPanes.push(sidebar);
        this._clientObjects[id] = sidebar;
        this.dispatchEventToListeners(WebInspector.ExtensionServer.Events.SidebarPaneAdded, sidebar);

        return this._status.OK();
    },

    /**
     * @return {!Array.<!WebInspector.ExtensionSidebarPane>}
     */
    sidebarPanes: function()
    {
        return this._sidebarPanes;
    },

    _onSetSidebarHeight: function(message)
    {
        var sidebar = this._clientObjects[message.id];
        if (!sidebar)
            return this._status.E_NOTFOUND(message.id);
        sidebar.setHeight(message.height);
        return this._status.OK();
    },

    _onSetSidebarContent: function(message, port)
    {
        var sidebar = this._clientObjects[message.id];
        if (!sidebar)
            return this._status.E_NOTFOUND(message.id);

        /**
         * @this {WebInspector.ExtensionServer}
         */
        function callback(error)
        {
            var result = error ? this._status.E_FAILED(error) : this._status.OK();
            this._dispatchCallback(message.requestId, port, result);
        }
        if (message.evaluateOnPage)
            return sidebar.setExpression(message.expression, message.rootTitle, message.evaluateOptions, port._extensionOrigin, callback.bind(this));
        sidebar.setObject(message.expression, message.rootTitle, callback.bind(this));
    },

    _onSetSidebarPage: function(message, port)
    {
        var sidebar = this._clientObjects[message.id];
        if (!sidebar)
            return this._status.E_NOTFOUND(message.id);
        sidebar.setPage(this._expandResourcePath(port._extensionOrigin, message.page));
    },

    _onOpenResource: function(message)
    {
        var uiSourceCode = WebInspector.networkMapping.uiSourceCodeForURLForAnyTarget(message.url);
        if (uiSourceCode) {
            WebInspector.Revealer.reveal(uiSourceCode.uiLocation(message.lineNumber, 0));
            return this._status.OK();
        }

        var resource = WebInspector.resourceForURL(message.url);
        if (resource) {
            WebInspector.Revealer.reveal(resource, message.lineNumber);
            return this._status.OK();
        }

        var request = WebInspector.NetworkLog.requestForURL(message.url);
        if (request) {
            WebInspector.Revealer.reveal(request);
            return this._status.OK();
        }

        return this._status.E_NOTFOUND(message.url);
    },

    _onSetOpenResourceHandler: function(message, port)
    {
        var name = this._registeredExtensions[port._extensionOrigin].name || ("Extension " + port._extensionOrigin);
        if (message.handlerPresent)
            WebInspector.openAnchorLocationRegistry.registerHandler(name, this._handleOpenURL.bind(this, port));
        else
            WebInspector.openAnchorLocationRegistry.unregisterHandler(name);
    },

    _handleOpenURL: function(port, details)
    {
        var url = /** @type {string} */ (details.url);
        var contentProvider = WebInspector.workspace.uiSourceCodeForURL(url) || WebInspector.resourceForURL(url);
        if (!contentProvider)
            return false;

        var lineNumber = details.lineNumber;
        if (typeof lineNumber === "number")
            lineNumber += 1;
        port.postMessage({
            command: "open-resource",
            resource: this._makeResource(contentProvider),
            lineNumber: lineNumber
        });
        return true;
    },

    _onReload: function(message)
    {
        var options = /** @type {!ExtensionReloadOptions} */ (message.options || {});

        WebInspector.multitargetNetworkManager.setUserAgentOverride(typeof options.userAgent === "string" ? options.userAgent : "");
        var injectedScript;
        if (options.injectedScript)
            injectedScript = "(function(){" + options.injectedScript + "})()";
        WebInspector.targetManager.reloadPage(!!options.ignoreCache, injectedScript);
        return this._status.OK();
    },

    _onEvaluateOnInspectedPage: function(message, port)
    {
        /**
         * @param {?Protocol.Error} error
         * @param {?WebInspector.RemoteObject} remoteObject
         * @param {boolean=} wasThrown
         * @this {WebInspector.ExtensionServer}
         */
        function callback(error, remoteObject, wasThrown)
        {
            var result;
            if (error || !remoteObject)
                result = this._status.E_PROTOCOLERROR(error.toString());
            else if (wasThrown)
                result = { isException: true, value: remoteObject.description };
            else
                result = { value: remoteObject.value };

            this._dispatchCallback(message.requestId, port, result);
        }
        return this.evaluate(message.expression, true, true, message.evaluateOptions, port._extensionOrigin, callback.bind(this));
    },

    _onGetHAR: function()
    {
        var requests = WebInspector.NetworkLog.requests();
        var harLog = (new WebInspector.HARLog(requests)).build();
        for (var i = 0; i < harLog.entries.length; ++i)
            harLog.entries[i]._requestId = this._requestId(requests[i]);
        return harLog;
    },

    /**
     * @param {!WebInspector.ContentProvider} contentProvider
     */
    _makeResource: function(contentProvider)
    {
        return {
            url: contentProvider.contentURL(),
            type: contentProvider.contentType().name()
        };
    },

    /**
     * @return {!Array.<!WebInspector.ContentProvider>}
     */
    _onGetPageResources: function()
    {
        var resources = {};

        /**
         * @this {WebInspector.ExtensionServer}
         */
        function pushResourceData(contentProvider)
        {
            if (!resources[contentProvider.contentURL()])
                resources[contentProvider.contentURL()] = this._makeResource(contentProvider);
        }
        var uiSourceCodes = WebInspector.workspace.uiSourceCodesForProjectType(WebInspector.projectTypes.Network);
        uiSourceCodes = uiSourceCodes.concat(WebInspector.workspace.uiSourceCodesForProjectType(WebInspector.projectTypes.ContentScripts));
        uiSourceCodes.forEach(pushResourceData.bind(this));
        for (var target of WebInspector.targetManager.targets())
            target.resourceTreeModel.forAllResources(pushResourceData.bind(this));
        return Object.values(resources);
    },

    /**
     * @param {!WebInspector.ContentProvider} contentProvider
     * @param {!Object} message
     * @param {!MessagePort} port
     */
    _getResourceContent: function(contentProvider, message, port)
    {
        /**
         * @param {?string} content
         * @this {WebInspector.ExtensionServer}
         */
        function onContentAvailable(content)
        {
            var contentEncoded = false;
            if (contentProvider instanceof WebInspector.Resource)
                contentEncoded = contentProvider.contentEncoded;
            if (contentProvider instanceof WebInspector.NetworkRequest)
                contentEncoded = contentProvider.contentEncoded;
            var response = {
                encoding: contentEncoded && content ? "base64" : "",
                content: content
            };
            this._dispatchCallback(message.requestId, port, response);
        }

        contentProvider.requestContent().then(onContentAvailable.bind(this));
    },

    _onGetRequestContent: function(message, port)
    {
        var request = this._requestById(message.id);
        if (!request)
            return this._status.E_NOTFOUND(message.id);
        this._getResourceContent(request, message, port);
    },

    _onGetResourceContent: function(message, port)
    {
        var url = /** @type {string} */ (message.url);
        var contentProvider = WebInspector.workspace.uiSourceCodeForURL(url) || WebInspector.resourceForURL(url);
        if (!contentProvider)
            return this._status.E_NOTFOUND(url);
        this._getResourceContent(contentProvider, message, port);
    },

    _onSetResourceContent: function(message, port)
    {
        /**
         * @param {?Protocol.Error} error
         * @this {WebInspector.ExtensionServer}
         */
        function callbackWrapper(error)
        {
            var response = error ? this._status.E_FAILED(error) : this._status.OK();
            this._dispatchCallback(message.requestId, port, response);
        }

        var url = /** @type {string} */ (message.url);
        var uiSourceCode = WebInspector.workspace.uiSourceCodeForURL(url);
        if (!uiSourceCode || !uiSourceCode.contentType().isDocumentOrScriptOrStyleSheet()) {
            var resource = WebInspector.ResourceTreeModel.resourceForURL(url);
            if (!resource)
                return this._status.E_NOTFOUND(url);
            return this._status.E_NOTSUPPORTED("Resource is not editable");
        }
        uiSourceCode.setWorkingCopy(message.content);
        if (message.commit)
            uiSourceCode.commitWorkingCopy();
        callbackWrapper.call(this, null);
    },

    _requestId: function(request)
    {
        if (!request._extensionRequestId) {
            request._extensionRequestId = ++this._lastRequestId;
            this._requests[request._extensionRequestId] = request;
        }
        return request._extensionRequestId;
    },

    _requestById: function(id)
    {
        return this._requests[id];
    },

    _onAddAuditCategory: function(message, port)
    {
        var category = new WebInspector.ExtensionAuditCategory(port._extensionOrigin, message.id, message.displayName, message.resultCount);
        this._clientObjects[message.id] = category;
        this._auditCategories.push(category);
        this.dispatchEventToListeners(WebInspector.ExtensionServer.Events.AuditCategoryAdded, category);
    },

    /**
     * @return {!Array.<!WebInspector.ExtensionAuditCategory>}
     */
    auditCategories: function()
    {
        return this._auditCategories;
    },

    _onAddAuditResult: function(message)
    {
        var auditResult = /** {!WebInspector.ExtensionAuditCategoryResults} */ (this._clientObjects[message.resultId]);
        if (!auditResult)
            return this._status.E_NOTFOUND(message.resultId);
        try {
            auditResult.addResult(message.displayName, message.description, message.severity, message.details);
        } catch (e) {
            return e;
        }
        return this._status.OK();
    },

    _onUpdateAuditProgress: function(message)
    {
        var auditResult = /** {!WebInspector.ExtensionAuditCategoryResults} */ (this._clientObjects[message.resultId]);
        if (!auditResult)
            return this._status.E_NOTFOUND(message.resultId);
        auditResult.updateProgress(Math.min(Math.max(0, message.progress), 1));
    },

    _onStopAuditCategoryRun: function(message)
    {
        var auditRun = /** {!WebInspector.ExtensionAuditCategoryResults} */ (this._clientObjects[message.resultId]);
        if (!auditRun)
            return this._status.E_NOTFOUND(message.resultId);
        auditRun.done();
    },

    _onForwardKeyboardEvent: function(message)
    {
        const Esc = "U+001B";
        message.entries.forEach(handleEventEntry);

        /**
         * @param {*} entry
         * @suppressGlobalPropertiesCheck
         */
        function handleEventEntry(entry)
        {
            if (!entry.ctrlKey && !entry.altKey && !entry.metaKey && !/^F\d+$/.test(entry.keyIdentifier) && entry.keyIdentifier !== Esc)
                return;
            // Fool around closure compiler -- it has its own notion of both KeyboardEvent constructor
            // and initKeyboardEvent methods and overriding these in externs.js does not have effect.
            var event = new window.KeyboardEvent(entry.eventType, {
                keyIdentifier: entry.keyIdentifier,
                location: entry.location,
                ctrlKey: entry.ctrlKey,
                altKey: entry.altKey,
                shiftKey: entry.shiftKey,
                metaKey: entry.metaKey
            });
            event.__keyCode = keyCodeForEntry(entry);
            document.dispatchEvent(event);
        }

        function keyCodeForEntry(entry)
        {
            var keyCode = entry.keyCode;
            if (!keyCode) {
                // This is required only for synthetic events (e.g. dispatched in tests).
                var match = entry.keyIdentifier.match(/^U\+([\dA-Fa-f]+)$/);
                if (match)
                    keyCode = parseInt(match[1], 16);
            }
            return keyCode || 0;
        }
    },

    _dispatchCallback: function(requestId, port, result)
    {
        if (requestId)
            port.postMessage({ command: "callback", requestId: requestId, result: result });
    },

    _initExtensions: function()
    {
        this._registerAutosubscriptionHandler(WebInspector.extensionAPI.Events.ResourceAdded,
            WebInspector.workspace, WebInspector.Workspace.Events.UISourceCodeAdded, this._notifyResourceAdded);
        this._registerAutosubscriptionTargetManagerHandler(WebInspector.extensionAPI.Events.NetworkRequestFinished,
            WebInspector.NetworkManager, WebInspector.NetworkManager.EventTypes.RequestFinished, this._notifyRequestFinished);

        /**
         * @this {WebInspector.ExtensionServer}
         */
        function onElementsSubscriptionStarted()
        {
            WebInspector.notifications.addEventListener(WebInspector.NotificationService.Events.SelectedNodeChanged, this._notifyElementsSelectionChanged, this);
        }

        /**
         * @this {WebInspector.ExtensionServer}
         */
        function onElementsSubscriptionStopped()
        {
            WebInspector.notifications.removeEventListener(WebInspector.NotificationService.Events.SelectedNodeChanged, this._notifyElementsSelectionChanged, this);
        }

        this._registerSubscriptionHandler(WebInspector.extensionAPI.Events.PanelObjectSelected + "elements",
            onElementsSubscriptionStarted.bind(this), onElementsSubscriptionStopped.bind(this));
        this._registerResourceContentCommittedHandler(this._notifyUISourceCodeContentCommitted);

        WebInspector.targetManager.addEventListener(WebInspector.TargetManager.Events.InspectedURLChanged,
            this._inspectedURLChanged, this);

        InspectorExtensionRegistry.getExtensionsAsync();
    },

    _notifyResourceAdded: function(event)
    {
        var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (event.data);
        this._postNotification(WebInspector.extensionAPI.Events.ResourceAdded, this._makeResource(uiSourceCode));
    },

    _notifyUISourceCodeContentCommitted: function(event)
    {
        var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (event.data.uiSourceCode);
        var content = /** @type {string} */ (event.data.content);
        this._postNotification(WebInspector.extensionAPI.Events.ResourceContentCommitted, this._makeResource(uiSourceCode), content);
    },

    _notifyRequestFinished: function(event)
    {
        var request = /** @type {!WebInspector.NetworkRequest} */ (event.data);
        this._postNotification(WebInspector.extensionAPI.Events.NetworkRequestFinished, this._requestId(request), (new WebInspector.HAREntry(request)).build());
    },

    _notifyElementsSelectionChanged: function()
    {
        this._postNotification(WebInspector.extensionAPI.Events.PanelObjectSelected + "elements");
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _addExtensions: function(event)
    {
        if (WebInspector.extensionServer._overridePlatformExtensionAPIForTest)
            window.buildPlatformExtensionAPI = WebInspector.extensionServer._overridePlatformExtensionAPIForTest;

        var extensionInfos = /** @type {!Array.<!ExtensionDescriptor>} */ (event.data);
        if (this._initializeCommandIssued)
            extensionInfos.forEach(this._addExtension, this);
        else
            this._pendingExtensionInfos = extensionInfos;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _setInspectedTabId: function(event)
    {
        this._inspectedTabId = /** @type {string} */ (event.data);
    },

    /**
     * @param {!ExtensionDescriptor} extensionInfo
     * @suppressGlobalPropertiesCheck
     */
    _addExtension: function(extensionInfo)
    {
        const urlOriginRegExp = new RegExp("([^:]+:\/\/[^/]*)\/"); // Can't use regexp literal here, MinJS chokes on it.
        var startPage = extensionInfo.startPage;
        var name = extensionInfo.name;

        try {
            var originMatch = urlOriginRegExp.exec(startPage);
            if (!originMatch) {
                console.error("Skipping extension with invalid URL: " + startPage);
                return false;
            }
            var extensionOrigin = originMatch[1];
            if (!this._registeredExtensions[extensionOrigin]) {
                // See ExtensionAPI.js for details.
                InspectorFrontendHost.setInjectedScriptForOrigin(extensionOrigin, buildExtensionAPIInjectedScript(extensionInfo, this._inspectedTabId));
                this._registeredExtensions[extensionOrigin] = { name: name };
            }
            var iframe = createElement("iframe");
            iframe.src = startPage;
            iframe.style.display = "none";
            document.body.appendChild(iframe);  // Only for main window.
        } catch (e) {
            console.error("Failed to initialize extension " + startPage + ":" + e);
            return false;
        }
        return true;
    },

    _registerExtension: function(origin, port)
    {
        if (!this._registeredExtensions.hasOwnProperty(origin)) {
            if (origin !== window.location.origin) // Just ignore inspector frames.
                console.error("Ignoring unauthorized client request from " + origin);
            return;
        }
        port._extensionOrigin = origin;
        port.addEventListener("message", this._onmessage.bind(this), false);
        port.start();
    },

    _onWindowMessage: function(event)
    {
        if (event.data === "registerExtension")
            this._registerExtension(event.origin, event.ports[0]);
    },

    _onmessage: function(event)
    {
        var message = event.data;
        var result;

        if (message.command in this._handlers)
            result = this._handlers[message.command](message, event.target);
        else
            result = this._status.E_NOTSUPPORTED(message.command);

        if (result && message.requestId)
            this._dispatchCallback(message.requestId, event.target, result);
    },

    _registerHandler: function(command, callback)
    {
        console.assert(command);
        this._handlers[command] = callback;
    },

    _registerSubscriptionHandler: function(eventTopic, onSubscribeFirst, onUnsubscribeLast)
    {
        this._subscriptionStartHandlers[eventTopic] = onSubscribeFirst;
        this._subscriptionStopHandlers[eventTopic] = onUnsubscribeLast;
    },

    /**
     * @param {string} eventTopic
     * @param {!Object} eventTarget
     * @param {string} frontendEventType
     * @param {function(!WebInspector.Event)} handler
     */
    _registerAutosubscriptionHandler: function(eventTopic, eventTarget, frontendEventType, handler)
    {
        this._registerSubscriptionHandler(eventTopic,
            eventTarget.addEventListener.bind(eventTarget, frontendEventType, handler, this),
            eventTarget.removeEventListener.bind(eventTarget, frontendEventType, handler, this));
    },

    /**
     * @param {string} eventTopic
     * @param {!Function} modelClass
     * @param {string} frontendEventType
     * @param {function(!WebInspector.Event)} handler
     */
    _registerAutosubscriptionTargetManagerHandler: function(eventTopic, modelClass, frontendEventType, handler)
    {
        this._registerSubscriptionHandler(eventTopic,
            WebInspector.targetManager.addModelListener.bind(WebInspector.targetManager, modelClass, frontendEventType, handler, this),
            WebInspector.targetManager.removeModelListener.bind(WebInspector.targetManager, modelClass, frontendEventType, handler, this));
    },

    _registerResourceContentCommittedHandler: function(handler)
    {
        /**
         * @this {WebInspector.ExtensionServer}
         */
        function addFirstEventListener()
        {
            WebInspector.workspace.addEventListener(WebInspector.Workspace.Events.WorkingCopyCommittedByUser, handler, this);
            WebInspector.workspace.setHasResourceContentTrackingExtensions(true);
        }

        /**
         * @this {WebInspector.ExtensionServer}
         */
        function removeLastEventListener()
        {
            WebInspector.workspace.setHasResourceContentTrackingExtensions(false);
            WebInspector.workspace.removeEventListener(WebInspector.Workspace.Events.WorkingCopyCommittedByUser, handler, this);
        }

        this._registerSubscriptionHandler(WebInspector.extensionAPI.Events.ResourceContentCommitted,
            addFirstEventListener.bind(this),
            removeLastEventListener.bind(this));
    },

    _expandResourcePath: function(extensionPath, resourcePath)
    {
        if (!resourcePath)
            return;
        return extensionPath + this._normalizePath(resourcePath);
    },

    _normalizePath: function(path)
    {
        var source = path.split("/");
        var result = [];

        for (var i = 0; i < source.length; ++i) {
            if (source[i] === ".")
                continue;
            // Ignore empty path components resulting from //, as well as a leading and traling slashes.
            if (source[i] === "")
                continue;
            if (source[i] === "..")
                result.pop();
            else
                result.push(source[i]);
        }
        return "/" + result.join("/");
    },

    /**
     * @param {string} expression
     * @param {boolean} exposeCommandLineAPI
     * @param {boolean} returnByValue
     * @param {?Object} options
     * @param {string} securityOrigin
     * @param {function(?string, ?WebInspector.RemoteObject, boolean=)} callback
     * @return {!WebInspector.ExtensionStatus.Record|undefined}
     */
    evaluate: function(expression, exposeCommandLineAPI, returnByValue, options, securityOrigin, callback)
    {
        var contextId;

        /**
         * @param {string} url
         * @return {boolean}
         */
        function resolveURLToFrame(url)
        {
            var found;
            function hasMatchingURL(frame)
            {
                found = (frame.url === url) ? frame : null;
                return found;
            }
            WebInspector.ResourceTreeModel.frames().some(hasMatchingURL);
            return found;
        }

        if (typeof options === "object") {
            var frame = options.frameURL ? resolveURLToFrame(options.frameURL) : WebInspector.targetManager.mainTarget().resourceTreeModel.mainFrame;
            if (!frame) {
                if (options.frameURL)
                    console.warn("evaluate: there is no frame with URL " + options.frameURL);
                else
                    console.warn("evaluate: the main frame is not yet available");
                return this._status.E_NOTFOUND(options.frameURL || "<top>");
            }

            var contextSecurityOrigin;
            if (options.useContentScriptContext)
                contextSecurityOrigin = securityOrigin;
            else if (options.scriptExecutionContext)
                contextSecurityOrigin = options.scriptExecutionContext;

            var context;
            var executionContexts = frame.target().runtimeModel.executionContexts();
            if (contextSecurityOrigin) {
                for (var i = 0; i < executionContexts.length; ++i) {
                    var executionContext = executionContexts[i];
                    if (executionContext.frameId === frame.id && executionContext.origin === contextSecurityOrigin && !executionContext.isMainWorldContext)
                        context = executionContext;

                }
                if (!context) {
                    console.warn("The JavaScript context " + contextSecurityOrigin + " was not found in the frame " + frame.url)
                    return this._status.E_NOTFOUND(contextSecurityOrigin)
                }
            } else {
                for (var i = 0; i < executionContexts.length; ++i) {
                    var executionContext = executionContexts[i];
                    if (executionContext.frameId === frame.id && executionContext.isMainWorldContext)
                        context = executionContext;

                }
                if (!context)
                    return this._status.E_FAILED(frame.url + " has no execution context");
            }

            contextId = context.id;
        }
        var target = target ? target : WebInspector.targetManager.mainTarget();
        if (!target)
            return;

        target.runtimeAgent().evaluate(expression, "extension", exposeCommandLineAPI, true, contextId, returnByValue, false, onEvalute);

        /**
         * @param {?Protocol.Error} error
         * @param {!RuntimeAgent.RemoteObject} result
         * @param {boolean=} wasThrown
         */
        function onEvalute(error, result, wasThrown)
        {
            if (error) {
                callback(error, null, wasThrown);
                return;
            }
            callback(error, target.runtimeModel.createRemoteObject(result), wasThrown);
        }
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @constructor
 * @param {string} name
 * @param {string} title
 * @param {!WebInspector.Panel} panel
 * @implements {WebInspector.PanelDescriptor}
 */
WebInspector.ExtensionServerPanelDescriptor = function(name, title, panel)
{
    this._name = name;
    this._title = title;
    this._panel = panel;
}

WebInspector.ExtensionServerPanelDescriptor.prototype = {
    /**
     * @override
     * @return {string}
     */
    name: function()
    {
        return this._name;
    },

    /**
     * @override
     * @return {string}
     */
    title: function()
    {
        return this._title;
    },

    /**
     * @override
     * @return {!Promise.<!WebInspector.Panel>}
     */
    panel: function()
    {
        return Promise.resolve(this._panel);
    }
}

/**
 * @constructor
 */
WebInspector.ExtensionStatus = function()
{
    /**
     * @param {string} code
     * @param {string} description
     * @return {!WebInspector.ExtensionStatus.Record}
     */
    function makeStatus(code, description)
    {
        var details = Array.prototype.slice.call(arguments, 2);
        var status = { code: code, description: description, details: details };
        if (code !== "OK") {
            status.isError = true;
            console.log("Extension server error: " + String.vsprintf(description, details));
        }
        return status;
    }

    this.OK = makeStatus.bind(null, "OK", "OK");
    this.E_EXISTS = makeStatus.bind(null, "E_EXISTS", "Object already exists: %s");
    this.E_BADARG = makeStatus.bind(null, "E_BADARG", "Invalid argument %s: %s");
    this.E_BADARGTYPE = makeStatus.bind(null, "E_BADARGTYPE", "Invalid type for argument %s: got %s, expected %s");
    this.E_NOTFOUND = makeStatus.bind(null, "E_NOTFOUND", "Object not found: %s");
    this.E_NOTSUPPORTED = makeStatus.bind(null, "E_NOTSUPPORTED", "Object does not support requested operation: %s");
    this.E_PROTOCOLERROR = makeStatus.bind(null, "E_PROTOCOLERROR", "Inspector protocol error: %s");
    this.E_FAILED = makeStatus.bind(null, "E_FAILED", "Operation failed: %s");
}

/**
 * @typedef {{code: string, description: string, details: !Array.<*>}}
 */
WebInspector.ExtensionStatus.Record;

WebInspector.extensionAPI = {};
defineCommonExtensionSymbols(WebInspector.extensionAPI);

/** @type {!WebInspector.ExtensionServer} */
WebInspector.extensionServer;;/* ExtensionPanel.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @implements {WebInspector.Searchable}
 * @extends {WebInspector.Panel}
 * @param {!WebInspector.ExtensionServer} server
 * @param {string} panelName
 * @param {string} id
 * @param {string} pageURL
 */
WebInspector.ExtensionPanel = function(server, panelName, id, pageURL)
{
    WebInspector.Panel.call(this, panelName);
    this._server = server;
    this._id = id;
    this.setHideOnDetach();
    this._panelToolbar = new WebInspector.Toolbar("hidden", this.element);

    this._searchableView = new WebInspector.SearchableView(this);
    this._searchableView.show(this.element);

    var extensionView = new WebInspector.ExtensionView(server, this._id, pageURL, "extension");
    extensionView.show(this._searchableView.element);
    this.setDefaultFocusedElement(extensionView.defaultFocusedElement());
}

WebInspector.ExtensionPanel.prototype = {
    /**
     * @override
     * @return {!Element}
     */
    defaultFocusedElement: function()
    {
        return WebInspector.Widget.prototype.defaultFocusedElement.call(this);
    },

    /**
     * @param {!WebInspector.ToolbarItem} item
     */
    addToolbarItem: function(item)
    {
        this._panelToolbar.element.classList.remove("hidden");
        this._panelToolbar.appendToolbarItem(item);
    },

    /**
     * @override
     */
    searchCanceled: function()
    {
        this._server.notifySearchAction(this._id, WebInspector.extensionAPI.panels.SearchAction.CancelSearch);
        this._searchableView.updateSearchMatchesCount(0);
    },

    /**
     * @override
     * @return {!WebInspector.SearchableView}
     */
    searchableView: function()
    {
        return this._searchableView;
    },

    /**
     * @override
     * @param {!WebInspector.SearchableView.SearchConfig} searchConfig
     * @param {boolean} shouldJump
     * @param {boolean=} jumpBackwards
     */
    performSearch: function(searchConfig, shouldJump, jumpBackwards)
    {
        var query = searchConfig.query;
        this._server.notifySearchAction(this._id, WebInspector.extensionAPI.panels.SearchAction.PerformSearch, query);
    },

    /**
     * @override
     */
    jumpToNextSearchResult: function()
    {
        this._server.notifySearchAction(this._id, WebInspector.extensionAPI.panels.SearchAction.NextSearchResult);
    },

    /**
     * @override
     */
    jumpToPreviousSearchResult: function()
    {
        this._server.notifySearchAction(this._id, WebInspector.extensionAPI.panels.SearchAction.PreviousSearchResult);
    },

    /**
     * @override
     * @return {boolean}
     */
    supportsCaseSensitiveSearch: function()
    {
        return false;
    },

    /**
     * @override
     * @return {boolean}
     */
    supportsRegexSearch: function()
    {
        return false;
    },

    __proto__: WebInspector.Panel.prototype
}

/**
 * @constructor
 * @param {!WebInspector.ExtensionServer} server
 * @param {string} id
 * @param {string} iconURL
 * @param {string=} tooltip
 * @param {boolean=} disabled
 */
WebInspector.ExtensionButton = function(server, id, iconURL, tooltip, disabled)
{
    this._id = id;

    this._toolbarButton = new WebInspector.ToolbarButton("", "");
    this._toolbarButton.addEventListener("click", server.notifyButtonClicked.bind(server, this._id));
    this.update(iconURL, tooltip, disabled);
}

WebInspector.ExtensionButton.prototype = {
    /**
     * @param {string} iconURL
     * @param {string=} tooltip
     * @param {boolean=} disabled
     */
    update: function(iconURL, tooltip, disabled)
    {
        if (typeof iconURL === "string")
            this._toolbarButton.setBackgroundImage(iconURL);
        if (typeof tooltip === "string")
            this._toolbarButton.setTitle(tooltip);
        if (typeof disabled === "boolean")
            this._toolbarButton.setEnabled(!disabled);
    },

    /**
     * @return {!WebInspector.ToolbarButton}
     */
    toolbarButton: function()
    {
        return this._toolbarButton;
    }
}

/**
 * @constructor
 * @extends {WebInspector.SidebarPane}
 * @param {!WebInspector.ExtensionServer} server
 * @param {string} panelName
 * @param {string} title
 * @param {string} id
 */
WebInspector.ExtensionSidebarPane = function(server, panelName, title, id)
{
    WebInspector.SidebarPane.call(this, title);
    this._panelName = panelName;
    this._server = server;
    this._id = id;
}

WebInspector.ExtensionSidebarPane.prototype = {
    /**
     * @return {string}
     */
    id: function()
    {
        return this._id;
    },

    /**
     * @return {string}
     */
    panelName: function()
    {
        return this._panelName;
    },

    /**
     * @param {!Object} object
     * @param {string} title
     * @param {function(?string=)} callback
     */
    setObject: function(object, title, callback)
    {
        this._createObjectPropertiesView();
        this._setObject(WebInspector.RemoteObject.fromLocalObject(object), title, callback);
    },

    /**
     * @param {string} expression
     * @param {string} title
     * @param {!Object} evaluateOptions
     * @param {string} securityOrigin
     * @param {function(?string=)} callback
     */
    setExpression: function(expression, title, evaluateOptions, securityOrigin, callback)
    {
        this._createObjectPropertiesView();
        this._server.evaluate(expression, true, false, evaluateOptions, securityOrigin, this._onEvaluate.bind(this, title, callback));
    },

    /**
     * @param {string} url
     */
    setPage: function(url)
    {
        if (this._objectPropertiesView) {
            this._objectPropertiesView.detach();
            delete this._objectPropertiesView;
        }
        if (this._extensionView)
            this._extensionView.detach(true);

        this._extensionView = new WebInspector.ExtensionView(this._server, this._id, url, "extension fill");
        this._extensionView.show(this.element);

        if (!this.element.style.height)
            this.setHeight("150px");
    },

    /**
     * @param {string} height
     */
    setHeight: function(height)
    {
        this.element.style.height = height;
    },

    /**
     * @param {string} title
     * @param {function(?string=)} callback
     * @param {?Protocol.Error} error
     * @param {?WebInspector.RemoteObject} result
     * @param {boolean=} wasThrown
     */
    _onEvaluate: function(title, callback, error, result, wasThrown)
    {
        if (error)
            callback(error.toString());
        else
            this._setObject(/** @type {!WebInspector.RemoteObject} */ (result), title, callback);
    },

    _createObjectPropertiesView: function()
    {
        if (this._objectPropertiesView)
            return;
        if (this._extensionView) {
            this._extensionView.detach(true);
            delete this._extensionView;
        }
        this._objectPropertiesView = new WebInspector.ExtensionNotifierView(this._server, this._id);
        this._objectPropertiesView.show(this.element);
    },

    /**
     * @param {!WebInspector.RemoteObject} object
     * @param {string} title
     * @param {function(?string=)} callback
     */
    _setObject: function(object, title, callback)
    {
        // This may only happen if setPage() was called while we were evaluating the expression.
        if (!this._objectPropertiesView) {
            callback("operation cancelled");
            return;
        }
        this._objectPropertiesView.element.removeChildren();
        var section = new WebInspector.ObjectPropertiesSection(object, title);
        if (!title)
            section.titleLessMode();
        section.expand();
        section.editable = false;
        this._objectPropertiesView.element.appendChild(section.element);
        callback();
    },

    __proto__: WebInspector.SidebarPane.prototype
}
;/* ExtensionView.js */
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.Widget}
 * @param {!WebInspector.ExtensionServer} server
 * @param {string} id
 * @param {string} src
 * @param {string} className
 */
WebInspector.ExtensionView = function(server, id, src, className)
{
    WebInspector.Widget.call(this);
    this.setHideOnDetach();
    this.element.className = "vbox flex-auto"; // Override

    this._server = server;
    this._id = id;
    this._iframe = createElement("iframe");
    this._iframe.addEventListener("load", this._onLoad.bind(this), false);
    this._iframe.src = src;
    this._iframe.className = className;
    this.setDefaultFocusedElement(this._iframe);

    this.element.appendChild(this._iframe);
}

WebInspector.ExtensionView.prototype = {
    wasShown: function()
    {
        if (typeof this._frameIndex === "number")
            this._server.notifyViewShown(this._id, this._frameIndex);
    },

    willHide: function()
    {
        if (typeof this._frameIndex === "number")
            this._server.notifyViewHidden(this._id);
    },

    _onLoad: function()
    {
        var frames = /** @type {!Array.<!Window>} */ (window.frames);
        this._frameIndex = Array.prototype.indexOf.call(frames, this._iframe.contentWindow);
        if (this.isShowing())
            this._server.notifyViewShown(this._id, this._frameIndex);
    },

    __proto__: WebInspector.Widget.prototype
}

/**
 * @constructor
 * @extends {WebInspector.VBox}
 * @param {!WebInspector.ExtensionServer} server
 * @param {string} id
 */
WebInspector.ExtensionNotifierView = function(server, id)
{
    WebInspector.VBox.call(this);

    this._server = server;
    this._id = id;
}

WebInspector.ExtensionNotifierView.prototype = {
    wasShown: function()
    {
        this._server.notifyViewShown(this._id);
    },

    willHide: function()
    {
        this._server.notifyViewHidden(this._id);
    },

    __proto__: WebInspector.VBox.prototype
}
;
/* Module emulation */
/* AdvancedApp.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @implements {WebInspector.App}
 */
WebInspector.AdvancedApp = function()
{
    WebInspector.dockController.addEventListener(WebInspector.DockController.Events.BeforeDockSideChanged, this._openToolboxWindow, this);
};

WebInspector.AdvancedApp.prototype = {
    /**
     * @override
     * @param {!Document} document
     */
    presentUI: function(document)
    {
        var rootView = new WebInspector.RootView();

        this._rootSplitWidget = new WebInspector.SplitWidget(false, true, "InspectorView.splitViewState", 555, 300, true);
        this._rootSplitWidget.show(rootView.element);

        this._rootSplitWidget.setSidebarWidget(WebInspector.inspectorView);

        this._inspectedPagePlaceholder = new WebInspector.InspectedPagePlaceholder();
        this._inspectedPagePlaceholder.addEventListener(WebInspector.InspectedPagePlaceholder.Events.Update, this._onSetInspectedPageBounds.bind(this), this);
        this._deviceModeView = new WebInspector.DeviceModeWrapper(this._inspectedPagePlaceholder);

        WebInspector.dockController.addEventListener(WebInspector.DockController.Events.BeforeDockSideChanged, this._onBeforeDockSideChange, this);
        WebInspector.dockController.addEventListener(WebInspector.DockController.Events.DockSideChanged, this._onDockSideChange, this);
        WebInspector.dockController.addEventListener(WebInspector.DockController.Events.AfterDockSideChanged, this._onAfterDockSideChange, this);
        this._onDockSideChange();

        WebInspector.inspectorView.showInitialPanel();
        console.timeStamp("AdvancedApp.attachToBody");
        rootView.attachToDocument(document);
        this._inspectedPagePlaceholder.update();
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _openToolboxWindow: function(event)
    {
        if (/** @type {string} */ (event.data.to) !== WebInspector.DockController.State.Undocked)
            return;

        if (this._toolboxWindow)
            return;

        var url = window.location.href.replace("inspector.html", "toolbox.html");
        this._toolboxWindow = window.open(url, undefined);
    },

    /**
     * @param {!Document} toolboxDocument
     */
    toolboxLoaded: function(toolboxDocument)
    {
        WebInspector.initializeUIUtils(toolboxDocument, WebInspector.settings.createSetting("uiTheme", "default"));
        WebInspector.installComponentRootStyles(/** @type {!Element} */ (toolboxDocument.body));
        WebInspector.ContextMenu.installHandler(toolboxDocument);
        WebInspector.Tooltip.installHandler(toolboxDocument);

        this._toolboxRootView = new WebInspector.RootView();
        this._toolboxRootView.attachToDocument(toolboxDocument);

        this._updateDeviceModeView();
    },

    _updateDeviceModeView: function()
    {
        if (this._isDocked())
            this._rootSplitWidget.setMainWidget(this._deviceModeView);
        else if (this._toolboxRootView)
            this._deviceModeView.show(this._toolboxRootView.element);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onBeforeDockSideChange: function(event)
    {
        if (/** @type {string} */ (event.data.to) === WebInspector.DockController.State.Undocked && this._toolboxRootView) {
            // Hide inspectorView and force layout to mimic the undocked state.
            this._rootSplitWidget.hideSidebar();
            this._inspectedPagePlaceholder.update();
        }

        this._changingDockSide = true;
    },

    /**
     * @param {!WebInspector.Event=} event
     */
    _onDockSideChange: function(event)
    {
        this._updateDeviceModeView();

        var toDockSide = event ? /** @type {string} */ (event.data.to) : WebInspector.dockController.dockSide();
        if (toDockSide === WebInspector.DockController.State.Undocked) {
            this._updateForUndocked();
        } else if (this._toolboxRootView && event && /** @type {string} */ (event.data.from) === WebInspector.DockController.State.Undocked) {
            // Don't update yet for smooth transition.
            this._rootSplitWidget.hideSidebar();
        } else {
            this._updateForDocked(toDockSide);
        }
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onAfterDockSideChange: function(event)
    {
        // We may get here on the first dock side change while loading without BeforeDockSideChange.
        if (!this._changingDockSide)
            return;
        if (/** @type {string} */ (event.data.from) === WebInspector.DockController.State.Undocked) {
            // Restore docked layout in case of smooth transition.
            this._updateForDocked(/** @type {string} */ (event.data.to));
        }
        this._changingDockSide = false;
        this._inspectedPagePlaceholder.update();
    },

    /**
     * @param {string} dockSide
     */
    _updateForDocked: function(dockSide)
    {
        this._rootSplitWidget.setVertical(dockSide === WebInspector.DockController.State.DockedToRight);
        this._rootSplitWidget.setSecondIsSidebar(dockSide === WebInspector.DockController.State.DockedToRight || dockSide === WebInspector.DockController.State.DockedToBottom);
        this._rootSplitWidget.toggleResizer(this._rootSplitWidget.resizerElement(), true);
        this._rootSplitWidget.toggleResizer(WebInspector.inspectorView.topResizerElement(), dockSide === WebInspector.DockController.State.DockedToBottom);
        this._rootSplitWidget.showBoth();
    },

    _updateForUndocked: function()
    {
        this._rootSplitWidget.toggleResizer(this._rootSplitWidget.resizerElement(), false);
        this._rootSplitWidget.toggleResizer(WebInspector.inspectorView.topResizerElement(), false);
        this._rootSplitWidget.hideMain();
    },

    _isDocked: function()
    {
        return WebInspector.dockController.dockSide() !== WebInspector.DockController.State.Undocked;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onSetInspectedPageBounds: function(event)
    {
        if (this._changingDockSide)
            return;
        var window = this._inspectedPagePlaceholder.element.window();
        if (!window.innerWidth || !window.innerHeight)
            return;
        if (!this._inspectedPagePlaceholder.isShowing())
            return;
        var bounds = /** @type {{x: number, y: number, width: number, height: number}} */ (event.data);
        console.timeStamp("AdvancedApp.setInspectedPageBounds");
        InspectorFrontendHost.setInspectedPageBounds(bounds);
    }
};

/** @type {!WebInspector.AdvancedApp} */
WebInspector.AdvancedApp._appInstance;

/**
 * @return {!WebInspector.AdvancedApp}
 */
WebInspector.AdvancedApp._instance = function()
{
    if (!WebInspector.AdvancedApp._appInstance)
        WebInspector.AdvancedApp._appInstance = new WebInspector.AdvancedApp();
    return WebInspector.AdvancedApp._appInstance;
};

/**
 * @constructor
 * @implements {WebInspector.AppProvider}
 */
WebInspector.AdvancedAppProvider = function()
{
};

WebInspector.AdvancedAppProvider.prototype = {
    /**
     * @override
     * @return {!WebInspector.App}
     */
    createApp: function()
    {
        return WebInspector.AdvancedApp._instance();
    }
};
;/* EmulatedDevices.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 */
WebInspector.EmulatedDevice = function()
{
    /** @type {string} */
    this.title = "";
    /** @type {string} */
    this.type = WebInspector.EmulatedDevice.Type.Unknown;
    /** @type {!WebInspector.EmulatedDevice.Orientation} */
    this.vertical = {width: 0, height: 0, outlineInsets: null, outlineImage: null};
    /** @type {!WebInspector.EmulatedDevice.Orientation} */
    this.horizontal = {width: 0, height: 0, outlineInsets: null, outlineImage: null};
    /** @type {number} */
    this.deviceScaleFactor = 1;
    /** @type {!Array.<string>} */
    this.capabilities = [WebInspector.EmulatedDevice.Capability.Touch, WebInspector.EmulatedDevice.Capability.Mobile];
    /** @type {string} */
    this.userAgent = "";
    /** @type {!Array.<!WebInspector.EmulatedDevice.Mode>} */
    this.modes = [];

    /** @type {string} */
    this._show = WebInspector.EmulatedDevice._Show.Default;
    /** @type {boolean} */
    this._showByDefault = true;

    /** @type {?Runtime.Extension} */
    this._extension = null;
}

/** @typedef {!{title: string, orientation: string, insets: !Insets, image: ?string}} */
WebInspector.EmulatedDevice.Mode;

/** @typedef {!{width: number, height: number, outlineInsets: ?Insets, outlineImage: ?string}} */
WebInspector.EmulatedDevice.Orientation;

WebInspector.EmulatedDevice.Horizontal = "horizontal";
WebInspector.EmulatedDevice.Vertical = "vertical";

WebInspector.EmulatedDevice.Type = {
    Phone: "phone",
    Tablet: "tablet",
    Notebook: "notebook",
    Desktop: "desktop",
    Unknown: "unknown"
}

WebInspector.EmulatedDevice.Capability = {
    Touch: "touch",
    Mobile: "mobile"
}

WebInspector.EmulatedDevice._Show = {
    Always: "Always",
    Default: "Default",
    Never: "Never"
}

/**
 * @param {*} json
 * @return {?WebInspector.EmulatedDevice}
 */
WebInspector.EmulatedDevice.fromJSONV1 = function(json)
{
    try {
        /**
         * @param {*} object
         * @param {string} key
         * @param {string} type
         * @param {*=} defaultValue
         * @return {*}
         */
        function parseValue(object, key, type, defaultValue)
        {
            if (typeof object !== "object" || object === null || !object.hasOwnProperty(key)) {
                if (typeof defaultValue !== "undefined")
                    return defaultValue;
                throw new Error("Emulated device is missing required property '" + key + "'");
            }
            var value = object[key];
            if (typeof value !== type || value === null)
                throw new Error("Emulated device property '" + key + "' has wrong type '" + typeof value + "'");
            return value;
        }

        /**
         * @param {*} object
         * @param {string} key
         * @return {number}
         */
        function parseIntValue(object, key)
        {
            var value = /** @type {number} */ (parseValue(object, key, "number"));
            if (value !== Math.abs(value))
                throw new Error("Emulated device value '" + key + "' must be integer");
            return value;
        }

        /**
         * @param {*} json
         * @return {!Insets}
         */
        function parseInsets(json)
        {
            return new Insets(parseIntValue(json, "left"), parseIntValue(json, "top"), parseIntValue(json, "right"), parseIntValue(json, "bottom"));
        }

        /**
         * @param {*} json
         * @return {!WebInspector.EmulatedDevice.Orientation}
         */
        function parseOrientation(json)
        {
            var result = {};

            result.width = parseIntValue(json, "width");
            if (result.width < 0 || result.width > WebInspector.DeviceModeModel.MaxDeviceSize || result.width < WebInspector.DeviceModeModel.MinDeviceSize)
                throw new Error("Emulated device has wrong width: " + result.width);

            result.height = parseIntValue(json, "height");
            if (result.height < 0 || result.height > WebInspector.DeviceModeModel.MaxDeviceSize || result.height < WebInspector.DeviceModeModel.MinDeviceSize)
                throw new Error("Emulated device has wrong height: " + result.height);

            var outlineInsets = parseValue(json["outline"], "insets", "object", null);
            if (outlineInsets) {
                result.outlineInsets = parseInsets(outlineInsets);
                if (result.outlineInsets.left < 0 || result.outlineInsets.top < 0)
                    throw new Error("Emulated device has wrong outline insets");
                result.outlineImage = /** @type {string} */ (parseValue(json["outline"], "image", "string"));
            }

            return /** @type {!WebInspector.EmulatedDevice.Orientation} */ (result);
        }

        var result = new WebInspector.EmulatedDevice();
        result.title = /** @type {string} */ (parseValue(json, "title", "string"));
        result.type = /** @type {string} */ (parseValue(json, "type", "string"));
        result.userAgent = /** @type {string} */ (parseValue(json, "user-agent", "string"));

        var capabilities = parseValue(json, "capabilities", "object", []);
        if (!Array.isArray(capabilities))
            throw new Error("Emulated device capabilities must be an array");
        result.capabilities = [];
        for (var i = 0; i < capabilities.length; ++i) {
            if (typeof capabilities[i] !== "string")
                throw new Error("Emulated device capability must be a string");
            result.capabilities.push(capabilities[i]);
        }

        result.deviceScaleFactor = /** @type {number} */ (parseValue(json["screen"], "device-pixel-ratio", "number"));
        if (result.deviceScaleFactor < 0 || result.deviceScaleFactor > 100)
            throw new Error("Emulated device has wrong deviceScaleFactor: " + result.deviceScaleFactor);

        result.vertical = parseOrientation(parseValue(json["screen"], "vertical", "object"));
        result.horizontal = parseOrientation(parseValue(json["screen"], "horizontal", "object"));

        var modes = parseValue(json, "modes", "object", []);
        if (!Array.isArray(modes))
            throw new Error("Emulated device modes must be an array");
        result.modes = [];
        for (var i = 0; i < modes.length; ++i) {
            var mode = {};
            mode.title = /** @type {string} */ (parseValue(modes[i], "title", "string"));
            mode.orientation = /** @type {string} */ (parseValue(modes[i], "orientation", "string"));
            if (mode.orientation !== WebInspector.EmulatedDevice.Vertical && mode.orientation !== WebInspector.EmulatedDevice.Horizontal)
                throw new Error("Emulated device mode has wrong orientation '" + mode.orientation + "'");
            var orientation = result.orientationByName(mode.orientation);
            mode.insets = parseInsets(parseValue(modes[i], "insets", "object"));
            if (mode.insets.top < 0 || mode.insets.left < 0 || mode.insets.right < 0 || mode.insets.bottom < 0 ||
                mode.insets.top + mode.insets.bottom > orientation.height || mode.insets.left + mode.insets.right > orientation.width) {
                throw new Error("Emulated device mode '" + mode.title + "'has wrong mode insets");
            }
            mode.image = /** @type {string} */ (parseValue(modes[i], "image", "string", null));
            result.modes.push(mode);
        }

        result._showByDefault = /** @type {boolean} */ (parseValue(json, "show-by-default", "boolean", undefined));
        result._show = /** @type {string} */ (parseValue(json, "show", "string", WebInspector.EmulatedDevice._Show.Default));

        return result;
    } catch (e) {
        return null;
    }
}

/**
 * @param {!WebInspector.EmulatedDevice} device1
 * @param {!WebInspector.EmulatedDevice} device2
 * @return {number}
 */
WebInspector.EmulatedDevice.deviceComparator = function(device1, device2)
{
    var order1 = (device1._extension && device1._extension.descriptor()["order"]) || -1;
    var order2 = (device2._extension && device2._extension.descriptor()["order"]) || -1;
    if (order1 > order2)
        return 1;
    if (order2 > order1)
        return -1;
    return device1.title < device2.title ? -1 : (device1.title > device2.title ? 1 : 0);
}

WebInspector.EmulatedDevice.prototype = {
    /**
     * @return {?Runtime.Extension}
     */
    extension: function()
    {
        return this._extension;
    },

    /**
     * @param {?Runtime.Extension} extension
     */
    setExtension: function(extension)
    {
        this._extension = extension;
    },

    /**
     * @param {string} orientation
     * @return {!Array.<!WebInspector.EmulatedDevice.Mode>}
     */
    modesForOrientation: function(orientation)
    {
        var result = [];
        for (var index = 0; index < this.modes.length; index++) {
            if (this.modes[index].orientation === orientation)
                result.push(this.modes[index]);
        }
        return result;
    },

    /**
     * @return {*}
     */
    _toJSON: function()
    {
        var json = {};
        json["title"] = this.title;
        json["type"] = this.type;
        json["user-agent"] = this.userAgent;
        json["capabilities"] = this.capabilities;

        json["screen"] = {};
        json["screen"]["device-pixel-ratio"] = this.deviceScaleFactor;
        json["screen"]["vertical"] = this._orientationToJSON(this.vertical);
        json["screen"]["horizontal"] = this._orientationToJSON(this.horizontal);

        json["modes"] = [];
        for (var i = 0; i < this.modes.length; ++i) {
            var mode = {};
            mode["title"] = this.modes[i].title;
            mode["orientation"] = this.modes[i].orientation;
            mode["insets"] = {};
            mode["insets"]["left"] = this.modes[i].insets.left;
            mode["insets"]["top"] = this.modes[i].insets.top;
            mode["insets"]["right"] = this.modes[i].insets.right;
            mode["insets"]["bottom"] = this.modes[i].insets.bottom;
            if (this.modes[i].image)
                mode["image"] = this.modes[i].image;
            json["modes"].push(mode);
        }

        json["show-by-default"] = this._showByDefault;
        json["show"] = this._show;

        return json;
    },

    /**
     * @param {!WebInspector.EmulatedDevice.Orientation} orientation
     * @return {*}
     */
    _orientationToJSON: function(orientation)
    {
        var json = {};
        json["width"] = orientation.width;
        json["height"] = orientation.height;
        if (orientation.outlineInsets) {
            json["outline"] = {};
            json["outline"]["insets"] = {};
            json["outline"]["insets"]["left"] = orientation.outlineInsets.left;
            json["outline"]["insets"]["top"] = orientation.outlineInsets.top;
            json["outline"]["insets"]["right"] = orientation.outlineInsets.right;
            json["outline"]["insets"]["bottom"] = orientation.outlineInsets.bottom;
            json["outline"]["image"] = orientation.outlineImage;
        }
        return json;
    },

    /**
     * @param {!WebInspector.EmulatedDevice.Mode} mode
     * @return {string}
     */
    modeImage: function(mode)
    {
        if (!mode.image)
            return "";
        if (!this._extension)
            return mode.image;
        return this._extension.module().substituteURL(mode.image);
    },

    /**
     * @param {string} name
     * @return {!WebInspector.EmulatedDevice.Orientation}
     */
    orientationByName: function(name)
    {
        return name === WebInspector.EmulatedDevice.Vertical ? this.vertical : this.horizontal;
    },

    /**
     * @return {boolean}
     */
    show: function()
    {
        if (this._show === WebInspector.EmulatedDevice._Show.Default)
            return this._showByDefault;
        return this._show === WebInspector.EmulatedDevice._Show.Always;
    },

    /**
     * @param {boolean} show
     */
    setShow: function(show)
    {
        this._show = show ? WebInspector.EmulatedDevice._Show.Always : WebInspector.EmulatedDevice._Show.Never;
    },

    /**
     * @param {!WebInspector.EmulatedDevice} other
     */
    copyShowFrom: function(other)
    {
        this._show = other._show;
    },

    /**
     * @return {boolean}
     */
    touch: function()
    {
        return this.capabilities.indexOf(WebInspector.EmulatedDevice.Capability.Touch) !== -1;
    },

    /**
     * @return {boolean}
     */
    mobile: function()
    {
        return this.capabilities.indexOf(WebInspector.EmulatedDevice.Capability.Mobile) !== -1;
    }
}


/**
 * @constructor
 * @extends {WebInspector.Object}
 */
WebInspector.EmulatedDevicesList = function()
{
    WebInspector.Object.call(this);

    /** @type {!WebInspector.Setting} */
    this._standardSetting = WebInspector.settings.createSetting("standardEmulatedDeviceList", []);
    /** @type {!Array.<!WebInspector.EmulatedDevice>} */
    this._standard = [];
    this._listFromJSONV1(this._standardSetting.get(), this._standard);
    this._updateStandardDevices();

    /** @type {!WebInspector.Setting} */
    this._customSetting = WebInspector.settings.createSetting("customEmulatedDeviceList", []);
    /** @type {!Array.<!WebInspector.EmulatedDevice>} */
    this._custom = [];
    if (!this._listFromJSONV1(this._customSetting.get(), this._custom))
        this.saveCustomDevices();
}

WebInspector.EmulatedDevicesList.Events = {
    CustomDevicesUpdated: "CustomDevicesUpdated",
    StandardDevicesUpdated: "StandardDevicesUpdated"
}

WebInspector.EmulatedDevicesList.prototype = {
    _updateStandardDevices: function()
    {
        var devices = [];
        var extensions = self.runtime.extensions("emulated-device");
        for (var i = 0; i < extensions.length; ++i) {
            var device = WebInspector.EmulatedDevice.fromJSONV1(extensions[i].descriptor()["device"]);
            device.setExtension(extensions[i]);
            devices.push(device);
        }
        this._copyShowValues(this._standard, devices);
        this._standard = devices;
        this.saveStandardDevices();
    },

    /**
     * @param {!Array.<*>} jsonArray
     * @param {!Array.<!WebInspector.EmulatedDevice>} result
     * @return {boolean}
     */
    _listFromJSONV1: function(jsonArray, result)
    {
        if (!Array.isArray(jsonArray))
            return false;
        var success = true;
        for (var i = 0; i < jsonArray.length; ++i) {
            var device = WebInspector.EmulatedDevice.fromJSONV1(jsonArray[i]);
            if (device) {
                result.push(device);
                if (!device.modes.length) {
                    device.modes.push({title: "", orientation: WebInspector.EmulatedDevice.Horizontal, insets: new Insets(0, 0, 0, 0), image: null});
                    device.modes.push({title: "", orientation: WebInspector.EmulatedDevice.Vertical, insets: new Insets(0, 0, 0, 0), image: null});
                }
            } else {
                success = false;
            }
        }
        return success;
    },

    /**
     * @return {!Array.<!WebInspector.EmulatedDevice>}
     */
    standard: function()
    {
        return this._standard;
    },

    /**
     * @return {!Array.<!WebInspector.EmulatedDevice>}
     */
    custom: function()
    {
        return this._custom;
    },

    revealCustomSetting: function()
    {
        WebInspector.Revealer.reveal(this._customSetting);
    },

    /**
     * @param {!WebInspector.EmulatedDevice} device
     */
    addCustomDevice: function(device)
    {
        this._custom.push(device);
        this.saveCustomDevices();
    },

    /**
     * @param {!WebInspector.EmulatedDevice} device
     */
    removeCustomDevice: function(device)
    {
        this._custom.remove(device);
        this.saveCustomDevices();
    },

    saveCustomDevices: function()
    {
        var json = this._custom.map(/** @param {!WebInspector.EmulatedDevice} device */ function(device) { return device._toJSON(); });
        this._customSetting.set(json);
        this.dispatchEventToListeners(WebInspector.EmulatedDevicesList.Events.CustomDevicesUpdated);
    },

    saveStandardDevices: function()
    {
        var json = this._standard.map(/** @param {!WebInspector.EmulatedDevice} device */ function(device) { return device._toJSON(); });
        this._standardSetting.set(json);
        this.dispatchEventToListeners(WebInspector.EmulatedDevicesList.Events.StandardDevicesUpdated);
    },

    /**
     * @param {!Array.<!WebInspector.EmulatedDevice>} from
     * @param {!Array.<!WebInspector.EmulatedDevice>} to
     */
    _copyShowValues: function(from, to)
    {
        var deviceById = new Map();
        for (var i = 0; i < from.length; ++i)
            deviceById.set(from[i].title, from[i]);

        for (var i = 0; i < to.length; ++i) {
            var title = to[i].title;
            if (deviceById.has(title))
                to[i].copyShowFrom(/** @type {!WebInspector.EmulatedDevice} */ (deviceById.get(title)));
        }
    },

    __proto__: WebInspector.Object.prototype
}

/** @type {?WebInspector.EmulatedDevicesList} */
WebInspector.EmulatedDevicesList._instance;

/**
 * @return {!WebInspector.EmulatedDevicesList}
 */
WebInspector.EmulatedDevicesList.instance = function()
{
    if (!WebInspector.EmulatedDevicesList._instance)
        WebInspector.EmulatedDevicesList._instance = new WebInspector.EmulatedDevicesList();
    return /** @type {!WebInspector.EmulatedDevicesList} */ (WebInspector.EmulatedDevicesList._instance);
}
;/* DevicesSettingsTab.js */
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.VBox}
 * @implements {WebInspector.ListWidget.Delegate}
 */
WebInspector.DevicesSettingsTab = function()
{
    WebInspector.VBox.call(this);
    this.element.classList.add("settings-tab-container");
    this.element.classList.add("devices-settings-tab");
    this.registerRequiredCSS("emulation/devicesSettingsTab.css");

    var header = this.element.createChild("header");
    header.createChild("h3").createTextChild(WebInspector.UIString("Emulated Devices"));
    this.containerElement = this.element.createChild("div", "help-container-wrapper").createChild("div", "settings-tab help-content help-container");

    var buttonsRow = this.containerElement.createChild("div", "devices-button-row");
    this._addCustomButton = createTextButton(WebInspector.UIString("Add custom device..."), this._addCustomDevice.bind(this));
    buttonsRow.appendChild(this._addCustomButton);

    this._list = new WebInspector.ListWidget(this);
    this._list.registerRequiredCSS("emulation/devicesSettingsTab.css");
    this._list.element.classList.add("devices-list");
    this._list.show(this.containerElement);

    this._muteUpdate = false;
    this._emulatedDevicesList = WebInspector.EmulatedDevicesList.instance();
    this._emulatedDevicesList.addEventListener(WebInspector.EmulatedDevicesList.Events.CustomDevicesUpdated, this._devicesUpdated, this);
    this._emulatedDevicesList.addEventListener(WebInspector.EmulatedDevicesList.Events.StandardDevicesUpdated, this._devicesUpdated, this);

    this.setDefaultFocusedElement(this._addCustomButton);
}

WebInspector.DevicesSettingsTab.prototype = {
    wasShown: function()
    {
        WebInspector.VBox.prototype.wasShown.call(this);
        this._devicesUpdated();
    },

    _devicesUpdated: function()
    {
        if (this._muteUpdate)
            return;

        this._list.clear();

        var devices = this._emulatedDevicesList.custom().slice();
        for (var i = 0; i < devices.length; ++i)
            this._list.appendItem(devices[i], true);

        this._list.appendSeparator();

        devices = this._emulatedDevicesList.standard().slice();
        devices.sort(WebInspector.EmulatedDevice.deviceComparator);
        for (var i = 0; i < devices.length; ++i)
            this._list.appendItem(devices[i], false);
    },

    /**
     * @param {boolean} custom
     */
    _muteAndSaveDeviceList: function(custom)
    {
        this._muteUpdate = true;
        if (custom)
            this._emulatedDevicesList.saveCustomDevices();
        else
            this._emulatedDevicesList.saveStandardDevices();
        this._muteUpdate = false;
    },

    _addCustomDevice: function()
    {
        var device = new WebInspector.EmulatedDevice();
        device.deviceScaleFactor = 0;
        device.horizontal.width = 700;
        device.horizontal.height = 400;
        device.vertical.width = 400;
        device.vertical.height = 700;
        this._list.addNewItem(this._emulatedDevicesList.custom().length, device);
    },

    /**
     * @param {number} value
     * @return {string}
     */
    _toNumericInputValue: function(value)
    {
        return value ? String(value) : "";
    },

    /**
     * @override
     * @param {*} item
     * @param {boolean} editable
     * @return {!Element}
     */
    renderItem: function(item, editable)
    {
        var device = /** @type {!WebInspector.EmulatedDevice} */ (item);
        var element = createElementWithClass("div", "devices-list-item");
        var checkbox = element.createChild("input", "devices-list-checkbox");
        checkbox.type = "checkbox";
        checkbox.checked = device.show();
        element.createChild("div", "devices-list-title").textContent = device.title;
        element.addEventListener("click", onItemClicked.bind(this), false);
        return element;

        /**
         * @param {!Event} event
         * @this {WebInspector.DevicesSettingsTab}
         */
        function onItemClicked(event)
        {
            var show = !checkbox.checked;
            device.setShow(show);
            this._muteAndSaveDeviceList(editable);
            checkbox.checked = show;
            event.consume();
        }
    },

    /**
     * @override
     * @param {*} item
     * @param {number} index
     */
    removeItemRequested: function(item, index)
    {
        this._emulatedDevicesList.removeCustomDevice(/** @type {!WebInspector.EmulatedDevice} */ (item));
    },

    /**
     * @override
     * @param {*} item
     * @param {!WebInspector.ListWidget.Editor} editor
     * @param {boolean} isNew
     */
    commitEdit: function(item, editor, isNew)
    {
        var device = /** @type {!WebInspector.EmulatedDevice} */ (item);
        device.title = editor.control("title").value.trim();
        device.vertical.width = editor.control("width").value ? parseInt(editor.control("width").value, 10) : 0;
        device.vertical.height = editor.control("height").value ? parseInt(editor.control("height").value, 10) : 0;
        device.horizontal.width = device.vertical.height;
        device.horizontal.height = device.vertical.width;
        device.deviceScaleFactor = editor.control("scale").value ? parseFloat(editor.control("scale").value) : 0;
        device.userAgent = editor.control("user-agent").value;
        device.modes = [];
        device.modes.push({title: "", orientation: WebInspector.EmulatedDevice.Vertical, insets: new Insets(0, 0, 0, 0), images: null});
        device.modes.push({title: "", orientation: WebInspector.EmulatedDevice.Horizontal, insets: new Insets(0, 0, 0, 0), images: null});
        device.capabilities = [];
        var uaType = editor.control("ua-type").value;
        if (uaType === WebInspector.DeviceModeModel.UA.Mobile || uaType === WebInspector.DeviceModeModel.UA.MobileNoTouch)
            device.capabilities.push(WebInspector.EmulatedDevice.Capability.Mobile);
        if (uaType === WebInspector.DeviceModeModel.UA.Mobile || uaType === WebInspector.DeviceModeModel.UA.DesktopTouch)
            device.capabilities.push(WebInspector.EmulatedDevice.Capability.Touch);
        if (isNew)
            this._emulatedDevicesList.addCustomDevice(device);
        else
            this._emulatedDevicesList.saveCustomDevices();
        this._addCustomButton.scrollIntoViewIfNeeded();
        this._addCustomButton.focus();
    },

    /**
     * @override
     * @param {*} item
     * @return {!WebInspector.ListWidget.Editor}
     */
    beginEdit: function(item)
    {
        var device = /** @type {!WebInspector.EmulatedDevice} */ (item);
        var editor = this._createEditor();
        editor.control("title").value = device.title;
        editor.control("width").value = this._toNumericInputValue(device.vertical.width);
        editor.control("height").value = this._toNumericInputValue(device.vertical.height);
        editor.control("scale").value = this._toNumericInputValue(device.deviceScaleFactor);
        editor.control("user-agent").value = device.userAgent;
        var uaType;
        if (device.mobile())
            uaType = device.touch() ? WebInspector.DeviceModeModel.UA.Mobile : WebInspector.DeviceModeModel.UA.MobileNoTouch;
        else
            uaType = device.touch() ? WebInspector.DeviceModeModel.UA.DesktopTouch : WebInspector.DeviceModeModel.UA.Desktop;
        editor.control("ua-type").value = uaType;
        return editor;
    },

    /**
     * @return {!WebInspector.ListWidget.Editor}
     */
    _createEditor: function()
    {
        if (this._editor)
            return this._editor;

        var editor = new WebInspector.ListWidget.Editor();
        this._editor = editor;
        var content = editor.contentElement();

        var fields = content.createChild("div", "devices-edit-fields");
        fields.createChild("div", "hbox").appendChild(editor.createInput("title", "text", WebInspector.UIString("Device name"), titleValidator));
        var screen = fields.createChild("div", "hbox");
        screen.appendChild(editor.createInput("width", "text", WebInspector.UIString("Width"), sizeValidator));
        screen.appendChild(editor.createInput("height", "text", WebInspector.UIString("height"), sizeValidator));
        var dpr = editor.createInput("scale", "text", WebInspector.UIString("Device pixel ratio"), scaleValidator);
        dpr.classList.add("device-edit-fixed");
        screen.appendChild(dpr);
        var ua = fields.createChild("div", "hbox");
        ua.appendChild(editor.createInput("user-agent", "text", WebInspector.UIString("User agent string"), () => true));
        var uaType = editor.createSelect("ua-type", [WebInspector.DeviceModeModel.UA.Mobile, WebInspector.DeviceModeModel.UA.MobileNoTouch, WebInspector.DeviceModeModel.UA.Desktop, WebInspector.DeviceModeModel.UA.DesktopTouch], () => true);
        uaType.classList.add("device-edit-fixed");
        ua.appendChild(uaType);

        return editor;

        /**
         * @param {*} item
         * @param {number} index
         * @param {!HTMLInputElement|!HTMLSelectElement} input
         * @return {boolean}
         */
        function titleValidator(item, index, input)
        {
            var value = input.value.trim();
            return value.length > 0 && value.length < 50;
        }

        /**
         * @param {*} item
         * @param {number} index
         * @param {!HTMLInputElement|!HTMLSelectElement} input
         * @return {boolean}
         */
        function sizeValidator(item, index, input)
        {
            return WebInspector.DeviceModeModel.deviceSizeValidator(input.value);
        }

        /**
         * @param {*} item
         * @param {number} index
         * @param {!HTMLInputElement|!HTMLSelectElement} input
         * @return {boolean}
         */
        function scaleValidator(item, index, input)
        {
            return WebInspector.DeviceModeModel.deviceScaleFactorValidator(input.value);
        }
    },

    __proto__: WebInspector.VBox.prototype
}
;/* DeviceOrientation.js */
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {number} alpha
 * @param {number} beta
 * @param {number} gamma
 */
WebInspector.DeviceOrientation = function(alpha, beta, gamma)
{
    this.alpha = alpha;
    this.beta = beta;
    this.gamma = gamma;
}

WebInspector.DeviceOrientation.prototype = {
    /**
     * @return {string}
     */
    toSetting: function()
    {
        return JSON.stringify(this);
    },

    apply: function()
    {
        for (var target of WebInspector.targetManager.targets(WebInspector.Target.Type.Page))
            target.deviceOrientationAgent().setDeviceOrientationOverride(this.alpha, this.beta, this.gamma);
    },

    clear: function()
    {
        for (var target of WebInspector.targetManager.targets(WebInspector.Target.Type.Page))
            target.deviceOrientationAgent().clearDeviceOrientationOverride();
    }
}

/**
 * @return {!WebInspector.DeviceOrientation}
 */
WebInspector.DeviceOrientation.parseSetting = function(value)
{
    if (value) {
        var jsonObject = JSON.parse(value);
        return new WebInspector.DeviceOrientation(jsonObject.alpha, jsonObject.beta, jsonObject.gamma);
    }
    return new WebInspector.DeviceOrientation(0, 0, 0);
}

/**
 * @return {?WebInspector.DeviceOrientation}
 */
WebInspector.DeviceOrientation.parseUserInput = function(alphaString, betaString, gammaString)
{
    if (!alphaString && !betaString && !gammaString)
        return null;

    var isAlphaValid = WebInspector.DeviceOrientation.validator(alphaString);
    var isBetaValid = WebInspector.DeviceOrientation.validator(betaString);
    var isGammaValid = WebInspector.DeviceOrientation.validator(gammaString);

    if (!isAlphaValid && !isBetaValid && !isGammaValid)
        return null;

    var alpha = isAlphaValid ? parseFloat(alphaString) : -1;
    var beta = isBetaValid ? parseFloat(betaString) : -1;
    var gamma = isGammaValid ? parseFloat(gammaString) : -1;

    return new WebInspector.DeviceOrientation(alpha, beta, gamma);
}

/**
 * @param {string} value
 * @return {boolean}
 */
WebInspector.DeviceOrientation.validator = function(value)
{
    return !value || /^([+-]?[\d]+(\.\d+)?|[+-]?\.\d+)$/.test(value);
}
;/* Geolocation.js */
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {number} latitude
 * @param {number} longitude
 * @param {string} error
 */
WebInspector.Geolocation = function(latitude, longitude, error)
{
    this.latitude = latitude;
    this.longitude = longitude;
    this.error = error;
}

WebInspector.Geolocation.prototype = {
    /**
     * @return {string}
     */
    toSetting: function()
    {
        return (typeof this.latitude === "number" && typeof this.longitude === "number" && typeof this.error === "string") ? this.latitude + "@" + this.longitude + ":" + this.error : "";
    },

    apply: function()
    {
        for (var target of WebInspector.targetManager.targets(WebInspector.Target.Type.Page)) {
            if (this.error)
                target.emulationAgent().setGeolocationOverride();
            else
                target.emulationAgent().setGeolocationOverride(this.latitude, this.longitude, 150);

        }
    },

    clear: function()
    {
        for (var target of WebInspector.targetManager.targets(WebInspector.Target.Type.Page))
            target.emulationAgent().clearGeolocationOverride();
    }
}

/**
 * @return {!WebInspector.Geolocation}
 */
WebInspector.Geolocation.parseSetting = function(value)
{
    if (value) {
        var splitError = value.split(":");
        if (splitError.length === 2) {
            var splitPosition = splitError[0].split("@");
            if (splitPosition.length === 2)
                return new WebInspector.Geolocation(parseFloat(splitPosition[0]), parseFloat(splitPosition[1]), splitError[1]);
        }
    }
    return new WebInspector.Geolocation(0, 0, "");
}

/**
 * @return {?WebInspector.Geolocation}
 */
WebInspector.Geolocation.parseUserInput = function(latitudeString, longitudeString, errorStatus)
{
    if (!latitudeString && !longitudeString)
        return null;

    var isLatitudeValid = WebInspector.Geolocation.latitudeValidator(latitudeString);
    var isLongitudeValid = WebInspector.Geolocation.longitudeValidator(longitudeString);

    if (!isLatitudeValid && !isLongitudeValid)
        return null;

    var latitude = isLatitudeValid ? parseFloat(latitudeString) : -1;
    var longitude = isLongitudeValid ? parseFloat(longitudeString) : -1;

    return new WebInspector.Geolocation(latitude, longitude, errorStatus ? "PositionUnavailable" : "");
}

/**
 * @param {string} value
 * @return {boolean}
 */
WebInspector.Geolocation.latitudeValidator = function(value)
{
    return !value || (/^([+-]?[\d]+(\.\d+)?|[+-]?\.\d+)$/.test(value) && value >= -90 && value <= 90);
}

/**
 * @param {string} value
 * @return {boolean}
 */
WebInspector.Geolocation.longitudeValidator = function(value)
{
    return !value || (/^([+-]?[\d]+(\.\d+)?|[+-]?\.\d+)$/.test(value) && value >= -180 && value <= 180);
}
;/* InspectedPagePlaceholder.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.Widget}
 */
WebInspector.InspectedPagePlaceholder = function()
{
    WebInspector.Widget.call(this);
    this.element.classList.add("inspected-page-placeholder");
    WebInspector.zoomManager.addEventListener(WebInspector.ZoomManager.Events.ZoomChanged, this._scheduleUpdate, this);
    this._margins = { top: 0, right: 0, bottom: 0, left: 0 };
    this.restoreMinimumSizeAndMargins();
};

WebInspector.InspectedPagePlaceholder.Events = {
    Update: "Update"
};

WebInspector.InspectedPagePlaceholder.MarginValue = 3;

WebInspector.InspectedPagePlaceholder.prototype = {
    _findMargins: function()
    {
        var margins = { top: 0, right: 0, bottom: 0, left: 0 };

        if (this._useMargins) {
            var adjacent = { top: true, right: true, bottom: true, left: true };
            var widget = this;
            while (widget.parentWidget()) {
                var parent = widget.parentWidget();
                // This view assumes it's always inside the main split widget element, not a sidebar.
                // Every parent which is not a split widget, must be of the same size as this widget.
                if (parent instanceof WebInspector.SplitWidget) {
                    var side = parent.sidebarSide();
                    if (adjacent[side] && !parent.hasCustomResizer() && parent.isResizable())
                        margins[side] = WebInspector.InspectedPagePlaceholder.MarginValue;
                    adjacent[side] = false;
                }
                widget = parent;
            }
        }

        if (this._margins.top !== margins.top || this._margins.left !== margins.left || this._margins.right !== margins.right || this._margins.bottom !== margins.bottom) {
            this._margins = margins;
            this._scheduleUpdate();
        }
    },

    onResize: function()
    {
        this._findMargins();
        this._scheduleUpdate();
    },

    _scheduleUpdate: function()
    {
        if (this._updateId)
            this.element.window().cancelAnimationFrame(this._updateId);
        this._updateId = this.element.window().requestAnimationFrame(this.update.bind(this));
    },

    restoreMinimumSizeAndMargins: function()
    {
        this._useMargins = true;
        this.setMinimumSize(150, 150);
        this._findMargins();
    },

    clearMinimumSizeAndMargins: function()
    {
        this._useMargins = false;
        this.setMinimumSize(1, 1);
        this._findMargins();
    },

    _dipPageRect: function()
    {
        var zoomFactor = WebInspector.zoomManager.zoomFactor();
        var rect = this.element.getBoundingClientRect();
        var bodyRect = this.element.ownerDocument.body.getBoundingClientRect();

        var left = Math.max(rect.left * zoomFactor + this._margins.left, bodyRect.left * zoomFactor);
        var top = Math.max(rect.top * zoomFactor + this._margins.top, bodyRect.top * zoomFactor);
        var bottom = Math.min(rect.bottom * zoomFactor - this._margins.bottom, bodyRect.bottom * zoomFactor);
        var right = Math.min(rect.right * zoomFactor - this._margins.right, bodyRect.right * zoomFactor);

        return { x: left, y: top, width: right - left, height: bottom - top };
    },

    update: function()
    {
        delete this._updateId;
        var rect = this._dipPageRect();
        var bounds = { x: Math.round(rect.x), y: Math.round(rect.y), height: Math.max(1, Math.round(rect.height)), width: Math.max(1, Math.round(rect.width)) };
        this.dispatchEventToListeners(WebInspector.InspectedPagePlaceholder.Events.Update, bounds);
    },

    __proto__: WebInspector.Widget.prototype
};
;/* MediaQueryInspector.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.Widget}
 * @implements {WebInspector.TargetManager.Observer}
 * @param {function():number} getWidthCallback
 * @param {function(number)} setWidthCallback
 */
WebInspector.MediaQueryInspector = function(getWidthCallback, setWidthCallback)
{
    WebInspector.Widget.call(this, true);
    this.registerRequiredCSS("emulation/mediaQueryInspector.css");
    this.contentElement.classList.add("media-inspector-view");
    this.contentElement.addEventListener("click", this._onMediaQueryClicked.bind(this), false);
    this.contentElement.addEventListener("contextmenu", this._onContextMenu.bind(this), false);
    this._mediaThrottler = new WebInspector.Throttler(0);

    this._getWidthCallback = getWidthCallback;
    this._setWidthCallback = setWidthCallback;
    this._scale = 1;

    WebInspector.targetManager.observeTargets(this);
    WebInspector.zoomManager.addEventListener(WebInspector.ZoomManager.Events.ZoomChanged, this._renderMediaQueries.bind(this), this);
}

/**
 * @enum {number}
 */
WebInspector.MediaQueryInspector.Section = {
    Max: 0,
    MinMax: 1,
    Min: 2
}

WebInspector.MediaQueryInspector.prototype = {
    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target)
    {
        // FIXME: adapt this to multiple targets.
        if (this._cssModel)
            return;
        this._cssModel = WebInspector.CSSStyleModel.fromTarget(target);
        if (!this._cssModel)
            return;
        this._cssModel.addEventListener(WebInspector.CSSStyleModel.Events.StyleSheetAdded, this._scheduleMediaQueriesUpdate, this);
        this._cssModel.addEventListener(WebInspector.CSSStyleModel.Events.StyleSheetRemoved, this._scheduleMediaQueriesUpdate, this);
        this._cssModel.addEventListener(WebInspector.CSSStyleModel.Events.StyleSheetChanged, this._scheduleMediaQueriesUpdate, this);
        this._cssModel.addEventListener(WebInspector.CSSStyleModel.Events.MediaQueryResultChanged, this._scheduleMediaQueriesUpdate, this);
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target)
    {
        if (WebInspector.CSSStyleModel.fromTarget(target) !== this._cssModel)
            return;
        this._cssModel.removeEventListener(WebInspector.CSSStyleModel.Events.StyleSheetAdded, this._scheduleMediaQueriesUpdate, this);
        this._cssModel.removeEventListener(WebInspector.CSSStyleModel.Events.StyleSheetRemoved, this._scheduleMediaQueriesUpdate, this);
        this._cssModel.removeEventListener(WebInspector.CSSStyleModel.Events.StyleSheetChanged, this._scheduleMediaQueriesUpdate, this);
        this._cssModel.removeEventListener(WebInspector.CSSStyleModel.Events.MediaQueryResultChanged, this._scheduleMediaQueriesUpdate, this);
        delete this._cssModel;
    },

    /**
     * @param {number} scale
     */
    setAxisTransform: function(scale)
    {
        if (Math.abs(this._scale - scale) < 1e-8)
            return;
        this._scale = scale;
        this._renderMediaQueries();
    },

    /**
     * @param {!Event} event
     */
    _onMediaQueryClicked: function(event)
    {
        var mediaQueryMarker = event.target.enclosingNodeOrSelfWithClass("media-inspector-bar");
        if (!mediaQueryMarker)
            return;

        var model = mediaQueryMarker._model;
        if (model.section() === WebInspector.MediaQueryInspector.Section.Max) {
            this._setWidthCallback(model.maxWidthExpression().computedLength());
            return;
        }
        if (model.section() === WebInspector.MediaQueryInspector.Section.Min) {
            this._setWidthCallback(model.minWidthExpression().computedLength());
            return;
        }
        var currentWidth = this._getWidthCallback();
        if (currentWidth !== model.minWidthExpression().computedLength())
            this._setWidthCallback(model.minWidthExpression().computedLength());
        else
            this._setWidthCallback(model.maxWidthExpression().computedLength());
    },

    /**
     * @param {!Event} event
     */
    _onContextMenu: function(event)
    {
        if (!this._cssModel || !this._cssModel.isEnabled())
            return;

        var mediaQueryMarker = event.target.enclosingNodeOrSelfWithClass("media-inspector-bar");
        if (!mediaQueryMarker)
            return;

        var locations = mediaQueryMarker._locations;
        var uiLocations = new Map();
        for (var i = 0; i < locations.length; ++i) {
            var uiLocation = WebInspector.cssWorkspaceBinding.rawLocationToUILocation(locations[i]);
            if (!uiLocation)
                continue;
            var descriptor = String.sprintf("%s:%d:%d", uiLocation.uiSourceCode.url(), uiLocation.lineNumber + 1, uiLocation.columnNumber + 1);
            uiLocations.set(descriptor, uiLocation);
        }

        var contextMenuItems = uiLocations.keysArray().sort();
        var contextMenu = new WebInspector.ContextMenu(event);
        var subMenuItem = contextMenu.appendSubMenuItem(WebInspector.UIString.capitalize("Reveal in ^source ^code"));
        for (var i = 0; i < contextMenuItems.length; ++i) {
            var title = contextMenuItems[i];
            subMenuItem.appendItem(title, this._revealSourceLocation.bind(this, /** @type {!WebInspector.UILocation} */(uiLocations.get(title))));
        }
        contextMenu.show();
    },

    /**
     * @param {!WebInspector.UILocation} location
     */
    _revealSourceLocation: function(location)
    {
        WebInspector.Revealer.reveal(location);
    },

    _scheduleMediaQueriesUpdate: function()
    {
        if (!this.isShowing())
            return;
        this._mediaThrottler.schedule(this._refetchMediaQueries.bind(this));
    },

    _refetchMediaQueries: function()
    {
        if (!this.isShowing() || !this._cssModel)
            return Promise.resolve();

        return this._cssModel.mediaQueriesPromise()
            .then(this._rebuildMediaQueries.bind(this))
    },

    /**
     * @param {!Array.<!WebInspector.MediaQueryInspector.MediaQueryUIModel>} models
     * @return {!Array.<!WebInspector.MediaQueryInspector.MediaQueryUIModel>}
     */
    _squashAdjacentEqual: function(models)
    {
        var filtered = [];
        for (var i = 0; i < models.length; ++i) {
            var last = filtered.peekLast();
            if (!last || !last.equals(models[i]))
                filtered.push(models[i]);
        }
        return filtered;
    },

    /**
     * @param {!Array.<!WebInspector.CSSMedia>} cssMedias
     */
    _rebuildMediaQueries: function(cssMedias)
    {
        var queryModels = [];
        for (var i = 0; i < cssMedias.length; ++i) {
            var cssMedia = cssMedias[i];
            if (!cssMedia.mediaList)
                continue;
            for (var j = 0; j < cssMedia.mediaList.length; ++j) {
                var mediaQuery = cssMedia.mediaList[j];
                var queryModel = WebInspector.MediaQueryInspector.MediaQueryUIModel.createFromMediaQuery(cssMedia, mediaQuery);
                if (queryModel && queryModel.rawLocation())
                    queryModels.push(queryModel);
            }
        }
        queryModels.sort(compareModels);
        queryModels = this._squashAdjacentEqual(queryModels);

        var allEqual = this._cachedQueryModels && this._cachedQueryModels.length == queryModels.length;
        for (var i = 0; allEqual && i < queryModels.length; ++i)
            allEqual = allEqual && this._cachedQueryModels[i].equals(queryModels[i]);
        if (allEqual)
            return;
        this._cachedQueryModels = queryModels;
        this._renderMediaQueries();

        /**
         * @param {!WebInspector.MediaQueryInspector.MediaQueryUIModel} model1
         * @param {!WebInspector.MediaQueryInspector.MediaQueryUIModel} model2
         * @return {number}
         */
        function compareModels(model1, model2)
        {
            return model1.compareTo(model2);
        }
    },

    _renderMediaQueries: function()
    {
        if (!this._cachedQueryModels || !this.isShowing())
            return;

        var markers = [];
        var lastMarker = null;
        for (var i = 0; i < this._cachedQueryModels.length; ++i) {
            var model = this._cachedQueryModels[i];
            if (lastMarker && lastMarker.model.dimensionsEqual(model)) {
                lastMarker.locations.push(model.rawLocation());
                lastMarker.active = lastMarker.active || model.active();
            } else {
                lastMarker = {
                    active: model.active(),
                    model: model,
                    locations: [ model.rawLocation() ]
                };
                markers.push(lastMarker);
            }
        }

        this.contentElement.removeChildren();

        var container = null;
        for (var i = 0; i < markers.length; ++i) {
            if (!i || markers[i].model.section() !== markers[i - 1].model.section())
                container = this.contentElement.createChild("div", "media-inspector-marker-container");
            var marker = markers[i];
            var bar = this._createElementFromMediaQueryModel(marker.model);
            bar._model = marker.model;
            bar._locations = marker.locations;
            bar.classList.toggle("media-inspector-marker-inactive", !marker.active);
            container.appendChild(bar);
        }
    },

    /**
     * @return {number}
     */
    _zoomFactor: function()
    {
        return WebInspector.zoomManager.zoomFactor() / this._scale;
    },

    wasShown: function()
    {
        this._scheduleMediaQueriesUpdate();
    },

    /**
     * @param {!WebInspector.MediaQueryInspector.MediaQueryUIModel} model
     * @return {!Element}
     */
    _createElementFromMediaQueryModel: function(model)
    {
        var zoomFactor = this._zoomFactor();
        var minWidthValue = model.minWidthExpression() ? model.minWidthExpression().computedLength() / zoomFactor : 0;
        var maxWidthValue = model.maxWidthExpression() ? model.maxWidthExpression().computedLength() / zoomFactor : 0;
        var result = createElementWithClass("div", "media-inspector-bar");

        if (model.section() === WebInspector.MediaQueryInspector.Section.Max) {
            result.createChild("div", "media-inspector-marker-spacer");
            var markerElement = result.createChild("div", "media-inspector-marker media-inspector-marker-max-width");
            markerElement.style.width = maxWidthValue + "px";
            markerElement.title = model.mediaText();
            appendLabel(markerElement, model.maxWidthExpression(), false, false);
            appendLabel(markerElement, model.maxWidthExpression(), true, true);
            result.createChild("div", "media-inspector-marker-spacer");
        }

        if (model.section() === WebInspector.MediaQueryInspector.Section.MinMax) {
            result.createChild("div", "media-inspector-marker-spacer");
            var leftElement = result.createChild("div", "media-inspector-marker media-inspector-marker-min-max-width");
            leftElement.style.width = (maxWidthValue - minWidthValue) * 0.5 + "px";
            leftElement.title = model.mediaText();
            appendLabel(leftElement, model.minWidthExpression(), true, false);
            appendLabel(leftElement, model.maxWidthExpression(), false, true);
            result.createChild("div", "media-inspector-marker-spacer").style.flex = "0 0 " + minWidthValue + "px";
            var rightElement = result.createChild("div", "media-inspector-marker media-inspector-marker-min-max-width");
            rightElement.style.width = (maxWidthValue - minWidthValue) * 0.5  + "px";
            rightElement.title = model.mediaText();
            appendLabel(rightElement, model.minWidthExpression(), true, false);
            appendLabel(rightElement, model.maxWidthExpression(), false, true);
            result.createChild("div", "media-inspector-marker-spacer");
        }

        if (model.section() === WebInspector.MediaQueryInspector.Section.Min) {
            var leftElement = result.createChild("div", "media-inspector-marker media-inspector-marker-min-width media-inspector-marker-min-width-left");
            leftElement.title = model.mediaText();
            appendLabel(leftElement, model.minWidthExpression(), false, false);
            result.createChild("div", "media-inspector-marker-spacer").style.flex = "0 0 " + minWidthValue + "px";
            var rightElement = result.createChild("div", "media-inspector-marker media-inspector-marker-min-width media-inspector-marker-min-width-right");
            rightElement.title = model.mediaText();
            appendLabel(rightElement, model.minWidthExpression(), true, true);
        }

        function appendLabel(marker, expression, atLeft, leftAlign)
        {
            marker.createChild("div", "media-inspector-marker-label-container " + (atLeft ? "media-inspector-marker-label-container-left" : "media-inspector-marker-label-container-right"))
                .createChild("span", "media-inspector-marker-label " + (leftAlign ? "media-inspector-label-left" : "media-inspector-label-right"))
                .textContent = expression.value() + expression.unit();
        }

        return result;
    },

    __proto__: WebInspector.Widget.prototype
};

/**
 * @constructor
 * @param {!WebInspector.CSSMedia} cssMedia
 * @param {?WebInspector.CSSMediaQueryExpression} minWidthExpression
 * @param {?WebInspector.CSSMediaQueryExpression} maxWidthExpression
 * @param {boolean} active
 */
WebInspector.MediaQueryInspector.MediaQueryUIModel = function(cssMedia, minWidthExpression, maxWidthExpression, active)
{
    this._cssMedia = cssMedia;
    this._minWidthExpression = minWidthExpression;
    this._maxWidthExpression = maxWidthExpression;
    this._active = active;
    if (maxWidthExpression && !minWidthExpression)
        this._section = WebInspector.MediaQueryInspector.Section.Max;
    else if (minWidthExpression && maxWidthExpression)
        this._section = WebInspector.MediaQueryInspector.Section.MinMax;
    else
        this._section = WebInspector.MediaQueryInspector.Section.Min;
}

/**
 * @param {!WebInspector.CSSMedia} cssMedia
 * @param {!WebInspector.CSSMediaQuery} mediaQuery
 * @return {?WebInspector.MediaQueryInspector.MediaQueryUIModel}
 */
WebInspector.MediaQueryInspector.MediaQueryUIModel.createFromMediaQuery = function(cssMedia, mediaQuery)
{
    var maxWidthExpression = null;
    var maxWidthPixels = Number.MAX_VALUE;
    var minWidthExpression = null;
    var minWidthPixels = Number.MIN_VALUE;
    var expressions = mediaQuery.expressions();
    for (var i = 0; i < expressions.length; ++i) {
        var expression = expressions[i];
        var feature = expression.feature();
        if (feature.indexOf("width") === -1)
            continue;
        var pixels = expression.computedLength();
        if (feature.startsWith("max-") && pixels < maxWidthPixels) {
            maxWidthExpression = expression;
            maxWidthPixels = pixels;
        } else if (feature.startsWith("min-") && pixels > minWidthPixels) {
            minWidthExpression = expression;
            minWidthPixels = pixels;
        }
    }
    if (minWidthPixels > maxWidthPixels || (!maxWidthExpression && !minWidthExpression))
        return null;

    return new WebInspector.MediaQueryInspector.MediaQueryUIModel(cssMedia, minWidthExpression, maxWidthExpression, mediaQuery.active());
}

WebInspector.MediaQueryInspector.MediaQueryUIModel.prototype = {
    /**
     * @param {!WebInspector.MediaQueryInspector.MediaQueryUIModel} other
     * @return {boolean}
     */
    equals: function(other)
    {
        return this.compareTo(other) === 0;
    },

    /**
     * @param {!WebInspector.MediaQueryInspector.MediaQueryUIModel} other
     * @return {boolean}
     */
    dimensionsEqual: function(other)
    {
        return this.section() === other.section()
            && (!this.minWidthExpression() || (this.minWidthExpression().computedLength() === other.minWidthExpression().computedLength()))
            && (!this.maxWidthExpression() || (this.maxWidthExpression().computedLength() === other.maxWidthExpression().computedLength()));
    },

    /**
     * @param {!WebInspector.MediaQueryInspector.MediaQueryUIModel} other
     * @return {number}
     */
    compareTo: function(other)
    {
        if (this.section() !== other.section())
            return this.section() - other.section();
        if (this.dimensionsEqual(other)) {
            var myLocation = this.rawLocation();
            var otherLocation = other.rawLocation();
            if (!myLocation && !otherLocation)
                return this.mediaText().compareTo(other.mediaText());
            if (myLocation && !otherLocation)
                return 1;
            if (!myLocation && otherLocation)
                return -1;
            if (this.active() !== other.active())
                return this.active() ? -1 : 1;
            return myLocation.url.compareTo(otherLocation.url) || myLocation.lineNumber - otherLocation.lineNumber || myLocation.columnNumber - otherLocation.columnNumber;
        }
        if (this.section() === WebInspector.MediaQueryInspector.Section.Max)
            return other.maxWidthExpression().computedLength() - this.maxWidthExpression().computedLength();
        if (this.section() === WebInspector.MediaQueryInspector.Section.Min)
            return this.minWidthExpression().computedLength() - other.minWidthExpression().computedLength();
        return this.minWidthExpression().computedLength() - other.minWidthExpression().computedLength() || other.maxWidthExpression().computedLength() - this.maxWidthExpression().computedLength();
    },

    /**
     * @return {!WebInspector.MediaQueryInspector.Section}
     */
    section: function()
    {
        return this._section;
    },

    /**
     * @return {string}
     */
    mediaText: function()
    {
        return this._cssMedia.text;
    },

    /**
     * @return {?WebInspector.CSSLocation}
     */
    rawLocation: function()
    {
        if (!this._rawLocation)
            this._rawLocation = this._cssMedia.rawLocation();
        return this._rawLocation;
    },

    /**
     * @return {?WebInspector.CSSMediaQueryExpression}
     */
    minWidthExpression: function()
    {
        return this._minWidthExpression;
    },

    /**
     * @return {?WebInspector.CSSMediaQueryExpression}
     */
    maxWidthExpression: function()
    {
        return this._maxWidthExpression;
    },

    /**
     * @return {boolean}
     */
    active: function()
    {
        return this._active;
    }
}
;/* SensorsView.js */
// Copyright (c) 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.VBox}
 */
WebInspector.SensorsView = function()
{
    WebInspector.VBox.call(this, true);
    this.registerRequiredCSS("emulation/sensors.css");
    this.contentElement.classList.add("sensors-view");

    this._geolocationSetting = WebInspector.settings.createSetting("emulation.geolocationOverride", "");
    this._geolocation = WebInspector.Geolocation.parseSetting(this._geolocationSetting.get());
    this._geolocationEnabled = false;
    this._appendGeolocationOverrideControl();

    this._deviceOrientationSetting = WebInspector.settings.createSetting("emulation.deviceOrientationOverride", "");
    this._deviceOrientation = WebInspector.DeviceOrientation.parseSetting(this._deviceOrientationSetting.get());
    this._deviceOrientationEnabled = false;
    this._appendDeviceOrientationOverrideControl();
}

WebInspector.SensorsView.prototype = {
    _appendGeolocationOverrideControl: function()
    {
        var checkboxLabel = createCheckboxLabel(WebInspector.UIString("Emulate geolocation coordinates"));
        this._geolocationOverrideCheckbox = checkboxLabel.checkboxElement;
        this._geolocationOverrideCheckbox.addEventListener("click", this._geolocationOverrideCheckboxClicked.bind(this));
        this.contentElement.appendChild(checkboxLabel);
        this._geolocationFieldset = this._createGeolocationOverrideElement(this._geolocation);
        this._geolocationFieldset.disabled = true;
        this.contentElement.appendChild(this._geolocationFieldset);
    },

    _geolocationOverrideCheckboxClicked: function()
    {
        var enabled = this._geolocationOverrideCheckbox.checked;

        this._geolocationEnabled = enabled;
        this._applyGeolocation();

        if (enabled && !this._latitudeElement.value)
            this._latitudeElement.focus();
        this._geolocationFieldset.disabled = !enabled;
    },

    _applyGeolocationUserInput: function()
    {
        var geolocation = WebInspector.Geolocation.parseUserInput(this._latitudeElement.value.trim(), this._longitudeElement.value.trim(), this._geolocationErrorElement.checked);
        if (!geolocation)
            return;

        this._geolocation = geolocation;
        this._applyGeolocation();
    },

    _applyGeolocation: function()
    {
        if (this._geolocationEnabled) {
            this._geolocationSetting.set(this._geolocation.toSetting());
            this._geolocation.apply();
        } else {
            this._geolocation.clear();
        }
    },

    /**
     * @param {!WebInspector.Geolocation} geolocation
     * @return {!Element}
     */
    _createGeolocationOverrideElement: function(geolocation)
    {
        var fieldsetElement = createElement("fieldset");
        fieldsetElement.id = "geolocation-override-section";

        var tableElement = fieldsetElement.createChild("table");
        var rowElement = tableElement.createChild("tr");
        var cellElement = rowElement.createChild("td");
        cellElement = rowElement.createChild("td");
        cellElement.createTextChild(WebInspector.UIString("Lat = "));
        this._latitudeElement = cellElement.createChild("input");
        this._latitudeElement.type = "text";
        WebInspector.bindInput(this._latitudeElement, this._applyGeolocationUserInput.bind(this), WebInspector.Geolocation.latitudeValidator, true)(String(geolocation.latitude));
        cellElement.createTextChild(" , ");
        cellElement.createTextChild(WebInspector.UIString("Lon = "));
        this._longitudeElement = cellElement.createChild("input");
        this._longitudeElement.type = "text";
        WebInspector.bindInput(this._longitudeElement, this._applyGeolocationUserInput.bind(this), WebInspector.Geolocation.longitudeValidator, true)(String(geolocation.longitude));
        rowElement = tableElement.createChild("tr");
        cellElement = rowElement.createChild("td");
        cellElement.colSpan = 2;
        var geolocationErrorLabelElement = createCheckboxLabel(WebInspector.UIString("Emulate position unavailable"), !geolocation || !!geolocation.error);
        var geolocationErrorCheckboxElement = geolocationErrorLabelElement.checkboxElement;
        geolocationErrorCheckboxElement.id = "geolocation-error";
        geolocationErrorCheckboxElement.addEventListener("click", this._applyGeolocationUserInput.bind(this), false);
        this._geolocationErrorElement = geolocationErrorCheckboxElement;
        cellElement.appendChild(geolocationErrorLabelElement);

        return fieldsetElement;
    },

    _appendDeviceOrientationOverrideControl: function()
    {
        var checkboxLabel = createCheckboxLabel(WebInspector.UIString("Emulate device orientation"));
        this._overrideDeviceOrientationCheckbox = checkboxLabel.checkboxElement;
        this._overrideDeviceOrientationCheckbox.addEventListener("click", this._deviceOrientationOverrideCheckboxClicked.bind(this));
        this.contentElement.appendChild(checkboxLabel);
        this._deviceOrientationFieldset = this._createDeviceOrientationOverrideElement(this._deviceOrientation);
        this._deviceOrientationFieldset.disabled = true;
        this.contentElement.appendChild(this._deviceOrientationFieldset);
    },

    _deviceOrientationOverrideCheckboxClicked: function()
    {
        var enabled = this._overrideDeviceOrientationCheckbox.checked;

        this._deviceOrientationEnabled = enabled;
        this._applyDeviceOrientation();

        if (enabled && !this._alphaElement.value)
            this._alphaElement.focus();
        this._deviceOrientationFieldset.disabled = !enabled;
    },

    _applyDeviceOrientation: function()
    {
        if (this._deviceOrientationEnabled) {
            this._deviceOrientationSetting.set(this._deviceOrientation.toSetting());
            this._deviceOrientation.apply();
        } else {
            this._deviceOrientation.clear();
        }
    },

    _applyDeviceOrientationUserInput: function()
    {
        this._setDeviceOrientation(WebInspector.DeviceOrientation.parseUserInput(this._alphaElement.value.trim(), this._betaElement.value.trim(), this._gammaElement.value.trim()), WebInspector.SensorsView.DeviceOrientationModificationSource.UserInput);
    },

    _resetDeviceOrientation: function()
    {
        this._setDeviceOrientation(new WebInspector.DeviceOrientation(0, 0, 0), WebInspector.SensorsView.DeviceOrientationModificationSource.ResetButton);
    },

    /**
     * @param {?WebInspector.DeviceOrientation} deviceOrientation
     * @param {!WebInspector.SensorsView.DeviceOrientationModificationSource} modificationSource
     */
    _setDeviceOrientation: function(deviceOrientation, modificationSource)
    {
        if (!deviceOrientation)
            return;

        if (modificationSource != WebInspector.SensorsView.DeviceOrientationModificationSource.UserInput) {
            this._alphaSetter(deviceOrientation.alpha);
            this._betaSetter(deviceOrientation.beta);
            this._gammaSetter(deviceOrientation.gamma);
        }

        if (modificationSource != WebInspector.SensorsView.DeviceOrientationModificationSource.UserDrag)
            this._setBoxOrientation(deviceOrientation);

        this._deviceOrientation = deviceOrientation;
        this._applyDeviceOrientation();
    },

    /**
     * @param {!Element} parentElement
     * @param {!Element} input
     * @param {string} label
     * @return {function(string)}
     */
    _createAxisInput: function(parentElement, input, label)
    {
        var div = parentElement.createChild("div", "accelerometer-axis-input-container");
        div.createTextChild(label);
        div.appendChild(input);
        input.type = "text";
        return WebInspector.bindInput(input, this._applyDeviceOrientationUserInput.bind(this), WebInspector.DeviceOrientation.validator, true);
    },

    /**
     * @param {!WebInspector.DeviceOrientation} deviceOrientation
     */
    _createDeviceOrientationOverrideElement: function(deviceOrientation)
    {
        var fieldsetElement = createElement("fieldset");
        fieldsetElement.classList.add("device-orientation-override-section");
        var tableElement = fieldsetElement.createChild("table");
        var rowElement = tableElement.createChild("tr");
        var cellElement = rowElement.createChild("td", "accelerometer-inputs-cell");

        this._alphaElement = createElement("input");
        this._alphaSetter = this._createAxisInput(cellElement, this._alphaElement, "\u03B1: ");
        this._alphaSetter(String(deviceOrientation.alpha));

        this._betaElement = createElement("input");
        this._betaSetter = this._createAxisInput(cellElement, this._betaElement, "\u03B2: ");
        this._betaSetter(String(deviceOrientation.beta));

        this._gammaElement = createElement("input");
        this._gammaSetter = this._createAxisInput(cellElement, this._gammaElement, "\u03B3: ");
        this._gammaSetter(String(deviceOrientation.gamma));

        cellElement.appendChild(createTextButton(WebInspector.UIString("Reset"), this._resetDeviceOrientation.bind(this), "accelerometer-reset-button"));

        this._stageElement = rowElement.createChild("td","accelerometer-stage");
        this._boxElement = this._stageElement.createChild("section", "accelerometer-box");

        this._boxElement.createChild("section", "front");
        this._boxElement.createChild("section", "top");
        this._boxElement.createChild("section", "back");
        this._boxElement.createChild("section", "left");
        this._boxElement.createChild("section", "right");
        this._boxElement.createChild("section", "bottom");

        WebInspector.installDragHandle(this._stageElement, this._onBoxDragStart.bind(this), this._onBoxDrag.bind(this), this._onBoxDragEnd.bind(this), "move");
        this._setBoxOrientation(deviceOrientation);
        return fieldsetElement;
    },

    /**
     * @param {!WebInspector.DeviceOrientation} deviceOrientation
     */
    _setBoxOrientation: function(deviceOrientation)
    {
        var matrix = new WebKitCSSMatrix();
        this._boxMatrix = matrix.rotate(-deviceOrientation.beta, deviceOrientation.gamma, -deviceOrientation.alpha);
        this._boxElement.style.webkitTransform = this._boxMatrix.toString();
    },

    /**
     * @param {!MouseEvent} event
     * @return {boolean}
     */
    _onBoxDrag: function(event)
    {
        var mouseMoveVector = this._calculateRadiusVector(event.x, event.y);
        if (!mouseMoveVector)
            return true;

        event.consume(true);
        var axis = WebInspector.Geometry.crossProduct(this._mouseDownVector, mouseMoveVector);
        axis.normalize();
        var angle = WebInspector.Geometry.calculateAngle(this._mouseDownVector, mouseMoveVector);
        var matrix = new WebKitCSSMatrix();
        var rotationMatrix = matrix.rotateAxisAngle(axis.x, axis.y, axis.z, angle);
        this._currentMatrix = rotationMatrix.multiply(this._boxMatrix);
        this._boxElement.style.webkitTransform = this._currentMatrix;
        var eulerAngles = WebInspector.Geometry.EulerAngles.fromRotationMatrix(this._currentMatrix);
        var newOrientation = new WebInspector.DeviceOrientation(-eulerAngles.alpha, -eulerAngles.beta, eulerAngles.gamma);
        this._setDeviceOrientation(newOrientation, WebInspector.SensorsView.DeviceOrientationModificationSource.UserDrag);
        return false;
    },

    /**
     * @param {!MouseEvent} event
     * @return {boolean}
     */
    _onBoxDragStart: function(event)
    {
        if (!this._overrideDeviceOrientationCheckbox.checked)
            return false;

        this._mouseDownVector = this._calculateRadiusVector(event.x, event.y);

        if (!this._mouseDownVector)
            return false;

        event.consume(true);
        return true;
    },

    _onBoxDragEnd: function()
    {
        this._boxMatrix = this._currentMatrix;
    },

    /**
     * @param {number} x
     * @param {number} y
     * @return {?WebInspector.Geometry.Vector}
     */
    _calculateRadiusVector: function(x, y)
    {
        var rect = this._stageElement.getBoundingClientRect();
        var radius = Math.max(rect.width, rect.height) / 2;
        var sphereX = (x - rect.left - rect.width / 2) / radius;
        var sphereY = (y - rect.top - rect.height / 2) / radius;
        var sqrSum = sphereX * sphereX + sphereY * sphereY;
        if (sqrSum > 0.5)
            return new WebInspector.Geometry.Vector(sphereX, sphereY, 0.5 / Math.sqrt(sqrSum));

        return new WebInspector.Geometry.Vector(sphereX, sphereY, Math.sqrt(1 - sqrSum));
    },

    __proto__ : WebInspector.VBox.prototype
}

/** @enum {string} */
WebInspector.SensorsView.DeviceOrientationModificationSource = {
    UserInput: "userInput",
    UserDrag: "userDrag",
    ResetButton: "resetButton"
}

/**
 * @return {!WebInspector.SensorsView}
 */
WebInspector.SensorsView.instance = function()
{
    if (!WebInspector.SensorsView._instanceObject)
        WebInspector.SensorsView._instanceObject = new WebInspector.SensorsView();
    return WebInspector.SensorsView._instanceObject;
}

/**
 * @constructor
 * @implements {WebInspector.ActionDelegate}
 */
WebInspector.SensorsView.ShowActionDelegate = function()
{
}

WebInspector.SensorsView.ShowActionDelegate.prototype = {
    /**
     * @override
     * @param {!WebInspector.Context} context
     * @param {string} actionId
     * @return {boolean}
     */
    handleAction: function(context, actionId)
    {
        WebInspector.inspectorView.showViewInDrawer("sensors");
        return true;
    }
}
;/* DeviceModeModel.js */
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {function()} updateCallback
 * @implements {WebInspector.TargetManager.Observer}
 */
WebInspector.DeviceModeModel = function(updateCallback)
{
    this._updateCallback = updateCallback;
    this._screenRect = new WebInspector.Rect(0, 0, 1, 1);
    this._visiblePageRect = new WebInspector.Rect(0, 0, 1, 1);
    this._availableSize = new Size(1, 1);
    this._preferredSize = new Size(1, 1);
    this._initialized = false;
    this._deviceMetricsThrottler = new WebInspector.Throttler(0);
    this._appliedDeviceSize = new Size(1, 1);
    this._appliedDeviceScaleFactor = window.devicePixelRatio;
    this._appliedUserAgentType = WebInspector.DeviceModeModel.UA.Desktop;

    this._scaleSetting = WebInspector.settings.createSetting("emulation.deviceScale", 1);
    // We've used to allow zero before.
    if (!this._scaleSetting.get())
        this._scaleSetting.set(1);
    this._scaleSetting.addChangeListener(this._scaleSettingChanged, this);

    this._widthSetting = WebInspector.settings.createSetting("emulation.deviceWidth", 400);
    if (this._widthSetting.get() < WebInspector.DeviceModeModel.MinDeviceSize)
        this._widthSetting.set(WebInspector.DeviceModeModel.MinDeviceSize);
    if (this._widthSetting.get() > WebInspector.DeviceModeModel.MaxDeviceSize)
        this._widthSetting.set(WebInspector.DeviceModeModel.MaxDeviceSize);
    this._widthSetting.addChangeListener(this._widthSettingChanged, this);

    this._heightSetting = WebInspector.settings.createSetting("emulation.deviceHeight", 0);
    if (this._heightSetting.get() && this._heightSetting.get() < WebInspector.DeviceModeModel.MinDeviceSize)
        this._heightSetting.set(WebInspector.DeviceModeModel.MinDeviceSize);
    if (this._heightSetting.get() > WebInspector.DeviceModeModel.MaxDeviceSize)
        this._heightSetting.set(WebInspector.DeviceModeModel.MaxDeviceSize);
    this._heightSetting.addChangeListener(this._heightSettingChanged, this);

    this._uaSetting = WebInspector.settings.createSetting("emulation.deviceUA", WebInspector.DeviceModeModel.UA.Mobile);
    this._uaSetting.addChangeListener(this._uaSettingChanged, this);
    this._deviceScaleFactorSetting = WebInspector.settings.createSetting("emulation.deviceScaleFactor", 0);
    this._deviceScaleFactorSetting.addChangeListener(this._deviceScaleFactorSettingChanged, this);

    /** @type {!WebInspector.DeviceModeModel.Type} */
    this._type = WebInspector.DeviceModeModel.Type.None;
    /** @type {?WebInspector.EmulatedDevice} */
    this._device = null;
    /** @type {?WebInspector.EmulatedDevice.Mode} */
    this._mode = null;
    /** @type {boolean} */
    this._touchEnabled = false;
    /** @type {string} */
    this._touchConfiguration = "";
    /** @type {number} */
    this._fitScale = 1;

    /** @type {?WebInspector.Target} */
    this._target = null;
    /** @type {?function()} */
    this._onTargetAvailable = null;
    WebInspector.targetManager.observeTargets(this, WebInspector.Target.Type.Page);
}

/** @enum {string} */
WebInspector.DeviceModeModel.Type = {
    None: "None",
    Responsive: "Responsive",
    Device: "Device"
}

/** @enum {string} */
WebInspector.DeviceModeModel.UA = {
    Mobile: WebInspector.UIString("Mobile"),
    MobileNoTouch: WebInspector.UIString("Mobile (no touch)"),
    Desktop: WebInspector.UIString("Desktop"),
    DesktopTouch: WebInspector.UIString("Desktop (touch)")
}

WebInspector.DeviceModeModel.MinDeviceSize = 50;
WebInspector.DeviceModeModel.MaxDeviceSize = 9999;

/**
 * @param {string} value
 * @return {boolean}
 */
WebInspector.DeviceModeModel.deviceSizeValidator = function(value)
{
    if (/^[\d]+$/.test(value) && value >= WebInspector.DeviceModeModel.MinDeviceSize && value <= WebInspector.DeviceModeModel.MaxDeviceSize)
        return true;
    return false;
}

/**
 * @param {string} value
 * @return {boolean}
 */
WebInspector.DeviceModeModel.deviceScaleFactorValidator = function(value)
{
    if (!value || (/^[\d]+(\.\d+)?|\.\d+$/.test(value) && value >= 0 && value <= 10))
        return true;
    return false;
}

WebInspector.DeviceModeModel._touchEventsScriptIdSymbol = Symbol("DeviceModeModel.touchEventsScriptIdSymbol");
WebInspector.DeviceModeModel._defaultMobileUserAgent = "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.76 Mobile Safari/537.36";
WebInspector.DeviceModeModel.defaultMobileScaleFactor = 2;

WebInspector.DeviceModeModel.prototype = {
    /**
     * @param {!Size} availableSize
     * @param {!Size} preferredSize
     */
    setAvailableSize: function(availableSize, preferredSize)
    {
        this._availableSize = availableSize;
        this._preferredSize = preferredSize;
        this._initialized = true;
        this._calculateAndEmulate(false);
    },

    /**
     * @param {!WebInspector.DeviceModeModel.Type} type
     * @param {?WebInspector.EmulatedDevice} device
     * @param {?WebInspector.EmulatedDevice.Mode} mode
     */
    emulate: function(type, device, mode)
    {
        var resetPageScaleFactor = this._type !== type || this._device !== device || this._mode !== mode;
        this._type = type;

        if (type === WebInspector.DeviceModeModel.Type.Device) {
            console.assert(device && mode, "Must pass device and mode for device emulation");
            this._device = device;
            this._mode = mode;
            if (this._initialized) {
                var orientation = device.orientationByName(mode.orientation);
                this._scaleSetting.set(this._calculateFitScale(orientation.width, orientation.height));
            }
        } else {
            this._device = null;
            this._mode = null;
        }

        if (type !== WebInspector.DeviceModeModel.Type.None)
            WebInspector.userMetrics.actionTaken(WebInspector.UserMetrics.Action.DeviceModeEnabled);
        this._calculateAndEmulate(resetPageScaleFactor);
    },

    /**
     * @param {number} width
     */
    setWidth: function(width)
    {
        var max = Math.min(WebInspector.DeviceModeModel.MaxDeviceSize, this._preferredScaledWidth());
        width = Math.max(Math.min(width, max), 1);
        this._widthSetting.set(width);
    },

    /**
     * @param {number} width
     */
    setWidthAndScaleToFit: function(width)
    {
        width = Math.max(Math.min(width, WebInspector.DeviceModeModel.MaxDeviceSize), 1);
        this._scaleSetting.set(this._calculateFitScale(width, this._heightSetting.get()));
        this._widthSetting.set(width);
    },

    /**
     * @param {number} height
     */
    setHeight: function(height)
    {
        var max = Math.min(WebInspector.DeviceModeModel.MaxDeviceSize, this._preferredScaledHeight());
        height = Math.max(Math.min(height, max), 0);
        if (height === this._preferredScaledHeight())
            height = 0;
        this._heightSetting.set(height);
    },

    /**
     * @param {number} height
     */
    setHeightAndScaleToFit: function(height)
    {
        height = Math.max(Math.min(height, WebInspector.DeviceModeModel.MaxDeviceSize), 0);
        this._scaleSetting.set(this._calculateFitScale(this._widthSetting.get(), height));
        this._heightSetting.set(height);
    },

    /**
     * @param {number} scale
     */
    setScale: function(scale)
    {
        this._scaleSetting.set(scale);
    },

    /**
     * @return {?WebInspector.EmulatedDevice}
     */
    device: function()
    {
        return this._device;
    },

    /**
     * @return {?WebInspector.EmulatedDevice.Mode}
     */
    mode: function()
    {
        return this._mode;
    },

    /**
     * @return {!WebInspector.DeviceModeModel.Type}
     */
    type: function()
    {
        return this._type;
    },

    /**
     * @return {string}
     */
    screenImage: function()
    {
        return (this._device && this._mode) ? this._device.modeImage(this._mode) : "";
    },

    /**
     * @return {!WebInspector.Rect}
     */
    screenRect: function()
    {
        return this._screenRect;
    },

    /**
     * @return {!WebInspector.Rect}
     */
    visiblePageRect: function()
    {
        return this._visiblePageRect;
    },

    /**
     * @return {number}
     */
    scale: function()
    {
        return this._scale;
    },

    /**
     * @return {number}
     */
    fitScale: function()
    {
        return this._fitScale;
    },

    /**
     * @return {!Size}
     */
    appliedDeviceSize: function()
    {
        return this._appliedDeviceSize;
    },

    /**
     * @return {number}
     */
    appliedDeviceScaleFactor: function()
    {
        return this._appliedDeviceScaleFactor;
    },

    /**
     * @return {!WebInspector.DeviceModeModel.UA}
     */
    appliedUserAgentType: function()
    {
        return this._appliedUserAgentType;
    },

    /**
     * @return {boolean}
     */
    isFullHeight: function()
    {
        return !this._heightSetting.get();
    },

    /**
     * @return {!WebInspector.Setting}
     */
    scaleSetting: function()
    {
        return this._scaleSetting;
    },

    /**
     * @return {!WebInspector.Setting}
     */
    uaSetting: function()
    {
        return this._uaSetting;
    },

    /**
     * @return {!WebInspector.Setting}
     */
    deviceScaleFactorSetting: function()
    {
        return this._deviceScaleFactorSetting;
    },

    reset: function()
    {
        this._deviceScaleFactorSetting.set(0);
        this._scaleSetting.set(1);
        this.setWidth(400);
        this.setHeight(0);
        this._uaSetting.set(WebInspector.DeviceModeModel.UA.Mobile);
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target)
    {
        if (!this._target) {
            this._target = target;
            var domModel = WebInspector.DOMModel.fromTarget(this._target);
            if (domModel)
                domModel.addEventListener(WebInspector.DOMModel.Events.InspectModeWillBeToggled, this._reapplyTouch, this);
            if (this._onTargetAvailable) {
                var callback = this._onTargetAvailable;
                this._onTargetAvailable = null;
                callback();
            } else {
                this._reapplyTouch();
            }
        }
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target)
    {
        if (this._target === target) {
            var domModel = WebInspector.DOMModel.fromTarget(this._target);
            if (domModel)
                domModel.removeEventListener(WebInspector.DOMModel.Events.InspectModeWillBeToggled, this._reapplyTouch, this);
            this._target = null;
        }
    },

    _scaleSettingChanged: function()
    {
        this._calculateAndEmulate(false);
    },

    _widthSettingChanged: function()
    {
        this._calculateAndEmulate(false);
    },

    _heightSettingChanged: function()
    {
        this._calculateAndEmulate(false);
    },

    _uaSettingChanged: function()
    {
        this._calculateAndEmulate(true);
    },

    _deviceScaleFactorSettingChanged: function()
    {
        this._calculateAndEmulate(false);
    },

    /**
     * @return {number}
     */
    _preferredScaledWidth: function()
    {
        return Math.floor(this._preferredSize.width / (this._scaleSetting.get() || 1));
    },

    /**
     * @return {number}
     */
    _preferredScaledHeight: function()
    {
        return Math.floor(this._preferredSize.height / (this._scaleSetting.get() || 1));
    },

    /**
     * @param {boolean} resetPageScaleFactor
     */
    _calculateAndEmulate: function(resetPageScaleFactor)
    {
        if (!this._target)
            this._onTargetAvailable = this._calculateAndEmulate.bind(this, resetPageScaleFactor);

        if (this._type === WebInspector.DeviceModeModel.Type.Device) {
            var orientation = this._device.orientationByName(this._mode.orientation);
            this._fitScale = this._calculateFitScale(orientation.width, orientation.height);
            if (this._device.mobile())
                this._appliedUserAgentType = this._device.touch() ? WebInspector.DeviceModeModel.UA.Mobile : WebInspector.DeviceModeModel.UA.MobileNoTouch;
            else
                this._appliedUserAgentType = this._device.touch() ? WebInspector.DeviceModeModel.UA.DesktopTouch : WebInspector.DeviceModeModel.UA.Desktop;
            this._applyDeviceMetrics(new Size(orientation.width, orientation.height), this._mode.insets, this._scaleSetting.get(), this._device.deviceScaleFactor, this._device.mobile(), this._mode.orientation == WebInspector.EmulatedDevice.Horizontal ? "landscapePrimary" : "portraitPrimary", resetPageScaleFactor);
            this._applyUserAgent(this._device.userAgent);
        } else if (this._type === WebInspector.DeviceModeModel.Type.None) {
            this._fitScale = this._calculateFitScale(this._availableSize.width, this._availableSize.height);
            this._appliedUserAgentType = WebInspector.DeviceModeModel.UA.Desktop;
            this._applyDeviceMetrics(this._availableSize, new Insets(0, 0, 0, 0), 1, 0, false, "", resetPageScaleFactor);
            this._applyUserAgent("");
        } else if (this._type === WebInspector.DeviceModeModel.Type.Responsive) {
            var screenWidth = this._widthSetting.get();
            if (!screenWidth || screenWidth > this._preferredScaledWidth())
                screenWidth = this._preferredScaledWidth();
            var screenHeight = this._heightSetting.get();
            if (!screenHeight || screenHeight > this._preferredScaledHeight())
                screenHeight = this._preferredScaledHeight();
            var mobile = this._uaSetting.get() === WebInspector.DeviceModeModel.UA.Mobile || this._uaSetting.get() === WebInspector.DeviceModeModel.UA.MobileNoTouch;
            var defaultDeviceScaleFactor = mobile ? WebInspector.DeviceModeModel.defaultMobileScaleFactor : 0;
            this._fitScale = this._calculateFitScale(this._widthSetting.get(), this._heightSetting.get());
            this._appliedUserAgentType = this._uaSetting.get();
            this._applyDeviceMetrics(new Size(screenWidth, screenHeight), new Insets(0, 0, 0, 0), this._scaleSetting.get(), this._deviceScaleFactorSetting.get() || defaultDeviceScaleFactor, mobile, screenHeight >= screenWidth ? "portraitPrimary" : "landscapePrimary", resetPageScaleFactor);
            this._applyUserAgent(mobile ? WebInspector.DeviceModeModel._defaultMobileUserAgent : "");
        }
        this._reapplyTouch();
        if (this._target)
            this._target.renderingAgent().setShowViewportSizeOnResize(this._type === WebInspector.DeviceModeModel.Type.None);
        this._updateCallback.call(null);
    },

    /**
     * @param {number} screenWidth
     * @param {number} screenHeight
     * @return {number}
     */
    _calculateFitScale: function(screenWidth, screenHeight)
    {
        var scale = Math.min(screenWidth ? this._preferredSize.width / screenWidth: 1, screenHeight ? this._preferredSize.height / screenHeight : 1);
        return Math.min(scale, 1);
    },

    /**
     * @param {number} width
     * @param {number} height
     */
    setSizeAndScaleToFit: function(width, height)
    {
        this._scaleSetting.set(this._calculateFitScale(width, height));
        this.setWidth(width);
    },

    _reapplyTouch: function()
    {
        var domModel = this._target ? WebInspector.DOMModel.fromTarget(this._target) : null;
        var inspectModeEnabled = domModel ? domModel.inspectModeEnabled() : false;
        if (inspectModeEnabled) {
            this._applyTouch(false, false);
            return;
        }

        if (this._type === WebInspector.DeviceModeModel.Type.Device)
            this._applyTouch(this._device.touch(), this._device.mobile());
        else if (this._type === WebInspector.DeviceModeModel.Type.None)
            this._applyTouch(false, false);
        else if (this._type === WebInspector.DeviceModeModel.Type.Responsive)
            this._applyTouch(this._uaSetting.get() === WebInspector.DeviceModeModel.UA.DesktopTouch || this._uaSetting.get() === WebInspector.DeviceModeModel.UA.Mobile, this._uaSetting.get() === WebInspector.DeviceModeModel.UA.Mobile);
    },

    /**
     * @param {string} userAgent
     */
    _applyUserAgent: function(userAgent)
    {
        WebInspector.multitargetNetworkManager.setUserAgentOverride(userAgent);
    },

    /**
     * @param {!Size} screenSize
     * @param {!Insets} insets
     * @param {number} scale
     * @param {number} deviceScaleFactor
     * @param {boolean} mobile
     * @param {string} screenOrientation
     * @param {boolean} resetPageScaleFactor
     */
    _applyDeviceMetrics: function(screenSize, insets, scale, deviceScaleFactor, mobile, screenOrientation, resetPageScaleFactor)
    {
        screenSize.width = Math.max(1, Math.floor(screenSize.width));
        screenSize.height = Math.max(1, Math.floor(screenSize.height));

        var pageWidth = screenSize.width - insets.left - insets.right;
        var pageHeight = screenSize.height - insets.top - insets.bottom;
        var positionX = insets.left;
        var positionY = insets.top;
        var screenOrientationAngle = screenOrientation === "landscapePrimary" ? 90 : 0;

        this._appliedDeviceSize = screenSize;
        this._appliedDeviceScaleFactor = deviceScaleFactor || window.devicePixelRatio;
        this._screenRect = new WebInspector.Rect(
            Math.max(0, (this._availableSize.width - screenSize.width * scale) / 2),
            0,
            screenSize.width * scale,
            screenSize.height * scale);
        this._visiblePageRect = new WebInspector.Rect(
            positionX * scale,
            positionY * scale,
            Math.min(pageWidth * scale, this._availableSize.width - this._screenRect.left - positionX * scale),
            Math.min(pageHeight * scale, this._availableSize.height - this._screenRect.top - positionY * scale));
        this._scale = scale;

        if (scale === 1 && this._availableSize.width >= screenSize.width && this._availableSize.height >= screenSize.height) {
            // When we have enough space, no page size override is required. This will speed things up and remove lag.
            pageWidth = 0;
            pageHeight = 0;
        }
        if (this._visiblePageRect.width === pageWidth * scale && this._visiblePageRect.height === pageHeight * scale) {
            // When we only have to apply scale, do not resize the page. This will speed things up and remove lag.
            pageWidth = 0;
            pageHeight = 0;
        }

        this._deviceMetricsThrottler.schedule(setDeviceMetricsOverride.bind(this));

        /**
         * @this {WebInspector.DeviceModeModel}
         * @return {!Promise.<?>}
         */
        function setDeviceMetricsOverride()
        {
            if (!this._target)
                return Promise.resolve();

            var clear = !pageWidth && !pageHeight && !mobile && !deviceScaleFactor && scale === 1 && !screenOrientation;
            var allPromises = [];
            if (resetPageScaleFactor)
                allPromises.push(this._target.emulationAgent().resetPageScaleFactor());
            var setDevicePromise;
            if (clear) {
                setDevicePromise = this._target.emulationAgent().clearDeviceMetricsOverride(this._deviceMetricsOverrideAppliedForTest.bind(this));
            } else {
                var params = {width: pageWidth, height: pageHeight, deviceScaleFactor: deviceScaleFactor, mobile: mobile, fitWindow: false, scale: scale, screenWidth: screenSize.width, screenHeight: screenSize.height, positionX: positionX, positionY: positionY};
                if (screenOrientation)
                    params.screenOrientation = {type: screenOrientation, angle: screenOrientationAngle};
                setDevicePromise = this._target.emulationAgent().invoke_setDeviceMetricsOverride(params, this._deviceMetricsOverrideAppliedForTest.bind(this));
            }
            allPromises.push(setDevicePromise);
            return Promise.all(allPromises);
        }
    },

    _deviceMetricsOverrideAppliedForTest: function()
    {
        // Used for sniffing in tests.
    },

    _applyTouch: function(touchEnabled, mobile)
    {
        var configuration = mobile ? "mobile" : "desktop";
        if (!this._target || (this._touchEnabled === touchEnabled && this._touchConfiguration === configuration))
            return;

        var target = this._target;

        /**
         * @suppressGlobalPropertiesCheck
         */
        const injectedFunction = function() {
            const touchEvents = ["ontouchstart", "ontouchend", "ontouchmove", "ontouchcancel"];
            var recepients = [window.__proto__, document.__proto__];
            for (var i = 0; i < touchEvents.length; ++i) {
                for (var j = 0; j < recepients.length; ++j) {
                    if (!(touchEvents[i] in recepients[j]))
                        Object.defineProperty(recepients[j], touchEvents[i], { value: null, writable: true, configurable: true, enumerable: true });
                }
            }
        };

        var symbol = WebInspector.DeviceModeModel._touchEventsScriptIdSymbol;

        if (typeof target[symbol] !== "undefined") {
            target.pageAgent().removeScriptToEvaluateOnLoad(target[symbol]);
            delete target[symbol];
        }

        if (touchEnabled)
            target.pageAgent().addScriptToEvaluateOnLoad("(" + injectedFunction.toString() + ")()", scriptAddedCallback);

        /**
         * @param {?Protocol.Error} error
         * @param {string} scriptId
         */
        function scriptAddedCallback(error, scriptId)
        {
            if (error)
                delete target[symbol];
            else
                target[symbol] = scriptId;
        }

        target.emulationAgent().setTouchEmulationEnabled(touchEnabled, configuration);
        this._touchEnabled = touchEnabled;
        this._touchConfiguration = configuration;
    }
}
;/* DeviceModeToolbar.js */
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {!WebInspector.DeviceModeModel} model
 * @param {!WebInspector.Setting} showMediaInspectorSetting
 * @param {!WebInspector.Setting} showRulersSetting
 * @constructor
 */
WebInspector.DeviceModeToolbar = function(model, showMediaInspectorSetting, showRulersSetting)
{
    this._model = model;
    this._showMediaInspectorSetting = showMediaInspectorSetting;
    this._showRulersSetting = showRulersSetting;

    this._showDeviceScaleFactorSetting = WebInspector.settings.createSetting("emulation.showDeviceScaleFactor", false);
    this._showDeviceScaleFactorSetting.addChangeListener(this._updateDeviceScaleFactorVisibility, this);

    this._showUserAgentTypeSetting = WebInspector.settings.createSetting("emulation.showUserAgentType", false);
    this._showUserAgentTypeSetting.addChangeListener(this._updateUserAgentTypeVisibility, this);

    this._showNetworkConditionsSetting = WebInspector.settings.createSetting("emulation.showNetworkConditions", false);
    this._showNetworkConditionsSetting.addChangeListener(this._updateNetworkConditionsVisibility, this);

    /** @type {!Map<!WebInspector.EmulatedDevice, !WebInspector.EmulatedDevice.Mode>} */
    this._lastMode = new Map();

    this._element = createElementWithClass("div", "device-mode-toolbar");

    var leftContainer = this._element.createChild("div", "device-mode-toolbar-spacer");
    leftContainer.createChild("div", "device-mode-toolbar-spacer");
    var leftToolbar = new WebInspector.Toolbar("", leftContainer);
    leftToolbar.makeWrappable();
    this._fillLeftToolbar(leftToolbar);

    var mainToolbar = new WebInspector.Toolbar("", this._element);
    mainToolbar.makeWrappable();
    this._fillMainToolbar(mainToolbar);

    var rightContainer = this._element.createChild("div", "device-mode-toolbar-spacer");
    var rightToolbar = new WebInspector.Toolbar("device-mode-toolbar-fixed-size", rightContainer);
    rightToolbar.makeWrappable();
    this._fillRightToolbar(rightToolbar);
    var modeToolbar = new WebInspector.Toolbar("device-mode-toolbar-fixed-size", rightContainer);
    modeToolbar.makeWrappable();
    this._fillModeToolbar(modeToolbar);
    rightContainer.createChild("div", "device-mode-toolbar-spacer");
    var optionsToolbar = new WebInspector.Toolbar("", rightContainer);
    optionsToolbar.makeWrappable(true);
    this._fillOptionsToolbar(optionsToolbar);

    this._emulatedDevicesList = WebInspector.EmulatedDevicesList.instance();
    this._emulatedDevicesList.addEventListener(WebInspector.EmulatedDevicesList.Events.CustomDevicesUpdated, this._deviceListChanged, this);
    this._emulatedDevicesList.addEventListener(WebInspector.EmulatedDevicesList.Events.StandardDevicesUpdated, this._deviceListChanged, this);

    this._persistenceSetting = WebInspector.settings.createSetting("emulation.deviceModeValue", {device: "", orientation: "", mode: ""});
}

WebInspector.DeviceModeToolbar.prototype = {
    /**
     * @param {!WebInspector.Toolbar} toolbar
     */
    _fillLeftToolbar: function(toolbar)
    {
        toolbar.appendToolbarItem(this._wrapToolbarItem(createElementWithClass("div", "device-mode-empty-toolbar-element")));
        this._deviceSelectItem = new WebInspector.ToolbarMenuButton(this._appendDeviceMenuItems.bind(this));
        this._deviceSelectItem.setGlyph("");
        this._deviceSelectItem.turnIntoSelect(95);
        toolbar.appendToolbarItem(this._deviceSelectItem);
    },

    /**
     * @param {!WebInspector.Toolbar} toolbar
     */
    _fillMainToolbar: function(toolbar)
    {
        var widthInput = createElementWithClass("input", "device-mode-size-input");
        widthInput.maxLength = 4;
        widthInput.type = "text";
        widthInput.title = WebInspector.UIString("Width");
        this._updateWidthInput = WebInspector.bindInput(widthInput, applyWidth.bind(this), WebInspector.DeviceModeModel.deviceSizeValidator, true);
        this._widthInput = widthInput;
        this._widthItem = this._wrapToolbarItem(widthInput);
        toolbar.appendToolbarItem(this._widthItem);

        var xElement = createElementWithClass("div", "device-mode-x");
        xElement.textContent = "\u00D7";
        this._xItem = this._wrapToolbarItem(xElement);
        toolbar.appendToolbarItem(this._xItem);

        var heightInput = createElementWithClass("input", "device-mode-size-input");
        heightInput.maxLength = 4;
        heightInput.type = "text";
        heightInput.title = WebInspector.UIString("Height (leave empty for full)");
        this._updateHeightInput = WebInspector.bindInput(heightInput, applyHeight.bind(this), validateHeight, true);
        this._heightInput = heightInput;
        this._heightItem = this._wrapToolbarItem(heightInput);
        toolbar.appendToolbarItem(this._heightItem);

        /**
         * @param {string} value
         * @return {boolean}
         */
        function validateHeight(value)
        {
            return !value || WebInspector.DeviceModeModel.deviceSizeValidator(value);
        }

        /**
         * @param {string} value
         * @this {WebInspector.DeviceModeToolbar}
         */
        function applyWidth(value)
        {
            var width = value ? Number(value) : 0;
            this._model.setWidthAndScaleToFit(width);
        }

        /**
         * @param {string} value
         * @this {WebInspector.DeviceModeToolbar}
         */
        function applyHeight(value)
        {
            var height = value ? Number(value) : 0;
            this._model.setHeightAndScaleToFit(height);
        }
    },

    /**
     * @param {!WebInspector.Toolbar} toolbar
     */
    _fillRightToolbar: function(toolbar)
    {
        toolbar.appendToolbarItem(this._wrapToolbarItem(createElementWithClass("div", "device-mode-empty-toolbar-element")));
        this._scaleItem = new WebInspector.ToolbarMenuButton(this._appendScaleMenuItems.bind(this));
        this._scaleItem.setTitle(WebInspector.UIString("Zoom"));
        this._scaleItem.setGlyph("");
        this._scaleItem.turnIntoSelect();
        toolbar.appendToolbarItem(this._scaleItem);

        toolbar.appendToolbarItem(this._wrapToolbarItem(createElementWithClass("div", "device-mode-empty-toolbar-element")));
        this._deviceScaleItem = new WebInspector.ToolbarMenuButton(this._appendDeviceScaleMenuItems.bind(this));
        this._deviceScaleItem.setVisible(this._showDeviceScaleFactorSetting.get());
        this._deviceScaleItem.setTitle(WebInspector.UIString("Device pixel ratio"));
        this._deviceScaleItem.setGlyph("");
        this._deviceScaleItem.turnIntoSelect();
        this._deviceScaleItem.element.style.padding = "0 5px";
        toolbar.appendToolbarItem(this._deviceScaleItem);

        toolbar.appendToolbarItem(this._wrapToolbarItem(createElementWithClass("div", "device-mode-empty-toolbar-element")));
        this._uaItem = new WebInspector.ToolbarMenuButton(this._appendUserAgentMenuItems.bind(this));
        this._uaItem.setVisible(this._showUserAgentTypeSetting.get());
        this._uaItem.setTitle(WebInspector.UIString("Device type"));
        this._uaItem.setGlyph("");
        this._uaItem.turnIntoSelect();
        this._uaItem.element.style.padding = "0 5px";
        toolbar.appendToolbarItem(this._uaItem);
    },

    /**
     * @param {!WebInspector.Toolbar} toolbar
     */
    _fillModeToolbar: function(toolbar)
    {
        toolbar.appendToolbarItem(this._wrapToolbarItem(createElementWithClass("div", "device-mode-empty-toolbar-element")));
        this._modeButton = new WebInspector.ToolbarButton("", "rotate-screen-toolbar-item");
        this._modeButton.addEventListener("click", this._modeMenuClicked, this);
        toolbar.appendToolbarItem(this._modeButton);
    },

    /**
     * @param {!WebInspector.Toolbar} toolbar
     */
    _fillOptionsToolbar: function(toolbar)
    {
        this._networkConditionsItem = WebInspector.NetworkConditionsSelector.createToolbarMenuButton();
        this._networkConditionsItem.setVisible(this._showNetworkConditionsSetting.get());
        this._networkConditionsItem.setTitle(WebInspector.UIString("Network throttling"));
        this._networkConditionsItem.element.style.padding = "0 5px";
        this._networkConditionsItem.element.style.maxWidth = "140px";
        toolbar.appendToolbarItem(this._networkConditionsItem);

        var moreOptionsButton = new WebInspector.ToolbarMenuButton(this._appendOptionsMenuItems.bind(this));
        moreOptionsButton.setTitle(WebInspector.UIString("More options"));
        toolbar.appendToolbarItem(moreOptionsButton);

        toolbar.appendToolbarItem(this._wrapToolbarItem(createElementWithClass("div", "device-mode-empty-toolbar-element")));
    },


    /**
     * @param {!WebInspector.ContextMenu} contextMenu
     */
    _appendScaleMenuItems: function(contextMenu)
    {
        var scaleSetting = this._model.scaleSetting();
        if (this._model.type() === WebInspector.DeviceModeModel.Type.Device) {
            contextMenu.appendItem(WebInspector.UIString("Fit to window (%.0f%%)", this._model.fitScale() * 100), scaleSetting.set.bind(scaleSetting, this._model.fitScale()), false);
            contextMenu.appendSeparator();
        }
        appendScaleItem(WebInspector.UIString("50%"), 0.5);
        appendScaleItem(WebInspector.UIString("75%"), 0.75);
        appendScaleItem(WebInspector.UIString("100%"), 1);
        appendScaleItem(WebInspector.UIString("125%"), 1.25);
        appendScaleItem(WebInspector.UIString("150%"), 1.5);

        /**
         * @param {string} title
         * @param {number} value
         */
        function appendScaleItem(title, value)
        {
            contextMenu.appendCheckboxItem(title, scaleSetting.set.bind(scaleSetting, value), scaleSetting.get() === value, false);
        }
    },

    /**
     * @param {!WebInspector.ContextMenu} contextMenu
     */
    _appendDeviceScaleMenuItems: function(contextMenu)
    {
        var deviceScaleFactorSetting = this._model.deviceScaleFactorSetting();
        var defaultValue = this._model.uaSetting().get() === WebInspector.DeviceModeModel.UA.Mobile || this._model.uaSetting().get() === WebInspector.DeviceModeModel.UA.MobileNoTouch ? WebInspector.DeviceModeModel.defaultMobileScaleFactor : window.devicePixelRatio;
        appendDeviceScaleFactorItem(WebInspector.UIString("Default: %.1f", defaultValue), 0);
        contextMenu.appendSeparator();
        appendDeviceScaleFactorItem(WebInspector.UIString("1"), 1);
        appendDeviceScaleFactorItem(WebInspector.UIString("2"), 2);
        appendDeviceScaleFactorItem(WebInspector.UIString("3"), 3);

        /**
         * @param {string} title
         * @param {number} value
         */
        function appendDeviceScaleFactorItem(title, value)
        {
            contextMenu.appendCheckboxItem(title, deviceScaleFactorSetting.set.bind(deviceScaleFactorSetting, value), deviceScaleFactorSetting.get() === value);
        }
    },

    /**
     * @param {!WebInspector.ContextMenu} contextMenu
     */
    _appendUserAgentMenuItems: function(contextMenu)
    {
        var uaSetting = this._model.uaSetting();
        appendUAItem(WebInspector.DeviceModeModel.UA.Mobile, WebInspector.DeviceModeModel.UA.Mobile);
        appendUAItem(WebInspector.DeviceModeModel.UA.MobileNoTouch, WebInspector.DeviceModeModel.UA.MobileNoTouch);
        appendUAItem(WebInspector.DeviceModeModel.UA.Desktop, WebInspector.DeviceModeModel.UA.Desktop);
        appendUAItem(WebInspector.DeviceModeModel.UA.DesktopTouch, WebInspector.DeviceModeModel.UA.DesktopTouch);

        /**
         * @param {string} title
         * @param {!WebInspector.DeviceModeModel.UA} value
         */
        function appendUAItem(title, value)
        {
            contextMenu.appendCheckboxItem(title, uaSetting.set.bind(uaSetting, value), uaSetting.get() === value);
        }
    },

    /**
     * @param {!WebInspector.ContextMenu} contextMenu
     */
    _appendOptionsMenuItems: function(contextMenu)
    {
        contextMenu.appendCheckboxItem(WebInspector.UIString("Show device pixel ratio"), this._toggleDeviceScaleFactor.bind(this), this._showDeviceScaleFactorSetting.get(), this._model.type() === WebInspector.DeviceModeModel.Type.None);
        contextMenu.appendCheckboxItem(WebInspector.UIString("Show device type"), this._toggleUserAgentType.bind(this), this._showUserAgentTypeSetting.get(), this._model.type() === WebInspector.DeviceModeModel.Type.None);
        contextMenu.appendCheckboxItem(WebInspector.UIString("Show throttling"), this._toggleNetworkConditions.bind(this), this._showNetworkConditionsSetting.get(), this._model.type() === WebInspector.DeviceModeModel.Type.None);
        contextMenu.appendCheckboxItem(WebInspector.UIString("Show media queries"), this._toggleMediaInspector.bind(this), this._showMediaInspectorSetting.get(), this._model.type() === WebInspector.DeviceModeModel.Type.None);
        contextMenu.appendCheckboxItem(WebInspector.UIString("Show rulers"), this._toggleRulers.bind(this), this._showRulersSetting.get(), this._model.type() === WebInspector.DeviceModeModel.Type.None);
        contextMenu.appendSeparator();
        contextMenu.appendItemsAtLocation("deviceModeMenu");
        contextMenu.appendSeparator();
        contextMenu.appendItem(WebInspector.UIString("Reset to defaults"), this._reset.bind(this));
    },

    _toggleDeviceScaleFactor: function()
    {
        this._showDeviceScaleFactorSetting.set(!this._showDeviceScaleFactorSetting.get());
    },

    _toggleUserAgentType: function()
    {
        this._showUserAgentTypeSetting.set(!this._showUserAgentTypeSetting.get());
    },

    _toggleMediaInspector: function()
    {
        this._showMediaInspectorSetting.set(!this._showMediaInspectorSetting.get());
    },

    _toggleRulers: function()
    {
        this._showRulersSetting.set(!this._showRulersSetting.get());
    },

    _toggleNetworkConditions: function()
    {
        this._showNetworkConditionsSetting.set(!this._showNetworkConditionsSetting.get());
    },

    _reset: function()
    {
        this._showDeviceScaleFactorSetting.set(false);
        this._showUserAgentTypeSetting.set(false);
        this._showMediaInspectorSetting.set(false);
        this._showRulersSetting.set(false);
        this._showNetworkConditionsSetting.set(false);
        this._model.reset();
    },

    /**
     * @param {!Element} element
     * @return {!WebInspector.ToolbarItem}
     */
    _wrapToolbarItem: function(element)
    {
        var container = createElement("div");
        var shadowRoot = WebInspector.createShadowRootWithCoreStyles(container, "emulation/deviceModeToolbar.css");
        shadowRoot.appendChild(element);
        return new WebInspector.ToolbarItem(container);
    },

    /**
     * @param {!WebInspector.EmulatedDevice} device
     */
    _emulateDevice: function(device)
    {
        this._model.emulate(WebInspector.DeviceModeModel.Type.Device, device, this._lastMode.get(device) || device.modes[0]);
    },

    _switchToResponsive: function()
    {
        this._model.emulate(WebInspector.DeviceModeModel.Type.Responsive, null, null);
    },

    /**
     * @param {!Array<!WebInspector.EmulatedDevice>} devices
     * @return {!Array<!WebInspector.EmulatedDevice>}
     */
    _filterDevices: function(devices)
    {
        devices = devices.filter(function(d) { return d.show(); });
        devices.sort(WebInspector.EmulatedDevice.deviceComparator);
        return devices;
    },

    /**
     * @return {!Array<!WebInspector.EmulatedDevice>}
     */
    _standardDevices: function()
    {
        return this._filterDevices(this._emulatedDevicesList.standard());
    },

    /**
     * @return {!Array<!WebInspector.EmulatedDevice>}
     */
    _customDevices: function()
    {
        return this._filterDevices(this._emulatedDevicesList.custom());
    },

    /**
     * @return {!Array<!WebInspector.EmulatedDevice>}
     */
    _allDevices: function()
    {
        return this._standardDevices().concat(this._customDevices());
    },

    /**
     * @param {!WebInspector.ContextMenu} contextMenu
     */
    _appendDeviceMenuItems: function(contextMenu)
    {
        contextMenu.appendCheckboxItem(WebInspector.UIString("Responsive"), this._switchToResponsive.bind(this), this._model.type() === WebInspector.DeviceModeModel.Type.Responsive, false);
        appendGroup.call(this, this._standardDevices());
        appendGroup.call(this, this._customDevices());
        contextMenu.appendSeparator();
        contextMenu.appendItem(WebInspector.UIString("Edit\u2026"), this._emulatedDevicesList.revealCustomSetting.bind(this._emulatedDevicesList), false);

        /**
         * @param {!Array<!WebInspector.EmulatedDevice>} devices
         * @this {WebInspector.DeviceModeToolbar}
         */
        function appendGroup(devices)
        {
            if (!devices.length)
                return;
            contextMenu.appendSeparator();
            for (var device of devices)
                contextMenu.appendCheckboxItem(device.title, this._emulateDevice.bind(this, device), this._model.device() === device, false);
        }
    },

    /**
     * @this {WebInspector.DeviceModeToolbar}
     */
    _deviceListChanged: function()
    {
        if (!this._model.device())
            return;

        var devices = this._allDevices();
        if (devices.indexOf(this._model.device()) === -1) {
            if (devices.length)
                this._emulateDevice(devices[0]);
            else
                this._model.emulate(WebInspector.DeviceModeModel.Type.Responsive, null, null);
        }
    },

    _updateDeviceScaleFactorVisibility: function()
    {
        this._deviceScaleItem.setVisible(this._showDeviceScaleFactorSetting.get());
    },

    _updateUserAgentTypeVisibility: function()
    {
        this._uaItem.setVisible(this._showUserAgentTypeSetting.get());
    },

    _updateNetworkConditionsVisibility: function()
    {
        this._networkConditionsItem.setVisible(this._showNetworkConditionsSetting.get());
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _modeMenuClicked: function(event)
    {
        var device = this._model.device();
        var model = this._model;

        if (device.modes.length === 2 && device.modes[0].orientation !== device.modes[1].orientation) {
            model.emulate(model.type(), model.device(), model.mode() === device.modes[0] ? device.modes[1] : device.modes[0]);
            return;
        }

        var contextMenu = new WebInspector.ContextMenu(/** @type {!Event} */ (event.data),
            false,
            event.target.element.totalOffsetLeft(),
            event.target.element.totalOffsetTop() + event.target.element.offsetHeight);
        addOrientation(WebInspector.EmulatedDevice.Vertical, WebInspector.UIString("Portrait"));
        addOrientation(WebInspector.EmulatedDevice.Horizontal, WebInspector.UIString("Landscape"));
        contextMenu.show();

        /**
         * @param {string} orientation
         * @param {string} title
         */
        function addOrientation(orientation, title)
        {
            var modes = device.modesForOrientation(orientation);
            if (!modes.length)
                return;
            if (modes.length === 1) {
                addMode(modes[0], title);
            } else {
                for (var index = 0; index < modes.length; index++)
                    addMode(modes[index], title + " \u2013 " + modes[index].title);
            }
        }

        /**
         * @param {!WebInspector.EmulatedDevice.Mode} mode
         * @param {string} title
         */
        function addMode(mode, title)
        {
            contextMenu.appendCheckboxItem(title, applyMode.bind(null, mode), model.mode() === mode, false);
        }

        /**
         * @param {!WebInspector.EmulatedDevice.Mode} mode
         */
        function applyMode(mode)
        {
            model.emulate(model.type(), model.device(), mode);
        }
    },

    /**
     * @return {!Element}
     */
    element: function()
    {
        return this._element;
    },

    update: function()
    {
        if (this._model.type() !== this._cachedModelType) {
            this._cachedModelType = this._model.type();
            this._widthInput.disabled = this._model.type() !== WebInspector.DeviceModeModel.Type.Responsive;
            this._heightInput.disabled = this._model.type() !== WebInspector.DeviceModeModel.Type.Responsive;
            this._deviceScaleItem.setEnabled(this._model.type() === WebInspector.DeviceModeModel.Type.Responsive);
            this._uaItem.setEnabled(this._model.type() === WebInspector.DeviceModeModel.Type.Responsive);
        }

        var size = this._model.appliedDeviceSize();
        this._updateHeightInput(this._model.type() === WebInspector.DeviceModeModel.Type.Responsive && this._model.isFullHeight() ? "" : String(size.height));
        this._updateWidthInput(String(size.width));
        this._heightInput.placeholder = size.height;

        if (this._model.scale() !== this._cachedScale) {
            this._scaleItem.setText(WebInspector.UIString("%.0f%%", this._model.scale() * 100));
            this._cachedScale = this._model.scale();
        }

        var deviceScale = this._model.appliedDeviceScaleFactor();
        if (deviceScale !== this._cachedDeviceScale) {
            this._deviceScaleItem.setText(WebInspector.UIString("DPR: %.1f", deviceScale));
            this._cachedDeviceScale = deviceScale;
        }

        var uaType = this._model.appliedUserAgentType();
        if (uaType !== this._cachedUaType) {
            this._uaItem.setText(uaType);
            this._cachedUaType = uaType;
        }

        var deviceItemTitle = WebInspector.UIString("None");
        if (this._model.type() === WebInspector.DeviceModeModel.Type.Responsive)
            deviceItemTitle = WebInspector.UIString("Responsive");
        if (this._model.type() === WebInspector.DeviceModeModel.Type.Device)
            deviceItemTitle = this._model.device().title;
        this._deviceSelectItem.setText(deviceItemTitle);

        if (this._model.device() !== this._cachedModelDevice) {
            var device = this._model.device();
            this._modeButton.setVisible(!!device);
            if (device) {
                var modeCount = device ? device.modes.length : 0;
                this._modeButton.setEnabled(modeCount >= 2);
                this._modeButton.setTitle(modeCount === 2 ? WebInspector.UIString("Rotate") : WebInspector.UIString("Screen options"));
            }
            this._cachedModelDevice = device;
        }

        if (this._model.type() === WebInspector.DeviceModeModel.Type.Device)
            this._lastMode.set(/** @type {!WebInspector.EmulatedDevice} */ (this._model.device()), /** @type {!WebInspector.EmulatedDevice.Mode} */ (this._model.mode()));

        if (this._model.mode() !== this._cachedModelMode && this._model.type() !== WebInspector.DeviceModeModel.Type.None) {
            this._cachedModelMode = this._model.mode();
            var value = this._persistenceSetting.get();
            if (this._model.device()) {
                value.device = this._model.device().title;
                value.orientation = this._model.mode() ? this._model.mode().orientation : "";
                value.mode = this._model.mode() ? this._model.mode().title : "";
            } else {
                value.device = "";
                value.orientation = "";
                value.mode = "";
            }
            this._persistenceSetting.set(value);
        }
    },

    restore: function()
    {
        for (var device of this._allDevices()) {
            if (device.title === this._persistenceSetting.get().device) {
                for (var mode of device.modes) {
                    if (mode.orientation === this._persistenceSetting.get().orientation && mode.title === this._persistenceSetting.get().mode) {
                        this._lastMode.set(device, mode);
                        this._emulateDevice(device);
                        return;
                    }
                }
            }
        }

        this._model.emulate(WebInspector.DeviceModeModel.Type.Responsive, null, null);
    }
}
;/* DeviceModeView.js */
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.VBox}
 */
WebInspector.DeviceModeView = function()
{
    WebInspector.VBox.call(this, true);
    this.setMinimumSize(150, 150);
    this.element.classList.add("device-mode-view");
    this.registerRequiredCSS("emulation/deviceModeView.css");
    WebInspector.Tooltip.addNativeOverrideContainer(this.contentElement);

    this._model = new WebInspector.DeviceModeModel(this._updateUI.bind(this));
    this._mediaInspector = new WebInspector.MediaQueryInspector(() => this._model.appliedDeviceSize().width, this._model.setWidth.bind(this._model));
    // TODO(dgozman): remove CountUpdated event.
    this._showMediaInspectorSetting = WebInspector.settings.createSetting("showMediaQueryInspector", false);
    this._showMediaInspectorSetting.addChangeListener(this._updateUI, this);
    this._showRulersSetting = WebInspector.settings.createSetting("emulation.showRulers", false);
    this._showRulersSetting.addChangeListener(this._updateUI, this);

    this._topRuler = new WebInspector.DeviceModeView.Ruler(true, this._model.setWidthAndScaleToFit.bind(this._model));
    this._topRuler.element.classList.add("device-mode-ruler-top");
    this._leftRuler = new WebInspector.DeviceModeView.Ruler(false, this._model.setHeightAndScaleToFit.bind(this._model));
    this._leftRuler.element.classList.add("device-mode-ruler-left");
    this._createUI();
    WebInspector.zoomManager.addEventListener(WebInspector.ZoomManager.Events.ZoomChanged, this._zoomChanged, this);
};

WebInspector.DeviceModeView.prototype = {
    _createUI: function()
    {
        this._toolbar = new WebInspector.DeviceModeToolbar(this._model, this._showMediaInspectorSetting, this._showRulersSetting);
        this.contentElement.appendChild(this._toolbar.element());

        this._contentClip = this.contentElement.createChild("div", "device-mode-content-clip vbox");
        this._responsivePresetsContainer = this._contentClip.createChild("div", "device-mode-presets-container");
        this._populatePresetsContainer();
        this._mediaInspectorContainer = this._contentClip.createChild("div", "device-mode-media-container");
        this._contentArea = this._contentClip.createChild("div", "device-mode-content-area");

        this._screenArea = this._contentArea.createChild("div", "device-mode-screen-area");
        this._screenImage = this._screenArea.createChild("img", "device-mode-screen-image hidden");
        this._screenImage.addEventListener("load", this._onScreenImageLoaded.bind(this, true), false);
        this._screenImage.addEventListener("error", this._onScreenImageLoaded.bind(this, false), false);

        this._bottomRightResizerElement = this._screenArea.createChild("div", "device-mode-resizer device-mode-bottom-right-resizer");
        this._bottomRightResizerElement.createChild("div", "");
        this._createResizer(this._bottomRightResizerElement, 2, 1);

        this._bottomLeftResizerElement = this._screenArea.createChild("div", "device-mode-resizer device-mode-bottom-left-resizer");
        this._bottomLeftResizerElement.createChild("div", "");
        this._createResizer(this._bottomLeftResizerElement, -2, 1);

        this._rightResizerElement = this._screenArea.createChild("div", "device-mode-resizer device-mode-right-resizer");
        this._rightResizerElement.createChild("div", "");
        this._createResizer(this._rightResizerElement, 2, 0);

        this._leftResizerElement = this._screenArea.createChild("div", "device-mode-resizer device-mode-left-resizer");
        this._leftResizerElement.createChild("div", "");
        this._createResizer(this._leftResizerElement, -2, 0);

        this._bottomResizerElement = this._screenArea.createChild("div", "device-mode-resizer device-mode-bottom-resizer");
        this._bottomResizerElement.createChild("div", "");
        this._createResizer(this._bottomResizerElement, 0, 1);
        this._bottomResizerElement.addEventListener("dblclick", this._model.setHeight.bind(this._model, 0), false);
        this._bottomResizerElement.title = WebInspector.UIString("Double-click for full height");

        this._pageArea = this._screenArea.createChild("div", "device-mode-page-area");
        this._pageArea.createChild("content");
    },

    _populatePresetsContainer: function()
    {
        var sizes = [320, 375, 425, 768, 1024, 1440, 2560];
        var titles = [WebInspector.UIString("Mobile S"),
                      WebInspector.UIString("Mobile M"),
                      WebInspector.UIString("Mobile L"),
                      WebInspector.UIString("Tablet"),
                      WebInspector.UIString("Laptop"),
                      WebInspector.UIString("Laptop L"),
                      WebInspector.UIString("4K")]
        this._presetBlocks = [];
        var inner = this._responsivePresetsContainer.createChild("div", "device-mode-presets-container-inner")
        for (var i = sizes.length - 1; i >= 0; --i) {
            var outer = inner.createChild("div", "fill device-mode-preset-bar-outer");
            var block = outer.createChild("div", "device-mode-preset-bar");
            block.createChild("span").textContent = titles[i] + " \u2013 " + sizes[i] + "px";
            block.addEventListener("click", applySize.bind(this, sizes[i]), false);
            block.__width = sizes[i];
            this._presetBlocks.push(block);
        }

        /**
         * @param {number} width
         * @param {!Event} e
         * @this {WebInspector.DeviceModeView}
         */
        function applySize(width, e)
        {
            this._model.emulate(WebInspector.DeviceModeModel.Type.Responsive, null, null);
            this._model.setSizeAndScaleToFit(width, 0);
            e.consume();
        }
    },

    toggleDeviceMode: function()
    {
        this._toolbar.toggleDeviceMode();
    },

    /**
     * @param {!Element} element
     * @param {number} widthFactor
     * @param {number} heightFactor
     * @return {!WebInspector.ResizerWidget}
     */
    _createResizer: function(element, widthFactor, heightFactor)
    {
        var resizer = new WebInspector.ResizerWidget();
        resizer.addElement(element);
        var cursor = widthFactor ? "ew-resize" : "ns-resize";
        if (widthFactor * heightFactor > 0)
            cursor = "nwse-resize";
        if (widthFactor * heightFactor < 0)
            cursor = "nesw-resize";
        resizer.setCursor(cursor);
        resizer.addEventListener(WebInspector.ResizerWidget.Events.ResizeStart, this._onResizeStart, this);
        resizer.addEventListener(WebInspector.ResizerWidget.Events.ResizeUpdate, this._onResizeUpdate.bind(this, widthFactor, heightFactor));
        resizer.addEventListener(WebInspector.ResizerWidget.Events.ResizeEnd, this._onResizeEnd, this);
        return resizer;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onResizeStart: function(event)
    {
        this._slowPositionStart = null;
        /** @type {!Size} */
        this._resizeStart = this._model.screenRect().size();
    },

    /**
     * @param {number} widthFactor
     * @param {number} heightFactor
     * @param {!WebInspector.Event} event
     */
    _onResizeUpdate: function(widthFactor, heightFactor, event)
    {
        if (event.data.shiftKey !== !!this._slowPositionStart)
            this._slowPositionStart = event.data.shiftKey ? {x: event.data.currentX, y: event.data.currentY} : null;

        var cssOffsetX = event.data.currentX - event.data.startX;
        var cssOffsetY = event.data.currentY - event.data.startY;
        if (this._slowPositionStart) {
            cssOffsetX = (event.data.currentX - this._slowPositionStart.x) / 10 + this._slowPositionStart.x - event.data.startX;
            cssOffsetY = (event.data.currentY - this._slowPositionStart.y) / 10 + this._slowPositionStart.y - event.data.startY;
        }

        if (widthFactor) {
            var dipOffsetX = cssOffsetX * WebInspector.zoomManager.zoomFactor();
            var newWidth = this._resizeStart.width + dipOffsetX * widthFactor;
            newWidth = Math.round(newWidth / this._model.scale());
            if (newWidth >= WebInspector.DeviceModeModel.MinDeviceSize && newWidth <= WebInspector.DeviceModeModel.MaxDeviceSize)
                this._model.setWidth(newWidth);
        }

        if (heightFactor) {
            var dipOffsetY = cssOffsetY * WebInspector.zoomManager.zoomFactor();
            var newHeight = this._resizeStart.height + dipOffsetY * heightFactor;
            newHeight = Math.round(newHeight / this._model.scale());
            if (newHeight >= WebInspector.DeviceModeModel.MinDeviceSize && newHeight <= WebInspector.DeviceModeModel.MaxDeviceSize)
                this._model.setHeight(newHeight);
        }
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onResizeEnd: function(event)
    {
        delete this._resizeStart;
        WebInspector.userMetrics.actionTaken(WebInspector.UserMetrics.Action.ResizedViewInResponsiveMode);
    },

    _updateUI: function()
    {
        if (!this.isShowing())
            return;

        var zoomFactor = WebInspector.zoomManager.zoomFactor();
        var callDoResize = false;
        var showRulers = this._showRulersSetting.get() && this._model.type() !== WebInspector.DeviceModeModel.Type.None;
        var contentAreaResized = false;
        var updateRulers = false;

        var cssScreenRect = this._model.screenRect().scale(1 / zoomFactor);
        if (!cssScreenRect.isEqual(this._cachedCssScreenRect)) {
            this._screenArea.style.left = cssScreenRect.left + "px";
            this._screenArea.style.top = cssScreenRect.top + "px";
            this._screenArea.style.width = cssScreenRect.width + "px";
            this._screenArea.style.height = cssScreenRect.height + "px";
            this._leftRuler.element.style.left = cssScreenRect.left + "px";
            updateRulers = true;
            callDoResize = true;
            this._cachedCssScreenRect = cssScreenRect;
        }

        var cssVisiblePageRect = this._model.visiblePageRect().scale(1 / zoomFactor);
        if (!cssVisiblePageRect.isEqual(this._cachedCssVisiblePageRect)) {
            this._pageArea.style.left = cssVisiblePageRect.left + "px";
            this._pageArea.style.top = cssVisiblePageRect.top + "px";
            this._pageArea.style.width = cssVisiblePageRect.width + "px";
            this._pageArea.style.height = cssVisiblePageRect.height + "px";
            callDoResize = true;
            this._cachedCssVisiblePageRect = cssVisiblePageRect;
        }

        var resizable = this._model.type() === WebInspector.DeviceModeModel.Type.Responsive;
        if (resizable !== this._cachedResizable) {
            this._rightResizerElement.classList.toggle("hidden", !resizable);
            this._leftResizerElement.classList.toggle("hidden", !resizable);
            this._bottomResizerElement.classList.toggle("hidden", !resizable);
            this._bottomRightResizerElement.classList.toggle("hidden", !resizable);
            this._bottomLeftResizerElement.classList.toggle("hidden", !resizable);
            this._cachedResizable = resizable;
        }

        var mediaInspectorVisible = this._showMediaInspectorSetting.get() && this._model.type() !== WebInspector.DeviceModeModel.Type.None;
        if (mediaInspectorVisible !== this._cachedMediaInspectorVisible) {
            if (mediaInspectorVisible)
                this._mediaInspector.show(this._mediaInspectorContainer);
            else
                this._mediaInspector.detach();
            contentAreaResized = true;
            callDoResize = true;
            this._cachedMediaInspectorVisible = mediaInspectorVisible;
        }

        if (showRulers !== this._cachedShowRulers) {
            this._contentClip.classList.toggle("device-mode-rulers-visible", showRulers);
            if (showRulers) {
                this._topRuler.show(this._contentClip, this._contentArea);
                this._leftRuler.show(this._contentArea);
            } else {
                this._topRuler.detach();
                this._leftRuler.detach();
            }
            contentAreaResized = true;
            callDoResize = true;
            this._cachedShowRulers = showRulers;
        }

        if (this._model.scale() !== this._cachedScale) {
            updateRulers = true;
            callDoResize = true;
            for (var block of this._presetBlocks)
                block.style.width = block.__width * this._model.scale() + "px";
            this._cachedScale = this._model.scale();
        }

        this._toolbar.update();
        this._loadScreenImage(this._model.screenImage());
        this._mediaInspector.setAxisTransform(this._model.scale());
        if (callDoResize)
            this.doResize();
        if (updateRulers) {
            this._topRuler.render(this._cachedCssScreenRect ? this._cachedCssScreenRect.left : 0, this._model.scale());
            this._leftRuler.render(0, this._model.scale());
        }
        if (contentAreaResized)
            this._contentAreaResized();
    },

    /**
     * @param {string} srcset
     */
    _loadScreenImage: function(srcset)
    {
        if (this._screenImage.getAttribute("srcset") === srcset)
            return;
        this._screenImage.setAttribute("srcset", srcset);
        if (!srcset)
            this._screenImage.classList.toggle("hidden", true);
    },

    /**
     * @param {boolean} success
     */
    _onScreenImageLoaded: function(success)
    {
        this._screenImage.classList.toggle("hidden", !success);
    },

    _contentAreaResized: function()
    {
        var zoomFactor = WebInspector.zoomManager.zoomFactor();
        var rect = this._contentArea.getBoundingClientRect();
        var availableSize = new Size(Math.max(rect.width * zoomFactor, 1), Math.max(rect.height * zoomFactor, 1));
        var preferredSize = new Size(Math.max((rect.width - 2 * this._handleWidth) * zoomFactor, 1), Math.max((rect.height - this._handleHeight) * zoomFactor, 1));
        this._model.setAvailableSize(availableSize, preferredSize);
    },

    _measureHandles: function()
    {
        var hidden = this._rightResizerElement.classList.contains("hidden");
        this._rightResizerElement.classList.toggle("hidden", false);
        this._bottomResizerElement.classList.toggle("hidden", false);
        this._handleWidth = this._rightResizerElement.offsetWidth;
        this._handleHeight = this._bottomResizerElement.offsetHeight;
        this._rightResizerElement.classList.toggle("hidden", hidden);
        this._bottomResizerElement.classList.toggle("hidden", hidden);
    },

    _zoomChanged: function()
    {
        delete this._handleWidth;
        delete this._handleHeight;
        if (this.isShowing()) {
            this._measureHandles();
            this._contentAreaResized();
        }
    },

    /**
     * @override
     */
    onResize: function()
    {
        if (this.isShowing())
            this._contentAreaResized();
    },

    /**
     * @override
     */
    wasShown: function()
    {
        this._measureHandles();
        this._toolbar.restore();
    },

    /**
     * @override
     */
    willHide: function()
    {
        this._model.emulate(WebInspector.DeviceModeModel.Type.None, null, null);
    },

    __proto__: WebInspector.VBox.prototype
}

/**
 * @constructor
 * @extends {WebInspector.VBox}
 * @param {boolean} horizontal
 * @param {function(number)} applyCallback
 */
WebInspector.DeviceModeView.Ruler = function(horizontal, applyCallback)
{
    WebInspector.VBox.call(this);
    this._contentElement = this.element.createChild("div", "device-mode-ruler flex-auto");
    this._horizontal = horizontal;
    this._scale = 1;
    this._offset = 0;
    this._count = 0;
    this._throttler = new WebInspector.Throttler(0);
    this._applyCallback = applyCallback;
}

WebInspector.DeviceModeView.Ruler.prototype = {
    /**
     * @param {number} offset
     * @param {number} scale
     */
    render: function(offset, scale)
    {
        this._scale = scale;
        this._offset = offset;
        if (this._horizontal)
            this.element.style.paddingLeft = this._offset + "px";
        else
            this.element.style.paddingTop = this._offset + "px";
        this._throttler.schedule(this._update.bind(this));
    },

    /**
     * @override
     */
    onResize: function()
    {
        this._throttler.schedule(this._update.bind(this));
    },

    /**
     * @return {!Promise.<?>}
     */
    _update: function()
    {
        var zoomFactor = WebInspector.zoomManager.zoomFactor();
        var size = this._horizontal ? this._contentElement.offsetWidth : this._contentElement.offsetHeight;

        if (this._scale !== this._renderedScale || zoomFactor !== this._renderedZoomFactor) {
            this._contentElement.removeChildren();
            this._count = 0;
            this._renderedScale = this._scale;
            this._renderedZoomFactor = zoomFactor;
        }

        var dipSize = size * zoomFactor / this._scale;
        var count = Math.ceil(dipSize / 5);
        var step = 1;
        if (this._scale < 0.8)
            step = 2;
        if (this._scale < 0.6)
            step = 4;
        if (this._scale < 0.4)
            step = 8;

        for (var i = count; i < this._count; i++) {
            if (!(i % step))
                this._contentElement.lastChild.remove();
        }

        for (var i = this._count; i < count; i++) {
            if (i % step)
                continue;
            var marker = this._contentElement.createChild("div", "device-mode-ruler-marker");
            if (i) {
                if (this._horizontal)
                    marker.style.left = (5 * i) * this._scale / zoomFactor + "px";
                else
                    marker.style.top = (5 * i) * this._scale / zoomFactor + "px";
                if (!(i % 20)) {
                    var text = marker.createChild("div", "device-mode-ruler-text");
                    text.textContent = i * 5;
                    text.addEventListener("click", this._onMarkerClick.bind(this, i * 5), false);
                }
            }
            if (!(i % 10))
                marker.classList.add("device-mode-ruler-marker-large");
            else if (!(i % 5))
                marker.classList.add("device-mode-ruler-marker-medium");
        }

        this._count = count;
        return Promise.resolve();
    },

    /**
     * @param {number} size
     */
    _onMarkerClick: function(size)
    {
        this._applyCallback.call(null, size);
    },

    __proto__: WebInspector.VBox.prototype
}
;/* DeviceModeWrapper.js */
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @extends {WebInspector.VBox}
 * @param {!WebInspector.InspectedPagePlaceholder} inspectedPagePlaceholder
 * @constructor
 */
WebInspector.DeviceModeWrapper = function(inspectedPagePlaceholder)
{
    WebInspector.VBox.call(this);
    WebInspector.DeviceModeView._wrapperInstance = this;
    this._inspectedPagePlaceholder = inspectedPagePlaceholder;
    /** @type {?WebInspector.DeviceModeView} */
    this._deviceModeView = null;
    this._toggleDeviceModeAction = WebInspector.actionRegistry.action("emulation.toggle-device-mode");
    this._showDeviceModeSetting = WebInspector.settings.createSetting("emulation.showDeviceMode", false);
    this._showDeviceModeSetting.addChangeListener(this._update.bind(this, false));
    this._update(true);
}

/** @type {!WebInspector.DeviceModeWrapper} */
WebInspector.DeviceModeView._wrapperInstance;

WebInspector.DeviceModeWrapper.prototype = {
    _toggleDeviceMode: function()
    {
        this._showDeviceModeSetting.set(!this._showDeviceModeSetting.get());
    },

    /**
     * @param {boolean} force
     */
    _update: function(force)
    {
        this._toggleDeviceModeAction.setToggled(this._showDeviceModeSetting.get());
        if (!force) {
            var showing = this._deviceModeView && this._deviceModeView.isShowing();
            if (this._showDeviceModeSetting.get() === showing)
                return;
        }

        if (this._showDeviceModeSetting.get()) {
            if (!this._deviceModeView)
                this._deviceModeView = new WebInspector.DeviceModeView();
            this._deviceModeView.show(this.element);
            this._inspectedPagePlaceholder.clearMinimumSizeAndMargins();
            this._inspectedPagePlaceholder.show(this._deviceModeView.element);
        } else {
            if (this._deviceModeView)
                this._deviceModeView.detach();
            this._inspectedPagePlaceholder.restoreMinimumSizeAndMargins();
            this._inspectedPagePlaceholder.show(this.element);
        }
    },

    __proto__: WebInspector.VBox.prototype
}

/**
 * @constructor
 * @implements {WebInspector.ActionDelegate}
 */
WebInspector.DeviceModeWrapper.ActionDelegate = function()
{
}

WebInspector.DeviceModeWrapper.ActionDelegate.prototype = {
    /**
     * @override
     * @param {!WebInspector.Context} context
     * @param {string} actionId
     * @return {boolean}
     */
    handleAction: function(context, actionId)
    {
        if (WebInspector.DeviceModeView._wrapperInstance) {
            if (actionId === "emulation.toggle-device-mode") {
                WebInspector.DeviceModeView._wrapperInstance._toggleDeviceMode();
                return true;
            }
            if (actionId === "emulation.request-app-banner") {
                var target = WebInspector.targetManager.mainTarget();
                if (target && target.isPage())
                    target.pageAgent().requestAppBanner();
                return true;
            }
        }
        return false;
    }
}
;
/* Module main */
/* FrontendWebSocketAPI.js */
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @implements {WebInspector.Linkifier.LinkHandler}
 */
WebInspector.FrontendWebSocketAPI = function()
{
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.DispatchFrontendAPIMessage, this._onFrontendAPIMessage, this);
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.FrontendAPIAttached, this._onAttach, this);
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.FrontendAPIDetached, this._onDetach, this);
}

WebInspector.FrontendWebSocketAPI.prototype = {
    _onAttach: function()
    {
        WebInspector.workspace.addEventListener(WebInspector.Workspace.Events.WorkingCopyCommittedByUser, this._workingCopyCommitted, this);
        WebInspector.workspace.addEventListener(WebInspector.Workspace.Events.WorkingCopyChanged, this._workingCopyChanged, this);
        WebInspector.Linkifier.setLinkHandler(this);
    },

    _onDetach: function()
    {
        WebInspector.workspace.removeEventListener(WebInspector.Workspace.Events.WorkingCopyCommittedByUser, this._workingCopyCommitted, this);
        WebInspector.workspace.removeEventListener(WebInspector.Workspace.Events.WorkingCopyChanged, this._workingCopyChanged, this);
        WebInspector.Linkifier.setLinkHandler(null);
    },

    /**
     * @override
     * @param {string} url
     * @param {number=} lineNumber
     * @return {boolean}
     */
    handleLink: function(url, lineNumber)
    {
        var uiSourceCode = WebInspector.networkMapping.uiSourceCodeForURLForAnyTarget(url);
        if (uiSourceCode)
            url = uiSourceCode.url();
        if (url.startsWith("file://")) {
            var file = url.substring(7);
            this._issueFrontendAPINotification("Frontend.revealLocation", { file: file, line: lineNumber });
            return true;
        }
        return false;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _onFrontendAPIMessage: function(event)
    {
        var message = JSON.parse(/** @type {string} */ (event.data));
        this._dispatchFrontendAPIMessage(message["id"], message["method"], message["params"] || null);
    },

    /**
     * @param {number} id
     * @param {string} method
     * @param {?Object} params
     */
    _dispatchFrontendAPIMessage: function(id, method, params)
    {
        this._dispatchingFrontendMessage = true;
        switch (method) {
        case "Frontend.updateBuffer":
            var file = params["file"];
            var buffer = params["buffer"];
            var saved = params["saved"];
            var uiSourceCode = WebInspector.workspace.uiSourceCodeForURL("file://" + file);
            if (uiSourceCode) {
                if (buffer !== uiSourceCode.workingCopy())
                    uiSourceCode.setWorkingCopy(buffer);
                if (saved)
                    uiSourceCode.checkContentUpdated(true);
            }
            break;
        default:
            WebInspector.console.log("Unhandled API message: " + method);
        }
        this._issueResponse(id);
        this._dispatchingFrontendMessage = false;
    },

    /**
     * @param {!WebInspector.Event} event
     * @param {boolean=} saved
     */
    _workingCopyChanged: function(event, saved)
    {
        if (this._dispatchingFrontendMessage)
            return;
        var uiSourceCode = /** @type {!WebInspector.UISourceCode} */ (event.data["uiSourceCode"]);
        var url = uiSourceCode.url();
        if (url.startsWith("file://"))
            url = url.substring(7);
        var params = { file: url, buffer: uiSourceCode.workingCopy() };
        if (saved)
            params.saved = true;
        this._issueFrontendAPINotification("Frontend.bufferUpdated", params);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _workingCopyCommitted: function(event)
    {
        this._workingCopyChanged(event, true);
    },

    /**
     * @param {number} id
     * @param {!Object=} params
     */
    _issueResponse: function(id, params)
    {
        var object = {id: id};
        if (params)
            object.params = params;
        InspectorFrontendHost.sendFrontendAPINotification(JSON.stringify(object));
    },

    /**
     * @param {string} method
     * @param {?Object} params
     */
    _issueFrontendAPINotification: function(method, params)
    {
        InspectorFrontendHost.sendFrontendAPINotification(JSON.stringify({ method: method, params: params }));
    }
}
;/* RenderingOptions.js */
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.VBox}
 * @implements {WebInspector.TargetManager.Observer}
 */
WebInspector.RenderingOptionsView = function()
{
    WebInspector.VBox.call(this, true);
    this.registerRequiredCSS("main/renderingOptions.css");

    /** @type {!Map.<string, !Element>} */
    this._settings = new Map();

    this._appendCheckbox(WebInspector.UIString("Enable paint flashing"), "setShowPaintRects");
    this._appendCheckbox(WebInspector.UIString("Show layer borders"), "setShowDebugBorders");
    this._appendCheckbox(WebInspector.UIString("Show FPS meter"), "setShowFPSCounter");
    var scrollingTitle = WebInspector.UIString("Shows areas of the page that slow down scrolling:\nTouch and mousewheel event listeners can delay scrolling.\nSome areas need to repaint their content when scrolled.");
    this._appendCheckbox(WebInspector.UIString("Show scrolling perf issues"), "setShowScrollBottleneckRects", scrollingTitle);

    // CSS media.
    var mediaRow = this.contentElement.createChild("div", "media-row");
    var checkboxLabel = createCheckboxLabel(WebInspector.UIString("Emulate media"), false);
    this._mediaCheckbox = checkboxLabel.checkboxElement;
    this._mediaCheckbox.addEventListener("click", this._mediaToggled.bind(this), false);
    mediaRow.appendChild(checkboxLabel);
    this._mediaSelect = mediaRow.createChild("select", "chrome-select");
    this._mediaSelect.appendChild(new Option(WebInspector.UIString("print"), "print"));
    this._mediaSelect.appendChild(new Option(WebInspector.UIString("screen"), "screen"));
    this._mediaSelect.addEventListener("change", this._mediaToggled.bind(this), false);
    this._mediaSelect.disabled = true;

    WebInspector.targetManager.observeTargets(this, WebInspector.Target.Type.Page);
}

WebInspector.RenderingOptionsView.prototype = {
    /**
     * @param {string} label
     * @param {string} setterName
     * @param {string=} title
     */
    _appendCheckbox: function(label, setterName, title)
    {
        var checkboxLabel = createCheckboxLabel(label, false);
        this._settings.set(setterName, checkboxLabel.checkboxElement);
        checkboxLabel.checkboxElement.addEventListener("click", this._settingToggled.bind(this, setterName));
        if (title)
            checkboxLabel.title = title;
        this.contentElement.appendChild(checkboxLabel);
    },

    /**
     * @param {string} setterName
     */
    _settingToggled: function(setterName)
    {
        var enabled = this._settings.get(setterName).checked;
        var targets = WebInspector.targetManager.targets(WebInspector.Target.Type.Page);
        for (var i = 0; i < targets.length; ++i)
            targets[i].renderingAgent()[setterName](enabled);
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target)
    {
        for (var setterName of this._settings.keysArray()) {
            if (this._settings.get(setterName).checked)
                target.renderingAgent()[setterName](true);
        }
        if (this._mediaCheckbox.checked)
            this._applyPrintMediaOverride(target);
    },

    _mediaToggled: function()
    {
        this._mediaSelect.disabled = !this._mediaCheckbox.checked;
        var targets = WebInspector.targetManager.targets(WebInspector.Target.Type.Page);
        for (var target of targets)
            this._applyPrintMediaOverride(target);
    },

    /**
     * @param {!WebInspector.Target} target
     */
    _applyPrintMediaOverride: function(target)
    {
        target.emulationAgent().setEmulatedMedia(this._mediaCheckbox.checked ? this._mediaSelect.value : "");
        var cssModel = WebInspector.CSSStyleModel.fromTarget(target);
        if (cssModel)
            cssModel.mediaQueryResultChanged();
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target)
    {
    },

    __proto__: WebInspector.VBox.prototype
}

/**
 * @return {!WebInspector.RenderingOptionsView}
 */
WebInspector.RenderingOptionsView.instance = function()
{
    if (!WebInspector.RenderingOptionsView._instanceObject)
        WebInspector.RenderingOptionsView._instanceObject = new WebInspector.RenderingOptionsView();
    return WebInspector.RenderingOptionsView._instanceObject;
}

/**
 * @constructor
 * @implements {WebInspector.ActionDelegate}
 */
WebInspector.RenderingOptionsView.ShowActionDelegate = function()
{
}

WebInspector.RenderingOptionsView.ShowActionDelegate.prototype = {
    /**
     * @override
     * @param {!WebInspector.Context} context
     * @param {string} actionId
     * @return {boolean}
     */
    handleAction: function(context, actionId)
    {
        WebInspector.inspectorView.showViewInDrawer("rendering");
        return true;
    }
};/* SimpleApp.js */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @implements {WebInspector.App}
 */
WebInspector.SimpleApp = function()
{
};

WebInspector.SimpleApp.prototype = {
    /**
     * @override
     * @param {!Document} document
     */
    presentUI: function(document)
    {
        var rootView = new WebInspector.RootView();
        WebInspector.inspectorView.show(rootView.element);
        WebInspector.inspectorView.showInitialPanel();
        rootView.attachToDocument(document);
    }
};

/**
 * @constructor
 * @implements {WebInspector.AppProvider}
 */
WebInspector.SimpleAppProvider = function()
{
};

WebInspector.SimpleAppProvider.prototype = {
    /**
     * @override
     * @return {!WebInspector.App}
     */
    createApp: function()
    {
        return new WebInspector.SimpleApp();
    }
};
;/* Tests.js */
/*
 * Copyright (C) 2010 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/**
 * @fileoverview This file contains small testing framework along with the
 * test suite for the frontend. These tests are a part of the continues build
 * and are executed by the devtools_sanity_unittest.cc as a part of the
 * Interactive UI Test suite.
 * FIXME: change field naming style to use trailing underscore.
 */

function createTestSuite(domAutomationController)
{

/**
 * Test suite for interactive UI tests.
 * @constructor
 */
function TestSuite()
{
    WebInspector.TestBase.call(this, domAutomationController);
    this._asyncInvocationId = 0;
};

TestSuite.prototype = {
    __proto__: WebInspector.TestBase.prototype
};


/**
 * @param {string} panelName Name of the panel to show.
 */
TestSuite.prototype.showPanel = function(panelName)
{
    return WebInspector.inspectorView.showPanel(panelName);
};

// UI Tests


/**
 * Tests that scripts tab can be open and populated with inspected scripts.
 */
TestSuite.prototype.testShowScriptsTab = function()
{
    var test = this;
    this.showPanel("sources").then(function() {
        // There should be at least main page script.
        this._waitUntilScriptsAreParsed(["debugger_test_page.html"],
            function() {
                test.releaseControl();
            });
    }.bind(this));
    // Wait until all scripts are added to the debugger.
    this.takeControl();
};


/**
 * Tests that scripts tab is populated with inspected scripts even if it
 * hadn't been shown by the moment inspected paged refreshed.
 * @see http://crbug.com/26312
 */
TestSuite.prototype.testScriptsTabIsPopulatedOnInspectedPageRefresh = function()
{
    var test = this;
    var debuggerModel = WebInspector.DebuggerModel.fromTarget(WebInspector.targetManager.mainTarget());
    debuggerModel.addEventListener(WebInspector.DebuggerModel.Events.GlobalObjectCleared, waitUntilScriptIsParsed);

    this.showPanel("elements").then(function() {
        // Reload inspected page. It will reset the debugger agent.
        test.evaluateInConsole_("window.location.reload(true);", function(resultText) {});
    });

    function waitUntilScriptIsParsed()
    {
        debuggerModel.removeEventListener(WebInspector.DebuggerModel.Events.GlobalObjectCleared, waitUntilScriptIsParsed);
        test.showPanel("sources").then(function() {
            test._waitUntilScriptsAreParsed(["debugger_test_page.html"],
                function() {
                    test.releaseControl();
                });
        });
    }

    // Wait until all scripts are added to the debugger.
    this.takeControl();
};


/**
 * Tests that scripts list contains content scripts.
 */
TestSuite.prototype.testContentScriptIsPresent = function()
{
    var test = this;
    this.showPanel("sources").then(function() {
        test._waitUntilScriptsAreParsed(
            ["page_with_content_script.html", "simple_content_script.js"],
            function() {
                test.releaseControl();
            });
    });

    // Wait until all scripts are added to the debugger.
    this.takeControl();
};


/**
 * Tests that scripts are not duplicaed on Scripts tab switch.
 */
TestSuite.prototype.testNoScriptDuplicatesOnPanelSwitch = function()
{
    var test = this;

    // There should be two scripts: one for the main page and another
    // one which is source of console API(see
    // InjectedScript._ensureCommandLineAPIInstalled).
    var expectedScriptsCount = 2;
    var parsedScripts = [];

    function switchToElementsTab() {
        test.showPanel("elements").then(function() {
            setTimeout(switchToScriptsTab, 0);
        });
    }

    function switchToScriptsTab() {
        test.showPanel("sources").then(function() {
            setTimeout(checkScriptsPanel, 0);
        });
    }

    function checkScriptsPanel() {
        test.assertTrue(test._scriptsAreParsed(["debugger_test_page.html"]), "Some scripts are missing.");
        checkNoDuplicates();
        test.releaseControl();
    }

    function checkNoDuplicates() {
        var uiSourceCodes = test.nonAnonymousUISourceCodes_();
        for (var i = 0; i < uiSourceCodes.length; i++) {
            var scriptName = WebInspector.networkMapping.networkURL(uiSourceCodes[i]);
            for (var j = i + 1; j < uiSourceCodes.length; j++)
                test.assertTrue(scriptName !== WebInspector.networkMapping.networkURL(uiSourceCodes[j]), "Found script duplicates: " + test.uiSourceCodesToString_(uiSourceCodes));
        }
    }

    this.showPanel("sources").then(function() {
        test._waitUntilScriptsAreParsed(
            ["debugger_test_page.html"],
            function() {
                checkNoDuplicates();
                setTimeout(switchToElementsTab, 0);
            });
    });

    // Wait until all scripts are added to the debugger.
    this.takeControl();
};


// Tests that debugger works correctly if pause event occurs when DevTools
// frontend is being loaded.
TestSuite.prototype.testPauseWhenLoadingDevTools = function()
{
    var debuggerModel = WebInspector.DebuggerModel.fromTarget(WebInspector.targetManager.mainTarget());
    if (debuggerModel.debuggerPausedDetails)
        return;

    this.showPanel("sources").then(function() {
        // Script execution can already be paused.

        this._waitForScriptPause(this.releaseControl.bind(this));
    }.bind(this));

    this.takeControl();
};


// Tests that pressing "Pause" will pause script execution if the script
// is already running.
TestSuite.prototype.testPauseWhenScriptIsRunning = function()
{
    this.showPanel("sources").then(function() {
        this.evaluateInConsole_(
            'setTimeout("handleClick()", 0)',
            didEvaluateInConsole.bind(this));
    }.bind(this));

    function didEvaluateInConsole(resultText) {
        this.assertTrue(!isNaN(resultText), "Failed to get timer id: " + resultText);
        // Wait for some time to make sure that inspected page is running the
        // infinite loop.
        setTimeout(testScriptPause.bind(this), 300);
    }

    function testScriptPause() {
        // The script should be in infinite loop. Click "Pause" button to
        // pause it and wait for the result.
        WebInspector.panels.sources._togglePause();

        this._waitForScriptPause(this.releaseControl.bind(this));
    }

    this.takeControl();
};


/**
 * Tests network size.
 */
TestSuite.prototype.testNetworkSize = function()
{
    var test = this;

    function finishResource(resource, finishTime)
    {
        test.assertEquals(25, resource.resourceSize, "Incorrect total data length");
        test.releaseControl();
    }

    this.addSniffer(WebInspector.NetworkDispatcher.prototype, "_finishNetworkRequest", finishResource);

    // Reload inspected page to sniff network events
    test.evaluateInConsole_("window.location.reload(true);", function(resultText) {});

    this.takeControl();
};


/**
 * Tests network sync size.
 */
TestSuite.prototype.testNetworkSyncSize = function()
{
    var test = this;

    function finishResource(resource, finishTime)
    {
        test.assertEquals(25, resource.resourceSize, "Incorrect total data length");
        test.releaseControl();
    }

    this.addSniffer(WebInspector.NetworkDispatcher.prototype, "_finishNetworkRequest", finishResource);

    // Send synchronous XHR to sniff network events
    test.evaluateInConsole_("var xhr = new XMLHttpRequest(); xhr.open(\"GET\", \"chunked\", false); xhr.send(null);", function() {});

    this.takeControl();
};


/**
 * Tests network raw headers text.
 */
TestSuite.prototype.testNetworkRawHeadersText = function()
{
    var test = this;

    function finishResource(resource, finishTime)
    {
        if (!resource.responseHeadersText)
            test.fail("Failure: resource does not have response headers text");
        var index = resource.responseHeadersText.indexOf("Date:")
        test.assertEquals(112, resource.responseHeadersText.substring(index).length, "Incorrect response headers text length");
        test.releaseControl();
    }

    this.addSniffer(WebInspector.NetworkDispatcher.prototype, "_finishNetworkRequest", finishResource);

    // Reload inspected page to sniff network events
    test.evaluateInConsole_("window.location.reload(true);", function(resultText) {});

    this.takeControl();
};


/**
 * Tests network timing.
 */
TestSuite.prototype.testNetworkTiming = function()
{
    var test = this;

    function finishResource(resource, finishTime)
    {
        // Setting relaxed expectations to reduce flakiness.
        // Server sends headers after 100ms, then sends data during another 100ms.
        // We expect these times to be measured at least as 70ms.
        test.assertTrue(resource.timing.receiveHeadersEnd - resource.timing.connectStart >= 70,
                        "Time between receiveHeadersEnd and connectStart should be >=70ms, but was " +
                        "receiveHeadersEnd=" + resource.timing.receiveHeadersEnd + ", connectStart=" + resource.timing.connectStart + ".");
        test.assertTrue(resource.responseReceivedTime - resource.startTime >= 0.07,
                "Time between responseReceivedTime and startTime should be >=0.07s, but was " +
                "responseReceivedTime=" + resource.responseReceivedTime + ", startTime=" + resource.startTime + ".");
        test.assertTrue(resource.endTime - resource.startTime >= 0.14,
                "Time between endTime and startTime should be >=0.14s, but was " +
                "endtime=" + resource.endTime + ", startTime=" + resource.startTime + ".");

        test.releaseControl();
    }

    this.addSniffer(WebInspector.NetworkDispatcher.prototype, "_finishNetworkRequest", finishResource);

    // Reload inspected page to sniff network events
    test.evaluateInConsole_("window.location.reload(true);", function(resultText) {});

    this.takeControl();
};


TestSuite.prototype.testConsoleOnNavigateBack = function()
{
    if (WebInspector.multitargetConsoleModel.messages().length === 1)
        firstConsoleMessageReceived.call(this);
    else
        WebInspector.multitargetConsoleModel.addEventListener(WebInspector.ConsoleModel.Events.MessageAdded, firstConsoleMessageReceived, this);

    function firstConsoleMessageReceived() {
        WebInspector.multitargetConsoleModel.removeEventListener(WebInspector.ConsoleModel.Events.MessageAdded, firstConsoleMessageReceived, this);
        this.evaluateInConsole_("clickLink();", didClickLink.bind(this));
    }

    function didClickLink() {
        // Check that there are no new messages(command is not a message).
        this.assertEquals(3, WebInspector.multitargetConsoleModel.messages().length);
        this.evaluateInConsole_("history.back();", didNavigateBack.bind(this));
    }

    function didNavigateBack()
    {
        // Make sure navigation completed and possible console messages were pushed.
        this.evaluateInConsole_("void 0;", didCompleteNavigation.bind(this));
    }

    function didCompleteNavigation() {
        this.assertEquals(7, WebInspector.multitargetConsoleModel.messages().length);
        this.releaseControl();
    }

    this.takeControl();
};

TestSuite.prototype.testSharedWorker = function()
{
    function didEvaluateInConsole(resultText) {
        this.assertEquals("2011", resultText);
        this.releaseControl();
    }
    this.evaluateInConsole_("globalVar", didEvaluateInConsole.bind(this));
    this.takeControl();
};


TestSuite.prototype.testPauseInSharedWorkerInitialization1 = function()
{
    // Make sure the worker is loaded.
    this.takeControl();
    this._waitForTargets(2, callback.bind(this));

    function callback()
    {
        var target = WebInspector.targetManager.targetsWithJSContext()[0];
        target._connection.runAfterPendingDispatches(this.releaseControl.bind(this));
    }
};

TestSuite.prototype.testPauseInSharedWorkerInitialization2 = function()
{
    this.takeControl();
    this._waitForTargets(2, callback.bind(this));

    function callback()
    {
        var target = WebInspector.targetManager.targetsWithJSContext()[0];
        var debuggerModel = WebInspector.DebuggerModel.fromTarget(target);
        if (debuggerModel.isPaused()) {
            this.releaseControl();
            return;
        }
        this._waitForScriptPause(this.releaseControl.bind(this));
    }
};

TestSuite.prototype.enableTouchEmulation = function()
{
    var deviceModeModel = new WebInspector.DeviceModeModel(function() {});
    deviceModeModel._target = WebInspector.targetManager.mainTarget();
    deviceModeModel._applyTouch(true, true);
};

TestSuite.prototype.enableAutoAttachToCreatedPages = function()
{
    WebInspector.settingForTest("autoAttachToCreatedPages").set(true);
}

TestSuite.prototype.waitForDebuggerPaused = function()
{
    var debuggerModel = WebInspector.DebuggerModel.fromTarget(WebInspector.targetManager.mainTarget());
    if (debuggerModel.debuggerPausedDetails)
        return;

    this.takeControl();
    this._waitForScriptPause(this.releaseControl.bind(this));
}

TestSuite.prototype.switchToPanel = function(panelName)
{
    this.showPanel(panelName).then(this.releaseControl.bind(this));
    this.takeControl();
}

// Regression test for crbug.com/370035.
TestSuite.prototype.testDeviceMetricsOverrides = function()
{
    const dumpPageMetrics = function()
    {
        return JSON.stringify({
            width: window.innerWidth,
            height: window.innerHeight,
            deviceScaleFactor: window.devicePixelRatio
        });
    };

    var test = this;

    function testOverrides(params, metrics, callback)
    {
        WebInspector.targetManager.mainTarget().emulationAgent().invoke_setDeviceMetricsOverride(params, getMetrics);

        function getMetrics()
        {
            test.evaluateInConsole_("(" + dumpPageMetrics.toString() + ")()", checkMetrics);
        }

        function checkMetrics(consoleResult)
        {
            test.assertEquals('"' + JSON.stringify(metrics) + '"', consoleResult, "Wrong metrics for params: " + JSON.stringify(params));
            callback();
        }
    }

    function step1()
    {
        testOverrides({width: 1200, height: 1000, deviceScaleFactor: 1, mobile: false, fitWindow: true}, {width: 1200, height: 1000, deviceScaleFactor: 1}, step2);
    }

    function step2()
    {
        testOverrides({width: 1200, height: 1000, deviceScaleFactor: 1, mobile: false, fitWindow: false}, {width: 1200, height: 1000, deviceScaleFactor: 1}, step3);
    }

    function step3()
    {
        testOverrides({width: 1200, height: 1000, deviceScaleFactor: 3, mobile: false, fitWindow: true}, {width: 1200, height: 1000, deviceScaleFactor: 3}, step4);
    }

    function step4()
    {
        testOverrides({width: 1200, height: 1000, deviceScaleFactor: 3, mobile: false, fitWindow: false}, {width: 1200, height: 1000, deviceScaleFactor: 3}, finish);
    }

    function finish()
    {
        test.releaseControl();
    }

    test.takeControl();
    step1();
};

TestSuite.prototype.testScreenshotRecording = function()
{
    var test = this;

    function performActionsInPage(callback)
    {
        var count = 0;
        var div = document.createElement("div");
        div.setAttribute("style", "left: 0px; top: 0px; width: 100px; height: 100px; position: absolute;");
        document.body.appendChild(div);
        requestAnimationFrame(frame);
        function frame()
        {
            var color = [0, 0, 0];
            color[count % 3] = 255;
            div.style.backgroundColor = "rgb(" + color.join(",") + ")";
            if (++count > 10)
                requestAnimationFrame(callback);
            else
                requestAnimationFrame(frame);
        }
    }

    var captureFilmStripSetting = WebInspector.settings.createSetting("timelineCaptureFilmStrip", false);
    captureFilmStripSetting.set(true);
    test.evaluateInConsole_(performActionsInPage.toString(), function() {});
    test.invokeAsyncWithTimeline_("performActionsInPage", onTimelineDone);

    function onTimelineDone()
    {
        captureFilmStripSetting.set(false);
        var filmStripModel = new WebInspector.FilmStripModel(WebInspector.panels.timeline._tracingModel);
        var frames = filmStripModel.frames();
        test.assertTrue(frames.length > 4 && typeof frames.length === "number");
        loadFrameImages(frames);
    }

    function loadFrameImages(frames)
    {
        var readyImages = [];
        for (var frame of frames)
            frame.imageDataPromise().then(onGotImageData)

        function onGotImageData(data)
        {
            var image = new Image();
            test.assertTrue(!!data, "No image data for frame");
            image.addEventListener("load", onLoad);
            image.src = "data:image/jpg;base64," + data;
        }

        function onLoad(event)
        {
            readyImages.push(event.target);
            if (readyImages.length === frames.length)
                validateImagesAndCompleteTest(readyImages);
        }
    }

    function validateImagesAndCompleteTest(images)
    {
        var redCount = 0;
        var greenCount = 0;
        var blueCount = 0;

        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        for (var image of images) {
            test.assertTrue(image.naturalWidth > 10);
            test.assertTrue(image.naturalHeight > 10);
            canvas.width = image.naturalWidth;
            canvas.height = image.naturalHeight;
            ctx.drawImage(image, 0, 0);
            var data = ctx.getImageData(0, 0, 1, 1);
            var color = Array.prototype.join.call(data.data, ",");
            if (data.data[0] > 200)
                redCount++;
            else if (data.data[1] > 200)
                greenCount++;
            else if (data.data[2] > 200)
                blueCount++;
            else
                test.fail("Unexpected color: " + color);
        }
        test.assertTrue(redCount && greenCount && blueCount, "Color sanity check failed");
        test.releaseControl();
    }

    test.takeControl();
}

TestSuite.prototype.testSettings = function()
{
    var test = this;

    createSettings();
    test.takeControl();
    setTimeout(reset, 0);

    function createSettings()
    {
        var localSetting = WebInspector.settings.createSetting("local", undefined, true);
        localSetting.set({s: "local", n: 1 });
        var globalSetting = WebInspector.settings.createSetting("global", undefined, false);
        globalSetting.set({s: "global", n: 2 });
    }

    function reset()
    {
        Runtime.experiments.clearForTest();
        InspectorFrontendHost.getPreferences(gotPreferences);
    }

    function gotPreferences(prefs)
    {
        WebInspector.Main._instanceForTest._createSettings(prefs);

        var localSetting = WebInspector.settings.createSetting("local", undefined, true);
        test.assertEquals("object", typeof localSetting.get());
        test.assertEquals("local", localSetting.get().s);
        test.assertEquals(1, localSetting.get().n);
        var globalSetting = WebInspector.settings.createSetting("global", undefined, false);
        test.assertEquals("object", typeof globalSetting.get());
        test.assertEquals("global", globalSetting.get().s);
        test.assertEquals(2, globalSetting.get().n);
        test.releaseControl();
    }
}

TestSuite.prototype.waitForTestResultsInConsole = function()
{
    var messages = WebInspector.multitargetConsoleModel.messages();
    for (var i = 0; i < messages.length; ++i) {
        var text = messages[i].messageText;
        if (text === "PASS")
            return;
        else if (/^FAIL/.test(text))
            this.fail(text); // This will throw.
    }
    // Neither PASS nor FAIL, so wait for more messages.
    function onConsoleMessage(event)
    {
        var text = event.data.messageText;
        if (text === "PASS")
            this.releaseControl();
        else if (/^FAIL/.test(text))
            this.fail(text);
    }

    WebInspector.multitargetConsoleModel.addEventListener(WebInspector.ConsoleModel.Events.MessageAdded, onConsoleMessage, this);
    this.takeControl();
};

TestSuite.prototype.startTimeline = function(callback)
{
    this.showPanel("timeline").then(function() {
        WebInspector.panels.timeline._model.addEventListener(WebInspector.TimelineModel.Events.RecordingStarted, onRecordingStarted);
        WebInspector.panels.timeline._toggleRecording();
    });

    function onRecordingStarted()
    {
        WebInspector.panels.timeline._model.removeEventListener(WebInspector.TimelineModel.Events.RecordingStarted, onRecordingStarted);
        callback();
    }
}

TestSuite.prototype.stopTimeline = function(callback)
{
    WebInspector.panels.timeline._model.addEventListener(WebInspector.TimelineModel.Events.RecordingStopped, onRecordingStopped);
    WebInspector.panels.timeline._toggleRecording();
    function onRecordingStopped()
    {
        WebInspector.panels.timeline._model.removeEventListener(WebInspector.TimelineModel.Events.RecordingStopped, onRecordingStopped);
        callback();
    }
}

TestSuite.prototype.invokePageFunctionAsync = function(functionName, opt_args, callback_is_always_last)
{
    var callback = arguments[arguments.length - 1];
    var doneMessage = `DONE: ${functionName}.${++this._asyncInvocationId}`;
    var argsString = arguments.length < 3 ? "" : Array.prototype.slice.call(arguments, 1, -1).map(arg => JSON.stringify(arg)).join(",") + ",";
    this.evaluateInConsole_(`${functionName}(${argsString} function() { console.log('${doneMessage}'); });`, function() {});
    WebInspector.multitargetConsoleModel.addEventListener(WebInspector.ConsoleModel.Events.MessageAdded, onConsoleMessage);

    function onConsoleMessage(event)
    {
        var text = event.data.messageText;
        if (text === doneMessage) {
            WebInspector.multitargetConsoleModel.removeEventListener(WebInspector.ConsoleModel.Events.MessageAdded, onConsoleMessage);
            callback();
        }
    }
}

TestSuite.prototype.invokeAsyncWithTimeline_ = function(functionName, callback)
{
    var test = this;

    this.startTimeline(onRecordingStarted);

    function onRecordingStarted()
    {
        test.invokePageFunctionAsync(functionName, pageActionsDone);
    }

    function pageActionsDone()
    {
        test.stopTimeline(callback);
    }
};

TestSuite.prototype.enableExperiment = function(name)
{
    Runtime.experiments.enableForTest(name);
}

TestSuite.prototype.checkInputEventsPresent = function()
{
    var expectedEvents = new Set(arguments);
    var model = WebInspector.panels.timeline._model;
    var asyncEvents = model.mainThreadAsyncEvents();
    var input = asyncEvents.get(WebInspector.TimelineUIUtils.asyncEventGroups().input) || [];
    var prefix = "InputLatency::";
    for (var e of input) {
        if (!e.name.startsWith(prefix))
            continue;
        expectedEvents.delete(e.name.substr(prefix.length));
    }
    if (expectedEvents.size)
        throw "Some expected events are not found: " + Array.from(expectedEvents.keys()).join(",");
}

/**
 * Serializes array of uiSourceCodes to string.
 * @param {!Array.<!WebInspectorUISourceCode>} uiSourceCodes
 * @return {string}
 */
TestSuite.prototype.uiSourceCodesToString_ = function(uiSourceCodes)
{
    var names = [];
    for (var i = 0; i < uiSourceCodes.length; i++)
        names.push('"' + WebInspector.networkMapping.networkURL(uiSourceCodes[i]) + '"');
    return names.join(",");
};


/**
 * Returns all loaded non anonymous uiSourceCodes.
 * @return {!Array.<!WebInspectorUISourceCode>}
 */
TestSuite.prototype.nonAnonymousUISourceCodes_ = function()
{
    function filterOutAnonymous(uiSourceCode)
    {
        return !!WebInspector.networkMapping.networkURL(uiSourceCode);
    }

    function filterOutService(uiSourceCode)
    {
        return !uiSourceCode.isFromServiceProject();
    }

    var uiSourceCodes = WebInspector.workspace.uiSourceCodes();
    uiSourceCodes = uiSourceCodes.filter(filterOutService);
    return uiSourceCodes.filter(filterOutAnonymous);
};


/*
 * Evaluates the code in the console as if user typed it manually and invokes
 * the callback when the result message is received and added to the console.
 * @param {string} code
 * @param {function(string)} callback
 */
TestSuite.prototype.evaluateInConsole_ = function(code, callback)
{
    function innerEvaluate()
    {
        WebInspector.context.removeFlavorChangeListener(WebInspector.ExecutionContext, showConsoleAndEvaluate, this);
        var consoleView = WebInspector.ConsolePanel._view();
        consoleView._prompt.setText(code);
        consoleView._promptElement.dispatchEvent(TestSuite.createKeyEvent("Enter"));

        this.addSniffer(WebInspector.ConsoleView.prototype, "_consoleMessageAddedForTest",
            function(viewMessage) {
                callback(viewMessage.toMessageElement().deepTextContent());
            }.bind(this));
    }

    function showConsoleAndEvaluate()
    {
        WebInspector.console.showPromise().then(innerEvaluate.bind(this));
    }

    if (!WebInspector.context.flavor(WebInspector.ExecutionContext)) {
        WebInspector.context.addFlavorChangeListener(WebInspector.ExecutionContext, showConsoleAndEvaluate, this);
        return;
    }
    showConsoleAndEvaluate.call(this);
};

/**
 * Checks that all expected scripts are present in the scripts list
 * in the Scripts panel.
 * @param {!Array.<string>} expected Regular expressions describing
 *     expected script names.
 * @return {boolean} Whether all the scripts are in "scripts-files" select
 *     box
 */
TestSuite.prototype._scriptsAreParsed = function(expected)
{
    var uiSourceCodes = this.nonAnonymousUISourceCodes_();
    // Check that at least all the expected scripts are present.
    var missing = expected.slice(0);
    for (var i = 0; i < uiSourceCodes.length; ++i) {
        for (var j = 0; j < missing.length; ++j) {
            if (uiSourceCodes[i].name().search(missing[j]) !== -1) {
                missing.splice(j, 1);
                break;
            }
        }
    }
    return missing.length === 0;
};


/**
 * Waits for script pause, checks expectations, and invokes the callback.
 * @param {function():void} callback
 */
TestSuite.prototype._waitForScriptPause = function(callback)
{
    this.addSniffer(WebInspector.DebuggerModel.prototype, "_pausedScript", callback);
};


/**
 * Waits until all the scripts are parsed and invokes the callback.
 */
TestSuite.prototype._waitUntilScriptsAreParsed = function(expectedScripts, callback)
{
    var test = this;

    function waitForAllScripts() {
        if (test._scriptsAreParsed(expectedScripts))
            callback();
        else
            test.addSniffer(WebInspector.panels.sources.sourcesView(), "_addUISourceCode", waitForAllScripts);
    }

    waitForAllScripts();
};

TestSuite.prototype._waitForTargets = function(n, callback)
{
    checkTargets.call(this);

    function checkTargets()
    {
        if (WebInspector.targetManager.targets().length >= n)
            callback.call(null);
        else
            this.addSniffer(WebInspector.TargetManager.prototype, "addTarget", checkTargets.bind(this));
    }
}

/**
 * Key event with given key identifier.
 */
TestSuite.createKeyEvent = function(keyIdentifier)
{
    var evt = document.createEvent("KeyboardEvent");
    evt.initKeyboardEvent("keydown", true /* can bubble */, true /* can cancel */, null /* view */, keyIdentifier, "");
    return evt;
};

return new TestSuite();

}

if (window.uiTests) {
    WebInspector.notifications.addEventListener(WebInspector.NotificationService.Events.InspectorAgentEnabledForTests,
        window.uiTests.testSuiteReady.bind(null, createTestSuite));
}
;/* OverlayController.js */
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 */
WebInspector.OverlayController = function()
{
    WebInspector.moduleSetting("disablePausedStateOverlay").addChangeListener(this._updateOverlayMessage, this);
    WebInspector.targetManager.addModelListener(WebInspector.DebuggerModel, WebInspector.DebuggerModel.Events.DebuggerPaused, this._updateOverlayMessage, this);
    WebInspector.targetManager.addModelListener(WebInspector.DebuggerModel, WebInspector.DebuggerModel.Events.DebuggerResumed, this._updateOverlayMessage, this);
    WebInspector.targetManager.addModelListener(WebInspector.DebuggerModel, WebInspector.DebuggerModel.Events.GlobalObjectCleared, this._updateOverlayMessage, this);
}

WebInspector.OverlayController.prototype = {

    /**
     * @param {!WebInspector.Event} event
     */
    _updateOverlayMessage: function(event)
    {
        var debuggerModel = /** @type {!WebInspector.DebuggerModel} */ (event.target);
        var message = debuggerModel.isPaused() && !WebInspector.moduleSetting("disablePausedStateOverlay").get() ? WebInspector.UIString("Paused in debugger") : undefined;
        debuggerModel.target().pageAgent().setOverlayMessage(message);
    }
};/* Connections.js */
// Copyright (c) 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {InspectorBackendClass.Connection}
 */
WebInspector.MainConnection = function()
{
    InspectorBackendClass.Connection.call(this);
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.DispatchMessage, this._dispatchMessage, this);
    InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.DispatchMessageChunk, this._dispatchMessageChunk, this);
}

WebInspector.MainConnection.prototype = {
    /**
     * @override
     * @param {!Object} messageObject
     */
    sendMessage: function(messageObject)
    {
        var message = JSON.stringify(messageObject);
        InspectorFrontendHost.sendMessageToBackend(message);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _dispatchMessage: function(event)
    {
        this.dispatch(/** @type {string} */ (event.data));
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _dispatchMessageChunk: function(event)
    {
        var messageChunk = /** @type {string} */ (event.data["messageChunk"]);
        var messageSize = /** @type {number} */ (event.data["messageSize"]);
        if (messageSize) {
            this._messageBuffer = "";
            this._messageSize = messageSize;
        }
        this._messageBuffer += messageChunk;
        if (this._messageBuffer.length === this._messageSize) {
            this.dispatch(this._messageBuffer);
            this._messageBuffer = "";
            this._messageSize = 0;
        }
    },

    __proto__: InspectorBackendClass.Connection.prototype
}

/**
 * @constructor
 * @extends {InspectorBackendClass.Connection}
 * @param {string} url
 * @param {function(!InspectorBackendClass.Connection)} onConnectionReady
 */
WebInspector.WebSocketConnection = function(url, onConnectionReady)
{
    InspectorBackendClass.Connection.call(this);
    this._socket = new WebSocket(url);
    this._socket.onmessage = this._onMessage.bind(this);
    this._socket.onerror = this._onError.bind(this);
    this._socket.onopen = onConnectionReady.bind(null, this);
    this._socket.onclose = this.connectionClosed.bind(this, "websocket_closed");
}

/**
 * @param {string} url
 * @param {function(!InspectorBackendClass.Connection)} onConnectionReady
 */
WebInspector.WebSocketConnection.Create = function(url, onConnectionReady)
{
    new WebInspector.WebSocketConnection(url, onConnectionReady);
}

WebInspector.WebSocketConnection.prototype = {

    /**
     * @param {!MessageEvent} message
     */
    _onMessage: function(message)
    {
        var data = /** @type {string} */ (message.data);
        this.dispatch(data);
    },

    /**
     * @param {!Event} error
     */
    _onError: function(error)
    {
        console.error(error);
    },

    /**
     * @override
     * @param {!Object} messageObject
     */
    sendMessage: function(messageObject)
    {
        var message = JSON.stringify(messageObject);
        this._socket.send(message);
    },

    __proto__: InspectorBackendClass.Connection.prototype
}

/**
 * @constructor
 * @extends {InspectorBackendClass.Connection}
 */
WebInspector.StubConnection = function()
{
    InspectorBackendClass.Connection.call(this);
}

WebInspector.StubConnection.prototype = {
    /**
     * @override
     * @param {!Object} messageObject
     */
    sendMessage: function(messageObject)
    {
        setTimeout(this._respondWithError.bind(this, messageObject), 0);
    },

    /**
     * @param {!Object} messageObject
     */
    _respondWithError: function(messageObject)
    {
        var error = { message: "This is a stub connection, can't dispatch message.", code:  InspectorBackendClass.DevToolsStubErrorCode, data: messageObject };
        this.dispatch({ id: messageObject.id, error: error });
    },

    __proto__: InspectorBackendClass.Connection.prototype
};/* Main.js */
/*
 * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.
 * Copyright (C) 2007 Matt Lilek (pewtermoose@gmail.com).
 * Copyright (C) 2009 Joseph Pecoraro
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @implements {InspectorAgent.Dispatcher}
 * @implements {WebInspector.Console.UIDelegate}
 * @suppressGlobalPropertiesCheck
 */
WebInspector.Main = function()
{
    WebInspector.console.setUIDelegate(this);
    WebInspector.Main._instanceForTest = this;
    runOnWindowLoad(this._loaded.bind(this));
}

WebInspector.Main.prototype = {
    /**
     * @override
     * @return {!Promise.<undefined>}
     */
    showConsole: function()
    {
        return WebInspector.Revealer.revealPromise(WebInspector.console);
    },

    _loaded: function()
    {
        console.timeStamp("Main._loaded");

        if (InspectorFrontendHost.isUnderTest())
            self.runtime.useTestBase();
        InspectorFrontendHost.getPreferences(this._gotPreferences.bind(this));
        new WebInspector.FrontendWebSocketAPI();
    },

    /**
     * @param {!Object<string, string>} prefs
     */
    _gotPreferences: function(prefs)
    {
        console.timeStamp("Main._gotPreferences");
        this._createSettings(prefs);
        this._createAppUI();
    },

    /**
     * @param {!Object<string, string>} prefs
     * Note: this function is called from testSettings in Tests.js.
     */
    _createSettings: function(prefs)
    {
        // Patch settings from the URL param (for tests).
        var settingsParam = Runtime.queryParam("settings");
        if (settingsParam) {
            try {
                var settings = JSON.parse(window.decodeURI(settingsParam));
                for (var key in settings)
                    prefs[key] = settings[key];
            } catch(e) {
                // Ignore malformed settings.
            }
        }

        this._initializeExperiments(prefs);
        WebInspector.settings = new WebInspector.Settings(new WebInspector.SettingsStorage(prefs,
            InspectorFrontendHost.setPreference, InspectorFrontendHost.removePreference, InspectorFrontendHost.clearPreferences));

        if (!InspectorFrontendHost.isUnderTest())
            new WebInspector.VersionController().updateVersion();
    },

    /**
     * @param {!Object<string, string>} prefs
     */
    _initializeExperiments: function(prefs)
    {
        Runtime.experiments.register("accessibilityInspection", "Accessibility Inspection");
        Runtime.experiments.register("applyCustomStylesheet", "Allow custom UI themes");
        Runtime.experiments.register("appBanner", "App banner support", true);
        Runtime.experiments.register("blackboxJSFramesOnTimeline", "Blackbox JavaScript frames on Timeline", true);
        Runtime.experiments.register("timelineCollapsible", "Collapsbile row groups in Timeline");
        Runtime.experiments.register("colorContrastRatio", "Contrast ratio line in color picker", true);
        Runtime.experiments.register("cpuThrottling", "CPU throttling", true);
        Runtime.experiments.register("emptySourceMapAutoStepping", "Empty sourcemap auto-stepping");
        Runtime.experiments.register("gpuTimeline", "GPU data on timeline", true);
        Runtime.experiments.register("inputEventsOnTimelineOverview", "Input events on Timeline overview", true);
        Runtime.experiments.register("layersPanel", "Layers panel");
        Runtime.experiments.register("layoutEditor", "Layout editor", true);
        Runtime.experiments.register("inspectTooltip", "Dark inspect element tooltip");
        Runtime.experiments.register("multipleTimelineViews", "Multiple main views on Timeline", true);
        Runtime.experiments.register("networkRequestHeadersFilterInDetailsView", "Network request headers filter in details view", true);
        Runtime.experiments.register("networkRequestsOnTimeline", "Network requests on Timeline", true);
        Runtime.experiments.register("privateScriptInspection", "Private script inspection");
        Runtime.experiments.register("promiseTracker", "Promise inspector");
        Runtime.experiments.register("requestBlocking", "Request blocking", true);
        Runtime.experiments.register("timelineShowAllEvents", "Show all events on Timeline", true);
        Runtime.experiments.register("timelineLatencyInfo", "Show input latency events on the Timeline", true);
        Runtime.experiments.register("securityPanel", "Security panel");
        Runtime.experiments.register("showPrimaryLoadWaterfallInNetworkTimeline", "Show primary load waterfall in Network timeline", true);
        Runtime.experiments.register("stepIntoAsync", "Step into async");
        Runtime.experiments.register("timelineFlowEvents", "Timeline flow events", true);
        Runtime.experiments.register("timelineInvalidationTracking", "Timeline invalidation tracking", true);
        Runtime.experiments.register("timelineRecordingPerspectives", "Timeline recording perspectives UI");
        Runtime.experiments.register("timelineTracingJSProfile", "Timeline tracing based JS profiler", true);

        Runtime.experiments.cleanUpStaleExperiments();

        if (InspectorFrontendHost.isUnderTest()) {
            var testPath = JSON.parse(prefs["testPath"] || "\"\"");
            // Enable experiments for testing.
            if (testPath.indexOf("debugger/promise") !== -1)
                Runtime.experiments.enableForTest("promiseTracker");
            if (testPath.indexOf("layers/") !== -1)
                Runtime.experiments.enableForTest("layersPanel");
            if (testPath.indexOf("timeline/") !== -1 || testPath.indexOf("layers/") !== -1)
                Runtime.experiments.enableForTest("layersPanel");
            if (testPath.indexOf("security/") !== -1)
                Runtime.experiments.enableForTest("securityPanel");
        }

        Runtime.experiments.setDefaultExperiments([
            "inspectTooltip",
            "securityPanel"
        ]);
    },

    /**
     * @suppressGlobalPropertiesCheck
     */
    _createAppUI: function()
    {
        console.timeStamp("Main._createApp");

        // Request filesystems early, we won't create connections until callback is fired. Things will happen in parallel.
        WebInspector.isolatedFileSystemManager = new WebInspector.IsolatedFileSystemManager();
        WebInspector.isolatedFileSystemManager.initialize(this._didInitializeFileSystemManager.bind(this));

        var themeSetting = WebInspector.settings.createSetting("uiTheme", "default");
        WebInspector.initializeUIUtils(document, themeSetting);
        themeSetting.addChangeListener(WebInspector.reload.bind(WebInspector));

        WebInspector.installComponentRootStyles(/** @type {!Element} */ (document.body));

        this._addMainEventListeners(document);

        var canDock = !!Runtime.queryParam("can_dock");
        WebInspector.zoomManager = new WebInspector.ZoomManager(window, InspectorFrontendHost);
        WebInspector.inspectorView = new WebInspector.InspectorView();
        WebInspector.ContextMenu.initialize();
        WebInspector.ContextMenu.installHandler(document);
        WebInspector.Tooltip.installHandler(document);
        WebInspector.dockController = new WebInspector.DockController(canDock);
        WebInspector.multitargetConsoleModel = new WebInspector.MultitargetConsoleModel();
        WebInspector.multitargetNetworkManager = new WebInspector.MultitargetNetworkManager();

        WebInspector.shortcutsScreen = new WebInspector.ShortcutsScreen();
        // set order of some sections explicitly
        WebInspector.shortcutsScreen.section(WebInspector.UIString("Elements Panel"));
        WebInspector.shortcutsScreen.section(WebInspector.UIString("Styles Pane"));
        WebInspector.shortcutsScreen.section(WebInspector.UIString("Debugger"));
        WebInspector.shortcutsScreen.section(WebInspector.UIString("Console"));

        WebInspector.fileManager = new WebInspector.FileManager();
        WebInspector.workspace = new WebInspector.Workspace();
        WebInspector.fileSystemMapping = new WebInspector.FileSystemMapping();

        var fileSystemWorkspaceBinding = new WebInspector.FileSystemWorkspaceBinding(WebInspector.isolatedFileSystemManager, WebInspector.workspace);
        WebInspector.networkMapping = new WebInspector.NetworkMapping(WebInspector.targetManager, WebInspector.workspace, fileSystemWorkspaceBinding, WebInspector.fileSystemMapping);
        WebInspector.networkProjectManager = new WebInspector.NetworkProjectManager(WebInspector.targetManager, WebInspector.workspace, WebInspector.networkMapping);
        WebInspector.presentationConsoleMessageHelper = new WebInspector.PresentationConsoleMessageHelper(WebInspector.workspace);
        WebInspector.cssWorkspaceBinding = new WebInspector.CSSWorkspaceBinding(WebInspector.targetManager, WebInspector.workspace, WebInspector.networkMapping);
        WebInspector.debuggerWorkspaceBinding = new WebInspector.DebuggerWorkspaceBinding(WebInspector.targetManager, WebInspector.workspace, WebInspector.networkMapping);
        WebInspector.breakpointManager = new WebInspector.BreakpointManager(null, WebInspector.workspace, WebInspector.networkMapping, WebInspector.targetManager, WebInspector.debuggerWorkspaceBinding);
        WebInspector.extensionServer = new WebInspector.ExtensionServer();

        new WebInspector.OverlayController();
        new WebInspector.ExecutionContextSelector(WebInspector.targetManager, WebInspector.context);
        WebInspector.blackboxManager = new WebInspector.BlackboxManager(WebInspector.debuggerWorkspaceBinding, WebInspector.networkMapping);

        var autoselectPanel = WebInspector.UIString("auto");
        var openAnchorLocationSetting = WebInspector.settings.createSetting("openLinkHandler", autoselectPanel);
        WebInspector.openAnchorLocationRegistry = new WebInspector.HandlerRegistry(openAnchorLocationSetting);
        WebInspector.openAnchorLocationRegistry.registerHandler(autoselectPanel, function() { return false; });
        WebInspector.Linkifier.setLinkHandler(new WebInspector.HandlerRegistry.LinkHandler());

        new WebInspector.Main.PauseListener();
        new WebInspector.Main.InspectedNodeRevealer();
        new WebInspector.NetworkPanelIndicator();
        new WebInspector.SourcesPanelIndicator();
        new WebInspector.BackendSettingsSync();
        WebInspector.domBreakpointsSidebarPane = new WebInspector.DOMBreakpointsSidebarPane();

        WebInspector.actionRegistry = new WebInspector.ActionRegistry();
        WebInspector.shortcutRegistry = new WebInspector.ShortcutRegistry(WebInspector.actionRegistry, document);
        WebInspector.ShortcutsScreen.registerShortcuts();
        this._registerForwardedShortcuts();
        this._registerMessageSinkListener();

        var appExtension = self.runtime.extensions(WebInspector.AppProvider)[0];
        appExtension.instancePromise().then(this._showAppUI.bind(this));
    },

    /**
     * @param {!Object} appProvider
     * @suppressGlobalPropertiesCheck
     */
    _showAppUI: function(appProvider)
    {
        var app = /** @type {!WebInspector.AppProvider} */ (appProvider).createApp();
        // It is important to kick controller lifetime after apps are instantiated.
        WebInspector.dockController.initialize();
        console.timeStamp("Main._presentUI");
        app.presentUI(document);

        var toggleSearchNodeAction = WebInspector.actionRegistry.action("elements.toggle-element-search");
        InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.EnterInspectElementMode, toggleSearchNodeAction.execute.bind(toggleSearchNodeAction), this);
        WebInspector.inspectorView.createToolbars();
        InspectorFrontendHost.loadCompleted();

        var extensions = self.runtime.extensions(WebInspector.QueryParamHandler);
        for (var extension of extensions) {
            var value = Runtime.queryParam(extension.descriptor()["name"]);
            if (value !== null)
                extension.instancePromise().then(handleQueryParam.bind(null, value));
        }

        /**
         * @param {string} value
         * @param {!WebInspector.QueryParamHandler} handler
         */
        function handleQueryParam(value, handler)
        {
            handler.handleQueryParam(value);
        }

        this._appUIShown = true;
        if (this._fileSystemManagerInitialized) {
            // Allow UI cycles to repaint prior to creating connection.
            setTimeout(this._createConnection.bind(this), 0);
        }

        // 暂时隐藏profiler tab;
        // this._hideProfilerTab();
    },

    _didInitializeFileSystemManager: function()
    {
        this._fileSystemManagerInitialized = true;
        if (this._appUIShown)
            this._createConnection();
    },

    _createConnection: function()
    {
        console.timeStamp("Main._createConnection");

        if (Runtime.queryParam("ws")) {
            var ws = "ws://" + Runtime.queryParam("ws");
            WebInspector.WebSocketConnection.Create(ws, this._connectionEstablished.bind(this));
            return;
        }

        if (!InspectorFrontendHost.isHostedMode()) {
            this._connectionEstablished(new WebInspector.MainConnection());
            return;
        }

        this._connectionEstablished(new WebInspector.StubConnection());
    },

    /**
     * @param {!InspectorBackendClass.Connection} connection
     */
    _connectionEstablished: function(connection)
    {
        console.timeStamp("Main._connectionEstablished");
        this._mainConnection = connection;
        connection.addEventListener(InspectorBackendClass.Connection.Events.Disconnected, onDisconnected);

        /**
         * @param {!WebInspector.Event} event
         */
        function onDisconnected(event)
        {
            if (WebInspector._disconnectedScreenWithReasonWasShown)
                return;
            WebInspector.RemoteDebuggingTerminatedScreen.show(event.data.reason);
        }

        var targetType = Runtime.queryParam("isSharedWorker") ? WebInspector.Target.Type.ServiceWorker : WebInspector.Target.Type.Page;
        this._mainTarget = WebInspector.targetManager.createTarget(WebInspector.UIString("Main"), targetType, connection, null);
        console.timeStamp("Main._mainTargetCreated");
        this._registerShortcuts();

        this._mainTarget.registerInspectorDispatcher(this);
        InspectorFrontendHost.events.addEventListener(InspectorFrontendHostAPI.Events.ReloadInspectedPage, this._reloadInspectedPage, this);

        if (this._mainTarget.isServiceWorker() || this._mainTarget.isPage())
            this._mainTarget.runtimeAgent().run();

        this._mainTarget.inspectorAgent().enable(inspectorAgentEnableCallback);

        function inspectorAgentEnableCallback()
        {
            console.timeStamp("Main.inspectorAgentEnableCallback");
            WebInspector.notifications.dispatchEventToListeners(WebInspector.NotificationService.Events.InspectorAgentEnabledForTests);
            // Asynchronously run the extensions.
            setTimeout(lateInitialization, 0);
        }

        function lateInitialization()
        {
            WebInspector.extensionServer.initializeExtensions();
        }
    },

    _registerForwardedShortcuts: function()
    {
        /** @const */ var forwardedActions = ["main.toggle-dock", "debugger.toggle-breakpoints-active", "debugger.toggle-pause"];
        var actionKeys = WebInspector.shortcutRegistry.keysForActions(forwardedActions).map(WebInspector.KeyboardShortcut.keyCodeAndModifiersFromKey);
        InspectorFrontendHost.setWhitelistedShortcuts(JSON.stringify(actionKeys));
    },

    _registerMessageSinkListener: function()
    {
        WebInspector.console.addEventListener(WebInspector.Console.Events.MessageAdded, messageAdded);

        /**
         * @param {!WebInspector.Event} event
         */
        function messageAdded(event)
        {
            var message = /** @type {!WebInspector.Console.Message} */ (event.data);
            if (message.show)
                WebInspector.console.show();
        }
    },

    _documentClick: function(event)
    {
        var target = event.target;
        if (target.shadowRoot)
            target = event.deepElementFromPoint();
        if (!target)
            return;

        var anchor = target.enclosingNodeOrSelfWithNodeName("a");
        if (!anchor || !anchor.href)
            return;

        // Prevent the link from navigating, since we don't do any navigation by following links normally.
        event.consume(true);

        if (anchor.preventFollow)
            return;

        function followLink()
        {
            if (WebInspector.isBeingEdited(target))
                return;
            if (WebInspector.openAnchorLocationRegistry.dispatch({ url: anchor.href, lineNumber: anchor.lineNumber}))
                return;

            var uiSourceCode = WebInspector.networkMapping.uiSourceCodeForURLForAnyTarget(anchor.href);
            if (uiSourceCode) {
                WebInspector.Revealer.reveal(uiSourceCode.uiLocation(anchor.lineNumber || 0, anchor.columnNumber || 0));
                return;
            }

            var resource = WebInspector.resourceForURL(anchor.href);
            if (resource) {
                WebInspector.Revealer.reveal(resource);
                return;
            }

            var request = WebInspector.NetworkLog.requestForURL(anchor.href);
            if (request) {
                WebInspector.Revealer.reveal(request);
                return;
            }
            InspectorFrontendHost.openInNewTab(anchor.href);
        }

        if (WebInspector.followLinkTimeout)
            clearTimeout(WebInspector.followLinkTimeout);

        if (anchor.preventFollowOnDoubleClick) {
            // Start a timeout if this is the first click, if the timeout is canceled
            // before it fires, then a double clicked happened or another link was clicked.
            if (event.detail === 1)
                WebInspector.followLinkTimeout = setTimeout(followLink, 333);
            return;
        }

        if (!anchor.classList.contains("webkit-html-external-link"))
            followLink();
        else
            InspectorFrontendHost.openInNewTab(anchor.href);
    },

    _registerShortcuts: function()
    {
        var shortcut = WebInspector.KeyboardShortcut;
        var section = WebInspector.shortcutsScreen.section(WebInspector.UIString("All Panels"));
        var keys = [
            shortcut.makeDescriptor("[", shortcut.Modifiers.CtrlOrMeta),
            shortcut.makeDescriptor("]", shortcut.Modifiers.CtrlOrMeta)
        ];
        section.addRelatedKeys(keys, WebInspector.UIString("Go to the panel to the left/right"));

        keys = [
            shortcut.makeDescriptor("[", shortcut.Modifiers.CtrlOrMeta | shortcut.Modifiers.Alt),
            shortcut.makeDescriptor("]", shortcut.Modifiers.CtrlOrMeta | shortcut.Modifiers.Alt)
        ];
        section.addRelatedKeys(keys, WebInspector.UIString("Go back/forward in panel history"));

        var toggleConsoleLabel = WebInspector.UIString("Show console");
        section.addKey(shortcut.makeDescriptor(shortcut.Keys.Tilde, shortcut.Modifiers.Ctrl), toggleConsoleLabel);
        section.addKey(shortcut.makeDescriptor(shortcut.Keys.Esc), WebInspector.UIString("Toggle drawer"));
        if (WebInspector.dockController.canDock()) {
            section.addKey(shortcut.makeDescriptor("M", shortcut.Modifiers.CtrlOrMeta | shortcut.Modifiers.Shift), WebInspector.UIString("Toggle device mode"));
            section.addKey(shortcut.makeDescriptor("D", shortcut.Modifiers.CtrlOrMeta | shortcut.Modifiers.Shift), WebInspector.UIString("Toggle dock side"));
        }
        section.addKey(shortcut.makeDescriptor("f", shortcut.Modifiers.CtrlOrMeta), WebInspector.UIString("Search"));

        var advancedSearchShortcutModifier = WebInspector.isMac()
                ? WebInspector.KeyboardShortcut.Modifiers.Meta | WebInspector.KeyboardShortcut.Modifiers.Alt
                : WebInspector.KeyboardShortcut.Modifiers.Ctrl | WebInspector.KeyboardShortcut.Modifiers.Shift;
        var advancedSearchShortcut = shortcut.makeDescriptor("f", advancedSearchShortcutModifier);
        section.addKey(advancedSearchShortcut, WebInspector.UIString("Search across all sources"));

        var inspectElementModeShortcuts = WebInspector.shortcutRegistry.shortcutDescriptorsForAction("elements.toggle-element-search");
        section.addKey(inspectElementModeShortcuts[0], WebInspector.UIString("Select node to inspect"));

        var openResourceShortcut = WebInspector.KeyboardShortcut.makeDescriptor("p", WebInspector.KeyboardShortcut.Modifiers.CtrlOrMeta);
        section.addKey(openResourceShortcut, WebInspector.UIString("Go to source"));

        if (WebInspector.isMac()) {
            keys = [
                shortcut.makeDescriptor("g", shortcut.Modifiers.Meta),
                shortcut.makeDescriptor("g", shortcut.Modifiers.Meta | shortcut.Modifiers.Shift)
            ];
            section.addRelatedKeys(keys, WebInspector.UIString("Find next/previous"));
        }
    },

    _postDocumentKeyDown: function(event)
    {
        if (event.handled)
            return;

        var target = event.deepActiveElement();
        if (target) {
            var anchor = target.enclosingNodeOrSelfWithNodeName("a");
            if (anchor && anchor.preventFollow)
                event.preventDefault();
        }

        if (!WebInspector.Dialog.hasInstance() && WebInspector.inspectorView.currentPanel()) {
            WebInspector.inspectorView.currentPanel().handleShortcut(event);
            if (event.handled) {
                event.consume(true);
                return;
            }
        }

        WebInspector.shortcutRegistry.handleShortcut(event);
    },

    _documentCanCopy: function(event)
    {
        var panel = WebInspector.inspectorView.currentPanel();
        if (panel && panel["handleCopyEvent"])
            event.preventDefault();
    },

    _documentCopy: function(event)
    {
        var panel = WebInspector.inspectorView.currentPanel();
        if (panel && panel["handleCopyEvent"])
            panel["handleCopyEvent"](event);
    },

    _documentCut: function(event)
    {
        var panel = WebInspector.inspectorView.currentPanel();
        if (panel && panel["handleCutEvent"])
            panel["handleCutEvent"](event);
    },

    _documentPaste: function(event)
    {
        var panel = WebInspector.inspectorView.currentPanel();
        if (panel && panel["handlePasteEvent"])
            panel["handlePasteEvent"](event);
    },

    _contextMenuEventFired: function(event)
    {
        if (event.handled || event.target.classList.contains("popup-glasspane"))
            event.preventDefault();
    },

    /**
     * @param {!Document} document
     */
    _addMainEventListeners: function(document)
    {
        document.addEventListener("keydown", this._postDocumentKeyDown.bind(this), false);
        document.addEventListener("beforecopy", this._documentCanCopy.bind(this), true);
        document.addEventListener("copy", this._documentCopy.bind(this), false);
        document.addEventListener("cut", this._documentCut.bind(this), false);
        document.addEventListener("paste", this._documentPaste.bind(this), false);
        document.addEventListener("contextmenu", this._contextMenuEventFired.bind(this), true);
        document.addEventListener("click", this._documentClick.bind(this), false);
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _reloadInspectedPage: function(event)
    {
        var hard = /** @type {boolean} */ (event.data);
        WebInspector.Main._reloadPage(hard);
    },

    /**
     * @override
     * @param {!RuntimeAgent.RemoteObject} payload
     * @param {!Object=} hints
     */
    inspect: function(payload, hints)
    {
        var object = this._mainTarget.runtimeModel.createRemoteObject(payload);
        if (object.isNode()) {
            WebInspector.Revealer.revealPromise(object).then(object.release.bind(object));
            return;
        }

        if (object.type === "function") {
            WebInspector.RemoteFunction.objectAsFunction(object).targetFunctionDetails().then(didGetDetails);
            return;
        }

        /**
         * @param {?WebInspector.DebuggerModel.FunctionDetails} response
         */
        function didGetDetails(response)
        {
            object.release();

            if (!response || !response.location)
                return;

            WebInspector.Revealer.reveal(WebInspector.debuggerWorkspaceBinding.rawLocationToUILocation(response.location));
        }

        if (hints.copyToClipboard)
            InspectorFrontendHost.copyText(object.value);
        object.release();
    },

    /**
     * @override
     * @param {string} reason
     */
    detached: function(reason)
    {
        WebInspector._disconnectedScreenWithReasonWasShown = true;
        WebInspector.RemoteDebuggingTerminatedScreen.show(reason);
    },

    /**
     * @override
     */
    targetCrashed: function()
    {
        var debuggerModel = WebInspector.DebuggerModel.fromTarget(this._mainTarget);
        if (debuggerModel)
            WebInspector.TargetCrashedScreen.show(debuggerModel);
    },

    /**
     * @override
     * @param {number} callId
     * @param {string} script
     */
    evaluateForTestInFrontend: function(callId, script)
    {
        if (!InspectorFrontendHost.isUnderTest())
            return;

        /**
         * @suppressGlobalPropertiesCheck
         */
        function invokeMethod()
        {
            try {
                script = script + "//# sourceURL=evaluateInWebInspector" + callId + ".js";
                window.eval(script);
            } catch (e) {
                console.error(e.stack);
            }
        }

        this._mainConnection.runAfterPendingDispatches(invokeMethod);
    }
}

/**
 * @constructor
 * @implements {WebInspector.ActionDelegate}
 */
WebInspector.Main.ReloadActionDelegate = function()
{
}

WebInspector.Main.ReloadActionDelegate.prototype = {
    /**
     * @override
     * @param {!WebInspector.Context} context
     * @param {string} actionId
     * @return {boolean}
     */
    handleAction: function(context, actionId)
    {
        switch (actionId) {
        case "main.reload":
            WebInspector.Main._reloadPage(false);
            return true;
        case "main.hard-reload":
            WebInspector.Main._reloadPage(true);
            return true;
        case "main.debug-reload":
            WebInspector.reload();
            return true;
        }
        return false;
    }
}

/**
 * @constructor
 * @implements {WebInspector.ActionDelegate}
 */
WebInspector.Main.ZoomActionDelegate = function()
{
}

WebInspector.Main.ZoomActionDelegate.prototype = {
    /**
     * @override
     * @param {!WebInspector.Context} context
     * @param {string} actionId
     * @return {boolean}
     */
    handleAction: function(context, actionId)
    {
        if (InspectorFrontendHost.isHostedMode())
            return false;

        switch (actionId) {
        case "main.zoom-in":
            InspectorFrontendHost.zoomIn();
            return true;
        case "main.zoom-out":
            InspectorFrontendHost.zoomOut();
            return true;
        case "main.zoom-reset":
            InspectorFrontendHost.resetZoom();
            return true;
        }
        return false;
    }
}

/**
 * @constructor
 * @implements {WebInspector.ActionDelegate}
 */
WebInspector.Main.SearchActionDelegate = function()
{
}

WebInspector.Main.SearchActionDelegate.prototype = {
    /**
     * @override
     * @param {!WebInspector.Context} context
     * @param {string} actionId
     * @return {boolean}
     */
    handleAction: function(context, actionId)
    {
        var searchableView = WebInspector.SearchableView.fromElement(WebInspector.currentFocusElement()) || WebInspector.inspectorView.currentPanel().searchableView();
        if (!searchableView)
            return false;
        switch (actionId) {
        case "main.search-in-panel.find":
            return searchableView.handleFindShortcut();
        case "main.search-in-panel.cancel":
            return searchableView.handleCancelSearchShortcut();
        case "main.search-in-panel.find-next":
            return searchableView.handleFindNextShortcut();
        case "main.search-in-panel.find-previous":
            return searchableView.handleFindPreviousShortcut();
        }
        return false;
    }
}

/**
 * @param {boolean} hard
 */
WebInspector.Main._reloadPage = function(hard)
{
    if (!WebInspector.targetManager.hasTargets())
        return;
    if (WebInspector.targetManager.mainTarget().isServiceWorker())
        return;
    WebInspector.targetManager.reloadPage(hard);
}

/**
 * @param {string} ws
 */
WebInspector.Main._addWebSocketTarget = function(ws)
{
    /**
     * @param {!InspectorBackendClass.Connection} connection
     */
    function callback(connection)
    {
        WebInspector.targetManager.createTarget(ws, WebInspector.Target.Type.Page, connection, null);
    }
    new WebInspector.WebSocketConnection(ws, callback);
}

/**
 * @constructor
 * @implements {WebInspector.ToolbarItem.Provider}
 */
WebInspector.Main.WarningErrorCounter = function()
{
    WebInspector.Main.WarningErrorCounter._instanceForTest = this;

    this._counter = createElement("div");
    this._counter.addEventListener("click", WebInspector.console.show.bind(WebInspector.console), false);
    this._toolbarItem = new WebInspector.ToolbarItem(this._counter);
    var shadowRoot = WebInspector.createShadowRootWithCoreStyles(this._counter, "main/errorWarningCounter.css");

    this._errors = this._createItem(shadowRoot, "error-icon");
    this._revokedErrors = this._createItem(shadowRoot, "revokedError-icon");
    this._warnings = this._createItem(shadowRoot, "warning-icon");
    this._titles = [];

    WebInspector.multitargetConsoleModel.addEventListener(WebInspector.ConsoleModel.Events.ConsoleCleared, this._update, this);
    WebInspector.multitargetConsoleModel.addEventListener(WebInspector.ConsoleModel.Events.MessageAdded, this._update, this);
    WebInspector.multitargetConsoleModel.addEventListener(WebInspector.ConsoleModel.Events.MessageUpdated, this._update, this);
    this._update();
}

WebInspector.Main.WarningErrorCounter.prototype = {
    /**
     * @param {!Node} shadowRoot
     * @param {string} iconType
     * @return {!{item: !Element, text: !Element}}
     */
    _createItem: function(shadowRoot, iconType)
    {
        var item = createElementWithClass("span", "counter-item");
        var icon = item.createChild("label", "", "dt-icon-label");
        icon.type = iconType;
        var text = icon.createChild("span");
        shadowRoot.appendChild(item);
        return {item: item, text: text};
    },

    /**
     * @param {!{item: !Element, text: !Element}} item
     * @param {number} count
     * @param {boolean} first
     * @param {string} title
     */
    _updateItem: function(item, count, first, title)
    {
        item.item.classList.toggle("hidden", !count);
        item.item.classList.toggle("counter-item-first", first);
        item.text.textContent = count;
        if (count)
            this._titles.push(title);
    },

    _update: function()
    {
        var errors = 0;
        var revokedErrors = 0;
        var warnings = 0;
        var targets = WebInspector.targetManager.targets();
        for (var i = 0; i < targets.length; ++i) {
            errors += targets[i].consoleModel.errors();
            revokedErrors += targets[i].consoleModel.revokedErrors();
            warnings += targets[i].consoleModel.warnings();
        }

        this._titles = [];
        this._toolbarItem.setVisible(!!(errors || revokedErrors || warnings));
        this._updateItem(this._errors, errors, false, WebInspector.UIString(errors === 1 ? "%d error" : "%d errors", errors));
        this._updateItem(this._revokedErrors, revokedErrors, !errors, WebInspector.UIString(revokedErrors === 1 ? "%d handled promise rejection" : "%d handled promise rejections", revokedErrors));
        this._updateItem(this._warnings, warnings, !errors && !revokedErrors, WebInspector.UIString(warnings === 1 ? "%d warning" : "%d warnings", warnings));
        this._counter.title = this._titles.join(", ");
        WebInspector.inspectorView.toolbarItemResized();
    },

    /**
     * @override
     * @return {?WebInspector.ToolbarItem}
     */
    item: function()
    {
        return this._toolbarItem;
    }
}

/**
 * @constructor
 * @implements {WebInspector.ToolbarItem.Provider}
 */
WebInspector.Main.MainMenuItem = function()
{
    this._item = new WebInspector.ToolbarButton(WebInspector.UIString("Customize and control DevTools"), "menu-toolbar-item");
    this._item.addEventListener("mousedown", this._mouseDown, this);
}

WebInspector.Main.MainMenuItem.prototype = {
    /**
     * @override
     * @return {?WebInspector.ToolbarItem}
     */
    item: function()
    {
        return this._item;
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _mouseDown: function(event)
    {
        var contextMenu = new WebInspector.ContextMenu(/** @type {!Event} */(event.data),
            true,
            this._item.element.totalOffsetLeft(),
            this._item.element.totalOffsetTop() + this._item.element.offsetHeight);

        if (WebInspector.dockController.canDock()) {
            var dockItemElement = createElementWithClass("div", "flex-centered flex-auto");
            var titleElement = dockItemElement.createChild("span", "flex-auto");
            titleElement.textContent = WebInspector.UIString("Dock side");
            var toggleDockSideShorcuts = WebInspector.shortcutRegistry.shortcutDescriptorsForAction("main.toggle-dock");
            titleElement.title = WebInspector.UIString("Placement of DevTools relative to the page. (%s to restore last position)", toggleDockSideShorcuts[0].name);
            dockItemElement.appendChild(titleElement);
            var dockItemToolbar = new WebInspector.Toolbar("", dockItemElement);
            dockItemToolbar.makeBlueOnHover();
            var undock = new WebInspector.ToolbarToggle(WebInspector.UIString("Undock into separate window"), "dock-toolbar-item-undock");
            var bottom = new WebInspector.ToolbarToggle(WebInspector.UIString("Dock to bottom"), "dock-toolbar-item-bottom");
            var right = new WebInspector.ToolbarToggle(WebInspector.UIString("Dock to right"), "dock-toolbar-item-right");
            undock.addEventListener("mouseup", setDockSide.bind(null, WebInspector.DockController.State.Undocked));
            bottom.addEventListener("mouseup", setDockSide.bind(null, WebInspector.DockController.State.DockedToBottom));
            right.addEventListener("mouseup", setDockSide.bind(null, WebInspector.DockController.State.DockedToRight));
            undock.setToggled(WebInspector.dockController.dockSide() === WebInspector.DockController.State.Undocked);
            bottom.setToggled(WebInspector.dockController.dockSide() === WebInspector.DockController.State.DockedToBottom);
            right.setToggled(WebInspector.dockController.dockSide() === WebInspector.DockController.State.DockedToRight);
            dockItemToolbar.appendToolbarItem(undock);
            dockItemToolbar.appendToolbarItem(bottom);
            dockItemToolbar.appendToolbarItem(right);
            contextMenu.appendCustomItem(dockItemElement);
            contextMenu.appendSeparator();
        }

        /**
         * @param {string} side
         */
        function setDockSide(side)
        {
            WebInspector.dockController.setDockSide(side);
            contextMenu.discard();
        }

        contextMenu.appendAction("main.toggle-drawer", WebInspector.inspectorView.drawerVisible() ? WebInspector.UIString("Hide console") : WebInspector.UIString("Show console"));
        contextMenu.appendItemsAtLocation("mainMenu");
        contextMenu.show();
    }
}

/**
 * @constructor
 */
WebInspector.NetworkPanelIndicator = function()
{
    var manager = WebInspector.multitargetNetworkManager;
    manager.addEventListener(WebInspector.MultitargetNetworkManager.Events.ConditionsChanged, updateVisibility);
    var blockedURLsSetting = WebInspector.moduleSetting("blockedURLs");
    blockedURLsSetting.addChangeListener(updateVisibility);
    updateVisibility();

    function updateVisibility()
    {
        if (manager.isThrottling()) {
            WebInspector.inspectorView.setPanelIcon("network", "warning-icon", WebInspector.UIString("Network throttling is enabled"));
        } else if (blockedURLsSetting.get().length) {
            WebInspector.inspectorView.setPanelIcon("network", "warning-icon", WebInspector.UIString("Requests may be blocked"));
        } else {
            WebInspector.inspectorView.setPanelIcon("network", "", "");
        }
    }
}

/**
 * @constructor
 */
WebInspector.SourcesPanelIndicator = function()
{
    WebInspector.moduleSetting("javaScriptDisabled").addChangeListener(javaScriptDisabledChanged);
    javaScriptDisabledChanged();

    function javaScriptDisabledChanged()
    {
        var javaScriptDisabled = WebInspector.moduleSetting("javaScriptDisabled").get();
        if (javaScriptDisabled) {
            WebInspector.inspectorView.setPanelIcon("sources", "warning-icon", WebInspector.UIString("JavaScript is disabled"));
        } else {
            WebInspector.inspectorView.setPanelIcon("sources", "", "");
        }
    }
}

/**
 * @constructor
 */
WebInspector.Main.PauseListener = function()
{
    WebInspector.targetManager.addModelListener(WebInspector.DebuggerModel, WebInspector.DebuggerModel.Events.DebuggerPaused, this._debuggerPaused, this);
}

WebInspector.Main.PauseListener.prototype = {
    /**
     * @param {!WebInspector.Event} event
     */
    _debuggerPaused: function(event)
    {
        WebInspector.targetManager.removeModelListener(WebInspector.DebuggerModel, WebInspector.DebuggerModel.Events.DebuggerPaused, this._debuggerPaused, this);
        var debuggerPausedDetails = /** @type {!WebInspector.DebuggerPausedDetails} */ (event.data);
        var debuggerModel = /** @type {!WebInspector.DebuggerModel} */ (event.target);
        WebInspector.context.setFlavor(WebInspector.Target, debuggerModel.target());
        WebInspector.Revealer.reveal(debuggerPausedDetails);
    }
}

/**
 * @constructor
 */
WebInspector.Main.InspectedNodeRevealer = function()
{
    WebInspector.targetManager.addModelListener(WebInspector.DOMModel, WebInspector.DOMModel.Events.NodeInspected, this._inspectNode, this);
}

WebInspector.Main.InspectedNodeRevealer.prototype = {
    /**
     * @param {!WebInspector.Event} event
     */
    _inspectNode: function(event)
    {
        var deferredNode = /** @type {!WebInspector.DeferredDOMNode} */ (event.data);
        WebInspector.Revealer.reveal(deferredNode);
    }
}

/**
 * @constructor
 * @extends {WebInspector.VBox}
 * @param {string} reason
 */
WebInspector.RemoteDebuggingTerminatedScreen = function(reason)
{
    WebInspector.VBox.call(this, true);
    this.registerRequiredCSS("main/remoteDebuggingTerminatedScreen.css");
    var message = this.contentElement.createChild("div", "message");
    message.createChild("span").textContent = WebInspector.UIString("Debugging connection was closed. Reason: ");
    message.createChild("span", "reason").textContent = reason;
    this.contentElement.createChild("div", "message").textContent = WebInspector.UIString("Reconnect when ready by reopening DevTools.");
}

/**
 * @param {string} reason
 */
WebInspector.RemoteDebuggingTerminatedScreen.show = function(reason)
{
    var dialog = new WebInspector.Dialog();
    dialog.setWrapsContent(true);
    dialog.addCloseButton();
    dialog.setDimmed(true);
    new WebInspector.RemoteDebuggingTerminatedScreen(reason).show(dialog.element);
    dialog.show();
}

WebInspector.RemoteDebuggingTerminatedScreen.prototype = {
    __proto__: WebInspector.VBox.prototype
}

/**
 * @constructor
 * @param {function()} hideCallback
 * @extends {WebInspector.VBox}
 */
WebInspector.TargetCrashedScreen = function(hideCallback)
{
    WebInspector.VBox.call(this, true);
    this.registerRequiredCSS("main/targetCrashedScreen.css");
    this.contentElement.createChild("div", "message").textContent = WebInspector.UIString("DevTools was disconnected from the page.");
    this.contentElement.createChild("div", "message").textContent = WebInspector.UIString("Once page is reloaded, DevTools will automatically reconnect.");
    this._hideCallback = hideCallback;
}

/**
 * @param {!WebInspector.DebuggerModel} debuggerModel
 */
WebInspector.TargetCrashedScreen.show = function(debuggerModel)
{
    var dialog = new WebInspector.Dialog();
    dialog.setWrapsContent(true);
    dialog.addCloseButton();
    dialog.setDimmed(true);
    var hideBound = dialog.detach.bind(dialog, false);
    debuggerModel.addEventListener(WebInspector.DebuggerModel.Events.GlobalObjectCleared, hideBound);

    new WebInspector.TargetCrashedScreen(onHide).show(dialog.element);
    dialog.show();

    function onHide()
    {
        debuggerModel.removeEventListener(WebInspector.DebuggerModel.Events.GlobalObjectCleared, hideBound);
    }
}

WebInspector.TargetCrashedScreen.prototype = {
    /**
     * @override
     */
    willHide: function()
    {
        this._hideCallback.call(null);
    },

    __proto__: WebInspector.VBox.prototype
}

/**
 * @constructor
 * @implements {WebInspector.TargetManager.Observer}
 */
WebInspector.BackendSettingsSync = function()
{
    this._autoAttachSetting = WebInspector.settings.moduleSetting("autoAttachToCreatedPages");
    this._autoAttachSetting.addChangeListener(this._update, this);
    this._disableJavascriptSetting = WebInspector.settings.moduleSetting("javaScriptDisabled");
    this._disableJavascriptSetting.addChangeListener(this._update, this);
    WebInspector.targetManager.observeTargets(this, WebInspector.Target.Type.Page);
}

WebInspector.BackendSettingsSync.prototype = {
    _update: function()
    {
        for (var target of WebInspector.targetManager.targets(WebInspector.Target.Type.Page)) {
            target.pageAgent().setAutoAttachToCreatedPages(this._autoAttachSetting.get());
            target.emulationAgent().setScriptExecutionDisabled(this._disableJavascriptSetting.get());
        }
    },

    /**
     * @param {!WebInspector.Target} target
     * @override
     */
    targetAdded: function(target)
    {
        target.pageAgent().setAutoAttachToCreatedPages(this._autoAttachSetting.get());
        target.emulationAgent().setScriptExecutionDisabled(this._disableJavascriptSetting.get());
        target.renderingAgent().setShowViewportSizeOnResize(true);
    },

    /**
     * @param {!WebInspector.Target} target
     * @override
     */
    targetRemoved: function(target)
    {
    }
}

/**
 * @constructor
 * @implements {WebInspector.SettingUI}
 */
WebInspector.ShowMetricsRulersSettingUI = function()
{
}

WebInspector.ShowMetricsRulersSettingUI.prototype = {
    /**
     * @override
     * @return {?Element}
     */
    settingElement: function()
    {
        return WebInspector.SettingsUI.createSettingCheckbox(WebInspector.UIString("Show rulers"), WebInspector.moduleSetting("showMetricsRulers"));
    }
}


new WebInspector.Main();
;/* Application descriptor inspector.json */
applicationDescriptor = [{"name": "ui_lazy"}, {"name": "promises"}, {"type": "worker", "name": "heap_snapshot_worker"}, {"name": "sources"}, {"type": "remote", "name": "emulated_devices"}, {"name": "diff"}, {"type": "autostart", "name": "bindings"}, {"name": "snippets"}, {"type": "worker", "name": "script_formatter_worker"}, {"name": "console"}, {"name": "network"}, {"type": "remote", "name": "cm_modes"}, {"type": "autostart", "name": "platform"}, {"name": "animation"}, {"name": "source_frame"}, {"type": "autostart", "name": "main"}, {"name": "elements"}, {"type": "autostart", "name": "workspace"}, {"name": "accessibility"}, {"type": "autostart", "name": "host"}, {"type": "autostart", "name": "emulation"}, {"type": "autostart", "name": "ui"}, {"type": "autostart", "name": "sdk"}, {"type": "worker", "name": "temp_storage_shared_worker"}, {"name": "sass"}, {"name": "settings"}, {"name": "components_lazy"}, {"name": "profiler"}, {"type": "remote", "name": "screencast", "condition": "remoteFrontend"}, {"type": "autostart", "name": "extensions"}, {"type": "autostart", "name": "common"}, {"type": "autostart", "name": "components"}, {"name": "devices"}];
/* Core resources */
Runtime.cachedResources["ui/checkboxTextLabel.css"] = "/*\n * Copyright (c) 2014 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n    padding: 0;\n    margin: 0;\n    display: inline-flex;\n    flex-shrink: 0;\n    align-items: center !important;\n}\n\ninput {\n    height: 12px;\n    width: 12px;\n    flex-shrink: 0;\n}\n\ninput.dt-checkbox-themed {\n    -webkit-appearance: none;\n    margin: 0 5px auto 2px;\n    border: 1px solid rgb(45, 45, 45);\n    border-radius: 3px;\n    background-color: rgb(102, 102, 102);\n    position: relative;\n    top: 1px;\n}\n\ninput.dt-checkbox-themed:after {\n    content: '';\n    line-height: 10px;\n    position: absolute;\n    cursor: pointer;\n    width: 12px;\n    height: 12px;\n    background: none;\n}\n\ninput.dt-checkbox-themed:checked:after {\n    background-color: #333;\n}\n\ninput.dt-checkbox-themed:after {\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs.png);\n    -webkit-mask-size: 352px 168px;\n    -webkit-mask-position: -128px -110px;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\ninput.dt-checkbox-themed:after {\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n\n} /* media */\n\n/*# sourceURL=ui/checkboxTextLabel.css */";
Runtime.cachedResources["ui/closeButton.css"] = "/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\ndiv {\n    background-image: url(Images/toolbarButtonGlyphs.png);\n    background-size: 352px 168px;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\ndiv {\n    background-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\n.close-button {\n    width: 14px;\n    height: 14px;\n    background-position: -128px -96px;\n    cursor: default;\n}\n\n.close-button:hover {\n    background-position: -96px -96px;\n}\n\n.close-button:active {\n    background-position: -111px -96px;\n}\n\n.close-button-gray {\n    width: 13px;\n    height: 13px;\n    background-position: -175px -96px;\n}\n\n.close-button-gray:hover {\n    background-position: -143px -96px;\n}\n\n.close-button-gray:active {\n    background-position: -160px -96px;\n}\n\n/*# sourceURL=ui/closeButton.css */";
Runtime.cachedResources["ui/colorSwatch.css"] = "/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n  white-space: nowrap;\n}\n\n.color-swatch {\n    position: relative;\n    margin-left: 1px;\n    margin-right: 2px;\n    width: 10px;\n    height: 10px;\n    top: 1px;\n    display: inline-block;\n    -webkit-user-select: none;\n    background-image: url(Images/checker.png);\n    line-height: 10px;\n}\n\n.color-swatch-inner {\n    width: 100%;\n    height: 100%;\n    display: inline-block;\n    border: 1px solid rgba(128, 128, 128, 0.6);\n}\n\n.color-swatch-inner:hover {\n    border: 1px solid rgba(64, 64, 64, 0.8);\n}\n\n\n/*# sourceURL=ui/colorSwatch.css */";
Runtime.cachedResources["ui/dialog.css"] = "/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n    position: absolute;\n    border: 1px solid rgb(204, 204, 204);\n    box-shadow: rgb(140, 140, 140) 0 3px 14px;\n    background: white;\n    justify-content: flex-start;\n    align-items: stretch;\n}\n\n.widget {\n    display: flex;\n    flex: auto;\n    justify-content: flex-start;\n    align-items: stretch;\n}\n\n:host-context(.wraps-content) {\n    justify-content: center;\n    align-items: flex-start;\n    overflow: hidden;\n}\n\n:host-context(.wraps-content) .widget {\n    flex: none !important;\n    justify-content: center;\n    align-items: center;\n}\n\n.dialog-close-button {\n    position: absolute;\n    right: 9px;\n    top: 9px;\n}\n/*# sourceURL=ui/dialog.css */";
Runtime.cachedResources["ui/dropTarget.css"] = "/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    display: flex;\n    background-color: rgba(255,255,255,0.8);\n    z-index: 1000;\n}\n\n.drop-target-message {\n    flex: auto;\n    font-size: 30px;\n    color: #999;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    margin: 20px;\n    border: 4px dashed #ddd;\n    pointer-events: none;\n}\n\n/*# sourceURL=ui/dropTarget.css */";
Runtime.cachedResources["ui/emptyWidget.css"] = "/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.empty-view {\n    font-size: 24px;\n    color: rgb(75%, 75%, 75%);\n    font-weight: bold;\n    padding: 10px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    overflow: auto;\n}\n\n/*# sourceURL=ui/emptyWidget.css */";
Runtime.cachedResources["ui/filter.css"] = "/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n.filter-bar {\n    background-color: #f3f3f3;\n    padding: 4px 0 4px 0;\n    flex: none;\n    flex-wrap: wrap;\n    align-items: center;\n    border-bottom: 1px solid #dadada;\n}\n\n.filter-text-filter {\n    display: inline-flex;\n    margin-left: 1px;\n    margin-right: 2px;\n    min-width: 40px;\n    max-width: 200px;\n    height: 24px;\n    align-items: center;\n}\n\n.filter-text-filter label {\n    margin: auto 0;\n}\n\n.filter-bitset-filter {\n    padding: 2px;\n    display: inline-flex;\n    overflow: hidden;\n    height: 24px;\n    position: relative;\n}\n\n.filter-bitset-filter li {\n    display: inline-block;\n    flex: none;\n    margin: auto 2px;\n    padding: 3px 6px 3px 3px;\n    background: transparent;\n    text-shadow: rgba(255, 255, 255, 0.5) 0 1px 0;\n    border-radius: 8px;\n    overflow: hidden;\n}\n\n.filter-bitset-filter-divider {\n    background-color: #ccc;\n    height: 16px;\n    width: 1px;\n    margin: auto 2px;\n    display: inline-block;\n}\n\n.filter-bitset-filter li.selected,\n.filter-bitset-filter li:hover,\n.filter-bitset-filter li:active {\n    color: white;\n    text-shadow: rgba(0, 0, 0, 0.4) 0 1px 0;\n}\n\n.filter-bitset-filter li:hover {\n    background: rgba(0, 0, 0, 0.2);\n}\n\n.filter-bitset-filter li.selected {\n    background: rgba(0, 0, 0, 0.3);\n}\n\n.filter-bitset-filter li:active {\n    background: rgba(0, 0, 0, 0.5);\n}\n\n.filter-combobox-filter {\n    margin-left: 5px;\n    margin-right: 2px;\n    flex: 0 0 auto;\n    display: inline-block;\n}\n\n.filter-checkbox-filter {\n    padding-left: 4px;\n    padding-right: 2px;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    display: inline-flex;\n    vertical-align: middle;\n    height: 24px;\n    position: relative;\n}\n\n.filter-checkbox-filter > label {\n    display: flex;\n    margin: auto 0;\n}\n\n.filter-text-invalid {\n    background-color: rgb(255, 200, 200);\n}\n\n.filter-checkbox-filter .checkbox-filter-checkbox {\n    width: 10px;\n    height: 10px;\n    margin: auto 3px;\n    padding: 0;\n    border-radius: 2px;\n    border: solid 1px;\n    display: inline-block;\n    overflow: visible;\n    opacity: 0.8;\n    flex-shrink: 0;\n}\n\n.filter-input-field {\n    -webkit-appearance: none;\n    border: 1px solid rgb(163, 163, 163);\n    border-radius: 2px;\n    padding: 1px 3px 0;\n    margin: 0 0 0 1px;\n    width: 253px;\n    height: 20px;\n    line-height: 17px;\n    flex: 1;\n}\n\n/*# sourceURL=ui/filter.css */";
Runtime.cachedResources["ui/infobar.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.infobar {\n    color: rgb(34, 34, 34);\n    display: flex;\n    flex: auto;\n    border-bottom: 1px solid rgb(171, 171, 171);\n    flex-direction: column;\n    align-items: stretch;\n    position: relative;\n}\n\n.infobar-warning {\n    background-color: rgb(253, 242, 192);\n}\n\n.infobar-info {\n    background-color: rgb(255, 255, 255);\n}\n\n.infobar-main-row {\n    display: flex;\n    flex-direction: row;\n    flex: auto;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    justify-content: space-between;\n    margin-right: 20px;\n    min-height: 25px;\n    align-items: center;\n    padding-left: 4px;\n}\n\n.infobar-main-row > * {\n    flex: none;\n    padding: 0 3px;\n}\n\n.infobar-main-title {\n    flex: auto;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.infobar-details-rows {\n    padding: 5px 5px 0 5px;\n}\n\n.infobar-details-row {\n    display: flex;\n    flex-direction: column;\n    line-height: 18px;\n    padding-bottom: 6px;\n}\n\n.close-button {\n    position: absolute;\n    top: 5px;\n    right: 6px;\n}\n\n.infobar-toggle {\n    color: hsl(214, 92%, 50%);\n    cursor: pointer;\n}\n\n.infobar-toggle:hover {\n    color: hsl(214, 92%, 30%);\n}\n\n.info-icon {\n    -webkit-mask-image: url(Images/ic_info_black_18dp.svg);\n    background-color: hsl(214, 92%, 50%);\n}\n\n.warning-icon {\n    -webkit-mask-image: url(Images/ic_warning_black_18dp.svg);\n    background-color: hsl(44, 92%, 50%);\n}\n\n.icon {\n    -webkit-mask-size: 18px 18px;\n    width: 18px;\n    height: 19px;\n}\n\n/*# sourceURL=ui/infobar.css */";
Runtime.cachedResources["ui/inspectorCommon.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n* {\n    /* This is required for correct sizing of flex items because we rely\n     * on an old version of the flexbox spec.\n     * Longer-term we should remove this, see crbug.com/473625 */\n    min-width: 0;\n    min-height: 0;\n}\n\n:host-context(.platform-mac) .monospace,\n:host-context(.platform-mac) .source-code,\n.platform-mac .monospace,\n.platform-mac .source-code {\n    font-size: 11px !important;\n    font-family: Menlo, monospace;\n}\n\n:host-context(.platform-windows) .monospace,\n:host-context(.platform-windows) .source-code,\n.platform-windows .monospace,\n.platform-windows .source-code {\n    font-size: 12px !important;\n    font-family: Consolas, Lucida Console, monospace;\n}\n\n:host-context(.platform-linux) .monospace,\n:host-context(.platform-linux) .source-code,\n.platform-linux .monospace,\n.platform-linux .source-code {\n    font-size: 11px !important;\n    font-family: dejavu sans mono, monospace;\n}\n\n.source-code {\n    font-family: monospace;\n    font-size: 11px !important;\n    white-space: pre-wrap;\n}\n\n* {\n    box-sizing: border-box;\n}\n\n:focus {\n    outline: none;\n}\n\nimg {\n    -webkit-user-drag: none;\n}\n\niframe,\na img {\n    border: none;\n}\n\n.fill {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n}\n\niframe.fill {\n    width: 100%;\n    height: 100%;\n}\n\n.widget {\n    position: relative;\n    flex: auto;\n}\n\n.hbox {\n    display: flex;\n    flex-direction: row !important;\n    position: relative;\n}\n\n.vbox {\n    display: flex;\n    flex-direction: column !important;\n    position: relative;\n}\n\n.flex-auto {\n    flex: auto;\n}\n\n.flex-auto-important {\n    flex: auto !important;\n}\n\n.flex-none {\n    flex: none;\n}\n\n.flex-centered {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\niframe.widget {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n}\n\n.hidden {\n    display: none !important;\n}\n\n.monospace {\n    font-size: 10px !important;\n    font-family: monospace;\n}\n\n.highlighted-search-result {\n    border-radius: 1px;\n    padding: 1px;\n    margin: -1px;\n    background-color: rgba(255, 255, 0, 0.8);\n}\n\n.-theme-with-dark-background .highlighted-search-result,\n:host-context(.-theme-with-dark-background) .highlighted-search-result {\n    background-color: hsl(133, 100%, 30%);\n    color: #333;\n}\n\n.link {\n    cursor: pointer;\n    text-decoration: underline;\n    color: rgb(17, 85, 204);\n}\n\nbutton,\ninput,\nselect {\n    font-family: inherit;\n    font-size: inherit;\n    color: inherit;\n}\n\ninput {\n    background-color: white;\n}\n\n:host-context(.-theme-with-dark-background) input[type=\"checkbox\"] {\n    -webkit-filter: invert(80%);\n}\n\ninput[type=\"search\"]:focus,\ninput[type=\"text\"]:focus {\n    outline: auto 5px -webkit-focus-ring-color;\n}\n\n\n.highlighted-search-result.current-search-result {\n    border-radius: 1px;\n    padding: 1px;\n    margin: -1px;\n    background-color: rgba(255, 127, 0, 0.8);\n}\n\n.dimmed {\n    opacity: 0.6;\n}\n\n.editing {\n    -webkit-user-select: text;\n    box-shadow: rgba(0, 0, 0, .5) 3px 3px 4px;\n    outline: 1px solid rgb(66%, 66%, 66%) !important;\n    background-color: white;\n    -webkit-user-modify: read-write-plaintext-only;\n    text-overflow: clip !important;\n    padding-left: 2px;\n    margin-left: -2px;\n    padding-right: 2px;\n    margin-right: -2px;\n    margin-bottom: -1px;\n    padding-bottom: 1px;\n    opacity: 1.0 !important;\n}\n\n.editing,\n.editing * {\n    color: #222 !important;\n    text-decoration: none !important;\n}\n\n.error-input {\n    outline: auto 2px red !important;\n}\n\n.chrome-select {\n    -webkit-appearance: none;\n    -webkit-user-select: none;\n    border: 1px solid rgb(160, 160, 160);\n    border-radius: 2px;\n    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.08),\n    inset 0 1px 2px rgba(255, 255, 255, 0.75);\n    color: #444;\n    font: inherit;\n    margin: 0 1px 0 0;\n    outline: none;\n    text-shadow: 0 1px 0 rgb(240, 240, 240);\n    padding-right: 20px;\n    padding-left: 6px;\n    background-image: -webkit-image-set(url(Images/chromeSelect.png) 1x, url(Images/chromeSelect_2x.png) 2x), linear-gradient(#ededed, #ededed 38%, #dedede);\n    background-position: right center;\n    background-repeat: no-repeat;\n    min-height: 24px;\n}\n\n.chrome-select:enabled:hover {\n    background-image: -webkit-image-set(url(Images/chromeSelect.png) 1x, url(Images/chromeSelect_2x.png) 2x), linear-gradient(#f0f0f0, #f0f0f0 38%, #e0e0e0);\n    border-color: rgba(0, 0, 0, 0.3);\n    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.12),\n    inset 0 1px 2px rgba(255, 255, 255, 0.95);\n    color: black;\n}\n\n.chrome-select:enabled:active {\n    background-image: -webkit-image-set(url(Images/chromeSelect.png) 1x, url(Images/chromeSelect_2x.png) 2x), linear-gradient(#e7e7e7, #e7e7e7 38%, #d7d7d7);\n    box-shadow: none;\n    text-shadow: none;\n}\n\n.chrome-select:enabled:focus {\n    /* OVERRIDE */\n    -webkit-transition: border-color 200ms;\n    /* We use border color because it follows the border radius (unlike outline).\n     * This is particularly noticeable on mac. */\n    border-color: rgb(77, 144, 254);\n    outline: none;\n}\n\nbody.inactive select.chrome-select,\n.chrome-select:disabled {\n    background-image: -webkit-image-set(url(Images/chromeDisabledSelect.png) 1x, url(Images/chromeDisabledSelect_2x.png) 2x), linear-gradient(#f1f1f1, #f1f1f1 38%, #e6e6e6);\n    border-color: rgba(80, 80, 80, 0.2);\n    box-shadow: 0 1px 0 rgba(80, 80, 80, 0.08),\n    inset 0 1px 2px rgba(255, 255, 255, 0.75);\n    color: #aaa;\n}\n\n:not(.platform-mac).-theme-with-dark-background ::-webkit-scrollbar,\n:host-context(:not(.platform-mac).-theme-with-dark-background) ::-webkit-scrollbar {\n    width: 14px;\n}\n\n:not(.platform-mac).-theme-with-dark-background ::-webkit-scrollbar-track,\n:host-context(:not(.platform-mac).-theme-with-dark-background) ::-webkit-scrollbar-track {\n    -webkit-box-shadow: inset 0 0 1px rgba(255,255,255,0.3);\n}\n\n:not(.platform-mac).-theme-with-dark-background ::-webkit-scrollbar-thumb,\n:host-context(:not(.platform-mac).-theme-with-dark-background) .-theme-with-dark-background ::-webkit-scrollbar-thumb {\n    border-radius: 2px;\n    background-color: #333;\n    -webkit-box-shadow: inset 0 0 1px rgba(255,255,255,0.5);\n}\n\n/*# sourceURL=ui/inspectorCommon.css */";
Runtime.cachedResources["ui/inspectorStyle.css"] = "/*\n * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.\n * Copyright (C) 2009 Anthony Ricaud <rik@webkit.org>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nhtml {\n    height: 100%;\n    overflow: hidden;\n}\n\nbody {\n    height: 100%;\n    width: 100%;\n    position: relative;\n    overflow: hidden;\n    margin: 0;\n    cursor: default;\n    font-family: '.SFNSDisplay-Regular', 'Helvetica Neue', 'Lucida Grande', sans-serif;\n    font-size: 12px;\n    tab-size: 4;\n    -webkit-user-select: none;\n    color: #222;\n}\n\n.platform-linux {\n    color: rgb(48, 57, 66);\n    font-family: Ubuntu, Arial, sans-serif;\n}\n\n.platform-mac {\n    color: rgb(48, 57, 66);\n    font-family: '.SFNSDisplay-Regular', 'Helvetica Neue', 'Lucida Grande', sans-serif;\n}\n\n.platform-windows {\n    font-family: 'Segoe UI', Tahoma, sans-serif;\n}\n\nlabel:hover input {\n    box-shadow: 0 0 3px highlight;\n}\n\nfieldset[disabled] label:hover input {\n    box-shadow: none;\n}\n\n.object-popover-container {\n    display: inline-block;\n}\n\n.inspected-page-placeholder {\n    background-color: white;\n}\n\n.toolbar-background {\n    padding-left: 1px;\n    border-bottom: 1px solid rgb(64%, 64%, 64%);\n    background-origin: padding-box;\n    background-clip: padding-box;\n}\n\n.bubble-repeat-count {\n    display: inline-block;\n    height: 14px;\n    background-color: rgb(128, 151, 189);\n    vertical-align: middle;\n    white-space: nowrap;\n    padding: 1px 4px;\n    text-align: left;\n    font-size: 11px;\n    line-height: normal;\n    font-weight: bold;\n    text-shadow: none;\n    color: white;\n    margin-top: -1px;\n    border-radius: 7px;\n}\n\n.error-message {\n    color: red;\n}\n\n.-theme-with-dark-background .error-message {\n    color: hsl(0, 100%, 65%);\n}\n\n.panel {\n    display: flex;\n    overflow: hidden;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    z-index: 0;\n}\n\niframe.extension {\n    flex: auto;\n    width: 100%;\n    height: 100%;\n}\n\niframe.panel.extension {\n    display: block;\n    height: 100%;\n}\n\n.outline-disclosure {\n    padding: 0 0 0 4px;\n    margin: 0;\n}\n\n.outline-disclosure li {\n    position: relative;\n}\n\n.outline-disclosure li.hovered:not(.selected) .selection {\n    display: block;\n    left: 3px;\n    right: 3px;\n    background-color: rgba(56, 121, 217, 0.1);\n    border-radius: 5px;\n}\n\n.outline-disclosure li .selection {\n    display: none;\n    z-index: -1;\n    margin-left: -10000px;\n}\n\n.outline-disclosure li.selected .selection {\n    display: block;\n    background-color: #dadada;\n}\n\n.outline-disclosure li.in-clipboard .highlight {\n    outline: 1px dotted darkgrey;\n}\n\n.outline-disclosure li.elements-drag-over .selection {\n    display: block;\n    margin-top: -2px;\n    border-top: 2px solid rgb(56, 121, 217);\n}\n\nol.outline-disclosure:focus li.selected .selection {\n    background-color: rgb(56, 121, 217);\n}\n\nol.outline-disclosure:focus li.parent.selected::before {\n    background-color: white;\n}\n\nol.outline-disclosure,\n.outline-disclosure ol {\n    list-style-type: none;\n}\n\n.outline-disclosure-no-padding {\n    padding: 0;\n}\n\n.outline-disclosure ol {\n    padding-left: 12px;\n}\n\n.outline-disclosure li {\n    margin-top: 1px;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\nol.outline-disclosure:focus li.selected {\n    color: white;\n}\n\nol.outline-disclosure:focus li.selected * {\n    color: inherit;\n}\n\n.outline-disclosure li::before {\n    -webkit-user-select: none;\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs.png);\n    -webkit-mask-size: 352px 168px;\n    content: \"aa\";\n    color: transparent;\n    text-shadow: none;\n    margin-right: -2px;\n}\n\n.outline-disclosure li:not(.parent)::before {\n    background-color: transparent;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n.outline-disclosure li::before {\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\n.outline-disclosure li::before {\n    -webkit-mask-position: -4px -96px;\n    background-color: rgb(110, 110, 110);\n}\n\n.outline-disclosure li.parent.expanded::before {\n    -webkit-mask-position: -20px -96px;\n}\n\n.outline-disclosure ol.children {\n    display: none;\n}\n\n.outline-disclosure ol.children.expanded {\n    display: block;\n}\n\n.properties-accessor-property-name {\n    font-style: italic;\n}\n\n.child-editing {\n    color: #222 !important;\n    text-decoration: none !important;\n    overflow: visible !important;\n}\n\n.sidebar {\n    overflow-x: hidden;\n    background-color: #f3f3f3;\n}\n\n.pane-title-button {\n    color: rgb(6, 6, 6);\n    background-color: transparent;\n    border: 1px solid rgb(165, 165, 165);\n    background-color: #eee;\n    background-image: linear-gradient(to bottom, rgb(252, 252, 252), rgb(223, 223, 223));\n    border-radius: 12px;\n    -webkit-appearance: none;\n}\n\n.pane-title-button:active {\n    background-color: rgb(215, 215, 215);\n    background-image: linear-gradient(to bottom, rgb(194, 194, 194), rgb(239, 239, 239));\n}\n\n.sidebar-tree,\n.sidebar-tree .children {\n    position: relative;\n    padding: 0;\n    margin: 0;\n    list-style: none;\n}\n\n.sidebar-tree-section {\n    position: relative;\n    height: 18px;\n    padding: 1px 10px 6px 10px;\n    white-space: nowrap;\n    margin-top: 1px;\n    color: rgb(92, 110, 129);\n    text-shadow: rgba(255, 255, 255, 0.75) 0 1px 0;\n}\n\n.sidebar-tree-item {\n    position: relative;\n    height: 36px;\n    padding: 0 5px 0 5px;\n    white-space: nowrap;\n    overflow-x: hidden;\n    overflow-y: hidden;\n    margin-top: 1px;\n    line-height: 34px;\n    border-top: 1px solid transparent;\n}\n\n.sidebar-tree .children {\n    display: none;\n}\n\n.sidebar-tree .children.expanded {\n    display: block;\n}\n\n.sidebar-tree-section + .children > .sidebar-tree-item {\n    padding-left: 10px !important;\n}\n\n.sidebar-tree-section + .children.small > .sidebar-tree-item {\n    padding-left: 17px !important;\n}\n\n.sidebar-tree > .children > .sidebar-tree-item {\n    padding-left: 37px;\n}\n\n.sidebar-tree > .children > .children > .sidebar-tree-item {\n    padding-left: 37px;\n}\n\n.sidebar-tree.some-expandable > .sidebar-tree-item:not(.parent) .icon {\n    margin-left: 16px;\n}\n\n.sidebar-tree-item .disclosure-button {\n    float: left;\n    width: 10px;\n    height: 10px;\n    border: 0;\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs.png);\n    -webkit-mask-size: 352px 168px;\n    -webkit-appearance: none;\n    background-color: rgba(0, 0, 0, 0.75);\n    position: relative;\n    top: 10px;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n.sidebar-tree-item .disclosure-button {\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\n.sidebar-tree-item .disclosure-button {\n    -webkit-mask-position: -4px -96px;\n}\n\n.sidebar-tree-item.selected .disclosure-button {\n    background-color: white;\n    -webkit-mask-position: -4px -96px;\n}\n\n.sidebar-tree-item.expanded .disclosure-button {\n    -webkit-mask-position: -20px -96px;\n}\n\n.sidebar-tree-item.selected.expanded .disclosure-button {\n    background-color: white;\n    -webkit-mask-position: -20px -96px;\n}\n\n.sidebar-tree-item .icon {\n    float: left;\n    width: 32px;\n    height: 32px;\n    margin-top: 1px;\n    margin-right: 3px;\n}\n\n.sidebar-tree-item.wait .icon {\n    content: none;\n}\n\n.spinner-icon::before,\n.sidebar-tree-item.wait .icon::before {\n    display: block;\n    width: 24px;\n    height: 24px;\n    margin: 4px;\n    border: 3px solid grey;\n    border-radius: 12px;\n    clip: rect(0, 15px, 15px, 0);\n    content: \"\";\n    position: absolute;\n    -webkit-animation: spinner-animation 1s linear infinite;\n    box-sizing: border-box;\n}\n\n.spinner-icon.small::before,\n.sidebar-tree-item.wait.small .icon::before {\n    width: 14px;\n    height: 14px;\n    margin: 1px;\n    clip: rect(0, 9px, 9px, 0);\n    border-width: 2px;\n}\n\n.sidebar-tree-item.wait.selected .icon::before {\n    border-color: white;\n}\n\n@-webkit-keyframes spinner-animation {\n    from { transform: rotate(0); }\n    to { transform: rotate(360deg); }\n}\n\nli .status {\n    float: right;\n    height: 16px;\n    margin-top: 9px;\n    margin-left: 4px;\n    line-height: 1em;\n}\n\nli .status:empty {\n    display: none;\n}\n\nli .status .bubble-repeat-count:empty {\n    display: none;\n}\n\nli.selected .status .bubble-repeat-count {\n    background-color: white !important;\n    color: rgb(132, 154, 190) !important;\n}\n\n:focus li.selected .status .bubble-repeat-count {\n    color: rgb(36, 98, 172) !important;\n}\n\nbody.inactive li.selected .status .bubble-repeat-count {\n    color: rgb(159, 159, 159) !important;\n}\n\n.sidebar-tree.small .sidebar-tree-item,\n.sidebar-tree .children.small .sidebar-tree-item,\n.sidebar-tree-item.small {\n    height: 20px;\n}\n\n.sidebar-tree.small .sidebar-tree-item .icon,\n.sidebar-tree .children.small .sidebar-tree-item .icon,\n.sidebar-tree-item.small .icon {\n    width: 16px;\n    height: 16px;\n}\n\n.sidebar-tree.small .sidebar-tree-item .status,\n.sidebar-tree .children.small .sidebar-tree-item .status,\n.sidebar-tree-item.small .status {\n    margin-top: 1px;\n}\n\n.sidebar-tree-item.selected,\n.-theme-selection-color {\n    color: white;\n    background-origin: padding-box;\n    background-clip: padding-box;\n    background-color: rgb(56, 121, 217);\n}\n\n:focus .sidebar-tree-item.selected {\n    background-color: rgb(56, 121, 217);\n}\n\nbody.inactive .sidebar-tree-item.selected {\n    background-color: rgb(180,180,180);\n}\n\n.sidebar-tree-item .titles {\n    display: flex;\n    flex-direction: column;\n    position: relative;\n    top: 5px;\n    line-height: 12px;\n    padding-bottom: 1px;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n}\n\n.titles > .title-container {\n    display: flex;\n}\n\n.sidebar-tree-item .titles.no-subtitle {\n    top: 10px;\n}\n\n.sidebar-tree.small .sidebar-tree-item .titles,\n.sidebar-tree .children.small .sidebar-tree-item .titles,\n.sidebar-tree-item.small .titles {\n    top: 2px;\n    line-height: normal;\n}\n\n.sidebar-tree:not(.small) .sidebar-tree-item:not(.small) .title::after,\n.sidebar-tree .children:not(.small) .sidebar-tree-item .title::after {\n    content: \"\\A\";\n    white-space: pre;\n}\n\n.sidebar-tree-item .subtitle {\n    font-size: 80%;\n}\n\n.sidebar-tree.small .sidebar-tree-item .subtitle,\n.sidebar-tree .children.small .sidebar-tree-item .subtitle,\n.sidebar-tree-item.small .subtitle {\n    display: none;\n}\n\n.sidebar-tree-item.selected .subtitle {\n    color: white;\n}\n\n.bubble-repeat-count.debug,\n.console-debug-level .bubble-repeat-count {\n    background-color: rgb(0, 0, 255) !important;\n}\n\n.bubble-repeat-count.warning,\n.console-warning-level .bubble-repeat-count {\n    background-color: rgb(232, 164, 0) !important;\n}\n\n.bubble-repeat-count.error,\n.console-error-level .bubble-repeat-count {\n    background-color: rgb(216, 35, 35) !important;\n}\n\n.soft-context-menu-glass-pane {\n    z-index: 20000;\n}\n\n.root-view {\n    background-color: white;\n    overflow: hidden;\n    position: absolute !important;\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n}\n\n.drawer-toolbar {\n    margin-right: -6px;\n}\n\n/*# sourceURL=ui/inspectorStyle.css */";
Runtime.cachedResources["ui/inspectorSyntaxHighlight.css"] = "/*\n * Copyright (C) 2009 Apple Inc.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n.cm-js-keyword {color: rgb(170, 13, 145);}\n.cm-js-number {color: rgb(28, 0, 207);}\n.cm-js-comment {color: rgb(0, 116, 0);}\n.cm-js-string {color: rgb(196, 26, 22);}\n.cm-js-string-2 {color: rgb(196, 26, 22);}\n\n.cm-css-keyword { color: rgb(7, 144, 154);}\n.cm-css-number {color: rgb(50, 0, 255);}\n.cm-css-comment {color: rgb(0, 116, 0);}\n.cm-css-def {color: rgb(200, 0, 0);}\n.cm-css-meta {color: rgb(200, 0, 0);}\n.cm-css-atom {color: rgb(7, 144, 154);}\n.cm-css-string {color: rgb(7, 144, 154);}\n.cm-css-string-2 {color: rgb(7, 144, 154);}\n.cm-css-link {color: rgb(7, 144, 154);}\n.cm-css-variable {color: rgb(200, 0, 0);}\n.cm-css-variable-2 {color: rgb(0, 0, 128);}\n.cm-css-property, .webkit-css-property {color: rgb(200, 0, 0);}\n\n.cm-xml-meta {color: rgb(192, 192, 192);}\n.cm-xml-comment {color: rgb(35, 110, 37);}\n.cm-xml-string {color: rgb(26, 26, 166);}\n.cm-xml-tag {color: rgb(136, 18, 128);}\n.cm-xml-attribute {color: rgb(153, 69, 0);}\n.cm-xml-link {color: #00e;}\n\n.webkit-html-comment {\n    /* Keep this in sync with view-source.css (.webkit-html-comment) */\n    color: rgb(35, 110, 37);\n}\n\n.webkit-html-tag {\n    color: rgb(168, 148, 166);\n}\n\n.webkit-html-tag-name, .webkit-html-close-tag-name {\n    /* Keep this in sync with view-source.css (.webkit-html-tag) */\n    color: rgb(136, 18, 128);\n}\n\n.webkit-html-pseudo-element {\n    /* This one is non-standard. */\n    color: brown;\n}\n\n.webkit-html-js-node,\n.webkit-html-css-node {\n    white-space: pre-wrap;\n}\n\n.webkit-html-text-node {\n    unicode-bidi: -webkit-isolate;\n}\n\n.webkit-html-entity-value {\n    /* This one is non-standard. */\n    background-color: rgba(0, 0, 0, 0.15);\n    unicode-bidi: -webkit-isolate;\n}\n\n.webkit-html-doctype {\n    /* Keep this in sync with view-source.css (.webkit-html-doctype) */\n    color: rgb(192, 192, 192);\n}\n\n.webkit-html-attribute-name {\n    /* Keep this in sync with view-source.css (.webkit-html-attribute-name) */\n    color: rgb(153, 69, 0);\n    unicode-bidi: -webkit-isolate;\n}\n\n.webkit-html-attribute-value {\n    /* Keep this in sync with view-source.css (.webkit-html-attribute-value) */\n    color: rgb(26, 26, 166);\n    unicode-bidi: -webkit-isolate;\n}\n\n.webkit-html-external-link,\n.webkit-html-resource-link {\n    /* Keep this in sync with view-source.css (.webkit-html-external-link, .webkit-html-resource-link) */\n    color: #00e;\n}\n\n.-theme-with-dark-background .webkit-html-external-link,\n.-theme-with-dark-background .webkit-html-resource-link,\n:host-context(.-theme-with-dark-background) .webkit-html-external-link,\n:host-context(.-theme-with-dark-background) .webkit-html-resource-link {\n    color: hsl(0, 0%, 67%);\n}\n\n.webkit-html-resource-link {\n    /* Required for consistency with view-source.css, since anchors may not have href attributes */\n    text-decoration: underline;\n    cursor: pointer;\n}\n\n.webkit-html-external-link {\n    /* Keep this in sync with view-source.css (.webkit-html-external-link) */\n    text-decoration: none;\n}\n\n.webkit-html-external-link:hover {\n    /* Keep this in sync with view-source.css (.webkit-html-external-link:hover) */\n    text-decoration: underline;\n}\n\n.webkit-html-end-of-file {\n    /* Keep this in sync with view-source.css (.webkit-html-end-of-file) */\n    color: rgb(255, 0, 0);\n    font-weight: bold;\n}\n\n/*# sourceURL=ui/inspectorSyntaxHighlight.css */";
Runtime.cachedResources["ui/inspectorSyntaxHighlightDark.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.cm-js-atom{color:rgb(161, 247, 181);}\n.cm-js-attribute{color:rgb(97, 148, 198);}\n.cm-js-builtin{color:rgb(159, 180, 214);}\n.cm-js-comment{color:rgb(116, 116, 116);}\n.cm-js-def{color:rgb(93, 176, 215);}\n.cm-js-keyword{color:rgb(154, 127, 213);}\n.cm-js-link{color:rgb(159, 180, 214);}\n.cm-js-meta{color:rgb(221, 251, 85);}\n.cm-js-number{color:rgb(161, 247, 181);}\n.cm-js-operator{color:rgb(210, 192, 87);}\n.cm-js-property{color:rgb(210, 192, 87);}\n.cm-js-string{color:rgb(242, 139, 84);}\n.cm-js-string-2{color:rgb(242, 139, 84);}\n.cm-js-tag{color:rgb(93, 176, 215);}\n.cm-js-variable{color:rgb(217, 217, 217);}\n.cm-js-variable-2{color:rgb(217, 217, 217);}\n.cm-atom{color:rgb(161, 247, 181);}\n.cm-comment{color:rgb(116, 116, 116);}\n.cm-variable{color:rgb(217, 217, 217);}\n.cm-string{color:rgb(242, 139, 84);}\n.cm-keyword{color:rgb(154, 127, 213);}\n.cm-number{color:rgb(161, 247, 181);}\n.cm-operator{color:rgb(210, 192, 87);}\n.cm-css-atom{color:rgb(217, 217, 217);}\n.cm-css-builtin{color:rgb(255, 163, 79);}\n.cm-css-def{color:rgb(255, 163, 79);}\n.cm-css-comment{color:rgb(116, 116, 116);}\n.cm-css-meta{color:rgb(132, 240, 255);}\n.cm-css-number{color:rgb(217, 217, 217);}\n.cm-css-operator{color:rgb(217, 217, 217);}\n.cm-css-property{color:rgb(132, 240, 255);}\n.cm-css-qualifier{color:rgb(255, 163, 79);}\n.cm-css-string{color:rgb(231, 194, 111);}\n.cm-css-string-2{color:rgb(217, 217, 217);}\n.cm-css-tag{color:rgb(255, 163, 79);}\n.cm-css-variable{color:rgb(255, 163, 79);}\n.cm-css-variable-2{color:rgb(255, 163, 79);}\n.cm-xml-comment{color:rgb(137, 137, 137);}\n.cm-xml-error{color:rgb(198, 95, 95);}\n.cm-xml-string{color:rgb(242, 151, 102);}\n.cm-xml-tag{color:rgb(93, 176, 215);}\n.cm-xml-attribute{color:rgb(155, 187, 220);}\n.cm-xml-link{color:rgb(231, 194, 111);}\n\n.webkit-html-attribute-name{color:rgb(155, 187, 220);}\n.webkit-html-attribute-value{color:rgb(242, 151, 102);}\n.webkit-html-comment{color:rgb(137, 137, 137);}\n.webkit-html-resource-link{color:rgb(231, 194, 111);}\n.webkit-html-external-link{color:rgb(231, 194, 111);}\n.webkit-html-tag{color:rgb(93, 176, 215);}\n.webkit-html-tag-name{color:rgb(93, 176, 215);}\n.webkit-html-close-tag-name{color:rgb(93, 176, 215);}\n.webkit-html-text-node{color:rgb(207, 208, 208);}\n.webkit-html-css-node{color:rgb(207, 208, 208);}\n.webkit-html-js-node{color:rgb(207, 208, 208);}\n.webkit-html-pseudo-element{color:rgb(93, 175, 215);}\n.webkit-css-selector{color:rgb(255, 163, 79);}\n.webkit-css-at-rule{color:rgb(188, 164, 197);}\n.webkit-css-color{color:rgb(255, 163, 79);}\n.webkit-css-comment{color:rgb(116, 116, 116);}\n.webkit-css-important{color:rgb(255, 26, 26);}\n.webkit-css-keyword{color:rgb(255, 163, 79);}\n.webkit-css-number{color:rgb(217, 217, 217);}\n.webkit-css-property{color: rgb(53, 212, 199);}\n.webkit-css-string{color:rgb(231, 194, 111);}\n.webkit-css-url{color:rgb(231, 194, 111);}\n\n/*# sourceURL=ui/inspectorSyntaxHighlightDark.css */";
Runtime.cachedResources["ui/listWidget.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.list {\n    flex: auto 0 1;\n    overflow-y: auto;\n    border: 1px solid rgb(231, 231, 231);\n    flex-direction: column;\n}\n\n.list-separator {\n    background: rgb(231, 231, 231);\n    height: 1px;\n}\n\n.list-item {\n    flex: none;\n    min-height: 30px;\n    display: flex;\n    align-items: center;\n    position: relative;\n}\n\n.list-item:hover {\n    background: hsl(0, 0%, 96%);\n}\n\n.controls-container {\n    display: flex;\n    flex-direction: row;\n    justify-content: flex-end;\n    align-items: stretch;\n    pointer-events: none;\n}\n\n.controls-gradient {\n    flex: 0 1 50px;\n}\n\n.list-item:hover .controls-gradient {\n    background-image: linear-gradient(90deg, transparent, hsl(0, 0%, 96%));\n}\n\n.controls-buttons {\n    flex: none;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    pointer-events: auto;\n}\n\n.list-item:hover .controls-buttons {\n    background-color: hsl(0, 0%, 96%);\n}\n\n.remove-button,\n.edit-button {\n    background-image: url(Images/toolbarButtonGlyphs.png);\n    background-size: 352px 168px;\n    width: 32px;\n    height: 24px;\n    opacity: 0.5;\n    cursor: pointer;\n    flex: none;\n    visibility: hidden;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n.remove-button,\n.edit-button {\n    background-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\n.list-item:hover .remove-button,\n.list-item:hover .edit-button {\n    visibility: visible;\n}\n\n.remove-button:hover,\n.edit-button:hover {\n    opacity: 0.7;\n}\n\n.remove-button {\n    background-position: -128px -24px;\n}\n\n.edit-button {\n    background-position: -160px 0px;\n}\n\n.editor-container {\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n    flex: none;\n    background: hsl(0, 0%, 96%);\n    overflow: hidden;\n}\n\n.editor-content {\n    flex: auto;\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n}\n\n.editor-buttons {\n    flex: none;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    justify-content: flex-start;\n    padding: 5px;\n}\n\n.editor-buttons > button {\n    flex: none;\n    margin-right: 10px;\n}\n\n.editor-content input {\n    margin-right: 10px;\n}\n\n.editor-content input.error-input {\n    background-color: white;\n}\n\n/*# sourceURL=ui/listWidget.css */";
Runtime.cachedResources["ui/panelEnablerView.css"] = "/*\n * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.\n * Copyright (C) 2009 Anthony Ricaud <rik@webkit.org>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n.panel-enabler-view {\n    background-color: white;\n    font-size: 13px;\n    text-align: center;\n    overflow-x: hidden;\n    overflow-y: overlay;\n    flex: auto;\n    display: flex;\n}\n\n.panel-enabler-view h1 {\n    color: rgb(110, 116, 128);\n    font-size: 16px;\n    line-height: 20px;\n    font-weight: normal;\n    margin-top: 0;\n}\n\n.panel-enabler-view img {\n    height: 100%;\n    min-height: 200px;\n    max-width: 100%;\n    top: 0;\n    bottom: 0;\n    padding: 20px 0 20px 20px;\n    margin: auto;\n    vertical-align: middle;\n}\n\n.panel-enabler-view img.hidden {\n    display: initial !important;\n    width: 0;\n}\n\n.panel-enabler-view .flexible-space {\n    -webkit-flex: 1;\n}\n\n.panel-enabler-view form {\n    display: inline-block;\n    vertical-align: middle;\n    width: 330px;\n    margin: 0;\n    padding: 15px;\n    white-space: normal;\n}\n\n.panel-enabler-view label {\n    position: relative;\n    display: block;\n    text-align: left;\n    word-break: break-word;\n    margin: 0 0 5px 20px;\n}\n\n/*# sourceURL=ui/panelEnablerView.css */";
Runtime.cachedResources["ui/popover.css"] = ".popover-container {\n    pointer-events: none;\n    overflow: hidden;\n}\n\n.popover {\n    position: absolute;\n    z-index: 600;\n    pointer-events: none;\n    display: flex;\n    background-color: white;\n    box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.3), 0 2px 2px 0 rgba(0, 0, 0, 0.2), 0 1px 4px 0 rgba(0, 0, 0, 0.37);\n    border-radius: 2px;\n}\n\n.popover .content {\n    pointer-events: auto;\n    overflow: auto;\n    -webkit-user-select: text;\n    line-height: 11px;\n    flex: auto;\n    margin: 6px;\n}\n\n.popover .content.no-margin {\n    margin: 0;\n    overflow: hidden;\n}\n\n.popover .arrow {\n    position: absolute;\n    background-image: url(Images/popoverArrows.png);\n    width: 19px;\n    height: 19px;\n    margin-top: -19px;\n    top: 0;\n    left: 0;\n}\n\n.-theme-with-dark-background .popover .arrow {\n    -webkit-filter: invert(80%);\n}\n\n.popover.top-left-arrow .arrow {\n    /* The default is top-left, no styles needed. */\n}\n\n.popover.top-right-arrow .arrow {\n    right: 19px;\n    left: auto;\n}\n\n.popover.bottom-left-arrow .arrow {\n    top: auto;\n    bottom: 0;\n    margin-top: 0;\n    margin-bottom: -19px;\n    background-position: 0 -19px;\n}\n\n.popover.bottom-right-arrow .arrow {\n    right: 15px;\n    left: auto;\n    top: auto;\n    bottom: 0;\n    margin-top: 0;\n    margin-bottom: -19px;\n    background-position: 0 -19px;\n}\n\n.source-frame-popover-title {\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n    font-weight: bold;\n    padding-left: 18px;\n}\n\n.source-frame-popover-tree {\n    border-top: 1px solid rgb(184, 184, 184);\n    overflow: auto;\n    position: absolute;\n    top: 21px;\n    bottom: 5px;\n    left: 5px;\n    right: 5px;\n    margin-top: 1px;\n}\n\n/*# sourceURL=ui/popover.css */";
Runtime.cachedResources["ui/progressIndicator.css"] = "/*\n * Copyright (c) 2014 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.progress-indicator-shadow-stop-button {\n    background-color: rgb(216, 0, 0) !important;\n    border: 0;\n    width: 10px;\n    height: 12px;\n    border-radius: 2px;\n}\n\n.progress-indicator-shadow-container {\n    display: flex;\n    flex: 1 0 auto;\n    align-items: center;\n}\n\n.progress-indicator-shadow-container .title {\n    text-overflow: ellipsis;\n    overflow: hidden;\n    max-width: 150px;\n    margin-right: 2px;\n    color: #777;\n}\n\n.progress-indicator-shadow-container progress {\n    flex: auto;\n    margin: 0 2px;\n    width: 100px\n}\n\n/*# sourceURL=ui/progressIndicator.css */";
Runtime.cachedResources["ui/propertiesSection.css"] = "/*\n * Copyright (c) 2014 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.properties-tree {\n    margin: 0;\n    padding: 0 6px 2px;\n    list-style: none;\n    min-height: 18px;\n}\n\n.properties-tree ol {\n    display: none;\n    margin: 0;\n    -webkit-padding-start: 12px;\n    list-style: none;\n}\n\n.properties-tree ol.expanded {\n    display: block;\n}\n\n.properties-tree li {\n    margin-left: 12px;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    -webkit-user-select: text;\n    cursor: default;\n    padding-top: 2px;\n    line-height: 12px;\n}\n\n.properties-tree li.parent {\n    margin-left: 1px;\n}\n\n.properties-tree li.parent::before {\n    -webkit-user-select: none;\n    background-image: url(Images/toolbarButtonGlyphs.png);\n    background-size: 352px 168px;\n    opacity: 0.5;\n    content: \"a\";\n    width: 8px;\n    float: left;\n    margin-right: 4px;\n    color: transparent;\n    text-shadow: none;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n.properties-tree li.parent::before {\n    background-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\n.properties-tree li.parent::before {\n    background-position: -4px -96px;\n}\n\n.properties-tree li.parent.expanded::before {\n    background-position: -20px -96px;\n}\n\n.properties-tree li .info {\n    padding-top: 4px;\n    padding-bottom: 3px;\n}\n\n.properties-tree li.editing {\n    margin-left: 10px;\n    text-overflow: clip;\n}\n\n.properties-tree li.editing-sub-part {\n    padding: 3px 6px 8px 18px;\n    margin: -1px -6px -8px -6px;\n    text-overflow: clip;\n}\n\n.properties-tree .name {\n    color: rgb(136, 19, 145);\n    flex-shrink: 0;\n}\n\n.properties-tree .separator {\n    flex-shrink: 0;\n}\n\n.properties-tree .dimmed {\n    opacity: 0.6;\n}\n\n.properties-tree .value.error {\n    color: red;\n}\n\n.properties-tree .number {\n    color: blue;\n}\n\n.properties-tree .keyword {\n    color: rgb(136, 19, 79);\n}\n\n.properties-tree .color {\n    color: rgb(118, 15, 21);\n}\n\n/*# sourceURL=ui/propertiesSection.css */";
Runtime.cachedResources["ui/radioButton.css"] = "/*\n * Copyright (c) 2014 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n::content .dt-radio-button {\n    height: 17px;\n    width: 17px;\n    min-width: 17px;\n    border: 1px solid rgb(165, 165, 165);\n    background-image: linear-gradient(to bottom, rgb(252, 252, 252), rgb(223, 223, 223));\n    border-radius: 8px;\n    -webkit-appearance: none;\n    vertical-align: middle;\n    margin: 0 5px 5px 0;\n}\n\n::content .dt-radio-button:active:not(:disabled) {\n    background-image: linear-gradient(to bottom, rgb(194, 194, 194), rgb(239, 239, 239));\n}\n\n::content .dt-radio-button:checked {\n    background: url(Images/radioDot.png) center no-repeat,\n                linear-gradient(to bottom, rgb(252, 252, 252), rgb(223, 223, 223));\n}\n\n::content .dt-radio-button:checked:active {\n    background: url(Images/radioDot.png) center no-repeat,\n                linear-gradient(to bottom, rgb(194, 194, 194), rgb(239, 239, 239));\n}\n\n/*# sourceURL=ui/radioButton.css */";
Runtime.cachedResources["ui/searchableView.css"] = "/*\n * Copyright (c) 2014 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.search-bar {\n    flex: 0 0 23px;\n    background-color: #eee;\n    border-top: 1px solid #ccc;\n    display: flex;\n    overflow: hidden;\n}\n\n.search-bar.replaceable {\n    flex: 0 0 44px;\n}\n\n.search-toolbar {\n    margin-top: -2px;\n}\n\n.search-replace {\n    -webkit-appearance: none;\n    border: 0;\n    padding: 0 3px;\n    margin: 0;\n    flex: 1;\n}\n\n.search-replace:focus {\n    outline: none;\n}\n\n.toolbar-search {\n    border-spacing: 1px;\n}\n\n.toolbar-search td {\n    padding: 0 5px 0 0;\n}\n\n.toolbar-search td > span {\n    display: flex;\n    align-items: baseline;\n    line-height: 17px;\n}\n\n.toolbar-search-navigation-controls {\n    align-self: stretch;\n    background-image: linear-gradient(rgb(228, 228, 228), rgb(206, 206, 206));\n}\n\n.toolbar-search-navigation {\n    display: inline-block;\n    width: 18px;\n    height: 18px;\n    background-repeat: no-repeat;\n    background-position: 4px 7px;\n    border-left: 1px solid rgb(170, 170, 170);\n    opacity: 0.3;\n}\n\n.toolbar-search-navigation.enabled {\n    opacity: 1.0;\n}\n\n.toolbar-search button.search-action-button {\n    border: 1px solid rgb(163, 163, 163);\n    border-radius: 8px;\n    margin: 0;\n    background-image: linear-gradient(rgb(241, 241, 241), rgb(220, 220, 220));\n    width: 100%;\n    height: 20px;\n}\n\n.toolbar-search button.search-action-button:active {\n    background-image: linear-gradient(rgb(185, 185, 185), rgb(156, 156, 156));\n}\n\n.toolbar-search-control {\n    display: -webkit-flex;\n    position: relative;\n    background-color: white;\n}\n\n.toolbar-replace-control,\n#search-input-field {\n    padding-top: 1px;\n    line-height: 17px;\n}\n\n.toolbar-search-control, .toolbar-replace-control {\n    border: 1px solid rgb(163, 163, 163);\n    height: 20px;\n    border-radius: 2px;\n    width: 253px;\n    margin-left: 1px;\n}\n\n.toolbar-search-navigation.enabled:active {\n    background-position: 4px 7px, 0 0;\n}\n\n.toolbar-search-navigation.toolbar-search-navigation-prev {\n    background-image: url(Images/searchPrev.png);\n    border-left: 1px solid rgb(163, 163, 163);\n}\n\n:host-context(.-theme-with-dark-background) .toolbar-search-navigation {\n    -webkit-filter: invert(90%);\n}\n\n.toolbar-search-navigation.toolbar-search-navigation-prev.enabled:active {\n    background-image: url(Images/searchPrev.png), linear-gradient(rgb(168, 168, 168), rgb(116, 116, 116));\n}\n\n.toolbar-search-navigation.toolbar-search-navigation-next {\n    background-image: url(Images/searchNext.png);\n    border-left: 1px solid rgb(230, 230, 230);\n}\n\n.toolbar-search-navigation.toolbar-search-navigation-next.enabled:active {\n    background-image: url(Images/searchNext.png), linear-gradient(rgb(168, 168, 168), rgb(116, 116, 116));\n}\n\n.search-results-matches {\n    display: inline-block;\n    text-align: right;\n    font-size: 11px;\n    padding: 0 4px;\n    color: rgb(165, 165, 165);\n}\n\n/*# sourceURL=ui/searchableView.css */";
Runtime.cachedResources["ui/section.css"] = "/*\n * Copyright (c) 2014 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.section {\n    position: relative;\n    margin-top: 1px;\n}\n\n.section > .header {\n    padding: 0 8px 0 5px;\n    min-height: 18px;\n    white-space: nowrap;\n    background-origin: padding-box;\n    background-clip: padding-box;\n}\n\n.section > .header::before {\n    -webkit-user-select: none;\n    background-image: url(Images/toolbarButtonGlyphs.png);\n    background-size: 352px 168px;\n    opacity: 0.5;\n    content: \"a\";\n    color: transparent;\n    text-shadow: none;\n    float: left;\n    width: 8px;\n    margin-right: 4px;\n    margin-top: 2px;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n.section > .header::before {\n    background-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\n.section > .header::before {\n    background-position: -4px -96px;\n}\n\n.section.expanded > .header::before {\n    background-position: -20px -96px;\n}\n\n.section > .header .title {\n    font-weight: normal;\n    word-wrap: break-word;\n    white-space: normal;\n    line-height: 18px;\n}\n\n.section > .header label {\n    display: none;\n}\n\n.section.expanded .header label {\n    display: inline;\n}\n\n.section > .header .subtitle {\n    float: right;\n    margin-left: 5px;\n    max-width: 55%;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.section > .header .subtitle a {\n    color: inherit;\n}\n\n.section > .properties {\n    display: none;\n}\n\n.section.expanded > .properties {\n    display: block;\n}\n\n/*# sourceURL=ui/section.css */";
Runtime.cachedResources["ui/sidebarPane.css"] = "/*\n * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.\n * Copyright (C) 2009 Anthony Ricaud <rik@webkit.org>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n.sidebar-pane {\n    position: relative;\n    flex-direction: column;\n    display: flex;\n    flex: none;\n}\n\n.sidebar-pane-hidden {\n    display: none;\n}\n\n.sidebar-pane .info {\n    text-align: center;\n    font-style: italic;\n    padding: 6px;\n    color: #888;\n}\n\n.sidebar-pane .section .properties-tree {\n    padding-left: 16px;\n}\n\n.sidebar-tabbed-pane .tabbed-pane-header {\n    border-bottom: 1px solid rgb(202, 202, 202);\n    background-color: #eee;\n}\n\n.sidebar-pane-title {\n    display: flex;\n    align-items: center;\n    background-color: #eee;\n    height: 20px;\n    padding: 0 5px;\n    border-top: 1px solid #dadada;\n    white-space: nowrap;\n    overflow: hidden;\n    position: relative;\n}\n\n.sidebar-pane-title.expanded,\n.sidebar-pane-title:last-child {\n    border-bottom: 1px solid #ddd;\n}\n\n.sidebar-pane-title::before {\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs.png);\n    -webkit-mask-size: 352px 168px;\n    background-color: #888;\n    float: left;\n    width: 11px;\n    height: 11px;\n    margin-right: 2px;\n    content: \"a\";\n    color: transparent;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n.sidebar-pane-title::before {\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\n.sidebar-pane-title::before {\n    -webkit-mask-position: -4px -96px;\n}\n\n.sidebar-pane-title.expanded::before {\n    -webkit-mask-position: -20px -96px;\n}\n\n.sidebar-pane > .toolbar {\n    border-bottom: 1px solid #eee;\n}\n\n.sidebar-pane > .toolbar > * {\n    pointer-events: auto;\n}\n\n.sidebar-pane-title > .toolbar {\n    position: absolute;\n    right: 0;\n    top: -3px;\n}\n\n.section > .header input[type=checkbox] {\n    height: 1em;\n    width: 1em;\n    margin-left: 0;\n    margin-top: 0;\n    margin-bottom: 0.25em;\n    vertical-align: bottom;\n}\n\n.hidden-callframes-message {\n    text-align: center;\n    font-style: italic;\n    padding: 4px;\n    color: #888;\n    background-color: #FFFFC2;\n}\n\n\n/*# sourceURL=ui/sidebarPane.css */";
Runtime.cachedResources["ui/smallIcon.css"] = "/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\ndiv {\n    width: 10px;\n    height: 10px;\n    margin-right: 2px;\n    display: inline-block;\n}\n\ndiv.error-icon,\ndiv.revokedError-icon,\ndiv.warning-icon,\ndiv.info-icon,\ndiv.device-icon,\ndiv.red-ball,\ndiv.green-ball,\ndiv.orange-ball {\n    background-image: url(Images/toolbarButtonGlyphs.png);\n    background-size: 352px 168px;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\ndiv.error-icon,\ndiv.revokedError-icon,\ndiv.warning-icon,\ndiv.info-icon,\ndiv.device-icon,\ndiv.red-ball,\ndiv.green-ball,\ndiv.orange-ball {\n    background-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\ndiv.error-icon {\n    background-position: -213px -96px;\n}\n\ndiv.revokedError-icon {\n    background-position: -245px -107px;\n}\n\ndiv.warning-icon {\n    background-position: -202px -107px;\n}\n\ndiv.info-icon {\n    background-position: -213px -107px;\n}\n\ndiv.device-icon {\n    background-position: -224px -107px;\n}\n\ndiv.red-ball {\n    background-position: -224px -96px;\n}\n\ndiv.green-ball {\n    background-position: -235px -96px;\n}\n\ndiv.orange-ball {\n    background-position: -246px -96px;\n}\n\n/*# sourceURL=ui/smallIcon.css */";
Runtime.cachedResources["ui/softContextMenu.css"] = "/*\n * Copyright (c) 2014 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n    position: absolute;\n    border: 1px solid rgba(196, 196, 196, 0.9);\n    border-top: 1px solid rgba(196, 196, 196, 0.5);\n    /* NOTE: Keep padding top in sync with topPadding in SoftContextMenu.js */\n    padding: 4px 0 4px 0;\n    border-radius: 4px;\n    background-color: rgb(240, 240, 240);\n    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.25);\n    overflow-y: auto;\n    min-width: 160px !important;\n}\n\n.soft-context-menu-item {\n    display: flex;\n    width: 100%;\n    line-height: 14px;\n    font-size: 12px;\n    border-top: 1px solid transparent;\n    border-bottom: 1px solid transparent;\n    padding: 2px 7px 2px 8px;\n    margin: 0 13px 0 0;\n    white-space: nowrap;\n}\n\n.soft-context-menu-disabled {\n    color: #999;\n    pointer-events: none;\n}\n\n.soft-context-menu-separator {\n    height: 10px;\n    margin: 0 1px;\n}\n\n.soft-context-menu-separator > .separator-line {\n    margin: 0;\n    height: 5px;\n    border-bottom: 1px solid rgb(222, 222, 222);\n    pointer-events: none;\n}\n\n.soft-context-menu-item-mouse-over,\n.-theme-selection-color {\n    border-top: 1px solid rgb(56, 121, 217);\n    border-bottom: 1px solid rgb(56, 121, 217);\n    background-color: rgb(56, 121, 217);\n    color: white;\n}\n\n:host-context(.platform-mac) .soft-context-menu-item-mouse-over,\n.-theme-selection-color {\n    border-top: 1px solid transparent;\n    border-bottom: 1px solid transparent;\n    background-image: linear-gradient(to right, hsl(214, 81%, 60%), hsl(214, 100%, 56%));\n}\n\n:host-context(.platform-mac) .separator-line {\n    border-width: 2px;\n}\n\n.soft-context-menu-item-submenu-arrow {\n    color: #222;\n    pointer-events: none;\n    font-size: 11px;\n    flex: 1 1 auto;\n    text-align: right;\n}\n\n.soft-context-menu-item-mouse-over .soft-context-menu-item-checkmark {\n    color: white;\n}\n\n.soft-context-menu-custom-item {\n    display: inline-flex;\n    justify-content: center;\n    align-items: center;\n    flex: auto;\n}\n\n.soft-context-menu-shortcut {\n    color: gray;\n    pointer-events: none;\n    flex: 1 1 auto;\n    text-align: right;\n    padding-left: 10px;\n}\n\n.soft-context-menu-item-mouse-over .soft-context-menu-shortcut {\n    color: inherit;\n}\n\n.checkmark {\n    background-image: url(Images/toolbarButtonGlyphs.png);\n    background-size: 352px 168px;\n    opacity: 0.7;\n    width: 10px;\n    height: 10px;\n    background-position: -128px -109px;\n    display: inline-block;\n    pointer-events: none;\n    margin: auto 5px auto 0px;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n.checkmark {\n    background-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n}\n\n/*# sourceURL=ui/softContextMenu.css */";
Runtime.cachedResources["ui/splitWidget.css"] = "/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. AND ITS CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE INC.\n * OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n:host {\n    overflow: hidden;\n}\n\n.shadow-split-widget {\n    display: flex;\n    overflow: hidden;\n}\n\n.shadow-split-widget-contents {\n    display: flex;\n    position: relative;\n    flex-direction: column;\n}\n\n.shadow-split-widget-sidebar {\n    flex: none;\n}\n\n.shadow-split-widget-main, .shadow-split-widget-sidebar.maximized {\n    flex: auto;\n}\n\n.shadow-split-widget.hbox > .shadow-split-widget-resizer {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    width: 6px;\n    z-index: 500;\n}\n\n.shadow-split-widget.vbox > .shadow-split-widget-resizer {\n    position: absolute;\n    left: 0;\n    right: 0;\n    height: 6px;\n    z-index: 500;\n}\n\n.shadow-split-widget.hbox.shadow-split-widget-first-is-sidebar {\n    flex-direction: row-reverse !important;\n}\n\n.shadow-split-widget.vbox.shadow-split-widget-first-is-sidebar {\n    flex-direction: column-reverse !important;\n}\n\n.shadow-split-widget-resizer-border {\n    pointer-events: none;\n}\n\n.shadow-split-widget.vbox > .shadow-split-widget-sidebar:not(.maximized) {\n    border: 0;\n    border-top: 1px solid rgb(64%, 64%, 64%);\n}\n\n.shadow-split-widget.vbox.shadow-split-widget-first-is-sidebar > .shadow-split-widget-sidebar:not(.maximized) {\n    border: 0;\n    border-bottom: 1px solid rgb(64%, 64%, 64%);\n}\n\n.shadow-split-widget.hbox > .shadow-split-widget-sidebar:not(.maximized) {\n    border: 0;\n    border-left: 1px solid rgb(64%, 64%, 64%);\n}\n\n.shadow-split-widget.hbox.shadow-split-widget-first-is-sidebar > .shadow-split-widget-sidebar:not(.maximized) {\n    border: 0;\n    border-right: 1px solid rgb(64%, 64%, 64%);\n}\n\n.shadow-split-widget button.sidebar-show-hide-button {\n    position: absolute;\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs.png);\n    -webkit-mask-size: 352px 168px;\n    height: 16px;\n    width: 16px;\n    border: none;\n    z-index: 20;\n    background-color: #5a5a5a;\n}\n\n.shadow-split-widget button.sidebar-show-hide-button:hover {\n    background-color: #333;\n}\n\n.shadow-split-widget button.sidebar-show-hide-button:active {\n    background-color: #5a5a5a;\n}\n\n.shadow-split-widget button.sidebar-show-hide-button:disabled {\n    background-color: rgba(0, 0, 0, 0.35);\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n.shadow-split-widget button.sidebar-show-hide-button {\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\n.shadow-split-widget button.left-sidebar-show-hide-button,\n.shadow-split-widget button.top-sidebar-show-hide-button {\n    top: 5px;\n    left: 5px;\n}\n\n.shadow-split-widget button.right-sidebar-show-hide-button {\n    top: 5px;\n    right:4px;\n}\n\n.shadow-split-widget button.bottom-sidebar-show-hide-button {\n    bottom: 5px;\n    right: 3px;\n}\n\n.shadow-split-widget button.left-sidebar-show-hide-button.toggled-show {\n    -webkit-mask-position: -168px -76px; /* |> */\n}\n\n.shadow-split-widget button.left-sidebar-show-hide-button.toggled-hide {\n    -webkit-mask-position: -199px -76px; /* |< */\n}\n\n.shadow-split-widget button.right-sidebar-show-hide-button.toggled-show {\n    -webkit-mask-position: -296px -76px; /* <| */\n}\n\n.shadow-split-widget button.right-sidebar-show-hide-button.toggled-hide {\n    -webkit-mask-position: -264px -76px; /* >| */\n}\n\n.shadow-split-widget button.top-sidebar-show-hide-button.toggled-show {\n    -webkit-mask-position: -168px -76px; /* |> */\n    transform: rotate(90deg);\n}\n\n.shadow-split-widget button.top-sidebar-show-hide-button.toggled-hide {\n    -webkit-mask-position: -199px -76px; /* |< */\n    transform: rotate(90deg);\n}\n\n.shadow-split-widget button.bottom-sidebar-show-hide-button.toggled-show {\n    -webkit-mask-position: -296px -76px; /* <| */\n    transform: rotate(90deg);\n}\n\n.shadow-split-widget button.bottom-sidebar-show-hide-button.toggled-hide {\n    -webkit-mask-position: -264px -76px; /* >| */\n    transform: rotate(90deg);\n}\n\n/*# sourceURL=ui/splitWidget.css */";
Runtime.cachedResources["ui/toolbar.css"] = "/*\n * Copyright (c) 2014 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n    flex: none;\n    padding: 0 2px;\n}\n\n.toolbar-shadow {\n    position: relative;\n    white-space: nowrap;\n    height: 26px;\n    overflow: hidden;\n    z-index: 12;\n    display: flex;\n    flex: none;\n    align-items: center;\n}\n\n.toolbar-shadow.wrappable {\n    flex-wrap: wrap;\n}\n\n.toolbar-shadow.wrappable-reverse {\n    flex-direction: row-reverse;\n}\n\n.toolbar-shadow.vertical {\n    flex-direction: column;\n    height: auto;\n    width: 26px;\n}\n\n.toolbar-item {\n    position: relative;\n    display: flex;\n    background-color: transparent;\n    flex: none;\n    align-items: center;\n    justify-content: center;\n    padding: 0;\n    height: 26px;\n    border: none;\n    color: #5a5a5a;\n}\n\n.toolbar-dropdown-arrow {\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs.png);\n    -webkit-mask-size: 352px 168px;\n    -webkit-mask-position: -18px -96px;\n    background-color: #6D6D6D;\n    width: 12px;\n    height: 12px;\n    display: inline-block;\n    pointer-events: none;\n    margin: auto 0;\n    flex: none;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n    .toolbar-dropdown-arrow {\n        -webkit-mask-image: url(Images/toolbarButtonGlyphs_2x.png);\n    }\n} /* media */\n\n/* Toolbar item */\n\n.toolbar-button {\n    white-space: nowrap;\n    overflow: hidden;\n    min-width: 28px;\n    background: transparent;\n}\n\n.toolbar-text {\n    margin: 0 5px;\n    flex: none;\n    color: #5a5a5a;\n}\n\n.toolbar-has-dropdown {\n    justify-content: space-between;\n}\n\n.toolbar-has-dropdown .toolbar-text {\n    margin: 0 4px 0 0;\n    text-overflow: ellipsis;\n    flex: auto;\n    overflow: hidden;\n    text-align: right;\n    color: #333 !important;\n}\n\n.toolbar-button .toolbar-dropdown-arrow {\n    background-color: #333 !important;\n}\n\n.toolbar-has-glyph .toolbar-text {\n    margin-left: 0;\n}\n\n.toolbar-button:not(.toolbar-has-glyph):not(.toolbar-has-dropdown):not(.menu-toolbar-item) {\n    font-weight: bold;\n}\n\n.toolbar-button:not(.toolbar-has-glyph):not(.toolbar-has-dropdown):not(.menu-toolbar-item).hover {\n    background-color: #f3f3f3;\n}\n\n.toolbar-glyph {\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs.png);\n    -webkit-mask-size: 352px 168px;\n    background-color: #5a5a5a;\n    width: 28px;\n    height: 24px;\n    flex: none;\n    transform: translateX(-2px);\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n.toolbar-glyph {\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\n/* Button */\n\n.toolbar-button:disabled {\n    opacity: 0.5;\n}\n\n.toolbar-button:enabled.hover:not(:active) .toolbar-glyph {\n    background-color: #333;\n}\n\n.toolbar-button:enabled.hover:not(:active) .toolbar-text {\n    color: #333;\n}\n\n.toolbar-button.toolbar-state-on .toolbar-glyph,\n.toolbar-blue-on-hover .toolbar-button:not(.toolbar-state-on):enabled.hover:not(:active),\n.-theme-selection-color {\n    background-color: hsl(218, 81%, 59%);\n}\n\n.toolbar-button.toolbar-state-on .toolbar-text,\n.-theme-selection-color {\n    color: hsl(218, 81%, 59%);\n}\n\n.toolbar-blue-on-hover .toolbar-button:not(.toolbar-state-on):enabled.hover .toolbar-glyph {\n    background-color: white;\n}\n\n.toolbar-blue-on-hover .toolbar-button:not(.toolbar-state-on):enabled.hover .toolbar-text {\n    color: white;\n}\n\n.toolbar-button.toolbar-state-on:enabled.hover:not(:active) .toolbar-glyph,\n.toolbar-blue-on-hover .toolbar-button:not(.toolbar-state-on):enabled:active.hover,\n.-theme-selection-color {\n    background-color: hsl(218, 96%, 54%);\n}\n\n.toolbar-button.toolbar-state-on:enabled.hover:not(:active) .toolbar-text,\n.-theme-selection-color {\n    color: hsl(218, 96%, 54%);\n}\n\n.toolbar-toggled-gray .toolbar-button.toolbar-state-on {\n    background-color: #f3f3f3 !important;\n}\n\n/* Checkbox */\n\n.toolbar-item.checkbox {\n    padding: 0 5px 0 2px;\n}\n\n.toolbar-item.checkbox.hover {\n    color: #333;\n}\n\n/* Select */\n\n.toolbar-select-container {\n    display: inline-flex;\n    flex-shrink: 0;\n    margin-right: 6px;\n}\n\nselect.toolbar-item {\n    min-width: 48px;\n    -webkit-appearance: none;\n    border: 0;\n    border-radius: 0;\n    padding: 0 15px 0 5px;\n    margin-right: -10px;\n    position: relative;\n}\n\n/* Input */\n\ninput.toolbar-item {\n    width: 200px;\n    height: 20px;\n    padding: 3px;\n    margin: 1px 3px;\n    background-color: white;\n    border: solid 1px #d8d8d8;\n}\n\ninput.toolbar-item:focus,\ninput.toolbar-item.hover {\n    border: solid 1px rgb(202, 202, 202);\n}\n\n/* Separator */\n\n.toolbar-divider {\n    background-color: #ccc;\n    width: 1px;\n    margin: 5px 4px;\n    height: 16px;\n}\n\n/* Long click */\n\n.long-click-glyph {\n    position: absolute;\n    background-color: #5a5a5a;\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs.png);\n    -webkit-mask-position: -290px -46px;\n    -webkit-mask-size: 352px 168px;\n    width: 28px;\n    height: 24px;\n    top: 0;\n    left:  0;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n.long-click-glyph {\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\n.toolbar-button.emulate-active {\n    background-color: rgb(163, 163, 163);\n}\n\n.toolbar-shadow.floating {\n    flex-direction: column;\n    height: auto;\n    background-color: white;\n    border: 1px solid #ccc;\n    margin-top: -1px;\n    width: 28px;\n    left: -2px;\n}\n\n/* Predefined items */\n\n.dock-toolbar-item-undock.toolbar-glyph {\n    -webkit-mask-position: 0 -48px;\n}\n\n.dock-toolbar-item-bottom.toolbar-glyph {\n    -webkit-mask-position: -32px -24px;\n}\n\n.dock-toolbar-item-right.toolbar-glyph {\n    -webkit-mask-position: -256px -48px;\n}\n\n.menu-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -192px -24px;\n}\n\n.node-search-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -320px -120px;\n}\n\n.delete-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -128px 0;\n}\n\n.clear-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -64px 0;\n}\n\n.refresh-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: 0 0;\n}\n\n.visibility-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -96px 0;\n}\n\n.large-list-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -224px 0;\n}\n\n.record-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -288px 0;\n}\n\n.toolbar-state-on .record-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -288px -24px;\n}\n\n.camera-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -96px -24px;\n}\n\n.step-in-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -64px -72px;\n}\n\n.step-out-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -96px -72px;\n}\n\n.step-over-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -128px -72px;\n}\n\n.play-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -64px -48px;\n}\n\n.play-backwards-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -64px -48px;\n    transform: scaleX(-1);\n}\n\n.pause-on-exceptions-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -256px 0;\n}\n\n.pause-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -32px -72px;\n}\n\n.toolbar-state-on .pause-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: 0 -72px;\n}\n\n.toolbar-state-on .breakpoint-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -32px 0;\n}\n\n.breakpoint-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: 0 -24px;\n}\n\n.format-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -256px -24px;\n}\n\n.garbage-collect-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -128px -24px;\n}\n\n.filter-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -32px -48px;\n}\n\n.waterfall-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -128px -48px;\n}\n\n.pan-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -98px -120px;\n}\n\n.center-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -128px -120px;\n}\n\n.rotate-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -160px -120px;\n}\n\n.pin-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -256px -120px;\n}\n\n.animation-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -192px -120px;\n}\n\n.eyedropper-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -288px -120px;\n}\n\n.add-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -224px -120px;\n}\n\n.toolbar-state-pause-outline .animation-control-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -320px 0px;\n}\n\n.toolbar-state-replay-outline .animation-control-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -320px -24px;\n    background-color: rgb(66, 129, 235) !important;\n}\n\n.toolbar-state-play-outline .animation-control-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -320px -48px;\n    background-color: rgb(66, 129, 235) !important;\n}\n\n.background-color-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -96px -144px;\n}\n\n.foreground-color-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -128px -144px;\n}\n\n.layout-editor-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: 0 -144px;\n}\n\n.block-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -32px -144px;\n}\n\n.phone-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -320px -96px;\n}\n\n.rotate-screen-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -192px -144px;\n}\n\n.enter-fullscreen-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -256px -96px;\n}\n\n.responsive-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -288px -96px;\n}\n\n.frame-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -256px -144px;\n}\n\n.domain-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -160px -144px;\n}\n\n.folder-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: -224px -144px;\n}\n\n.goto-source-toolbar-item.toolbar-glyph {\n    -webkit-mask-position: 0 -120px;\n}\n\n.toolbar-state-on .record-toolbar-item.toolbar-glyph,\n.toolbar-state-active .filter-toolbar-item.toolbar-glyph,\n.toolbar-state-active .block-toolbar-item.toolbar-glyph {\n    background-color: rgb(216, 0, 0) !important;\n}\n\n:host-context(.-theme-with-dark-background) .toolbar-state-active .filter-toolbar-item.toolbar-glyph,\n:host-context(.-theme-with-dark-background) .toolbar-state-active .block-toolbar-item.toolbar-glyph,\n:host-context(.-theme-with-dark-background) .toolbar-state-on .record-toolbar-item.toolbar-glyph {\n    background-color: hsl(0, 100%, 65%) !important;\n}\n\n/*# sourceURL=ui/toolbar.css */";
Runtime.cachedResources["ui/suggestBox.css"] = "/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n:host {\n    position: absolute;\n    background-color: transparent;\n    z-index: 1000;\n    pointer-events: none;\n    overflow: hidden;\n    display: flex;\n    flex-direction: row;\n}\n\n.suggest-box-left-spacer {\n    flex: 0 1 auto;\n}\n\n.suggest-box-horizontal {\n    display: flex;\n    flex-direction: column;\n    flex: 0 0 auto;\n    max-width: 300px;\n}\n\n.suggest-box-top-spacer {\n    flex: auto;\n}\n\n:host(.under-anchor) .suggest-box-top-spacer,\n:host(:not(.under-anchor)) .suggest-box-bottom-spacer {\n    flex: 0 0 auto;\n}\n\n.suggest-box-container {\n    display: flex;\n    flex-direction: row;\n}\n\n.suggest-box {\n    background-color: #FFFFFF;\n    border: 1px solid rgb(66%, 66%, 66%);\n    pointer-events: auto;\n    margin-left: -3px;\n    overflow-x: hidden;\n    overflow-y: auto;\n    display: flex;\n    flex-direction: column;\n    flex: 0 0 auto;\n    border-radius: 5px 5px 5px 0;\n}\n\n:host(.under-anchor) .suggest-box {\n    border-radius: 0 5px 5px 5px;\n}\n\n.suggest-box .suggest-box-content-item {\n    padding: 1px;\n    margin: 0;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    border: 1px solid transparent;\n    flex: 0 0 auto;\n    padding-right: 0;\n    white-space: nowrap;\n}\n\n.suggest-box .suggest-box-content-item.additional {\n    background-color: #f9f9f9;\n}\n\n.suggest-box .suggest-box-content-item.additional::before {\n    display: inline-block;\n    content: \"\";\n    -webkit-user-select: none;\n    background-image: url(Images/toolbarButtonGlyphs.png);\n    background-size: 352px 168px;\n    width: 10px;\n    height: 10px;\n    position: relative;\n    top: 2px;\n    margin-right: 4px;\n    background-position: -192px -96px;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n.suggest-box .suggest-box-content-item.additional::before {\n    background-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\n.suggest-box .suggest-box-content-item .prefix {\n    font-weight: bold;\n}\n\n.suggest-box .suggest-box-content-item .spacer {\n    display: inline-block;\n    width: 20px;\n}\n\n.suggest-box .suggest-box-content-item.selected {\n    background-color: rgba(56, 121, 217, 0.1);\n}\n\n.suggest-box .suggest-box-content-item:hover:not(.selected) {\n    border: 1px solid rgb(204, 204, 204);\n}\n\n.suggest-box .details-popup {\n    padding: 17px;\n    pointer-events: auto;\n    margin-left: 3px;\n    max-width: 750px;\n    word-wrap: normal;\n}\n\n.suggest-box .details-popup .description {\n    margin-top: 22px;\n    color: #808080;\n}\n\n/*# sourceURL=ui/suggestBox.css */";
Runtime.cachedResources["ui/tabbedPane.css"] = "/*\n * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.\n * Copyright (C) 2009 Anthony Ricaud <rik@webkit.org>\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * 1. Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. AND ITS CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE INC.\n * OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n.tabbed-pane {\n    flex: auto;\n    overflow: hidden;\n}\n\n.tabbed-pane-content {\n    position: relative;\n    overflow: auto;\n    flex: auto;\n    display: flex;\n    flex-direction: column;\n}\n\n.tabbed-pane-content.has-no-tabs {\n    background-color: lightgray;\n}\n\n.tabbed-pane-placeholder {\n    font-size: 14px;\n    text-align: center;\n    margin-top: 20px;\n    text-shadow: rgba(255, 255, 255, 0.75) 0 1px 0;\n}\n\n.tabbed-pane-header {\n    display: flex;\n    flex: 0 0 27px;\n    border-bottom: 1px solid #ccc;\n    overflow: visible;\n    width: 100%;\n    background-color: #f3f3f3;\n}\n\n.tabbed-pane-header-contents {\n    flex: auto;\n    pointer-events: none;\n    margin-left: 5px;\n    position: relative;\n}\n\n.tabbed-pane-header-contents > * {\n    pointer-events: initial;\n}\n\n.tabbed-pane-header-tab-icon {\n    margin-right: 2px;\n}\n\n.tabbed-pane-header-tab {\n    float: left;\n    margin-top: 2px;\n    padding: 2px 4px 2px 4px;\n    height: 24px;\n    border: 1px solid transparent;\n    border-bottom: none;\n    line-height: 15px;\n    white-space: nowrap;\n    cursor: default;\n    display: flex;\n    align-items: center;\n    color: #5a5a5a;\n}\n\n.tabbed-pane-header-tab:hover,\n.tabbed-pane-header-tab.selected:hover {\n    color: #333;\n    background-color: #e5e5e5;\n}\n\n.tabbed-pane-header-tab-title {\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.tabbed-pane-header-tab.measuring {\n    visibility: hidden;\n}\n\n.tabbed-pane-header-tab.selected {\n    border: 1px solid #ccc;\n    border-bottom: none;\n    color: #333;\n}\n\n.tabbed-pane-header-tab.selected {\n    background-color: white;\n    border-top-color: #ccc;\n}\n\n.tabbed-pane-header-tab.dragging {\n    position: relative;\n    box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.37);\n    background-color: #e5e5e5;\n}\n\n.tabbed-pane-header-tab .tabbed-pane-close-button {\n    display: inline-block;\n    position: relative;\n    top: 2px;\n    left: 1px;\n    margin-left: 2px;\n    margin-top: -3px;\n    visibility: hidden;\n}\n\n.tabbed-pane-header-tab:hover .tabbed-pane-close-button,\n.tabbed-pane-header-tab.selected .tabbed-pane-close-button {\n    visibility: visible;\n}\n\n.tabbed-pane-header-tabs-drop-down-container {\n    float: left;\n    position: relative;\n    vertical-align: bottom;\n    line-height: 24px;\n    opacity: 0.8;\n    color: inherit;\n    font-size: 133%;\n    cursor: pointer;\n}\n\n.tabbed-pane-header-tabs-drop-down-container > .glyph {\n    height: 26px;\n    background-color: hsla(0,0%,20%,1);\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs.png);\n    -webkit-mask-position: -68px -143px;\n    -webkit-mask-size: 352px 168px;\n    width: 24px;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n.tabbed-pane-header-tabs-drop-down-container > .glyph {\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\n.tabbed-pane-header-tabs-drop-down-container:hover {\n    background-color: rgb(229, 229, 229);\n}\n\n.tabbed-pane-header-tabs-drop-down-container.measuring {\n    visibility: hidden;\n}\n\n.tabbed-pane-header-tabs-drop-down-container:hover {\n    opacity: 1.0;\n}\n\n.tabbed-pane-header-tabs-drop-down-container:active {\n    opacity: 0.8;\n}\n\n/* Web page style */\n\n.tabbed-pane-shadow.vertical-tab-layout {\n    flex-direction: row !important;\n}\n\n.tabbed-pane-shadow.vertical-tab-layout .tabbed-pane-header {\n    background-color: transparent;\n    border: none transparent !important;\n    width: auto;\n    flex: 0 0 auto;\n    flex-direction: column;\n    padding-top: 10px;\n    overflow: hidden;\n}\n\n.tabbed-pane-shadow.vertical-tab-layout .tabbed-pane-content {\n    padding: 10px 10px 10px 0;\n    overflow-x: hidden;\n}\n\n.tabbed-pane-shadow.vertical-tab-layout .tabbed-pane-header-contents {\n    margin: 0;\n    flex: none;\n}\n\n.tabbed-pane-shadow.vertical-tab-layout .tabbed-pane-header-tabs {\n    display: flex;\n    flex-direction: column;\n    width: 120px;\n}\n\n.tabbed-pane-shadow.vertical-tab-layout .tabbed-pane-header-tab {\n    background-color: transparent;\n    border: none transparent;\n    font-weight: normal;\n    text-shadow: none;\n    color: #777;\n    height: 26px;\n    padding-left: 10px;\n    border-left: 6px solid transparent;\n    margin: 0;\n    display: flex;\n    align-items: center;\n}\n\n.tabbed-pane-shadow.vertical-tab-layout .tabbed-pane-header-tab:not(.selected) {\n    cursor: pointer !important;\n}\n\n.tabbed-pane-shadow.vertical-tab-layout .tabbed-pane-header-tab.selected {\n    color: inherit;\n    border: none transparent;\n    border-left: 6px solid #666;\n}\n\n.tabbed-pane-tab-slider,\n.-theme-selection-color {\n    height: 2px;\n    position: absolute;\n    bottom: -1px;\n    background-color: #3E82F7;\n    left: 0;\n    z-index: 50;\n    transform-origin: 0 100%;\n    transition: transform 150ms cubic-bezier(0, 0, 0.2, 1);\n    visibility: hidden;\n    border-top: 1px solid hsl(218, 82%, 78%);\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n    .tabbed-pane-tab-slider {\n        border-top: none;\n    }\n}\n\n.tabbed-pane-tab-slider.enabled {\n    visibility: visible;\n}\n\n.tabbed-pane-header.tabbed-pane-no-header-background {\n    background-color: transparent;\n}\n\n.toolkit-hide {\n    display: none !important;\n}\n/*# sourceURL=ui/tabbedPane.css */";
Runtime.cachedResources["ui/textButton.css"] = "/*\n * Copyright (c) 2014 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n    background-image: linear-gradient(hsl(0, 0%, 93%), hsl(0, 0%, 93%) 38%, hsl(0, 0%, 87%));\n    border: 1px solid hsla(0, 0%, 0%, 0.25);\n    border-radius: 2px;\n    box-shadow: 0 1px 0 hsla(0, 0%, 0%, 0.08), inset 0 1px 2px hsla(0, 100%, 100%, 0.75);\n    color: hsl(0, 0%, 27%);\n    font-size: 12px;\n    margin: 0 1px 0 0;\n    text-shadow: 0 1px 0 hsl(0, 0%, 94%);\n    min-height: 2em !important;\n    padding-left: 10px;\n    padding-right: 10px;\n    -webkit-user-select: none;\n    flex: none;\n}\n\n:host-context(body.inactive),\n:host(:disabled) {\n    background-image: linear-gradient(#f1f1f1, #f1f1f1 38%, #e6e6e6);\n    border-color: rgba(80, 80, 80, 0.2);\n    box-shadow: 0 1px 0 rgba(80, 80, 80, 0.08), inset 0 1px 2px rgba(255, 255, 255, 0.75);\n    color: #aaa;\n}\n\n:host(:not(:disabled):hover) {\n    background-image: linear-gradient(hsl(0, 0%, 94%), hsl(0, 0%, 94%) 38%, hsl(0, 0%, 88%));\n    border-color: hsla(0, 0%, 0%, 0.3);\n    box-shadow: 0 1px 0 hsla(0, 0%, 0%, 0.12), inset 0 1px 2px hsla(0, 100%, 100%, 0.95);\n    color: hsl(0, 0%, 0%);\n}\n\n:host(:not(:disabled):active) {\n    background-image: linear-gradient(hsl(0, 0%, 91%), hsl(0, 0%, 91%) 38%, hsl(0, 0%, 84%));\n    box-shadow: none;\n    text-shadow: none;\n}\n\n:host(:not(:disabled):focus) {\n    -webkit-transition: border-color 200ms;\n    border-color: rgb(77, 144, 254);\n    outline: none;\n}\n\n/*# sourceURL=ui/textButton.css */";
Runtime.cachedResources["ui/textPrompt.css"] = "/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.text-prompt-editing {\n    -webkit-user-select: text;\n    box-shadow: rgba(0, 0, 0, .5) 3px 3px 4px;\n    outline: 1px solid rgb(66%, 66%, 66%) !important;\n    background-color: white;\n    -webkit-user-modify: read-write-plaintext-only;\n    text-overflow: clip !important;\n    padding-left: 2px;\n    margin-left: -2px;\n    padding-right: 2px;\n    margin-right: -2px;\n    margin-bottom: -1px;\n    padding-bottom: 1px;\n    opacity: 1.0 !important;\n}\n\n.text-prompt-editing,\n.text-prompt-editing ::content * {\n    color: #222 !important;\n    text-decoration: none !important;\n    -webkit-user-modify: read-write-plaintext-only;\n}\n\n::content .auto-complete-text,\n.text-prompt-editing ::content .auto-complete-text {\n    color: rgb(128, 128, 128) !important;\n    -webkit-user-select: none;\n    -webkit-user-modify: read-only;\n}\n\n.text-prompt-editing ::content br {\n    display: none;\n}\n\n/*# sourceURL=ui/textPrompt.css */";
Runtime.cachedResources["ui/tooltip.css"] = "/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.tooltip {\n    background: hsl(0, 0%, 95%);\n    border-radius: 2px;\n    color: hsl(0, 0%, 20%);\n    padding: 5px 8px;\n    font-size: 11px;\n    line-height: 14px;\n    display: flex;\n    align-items: center;\n    -webkit-filter: drop-shadow(0 1px 2px hsla(0, 0%, 0%, 0.3));\n    border: 1px solid hsla(0, 0%, 0%, 0.1);\n    background-clip: padding-box;\n    box-sizing: border-box;\n    position: absolute;\n    visibility: hidden;\n    transition: visibility 0s 100ms, opacity 150ms cubic-bezier(0, 0, .2, 1);\n    z-index: 20001;\n    top: 0;\n    left: 0;\n    opacity: 0;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.tooltip.shown {\n    visibility: visible;\n    transition-delay: 600ms;\n    opacity: 1;\n}\n\n.tooltip.shown.instant {\n    transition-delay: 0s;\n}\n\n.tooltip-shortcut {\n    color: hsl(0, 0%, 45%);\n    display: inline-block;\n    margin-left: 8px;\n    flex: 0 0 auto;\n}\n\n/*# sourceURL=ui/tooltip.css */";
Runtime.cachedResources["ui/treeoutline.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n    flex: 1 1;\n    padding: 2px 0 0 0;\n}\n\n.tree-outline-disclosure:not(.tree-outline-disclosure-hide-overflow) {\n    min-width: 100%;\n    display: inline-block;\n}\n\n.tree-outline {\n    padding: 0 0 4px 4px;\n    margin: 0;\n    z-index: 0;\n    position: relative;\n}\n\n.tree-outline li.hovered:not(.selected) .selection {\n    display: block;\n    left: 3px;\n    right: 3px;\n    background-color: rgba(56, 121, 217, 0.1);\n    border-radius: 5px;\n}\n\n.tree-outline li .selection {\n    display: none;\n    z-index: -1;\n    margin-left: -10000px;\n}\n\n.tree-outline li.selected .selection {\n    display: block;\n    background-color: #ddd;\n}\n\n.tree-outline li.in-clipboard .highlight {\n    outline: 1px dotted darkgrey;\n}\n\n.tree-outline li.elements-drag-over .selection {\n    display: block;\n    margin-top: -2px;\n    border-top: 2px solid rgb(56, 121, 217);\n}\n\nol.tree-outline:focus li.selected .selection {\n    background-color: rgb(56, 121, 217);\n}\n\nol.tree-outline:focus li.parent.selected::before {\n    background-color: white;\n}\n\nol.tree-outline,\n.tree-outline ol {\n    list-style-type: none;\n}\n\n.tree-outline-no-padding {\n    padding: 0;\n}\n\n.tree-outline ol {\n    padding-left: 12px;\n}\n\n.tree-outline li {\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    position: relative;\n    display: flex;\n    align-items: center;\n    min-height: 16px;\n}\n\nol.tree-outline:focus li.selected {\n    color: white;\n}\n\nol.tree-outline:focus li.selected * {\n    color: inherit;\n}\n\n.tree-outline li::before {\n    -webkit-user-select: none;\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs.png);\n    -webkit-mask-size: 352px 168px;\n    content: \"aa\";\n    color: transparent;\n    text-shadow: none;\n    margin-right: -2px;\n    height: 12px;\n}\n\n.tree-outline li:not(.parent)::before {\n    background-color: transparent;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n.tree-outline li::before {\n    -webkit-mask-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\n.tree-outline li::before {\n    -webkit-mask-position: -4px -96px;\n    background-color: rgb(110, 110, 110);\n}\n\n.tree-outline li.parent.expanded::before {\n    -webkit-mask-position: -20px -96px;\n}\n\n.tree-outline ol.children {\n    display: none;\n}\n\n.tree-outline ol.children.expanded {\n    display: block;\n}\n\n/*# sourceURL=ui/treeoutline.css */";
Runtime.cachedResources["components/breakpointsList.css"] = "/*\n * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.\n * Copyright (C) 2009 Anthony Ricaud <rik@webkit.org>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n.sidebar-pane .breakpoint-condition {\n    display: block;\n    margin-top: 4px;\n    margin-bottom: 4px;\n    margin-left: 23px;\n    margin-right: 8px;\n}\n\n.breakpoint-list .editing.being-edited {\n    overflow: hidden;\n    white-space: nowrap;\n}\n\n#breakpoint-condition-input {\n    display: block;\n    margin-left: 0;\n    margin-right: 0;\n    outline: none !important;\n    border: 1px solid rgb(66%, 66%, 66%);\n}\n\nol.breakpoint-list {\n    -webkit-padding-start: 0;\n    list-style: none;\n    margin: 0;\n    padding-bottom: 3px;\n}\n\n.breakpoints-list-deactivated {\n    background-color: #eee;\n    opacity: 0.3;\n}\n\n.breakpoint-list li {\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    padding: 2px 0;\n}\n\n.breakpoint-list li:hover {\n    background-color: #eee;\n}\n\n.breakpoint-list .source-text {\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    margin: 2px 0 0 20px;\n}\n\n.sidebar-pane .breakpoint-hit {\n    background-color: rgb(255, 255, 194);\n}\n\n.-theme-with-dark-background .sidebar-pane .breakpoint-hit {\n    background-color: hsl(46, 98%, 22%);\n    color: #ccc;\n}\n\nli.breakpoint-hit .breakpoint-hit-marker {\n    background-color: rgb(255, 255, 194);\n    height: 18px;\n    left: 0;\n    margin-top: -16px;\n    position: absolute;\n    right: 0;\n    z-index: -1;\n}\n\n.event-listener-breakpoints {\n    margin-top: 0;\n    padding: 2px 6px;\n    list-style: none;\n    min-height: 18px;\n}\n\n.event-listener-breakpoints ol {\n    display: none;\n    margin: 0;\n    -webkit-padding-start: 12px;\n    list-style: none;\n}\n\n.event-listener-breakpoints ol.expanded {\n    display: block;\n}\n\n.event-listener-breakpoints li {\n    margin-left: 12px;\n    text-overflow: ellipsis;\n    -webkit-user-select: text;\n    cursor: default;\n}\n\n.event-listener-breakpoints li.parent {\n    margin-left: 1px;\n}\n\n.event-listener-breakpoints li.parent::before {\n    -webkit-user-select: none;\n    background-image: url(Images/toolbarButtonGlyphs.png);\n    background-size: 352px 168px;\n    opacity: 0.5;\n    content: \"a\";\n    width: 8px;\n    float: left;\n    margin: 2px 2px 0 -2px;\n    color: transparent;\n    text-shadow: none;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n.event-listener-breakpoints li.parent::before {\n    background-image: url(Images/toolbarButtonGlyphs_2x.png);\n}\n} /* media */\n\n.event-listener-breakpoints li.parent::before {\n    background-position: -4px -96px;\n}\n\n.event-listener-breakpoints li.parent.expanded::before {\n    background-position: -20px -96px;\n}\n\n.event-listener-breakpoints .children li {\n    margin-left: 12px;\n}\n\n.async-operations li > label {\n    float: left;\n}\n\n.async-operations li > div {\n    float: right;\n    margin: 2px 3px 0 2px;\n}\n\n.dom-breakpoints-list > li {\n    display: flex;\n}\n\n.dom-breakpoints-list .dom-breakpoint > div {\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n/*# sourceURL=components/breakpointsList.css */";
Runtime.cachedResources["components/customPreviewSection.css"] = "/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.custom-expandable-section {\n    display: inline-flex;\n    flex-direction: column;\n}\n\n.custom-expandable-section-header::before {\n    -webkit-user-select: none;\n    background-image: url(Images/toolbarButtonGlyphs.png);\n    background-size: 352px 168px;\n    opacity: 0.5;\n    content: \"a\";\n    width: 8px;\n    margin-right: 4px;\n    padding-right: 2px;\n    color: transparent;\n    text-shadow: none;\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n    .custom-expandable-section-header::before {\n        background-image: url(Images/toolbarButtonGlyphs_2x.png);\n    }\n} /* media */\n\n\n.custom-expandable-section-header::before {\n    background-position: -4px -96px;\n}\n\n.custom-expandable-section-header.expanded::before {\n    background-position: -20px -96px;\n}\n\n.custom-expandable-section-standard-section {\n    display: inline-flex;\n}\n/*# sourceURL=components/customPreviewSection.css */";
Runtime.cachedResources["components/eventListenersView.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.tree-outline-disclosure li {\n    padding: 2px 0 0 5px;\n    overflow: hidden;\n    display: list-item;\n    min-height: 16px;\n}\n\n.tree-outline-disclosure > li {\n    border-top: 1px solid #f0f0f0;\n}\n\n.tree-outline-disclosure > li:first-of-type {\n    border-top: none;\n}\n\n.tree-outline-disclosure {\n    padding-left: 0 !important;\n    padding-right: 3px;\n}\n\n.tree-outline-disclosure li.parent::before {\n    top: 0 !important;\n}\n\n.tree-outline-disclosure .name {\n    color: rgb(136, 19, 145);\n}\n\n.event-listener-tree-subtitle {\n    float: right;\n    margin-left: 5px;\n}\n\n.event-listener-delete-button {\n    padding: 0 3px;\n    background-color: #f2f2f2;\n    border-radius: 3px;\n    border: 1px solid #c3c3c3;\n    margin-left: 10px;\n    display: none;\n    cursor: pointer;\n}\n\n.event-listener-delete-button:hover {\n    background-color: #e0e0e0;\n}\n\n.tree-outline-disclosure li:hover .event-listener-delete-button {\n    display: inline;\n}\n\n/*# sourceURL=components/eventListenersView.css */";
Runtime.cachedResources["components/domUtils.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n  display: inline;\n}\n\n.node-link {\n    cursor: pointer;\n    display: inline;\n    pointer-events: auto;\n}\n\n.stack-preview-async-description {\n    padding: 3px 0 1px;\n    font-style: italic;\n}\n\n.stack-preview-container .webkit-html-blackbox-link {\n    opacity: 0.6;\n}\n\n.stack-preview-container > tr {\n    height: 16px;\n    line-height: 16px;\n}\n\n.stack-preview-container td {\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.stack-preview-container .function-name {\n    max-width: 80em;\n}\n\n.node-label-name {\n    color: rgb(136, 18, 128);\n}\n\n.node-label-id {\n    color: rgb(26, 26, 166);\n}\n\n.node-label-class, .node-label-pseudo {\n    color: rgb(153, 69, 0);\n}\n\n/*# sourceURL=components/domUtils.css */";
Runtime.cachedResources["components/inspectorViewTabbedPane.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.tabbed-pane-header-tab,\n.tabbed-pane-header-tab.selected {\n    height: 26px;\n    margin: 0;\n    background: #f3f3f3;\n    border: none;\n    border-left: 2px solid transparent;\n    border-right: 2px solid transparent;\n    padding: 0 6px;\n}\n\n.tabbed-pane-header-tab.selected {\n    border-width: 0 2px 0 2px;\n}\n\n.tabbed-pane-header-contents {\n    margin-left: 0;\n}\n\n/*# sourceURL=components/inspectorViewTabbedPane.css */";
Runtime.cachedResources["components/networkConditionsSettingsTab.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n    overflow:hidden;\n}\n\n.header {\n    padding: 0 0 6px;\n    border-bottom: 1px solid #EEEEEE;\n    font-size: 18px;\n    font-weight: normal;\n    flex: none;\n}\n\n.add-conditions-button {\n    flex: none;\n    margin: 10px 0;\n    min-width: 140px;\n    align-self: flex-start;\n}\n\n.conditions-list {\n    max-width: 500px;\n    min-width: 340px;\n    flex: auto;\n}\n\n.conditions-list-item {\n    padding: 3px 5px 3px 5px;\n    height: 30px;\n    display: flex;\n    align-items: center;\n    position: relative;\n    flex: auto 1 1;\n}\n\n.conditions-list-text {\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    flex: 0 0 70px;\n    -webkit-user-select: none;\n    color: #222;\n    text-align: end;\n    position: relative;\n}\n\n.conditions-list-title {\n    text-align: start;\n    flex: auto;\n    display: flex;\n    align-items: flex-start;\n}\n\n.conditions-list-title-text {\n    overflow: hidden;\n    flex: auto;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n}\n\n.conditions-list-separator {\n    flex: 0 0 1px;\n    background-color: rgb(231, 231, 231);\n    height: 30px;\n    margin: 0 4px;\n}\n\n.conditions-list-separator-invisible {\n    visibility: hidden;\n    height: 100% !important;\n}\n\n.conditions-edit-row {\n    flex: none;\n    display: flex;\n    flex-direction: row;\n    margin: 6px 5px;\n}\n\n.conditions-edit-row input {\n    width: 100%;\n    text-align: inherit;\n}\n\n.conditions-edit-optional {\n    position: absolute;\n    bottom: -20px;\n    right: 0;\n    color: rgb(128, 128, 128);\n}\n\n/*# sourceURL=components/networkConditionsSettingsTab.css */";
Runtime.cachedResources["components/objectPropertiesSection.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.object-properties-section .name {\n    color: rgb(136, 19, 145);\n    flex-shrink: 0;\n}\n\n.object-properties-section-separator {\n    flex-shrink: 0;\n    padding-right: 5px;\n}\n\n.object-properties-section-dimmed {\n    opacity: 0.6;\n}\n\n.object-properties-section {\n    padding: 0 0 0px 0px;\n    color: rgb(33,33,33) !important;\n    display: flex;\n    flex-direction: column;\n}\n\n.object-properties-section li {\n    -webkit-user-select: text;\n}\n\n.object-properties-section li::before {\n    top: -1px;\n}\n\n.object-properties-section li.editing-sub-part {\n    padding: 3px 6px 8px;\n    margin: -1px -6px -8px -6px;\n    text-overflow: clip;\n}\n\n.object-properties-section li.editing {\n    margin-left: 10px;\n    text-overflow: clip;\n}\n\n.tree-outline ol.title-less-mode {\n    padding-left: 0px;\n}\n\n.object-properties-section .synthetic-property {\n    font-style: italic;\n}\n\n.object-properties-section-root-element {\n    display: flex;\n    flex-direction: row;\n}\n\n.object-properties-section-root-element::before {\n    -webkit-mask-position: -4px -97px !important;\n}\n\n.object-properties-section-root-element.expanded::before {\n    -webkit-mask-position: -20px -97px !important;\n}\n\n/*# sourceURL=components/objectPropertiesSection.css */";
Runtime.cachedResources["components/objectValue.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.object-value-scientific-notation-exponent {\n    flex-shrink: 0;\n}\n\n.object-value-scientific-notation-mantissa {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    flex-shrink: 1;\n    min-width: 1ex;\n}\n\n.object-value-scientific-notation-number {\n    display: flex !important;\n}\n\n.object-value-node:hover {\n    background-color: rgba(56, 121, 217, 0.1);\n}\n\n.object-value-function::before {\n    content: \"function\";\n    color: rgb(170, 13, 145);\n    padding-right: 5px;\n}\n\n.object-value-function {\n    font-style: italic;\n}\n\n.object-value-function.linkified:hover {\n    background-color: rgba(0, 0, 0, 0.1);\n    cursor: pointer;\n}\n\n.object-value-object,\n.object-value-map,\n.object-value-set,\n.object-value-iterator,\n.object-value-generator,\n.object-value-node,\n.object-value-array {\n    position: relative;\n    vertical-align: top;\n    color: inherit;\n    display: inline-block;\n}\n\n.object-value-number,\n.object-value-boolean {\n    color: rgb(28, 0, 207);\n}\n\n.object-value-string,\n.object-value-regexp,\n.object-value-symbol {\n    color: rgb(196, 26, 22);\n    white-space: pre;\n    unicode-bidi: -webkit-isolate;\n}\n\n.object-value-node {\n    color: rgb(136, 18, 128);\n}\n\n.object-value-null,\n.object-value-undefined {\n    color: rgb(128, 128, 128);\n}\n\n.object-value {\n    text-overflow: ellipsis;\n    overflow: hidden;\n    -webkit-user-select: text;\n}\n\n.object-value-calculate-value-button:hover {\n    text-decoration: underline;\n}\n\n.object-value-object .section,\n.object-formatted-map .section,\n.object-value-set .section,\n.object-value-iterator .section,\n.object-value-generator .section,\n.object-value-node .section,\n.object-value-array .section {\n    position: static;\n}\n.object-value-object .section > .header::before {\n    margin-top: 0;\n}\n\n\n.object-value-object .properties-tree,\n.object-value-map .properties-tree,\n.object-value-set .properties-tree,\n.object-value-iterator .properties-tree,\n.object-value-generator .properties-tree,\n.object-value-node .properties-tree {\n    padding-left: 0 !important;\n}\n\n.object-value-preview-node,\n.section .object-value-node {\n    color: rgb(136, 18, 128);\n}\n\n.object-properties-section-custom-section {\n    display: inline-flex;\n    flex-direction: column;\n}\n\n.-theme-with-dark-background .object-value-number,\n:host-context(.-theme-with-dark-background) .object-value-number,\n.-theme-with-dark-background .object-value-boolean,\n:host-context(.-theme-with-dark-background) .object-value-boolean {\n    color: hsl(252, 100%, 75%);\n}\n\n/*# sourceURL=components/objectValue.css */";
Runtime.cachedResources["emulation/devicesSettingsTab.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.devices-settings-tab .settings-tab.help-content {\n    display: flex;\n    flex-direction: column;\n    align-items: flex-start;\n    height: 100%;\n    margin: 0;\n}\n\n.devices-settings-tab .devices-title {\n    font-size: 120%;\n    color: #222;\n    flex: none;\n}\n\n.devices-settings-tab .devices-button-row {\n    flex: none;\n    display: flex;\n}\n\n.devices-settings-tab .devices-button-row button {\n    margin-right: 10px;\n    min-width: 120px;\n    flex: none;\n}\n\n.devices-settings-tab .devices-list {\n    width: 350px;\n    margin-top: 10px;\n}\n\n.devices-list-item {\n    padding: 3px 5px 3px 5px;\n    height: 30px;\n    display: flex;\n    align-items: center;\n    flex: auto 1 1;\n    cursor: pointer;\n}\n\n.devices-list-checkbox {\n    height: 12px;\n    width: 12px;\n    margin: 3px 5px 2px 2px;\n    flex: none;\n    pointer-events: none;\n}\n\n.devices-list-title {\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    flex: auto;\n    -webkit-user-select: none;\n    color: #222;\n}\n\n.devices-edit-fields {\n    flex: auto;\n    display: flex;\n    flex-direction: column;\n    align-items: stretch;\n    margin-bottom: 5px;\n}\n\n.devices-edit-fields input {\n    flex: auto;\n    margin: 8px 5px 0 5px;\n    height: 22px;\n    border: 1px solid rgb(213, 213, 213);\n    border-radius: 2px;\n    color: #444444;\n    padding: 3px;\n}\n\n.devices-edit-fields .device-edit-fixed {\n    flex: 0 0 140px;\n}\n\n.devices-edit-fields select {\n    margin: 8px 5px 0 5px;\n}\n\n/*# sourceURL=emulation/devicesSettingsTab.css */";
Runtime.cachedResources["emulation/deviceModeToolbar.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.device-mode-size-input {\n    background: hsl(0, 0%, 100%);\n    border: none;\n    padding: 2px 0;\n    width: 34px !important;\n    margin: 0 2px;\n    text-align: center;\n    box-shadow: 0px 0px 1px 0px hsla(0, 0%, 0%, 0.13);\n    border-radius: 1px;\n    height: 18px;\n    color: hsl(210, 16%, 22%);\n}\n\n.device-mode-size-input:focus::-webkit-input-placeholder {\n    color: transparent;\n}\n\n.device-mode-size-input:disabled {\n    background: transparent;\n    box-shadow: none;\n    -webkit-user-select: none;\n}\n\n.device-mode-x {\n    margin: 0 1px;\n    font-size: 16px;\n}\n\n.device-mode-empty-toolbar-element {\n    width: 0;\n}\n\n/*# sourceURL=emulation/deviceModeToolbar.css */";
Runtime.cachedResources["emulation/deviceModeView.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n    overflow: hidden;\n    align-items: stretch;\n    flex: auto;\n    background-color: hsl(0, 0%, 98%);\n}\n\n.device-mode-toolbar {\n    flex: none;\n    background-color: hsl(0, 0%, 98%);\n    border-bottom: 1px solid #ccc;\n    display: flex;\n    flex-direction: row;\n    align-items: stretch;\n}\n\n.device-mode-toolbar .toolbar {\n    overflow: hidden;\n    flex: 0 100000 auto;\n    padding: 0 5px;\n}\n\n.device-mode-toolbar .toolbar.device-mode-toolbar-fixed-size {\n    flex: 0 1 auto;\n}\n\n.device-mode-toolbar-spacer {\n    flex: 1 1 0;\n    display: flex;\n    flex-direction: row;\n    overflow: hidden;\n}\n\n.device-mode-content-clip {\n    overflow: hidden;\n    flex: auto;\n}\n\n.device-mode-media-container {\n    flex: none;\n    overflow: hidden;\n    box-shadow: inset 0 -1px #ccc;\n}\n\n.device-mode-content-clip:not(.device-mode-rulers-visible) .device-mode-media-container {\n    margin-bottom: 20px;\n}\n\n.device-mode-presets-container {\n    flex: 0 0 20px;\n    display: flex;\n}\n\n.device-mode-presets-container-inner {\n    flex: auto;\n    justify-content: center;\n    position: relative;\n    background-color: hsl(0, 0%, 90%);\n    border: 2px solid hsl(0, 0%, 98%);\n    border-bottom: 2px solid hsl(0, 0%, 98%);\n }\n\n.device-mode-presets-container:hover {\n    transition: opacity 0.1s;\n    transition-delay: 50ms;\n    opacity: 1;\n}\n\n.device-mode-preset-bar-outer {\n    pointer-events: none;\n    display: flex;\n    justify-content: center;\n}\n\n.device-mode-preset-bar {\n    border-left: 2px solid hsl(0, 0%, 98%);\n    border-right: 2px solid hsl(0, 0%, 98%);\n    pointer-events: auto;\n    text-align: center;\n    flex: none;\n    cursor: pointer;\n    color: #5A5A5A;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    white-space: nowrap;\n    margin-bottom: 1px;\n}\n\n.device-mode-preset-bar:hover {\n    transition: background-color 0.1s;\n    transition-delay: 50ms;\n    background-color: #d6d6d6;\n}\n\n.device-mode-preset-bar > span {\n    visibility: hidden;\n}\n\n.device-mode-preset-bar:hover > span {\n    transition: visibility 0.1s;\n    transition-delay: 50ms;\n    visibility: visible;\n}\n\n.device-mode-content-area {\n    flex: auto;\n    position: relative;\n    margin: 0;\n}\n\n.device-mode-screen-area {\n    position: absolute;\n    left: 0;\n    right: 0;\n    width: 0;\n    height: 0;\n    background-color: #171717;\n    box-shadow: hsl(240, 3%, 84%) 0 0 0 0.5px, hsla(0, 0%, 80%, 0.4) 0 0 20px;\n}\n\n.device-mode-screen-image {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n}\n\n.device-mode-resizer {\n    position: absolute;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    overflow: hidden;\n    transition: background-color 0.1s ease, opacity 0.1s ease;\n}\n\n.device-mode-resizer:hover {\n    background-color: hsla(0, 0%, 0%, 0.1);\n    opacity: 1;\n}\n\n.device-mode-resizer > div {\n    pointer-events: none;\n}\n\n.device-mode-right-resizer {\n    top: 0;\n    bottom: -1px;\n    right: -20px;\n    width: 20px;\n}\n\n.device-mode-left-resizer {\n    top: 0;\n    bottom: -1px;\n    left: -20px;\n    width: 20px;\n    opacity: 0;\n}\n\n.device-mode-bottom-resizer {\n    left: 0;\n    right: -1px;\n    bottom: -20px;\n    height: 20px;\n}\n\n.device-mode-bottom-right-resizer {\n    left: 0;\n    top: 0;\n    right: -20px;\n    bottom: -20px;\n    background-color: hsla(0, 0%, 0%, 0.02);\n}\n\n.device-mode-bottom-left-resizer {\n    left: -20px;\n    top: 0;\n    right: 0;\n    bottom: -20px;\n    opacity: 0;\n}\n\n.device-mode-right-resizer > div {\n    content: url(Images/resizeHorizontal.png);\n    width: 6px;\n    height: 26px;\n}\n\n.device-mode-left-resizer > div {\n    content: url(Images/resizeHorizontal.png);\n    width: 6px;\n    height: 26px;\n}\n\n.device-mode-bottom-resizer > div {\n    content: url(Images/resizeVertical.png);\n    margin-bottom: -2px;\n    width: 26px;\n    height: 6px;\n}\n\n.device-mode-bottom-right-resizer > div {\n    position: absolute;\n    bottom: 3px;\n    right: 3px;\n    width: 13px;\n    height: 13px;\n    content: url(Images/resizeDiagonal.png);\n}\n\n.device-mode-bottom-left-resizer > div {\n    position: absolute;\n    bottom: 3px;\n    left: 3px;\n    width: 13px;\n    height: 13px;\n    content: url(Images/resizeDiagonal.png);\n    transform: rotate(90deg);\n}\n\n@media (-webkit-min-device-pixel-ratio: 1.5) {\n    .device-mode-right-resizer > div {\n        content: url(Images/resizeHorizontal_2x.png);\n    }\n\n    .device-mode-left-resizer > div {\n        content: url(Images/resizeHorizontal_2x.png);\n    }\n\n    .device-mode-bottom-resizer > div {\n        content: url(Images/resizeVertical_2x.png);\n    }\n\n    .device-mode-bottom-right-resizer > div {\n        content: url(Images/resizeDiagonal_2x.png);\n    }\n\n    .device-mode-bottom-left-resizer > div {\n        content: url(Images/resizeDiagonal_2x.png);\n    }\n} /* media */\n\n.device-mode-page-area {\n    position: absolute;\n    left: 0;\n    right: 0;\n    width: 0;\n    height: 0;\n    display: flex;\n    background-color: #fcfcfc;\n}\n\n.device-mode-ruler {\n    pointer-events: none;\n    position: relative;\n}\n\n.device-mode-ruler-top {\n    flex: 0 0 20px;\n}\n\n.device-mode-ruler-left {\n    position: absolute;\n    left: 0;\n    width: 20px;\n    top: 0;\n    bottom: 0;\n    transform: translateX(-20px);\n}\n\n.device-mode-ruler-marker {\n    position: absolute;\n}\n\n.device-mode-ruler-top .device-mode-ruler-marker {\n    width: 0;\n    height: 5px;\n    bottom: 0;\n    border-right: 1px solid hsl(0, 0%, 50%);\n    margin-right: -1px;\n}\n\n.device-mode-ruler-top .device-mode-ruler-marker.device-mode-ruler-marker-medium {\n    height: 10px;\n}\n\n.device-mode-ruler-top .device-mode-ruler-marker.device-mode-ruler-marker-large {\n    height: 15px;\n}\n\n.device-mode-ruler-left .device-mode-ruler-marker {\n    height: 0;\n    width: 5px;\n    right: 0;\n    border-bottom: 1px solid hsl(0, 0%, 50%);\n    margin-bottom: -1px;\n}\n\n.device-mode-ruler-left .device-mode-ruler-marker.device-mode-ruler-marker-medium {\n    width: 10px;\n}\n\n.device-mode-ruler-left .device-mode-ruler-marker.device-mode-ruler-marker-large {\n    width: 15px;\n}\n\n.device-mode-ruler-text {\n    font-size: 11px;\n    color: hsl(0, 0%, 50%);\n    position: relative;\n    pointer-events: auto;\n}\n\n.device-mode-ruler-text:hover {\n    color: hsl(0, 0%, 10%);\n}\n\n.device-mode-ruler-top .device-mode-ruler-text {\n    left: 2px;\n    top: -2px;\n}\n\n.device-mode-ruler-left .device-mode-ruler-text {\n    left: -4px;\n    top: -15px;\n    transform: rotate(270deg);\n}\n\n/*# sourceURL=emulation/deviceModeView.css */";
Runtime.cachedResources["emulation/mediaQueryInspector.css"] = "/*\n * Copyright 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n/* Media query bars */\n\n.media-inspector-view {\n    height: 50px;\n}\n\n.media-inspector-marker-container {\n    height: 14px;\n    margin: 2px 0;\n    position: relative;\n}\n\n.media-inspector-bar {\n    display: flex;\n    flex-direction: row;\n    align-items: stretch;\n    pointer-events: none;\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n}\n\n.media-inspector-marker {\n    flex: none;\n    pointer-events: auto;\n    margin: 1px 0;\n    white-space: nowrap;\n    z-index: auto;\n    position: relative;\n}\n\n.media-inspector-marker-spacer {\n    flex: auto;\n}\n\n.media-inspector-marker:hover {\n    margin: -1px 0;\n    opacity: 1;\n}\n\n.media-inspector-marker-max-width {\n    background-color: hsl(207, 90%, 77%);\n    border-right: 2px solid hsl(207, 90%, 61%);\n    border-left: 2px solid hsl(207, 90%, 61%);\n}\n\n.media-inspector-marker-inactive .media-inspector-marker-max-width:not(:hover) {\n    background-color: hsl(199, 94%, 94%);\n}\n\n.media-inspector-marker-min-max-width {\n    background-color: hsl(88, 50%, 76%);\n    border-left: 2px solid #689F38;\n    border-right: 2px solid hsl(92, 48%, 42%);\n}\n\n.media-inspector-marker-inactive .media-inspector-marker-min-max-width:not(:hover) {\n    background-color: hsl(125, 39%, 94%);\n}\n\n.media-inspector-marker-min-max-width:hover {\n    z-index: 1;\n}\n\n.media-inspector-marker-min-width {\n    background-color: hsl(36, 100%, 75%);\n    flex: auto;\n}\n\n.media-inspector-marker-inactive .media-inspector-marker-min-width:not(:hover) {\n    background-color: hsl(37, 100%, 94%);\n}\n\n.media-inspector-marker-min-width-right {\n    border-left: 2px solid hsl(30, 100%, 48%);\n}\n\n.media-inspector-marker-min-width-left {\n    border-right: 2px solid hsl(30, 100%, 48%);\n}\n\n/* Media query labels */\n\n.media-inspector-marker:not(:hover) .media-inspector-marker-label-container {\n    display: none;\n}\n\n.media-inspector-marker-label-container {\n    position: absolute;\n    z-index: 1;\n}\n\n.media-inspector-marker-label-container-left {\n    left: -2px;\n}\n\n.media-inspector-marker-label-container-right {\n    right: -2px;\n}\n\n.media-inspector-marker-label {\n    color: #222;\n    position: absolute;\n    top: 1px;\n    bottom: 0;\n    font-size: 12px;\n    pointer-events: none;\n}\n\n.media-inspector-label-right {\n    right: 4px;\n}\n\n.media-inspector-label-left {\n    left: 4px;\n}\n\n/*# sourceURL=emulation/mediaQueryInspector.css */";
Runtime.cachedResources["emulation/sensors.css"] = "/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.sensors-view {\n    padding: 12px;\n}\n\n.sensors-view label {\n    margin-bottom: 10px;\n}\n\n.sensors-view input {\n    text-align: right;\n    width: 80px;\n}\n\n.sensors-view input[type=text]:not(.error-input):enabled:focus,\n.sensors-view select:enabled:focus {\n    border-color: rgb(77, 144, 254);\n    outline: none;\n}\n\n.sensors-view input[type=text],\n.sensors-view select {\n    border: 1px solid #bfbfbf;\n    border-radius: 2px;\n    box-sizing: border-box;\n    color: #444;\n    font: inherit;\n    border-width: 1px;\n}\n\n.sensors-view input[type=text] {\n    margin-left: 3px;\n    min-height: 2em;\n    padding: 3px;\n}\n\n.sensors-view input[readonly] {\n    background-color: rgb(235, 235, 228);\n}\n\n.sensors-view fieldset {\n    border: none;\n    padding: 0 0 5px 15px;\n    flex: 0 0 auto;\n}\n\n.sensors-view fieldset[disabled] {\n    opacity: 0.5;\n}\n\n.sensors-view .field-error-message {\n    display: none;\n}\n\n.sensors-view input[type='text']:focus::-webkit-input-placeholder {\n    color: transparent !important;\n}\n\n/* Accelerometer */\n\n.accelerometer-stage {\n    -webkit-perspective: 700px;\n    -webkit-perspective-origin: 50% 50%;\n    width: 200px;\n    height: 130px;\n}\n\nfieldset.device-orientation-override-section[disabled] .accelerometer-stage {\n    cursor: default !important;\n}\n\n.accelerometer-box {\n    pointer-events:none;\n    margin-top: -54px;\n    margin-left: -40px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 80px;\n    height: 108px;\n    -webkit-transform-style: preserve-3d;\n}\n\n.accelerometer-box section {\n    margin-top: -54px;\n    margin-left: -40px;\n    position: absolute;\n    display: block;\n    overflow: hidden;\n    top: 50%;\n    left: 50%;\n    -webkit-transform-style: flat;\n    -webkit-box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.7);\n}\n\n.accelerometer-box .front {\n    border:15px solid black;\n    width: 80px;\n    height: 107px;\n    background-color: gray;\n    transform: translate3d(0, 0, 10px);\n}\n\n.accelerometer-box .back {\n    width: 80px;\n    height: 107px;\n    background-color: black;\n    transform: rotateY(-180deg) translate3d(0, 0, 10px);\n}\n\n.accelerometer-box .top {\n    overflow: hidden;\n    width: 80px;\n    height: 20px;\n    background-color: #75CE89;\n    transform: rotateX(-90deg) translate3d(0, 0, -10px);\n}\n\n.accelerometer-box .bottom {\n    overflow: hidden;\n    width: 80px;\n    height: 20px;\n    background-color: #865C6C;\n    transform: rotateX(90deg) translate3d(0, 0, -97px);\n}\n\n.accelerometer-box .left {\n    width: 20px;\n    height: 107px;\n    background-color: #7992CB;\n    transform: rotateY(90deg) translate3d(0, 0, 70px);\n}\n\n.accelerometer-box .right {\n    width: 20px;\n    height: 107px;\n    background-color: #7992CB;\n    transform: rotateY(-90deg) translate3d(0, 0, 10px);\n}\n\n.accelerometer-axis-input-container {\n    margin-bottom: 10px;\n}\n\nfieldset.device-orientation-override-section {\n    display: flex;\n}\n/*# sourceURL=emulation/sensors.css */";
Runtime.cachedResources["main/errorWarningCounter.css"] = "/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n:host {\n    cursor: pointer;\n    padding: 0 2px;\n    min-width: 26px;\n}\n\n:host:hover {\n    color: #333;\n}\n\n.counter-item {\n    margin-left: 6px;\n}\n\n.counter-item label {\n    cursor: inherit;\n}\n\n.counter-item.counter-item-first {\n    margin-left: 0;\n}\n\n/*# sourceURL=main/errorWarningCounter.css */";
Runtime.cachedResources["main/remoteDebuggingTerminatedScreen.css"] = "/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.widget {\n    padding: 25px;\n}\n\n.message {\n    font-size: larger;\n    white-space: pre;\n    margin: 5px;\n}\n\n.reason {\n    color: #8b0000;\n}\n\n/*# sourceURL=main/remoteDebuggingTerminatedScreen.css */";
Runtime.cachedResources["main/renderingOptions.css"] = "/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\nlabel {\n    margin: 12px 0 0 0;\n    padding: 0 4px 0 12px;\n    flex: none;\n}\n\n.media-row {\n    display: flex;\n    align-items: center;\n    margin-top: 9px;\n    flex: none;\n}\n\n.media-row > label {\n    margin: 0 5px 0 0;\n}\n\n/*# sourceURL=main/renderingOptions.css */";
Runtime.cachedResources["main/targetCrashedScreen.css"] = "/*\n * Copyright (c) 2015 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n.widget {\n    padding: 25px;\n}\n\n.message {\n    font-size: larger;\n    white-space: pre;\n    margin: 5px;\n}\n\n/*# sourceURL=main/targetCrashedScreen.css */";

/* Application loader */
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Runtime.startApplication("inspector");
Runtime.startApplication("inspector");
